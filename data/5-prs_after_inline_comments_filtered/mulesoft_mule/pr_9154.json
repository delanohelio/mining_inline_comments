{"pr_number": 9154, "pr_title": "MULE-18642: ComponentAst downcasting fails when a BaseComponentAstDecorator is used", "pr_createdAt": "2020-08-03T19:30:24Z", "pr_url": "https://github.com/mulesoft/mule/pull/9154", "timeline": [{"oid": "6c61695f50ba35f9f9beb2e805f7108b82e24e90", "url": "https://github.com/mulesoft/mule/commit/6c61695f50ba35f9f9beb2e805f7108b82e24e90", "message": "DslElementModel.withConfig - create the config from a ComponentAst", "committedDate": "2020-08-04T15:19:44Z", "type": "forcePushed"}, {"oid": "c3051b71b591b84d924fb57f268c6f693de846c0", "url": "https://github.com/mulesoft/mule/commit/c3051b71b591b84d924fb57f268c6f693de846c0", "message": "DslElementModel.withConfig - create the config from a ComponentAst", "committedDate": "2020-08-05T00:13:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3Njc5MQ==", "url": "https://github.com/mulesoft/mule/pull/9154#discussion_r465676791", "bodyText": "missing \"deploymentProperties\" at javadocs", "author": "mlischetti", "createdAt": "2020-08-05T12:03:30Z", "path": "modules/spring-config/src/main/java/org/mule/runtime/config/internal/model/ApplicationModel.java", "diffHunk": "@@ -216,14 +214,20 @@\n    * <p/>\n    * A set of validations are applied that may make creation fail.\n    *\n-   * @param artifactConfig      the mule artifact configuration content.\n+   * @param artifactConfig the mule artifact configuration content.\n    * @param artifactDeclaration an {@link ArtifactDeclaration}\n+   * @param extensionModels Set of {@link ExtensionModel extensionModels} that will be used to type componentModels\n+   * @param parentConfigurationProperties the {@link ConfigurationProperties} of the parent artifact. For instance, application\n+   *        will receive the domain resolver.\n+   * @param externalResourceProvider the provider for configuration properties files and ${file::name.txt} placeholders\n    * @throws Exception when the application configuration has semantic errors.\n    */\n   public ApplicationModel(ArtifactConfig artifactConfig, ArtifactDeclaration artifactDeclaration,\n-                          ResourceProvider externalResourceProvider)\n-      throws Exception {\n-    this(artifactConfig, artifactDeclaration, emptySet(), emptyMap(), empty(), of(new ComponentBuildingDefinitionRegistry()),\n+                          Set<ExtensionModel> extensionModels,\n+                          Map<String, String> deploymentProperties,\n+                          Optional<ConfigurationProperties> parentConfigurationProperties,\n+                          ResourceProvider externalResourceProvider) {\n+    this(artifactConfig, artifactDeclaration, extensionModels, deploymentProperties, parentConfigurationProperties, empty(),", "originalCommit": "6c61695f50ba35f9f9beb2e805f7108b82e24e90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2c5336f51c9af15681accd3193253d5df75038f8", "url": "https://github.com/mulesoft/mule/commit/2c5336f51c9af15681accd3193253d5df75038f8", "message": "review", "committedDate": "2020-08-05T14:11:41Z", "type": "commit"}, {"oid": "2c5336f51c9af15681accd3193253d5df75038f8", "url": "https://github.com/mulesoft/mule/commit/2c5336f51c9af15681accd3193253d5df75038f8", "message": "review", "committedDate": "2020-08-05T14:11:41Z", "type": "forcePushed"}, {"oid": "1388e925a1df4bddd1cc76866a0f4eb467f33df1", "url": "https://github.com/mulesoft/mule/commit/1388e925a1df4bddd1cc76866a0f4eb467f33df1", "message": "format + fix", "committedDate": "2020-08-05T17:56:37Z", "type": "commit"}, {"oid": "9240a0479f9d9eabc7fa6aa2977ed083a025c57f", "url": "https://github.com/mulesoft/mule/commit/9240a0479f9d9eabc7fa6aa2977ed083a025c57f", "message": "more sonar", "committedDate": "2020-08-05T20:06:31Z", "type": "commit"}, {"oid": "220c008ff33d9ea4805d52f15702340b1439caf2", "url": "https://github.com/mulesoft/mule/commit/220c008ff33d9ea4805d52f15702340b1439caf2", "message": "more sonar 2", "committedDate": "2020-08-05T20:08:42Z", "type": "commit"}, {"oid": "f2b573fd85c6472e5c69aaf8ca84d0bd93d37684", "url": "https://github.com/mulesoft/mule/commit/f2b573fd85c6472e5c69aaf8ca84d0bd93d37684", "message": "Revert \"more sonar 2\"\n\nThis reverts commit 220c008ff33d9ea4805d52f15702340b1439caf2.", "committedDate": "2020-08-05T21:18:54Z", "type": "commit"}, {"oid": "2aae103ca45621a8c1ac5f424eab5eb1099a12d1", "url": "https://github.com/mulesoft/mule/commit/2aae103ca45621a8c1ac5f424eab5eb1099a12d1", "message": "finally...", "committedDate": "2020-08-05T21:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1ODQyNw==", "url": "https://github.com/mulesoft/mule/pull/9154#discussion_r466058427", "bodyText": "remove unnecessary return", "author": "mlischetti", "createdAt": "2020-08-05T23:25:54Z", "path": "modules/spring-config/src/main/java/org/mule/runtime/config/internal/dsl/model/ComponentAstBasedElementModelFactory.java", "diffHunk": "@@ -0,0 +1,917 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.config.internal.dsl.model;\n+\n+import static com.google.common.collect.Sets.newHashSet;\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static java.util.Optional.ofNullable;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Stream.concat;\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+import static org.mule.metadata.api.utils.MetadataTypeUtils.getLocalPart;\n+import static org.mule.runtime.api.component.ComponentIdentifier.builder;\n+import static org.mule.runtime.ast.api.ComponentAst.BODY_RAW_PARAM_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.EXPIRATION_POLICY_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.POOLING_PROFILE_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.RECONNECTION_CONFIG_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.RECONNECTION_STRATEGY_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.REDELIVERY_POLICY_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.SCHEDULING_STRATEGY_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.STREAMING_STRATEGY_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.ExtensionConstants.TLS_PARAMETER_NAME;\n+import static org.mule.runtime.extension.api.declaration.type.StreamingStrategyTypeBuilder.NON_REPEATABLE_BYTE_STREAM_ALIAS;\n+import static org.mule.runtime.extension.api.declaration.type.StreamingStrategyTypeBuilder.NON_REPEATABLE_OBJECTS_STREAM_ALIAS;\n+import static org.mule.runtime.extension.api.declaration.type.StreamingStrategyTypeBuilder.REPEATABLE_FILE_STORE_BYTES_STREAM_ALIAS;\n+import static org.mule.runtime.extension.api.declaration.type.StreamingStrategyTypeBuilder.REPEATABLE_FILE_STORE_OBJECTS_STREAM_ALIAS;\n+import static org.mule.runtime.extension.api.declaration.type.StreamingStrategyTypeBuilder.REPEATABLE_IN_MEMORY_BYTES_STREAM_ALIAS;\n+import static org.mule.runtime.extension.api.declaration.type.StreamingStrategyTypeBuilder.REPEATABLE_IN_MEMORY_OBJECTS_STREAM_ALIAS;\n+import static org.mule.runtime.extension.api.util.ExtensionMetadataTypeUtils.getId;\n+import static org.mule.runtime.extension.api.util.ExtensionMetadataTypeUtils.isMap;\n+import static org.mule.runtime.extension.api.util.ExtensionModelUtils.getDefaultValue;\n+import static org.mule.runtime.extension.api.util.ExtensionModelUtils.isContent;\n+import static org.mule.runtime.extension.api.util.ExtensionModelUtils.isInfrastructure;\n+import static org.mule.runtime.extension.api.util.ExtensionModelUtils.isRequired;\n+import static org.mule.runtime.extension.api.util.ExtensionModelUtils.isText;\n+import static org.mule.runtime.internal.dsl.DslConstants.CORE_PREFIX;\n+import static org.mule.runtime.internal.dsl.DslConstants.CRON_STRATEGY_ELEMENT_IDENTIFIER;\n+import static org.mule.runtime.internal.dsl.DslConstants.EE_PREFIX;\n+import static org.mule.runtime.internal.dsl.DslConstants.EXPIRATION_POLICY_ELEMENT_IDENTIFIER;\n+import static org.mule.runtime.internal.dsl.DslConstants.KEY_ATTRIBUTE_NAME;\n+import static org.mule.runtime.internal.dsl.DslConstants.RECONNECT_ELEMENT_IDENTIFIER;\n+import static org.mule.runtime.internal.dsl.DslConstants.RECONNECT_FOREVER_ELEMENT_IDENTIFIER;\n+import static org.mule.runtime.internal.dsl.DslConstants.REDELIVERY_POLICY_ELEMENT_IDENTIFIER;\n+import static org.mule.runtime.internal.dsl.DslConstants.SCHEDULING_STRATEGY_ELEMENT_IDENTIFIER;\n+import static org.mule.runtime.internal.dsl.DslConstants.VALUE_ATTRIBUTE_NAME;\n+\n+import org.mule.metadata.api.ClassTypeLoader;\n+import org.mule.metadata.api.model.ArrayType;\n+import org.mule.metadata.api.model.MetadataType;\n+import org.mule.metadata.api.model.ObjectType;\n+import org.mule.metadata.api.visitor.MetadataTypeVisitor;\n+import org.mule.runtime.api.component.ComponentIdentifier;\n+import org.mule.runtime.api.meta.model.ComponentModel;\n+import org.mule.runtime.api.meta.model.ComposableModel;\n+import org.mule.runtime.api.meta.model.ExtensionModel;\n+import org.mule.runtime.api.meta.model.config.ConfigurationModel;\n+import org.mule.runtime.api.meta.model.connection.ConnectionProviderModel;\n+import org.mule.runtime.api.meta.model.connection.HasConnectionProviderModels;\n+import org.mule.runtime.api.meta.model.construct.ConstructModel;\n+import org.mule.runtime.api.meta.model.construct.HasConstructModels;\n+import org.mule.runtime.api.meta.model.nested.NestableElementModel;\n+import org.mule.runtime.api.meta.model.nested.NestedRouteModel;\n+import org.mule.runtime.api.meta.model.operation.HasOperationModels;\n+import org.mule.runtime.api.meta.model.operation.OperationModel;\n+import org.mule.runtime.api.meta.model.parameter.ParameterGroupModel;\n+import org.mule.runtime.api.meta.model.parameter.ParameterModel;\n+import org.mule.runtime.api.meta.model.parameter.ParameterizedModel;\n+import org.mule.runtime.api.meta.model.source.HasSourceModels;\n+import org.mule.runtime.api.meta.model.source.SourceModel;\n+import org.mule.runtime.api.meta.model.util.ExtensionWalker;\n+import org.mule.runtime.api.util.Reference;\n+import org.mule.runtime.ast.api.ComponentAst;\n+import org.mule.runtime.config.api.dsl.model.DslElementModel;\n+import org.mule.runtime.config.api.dsl.model.DslElementModelFactory;\n+import org.mule.runtime.core.api.source.scheduler.CronScheduler;\n+import org.mule.runtime.core.api.source.scheduler.FixedFrequencyScheduler;\n+import org.mule.runtime.extension.api.declaration.type.ExtensionsTypeLoaderFactory;\n+import org.mule.runtime.extension.api.declaration.type.annotation.FlattenedTypeAnnotation;\n+import org.mule.runtime.extension.api.dsl.syntax.DslElementSyntax;\n+import org.mule.runtime.extension.api.dsl.syntax.resolver.DslSyntaxResolver;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+\n+/**\n+ * Implementation of {@link DslElementModelFactory} that creates a {@link DslElementModel} based on its {@link ComponentAst}\n+ * representation.\n+ *\n+ * @since 4.0\n+ */\n+// TODO MULE-11496 Delete this factory once everything has an ExtensionModel and can be represented with an ElementDeclaration\n+class ComponentAstBasedElementModelFactory {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ComponentAstBasedElementModelFactory.class);\n+\n+  private final ClassTypeLoader typeLoader = ExtensionsTypeLoaderFactory.getDefault().createTypeLoader();\n+  private final Map<ExtensionModel, DslSyntaxResolver> resolvers;\n+  private ExtensionModel currentExtension;\n+  private DslSyntaxResolver dsl;\n+\n+  ComponentAstBasedElementModelFactory(Map<ExtensionModel, DslSyntaxResolver> resolvers) {\n+    this.resolvers = resolvers;\n+  }\n+\n+  public <T> Optional<DslElementModel<T>> create(ComponentAst configuration) {\n+    return ofNullable(createIdentifiedElement(configuration));\n+  }\n+\n+  private DslElementModel createIdentifiedElement(ComponentAst configuration) {\n+\n+    final ComponentIdentifier identifier = configuration.getIdentifier();\n+\n+    Optional<Map.Entry<ExtensionModel, DslSyntaxResolver>> entry =\n+        resolvers.entrySet().stream()\n+            .filter(e -> e.getKey().getXmlDslModel().getPrefix().equals(identifier.getNamespace()))\n+            .findFirst();\n+\n+    if (!entry.isPresent()) {\n+      return null;\n+    }\n+\n+    currentExtension = entry.get().getKey();\n+    dsl = entry.get().getValue();\n+\n+    Reference<DslElementModel> elementModel = new Reference<>();\n+    new ExtensionWalker() {\n+\n+      @Override\n+      protected void onConfiguration(ConfigurationModel model) {\n+        final DslElementSyntax elementDsl = dsl.resolve(model);\n+        getIdentifier(elementDsl)\n+            .filter(elementId -> elementId.equals(identifier))\n+            .ifPresent(elementId -> {\n+              DslElementModel.Builder<ConfigurationModel> builder = DslElementModel.<ConfigurationModel>builder()\n+                  .withModel(model)\n+                  .withDsl(elementDsl)\n+                  .withConfig(configuration);\n+\n+              addConnectionProvider(model, dsl, builder, configuration);\n+\n+              enrichElementModel(model, elementDsl, configuration, builder);\n+\n+              elementModel.set(builder.build());\n+              stop();\n+            });\n+      }\n+\n+      @Override\n+      protected void onConnectionProvider(HasConnectionProviderModels owner, ConnectionProviderModel model) {\n+        final DslElementSyntax providerDsl = dsl.resolve(model);\n+        getIdentifier(providerDsl)\n+            .filter(elementId -> elementId.equals(identifier))\n+            .ifPresent(elementId -> {\n+              elementModel.set(createConnectionProviderModel(model, providerDsl, configuration));\n+              stop();\n+            });\n+      }\n+\n+      @Override\n+      protected void onConstruct(HasConstructModels owner, ConstructModel model) {\n+        onComponentModel(model);\n+      }\n+\n+      @Override\n+      protected void onOperation(HasOperationModels owner, OperationModel model) {\n+        onComponentModel(model);\n+      }\n+\n+      @Override\n+      protected void onSource(HasSourceModels owner, SourceModel model) {\n+        onComponentModel(model);\n+      }\n+\n+      private void onComponentModel(final ComponentModel model) {\n+        final DslElementSyntax elementDsl = dsl.resolve(model);\n+        getIdentifier(elementDsl)\n+            .filter(elementId -> elementId.equals(identifier))\n+            .ifPresent(elementId -> {\n+              elementModel.set(createElementModel(model, elementDsl, configuration).build());\n+              stop();\n+            });\n+      }\n+\n+    }.walk(currentExtension);\n+\n+    if (elementModel.get() == null) {\n+      resolveBasedOnTypes(configuration)\n+          .ifPresent(elementModel::set);\n+    }\n+\n+    return elementModel.get();\n+  }\n+\n+  private Optional<DslElementModel<ObjectType>> resolveBasedOnTypes(ComponentAst configuration) {\n+    return currentExtension.getTypes().stream()\n+        .map(type -> resolveBasedOnType(type, configuration, new ArrayDeque<>()))\n+        .filter(Optional::isPresent)\n+        .map(Optional::get)\n+        .findFirst();\n+  }\n+\n+  private void withStackControl(Deque<String> typeResolvingStack, String stackId, Runnable action) {\n+    if (!typeResolvingStack.contains(stackId)) {\n+      typeResolvingStack.push(stackId);\n+      action.run();\n+      typeResolvingStack.pop();\n+    }\n+  }\n+\n+  private Optional<DslElementModel<ObjectType>> resolveBasedOnType(ObjectType type,\n+                                                                   ComponentAst configuration,\n+                                                                   Deque<String> typeResolvingStack) {\n+    Optional<DslElementSyntax> typeDsl = dsl.resolve(type);\n+    if (typeDsl.isPresent()) {\n+      Optional<ComponentIdentifier> elementIdentifier = getIdentifier(typeDsl.get());\n+      if (elementIdentifier.isPresent() && elementIdentifier.get().equals(configuration.getIdentifier())) {\n+        DslElementModel.Builder<ObjectType> typeBuilder = DslElementModel.<ObjectType>builder()\n+            .withModel(type)\n+            .withDsl(typeDsl.get())\n+            .withConfig(configuration);\n+\n+        getId(type).ifPresent(id -> withStackControl(typeResolvingStack, id,\n+                                                     () -> populateObjectFields(type, configuration, typeDsl.get(),\n+                                                                                typeBuilder, typeResolvingStack)));\n+\n+        return Optional.of(typeBuilder.build());\n+      }\n+    }\n+    return Optional.empty();\n+  }\n+\n+  private void populateObjectFields(ObjectType type, ComponentAst configuration, DslElementSyntax typeDsl,\n+                                    DslElementModel.Builder typeBuilder, Deque<String> typeResolvingStack) {\n+    LOGGER.trace(\"populateObjectFields: type: '{}'\", type);\n+\n+    type.getFields().forEach(field -> {\n+\n+      if (field.getValue() instanceof ObjectType && field.getAnnotation(FlattenedTypeAnnotation.class).isPresent()) {\n+        ((ObjectType) field.getValue()).getFields().forEach(nested -> {\n+          final String name = getLocalPart(nested);\n+          LOGGER.trace(\"populateObjectFields: type: '{}', flattened: {}, field: {}\", type, field.getValue(), name);\n+          typeDsl.getContainedElement(name)\n+              .ifPresent(fieldDsl -> nested.getValue()\n+                  .accept(getComponentChildVisitor(typeBuilder, configuration, nested, name, fieldDsl,\n+                                                   getDefaultValue(name, field.getValue()),\n+                                                   typeResolvingStack)));\n+\n+        });\n+\n+      } else {\n+        final String name = getLocalPart(field);\n+        LOGGER.trace(\"populateObjectFields: type: '{}', field: {}\", type, name);\n+        typeDsl.getContainedElement(name)\n+            .ifPresent(fieldDsl -> field.getValue()\n+                .accept(getComponentChildVisitor(typeBuilder, configuration, field, name, fieldDsl,\n+                                                 getDefaultValue(name, type), typeResolvingStack)));\n+      }\n+    });\n+  }\n+\n+  private Multimap<ComponentIdentifier, ComponentAst> getNestedComponents(ComponentAst configuration) {\n+    Multimap<ComponentIdentifier, ComponentAst> result = ArrayListMultimap.create();\n+    configuration.directChildrenStream().forEach(componentConfiguration -> {\n+      result.put(componentConfiguration.getIdentifier(), componentConfiguration);\n+    });\n+    return result;\n+  }\n+\n+  private MetadataTypeVisitor getComponentChildVisitor(final DslElementModel.Builder typeBuilder,\n+                                                       final ComponentAst configuration,\n+                                                       final MetadataType model, final String name,\n+                                                       final DslElementSyntax modelDsl, final Optional<String> defaultValue,\n+                                                       Deque<String> typeResolvingStack) {\n+\n+    return new MetadataTypeVisitor() {\n+\n+      @Override\n+      protected void defaultVisit(MetadataType metadataType) {\n+        DslElementModel.Builder<MetadataType> elementBuilder = DslElementModel.<MetadataType>builder()\n+            .withModel(model)\n+            .withDsl(modelDsl);\n+\n+        Optional<ComponentIdentifier> identifier = getIdentifier(modelDsl);\n+        String value = configuration.getRawParameterValue(name).orElse(null);\n+        LOGGER.trace(\"getComponentChildVisitor#defaultVisit: '{}': '{}'\", identifier, value);\n+\n+        if (isBlank(value)) {\n+          if (identifier.isPresent()) {\n+            ComponentAst nested = getSingleComponentConfiguration(getNestedComponents(configuration), identifier);\n+            if (nested != null) {\n+              value = nested.getRawParameterValue(BODY_RAW_PARAM_NAME)\n+                  .flatMap(body -> !isBlank(body) ? of(body.trim()) : empty())\n+                  .orElse(null);\n+            }\n+          } else if (defaultValue.isPresent()) {\n+            value = defaultValue.get();\n+            elementBuilder.isExplicitInDsl(false);\n+          }\n+        }\n+\n+        if (!isBlank(value)) {\n+          typeBuilder.containing(elementBuilder.withValue(value).build());\n+          return;", "originalCommit": "2aae103ca45621a8c1ac5f424eab5eb1099a12d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4320db3be6d5ac43379956510bf945efe5962bba", "url": "https://github.com/mulesoft/mule/commit/4320db3be6d5ac43379956510bf945efe5962bba", "message": "dho", "committedDate": "2020-08-05T23:27:28Z", "type": "commit"}]}