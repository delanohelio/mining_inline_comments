{"pr_number": 8711, "pr_title": "MULE-18077: Performance issues with functional idioms", "pr_createdAt": "2020-03-05T18:40:14Z", "pr_url": "https://github.com/mulesoft/mule/pull/8711", "timeline": [{"oid": "9a7e88b7c54ab1647d93ffe1e80e9e594c40a82a", "url": "https://github.com/mulesoft/mule/commit/9a7e88b7c54ab1647d93ffe1e80e9e594c40a82a", "message": "cherry picking locks", "committedDate": "2020-03-05T16:47:50Z", "type": "commit"}, {"oid": "420851df01b5a6e63b5a47a69366a792603b3d87", "url": "https://github.com/mulesoft/mule/commit/420851df01b5a6e63b5a47a69366a792603b3d87", "message": "compilation", "committedDate": "2020-03-05T16:47:51Z", "type": "commit"}, {"oid": "cee14ac0e97e32551cb2110a86cd4f1235b7705f", "url": "https://github.com/mulesoft/mule/commit/cee14ac0e97e32551cb2110a86cd4f1235b7705f", "message": "fix", "committedDate": "2020-03-05T16:47:51Z", "type": "commit"}, {"oid": "3e2d541aeee8995655f7d24ef098917c423a8916", "url": "https://github.com/mulesoft/mule/commit/3e2d541aeee8995655f7d24ef098917c423a8916", "message": "jdoc", "committedDate": "2020-03-05T16:47:51Z", "type": "commit"}, {"oid": "4096ad528a3ccc85b3bb869b19cc9abcc0cc98f3", "url": "https://github.com/mulesoft/mule/commit/4096ad528a3ccc85b3bb869b19cc9abcc0cc98f3", "message": "format", "committedDate": "2020-03-05T16:47:51Z", "type": "commit"}, {"oid": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c", "url": "https://github.com/mulesoft/mule/commit/2ee52ec591596a3de5f5016fe6f8d3da0f16e98c", "message": "rebase", "committedDate": "2020-03-05T18:15:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDYwNA==", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388490604", "bodyText": "what's the purpose of this method if most of the dirty work has to be done by the caller?", "author": "elrodro83", "createdAt": "2020-03-05T18:49:00Z", "path": "core/src/main/java/org/mule/runtime/core/api/util/ClassUtils.java", "diffHunk": "@@ -957,17 +971,49 @@ public static void withContextClassLoader(ClassLoader classLoader, Runnable runn\n     }\n   }\n \n+  /**\n+   * Sets {@code newClassLoader} as the context class loader for the {@code thread}, as long as said classloader is not the\n+   * same instance as {@code currentClassLoader}.\n+   * <p>\n+   * Since obtaining and setting the context classloader from a thread are expensive operations, the purpose of this method\n+   * is to avoid performing those operations when possible, which is why the two classloaders are tested not to be the same\n+   * before performing the set operation. For this method to make sense, {@code currentClassLoader} should actually be the\n+   * current context classloader from the {@code thread}.\n+   * <p>\n+   * This is how a typical use should look like:\n+   * <pre>\n+   *   Thread thread = Thread.currentThread();\n+   *   ClassLoader currentClassLoader = thread.getContextClassLoader();\n+   *   ClassLoader newClassLoader = getNewContextClassLoader(); // this one depends on your logic\n+   *   ClassUtils.setContextClassLoader(thread, currentClassLoader, newClassLoader);\n+   *   try {\n+   *     // execute your logic\n+   *   } finally {\n+   *     // set things back as they were by reversing the arguments order\n+   *     ClassUtils.setContextClassLoader(thread, newClassLoader, currentClassLoader);\n+   *   }\n+   * </pre>\n+   *\n+   * @param thread             the thread which context classloader is to be changed\n+   * @param currentClassLoader the thread's current context classloader\n+   * @param newClassLoader     the new classloader to be set\n+   * @since 4.3.0\n+   */\n+  public static void setContextClassLoader(Thread thread, ClassLoader currentClassLoader, ClassLoader newClassLoader) {", "originalCommit": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2OTM4Ng==", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388569386", "bodyText": "basically? the if... do not switch if the target classloader is the same as the current", "author": "marianogonzalez", "createdAt": "2020-03-05T21:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2OTcwNA==", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388569704", "bodyText": "switching the TCCL is expensive", "author": "marianogonzalez", "createdAt": "2020-03-05T21:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MDkwMQ==", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388490901", "bodyText": "see?", "author": "elrodro83", "createdAt": "2020-03-05T18:49:34Z", "path": "core/src/main/java/org/mule/runtime/core/internal/execution/MuleMessageProcessingManager.java", "diffHunk": "@@ -38,8 +39,15 @@ public void initialise() throws InitialisationException {\n   @Override\n   public void processMessage(FlowProcessTemplate messageProcessTemplate,\n                              MessageProcessContext messageProcessContext) {\n-    withContextClassLoader(messageProcessContext.getExecutionClassLoader(),\n-                           () -> mediator.process(messageProcessTemplate, messageProcessContext, this));\n+    Thread currentThread = currentThread();", "originalCommit": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzQxNg==", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388493416", "bodyText": ":O", "author": "elrodro83", "createdAt": "2020-03-05T18:54:02Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/interceptor/ReactiveInterceptorAdapter.java", "diffHunk": "@@ -127,15 +128,22 @@ protected ReactiveProcessor doApply(Processor component, ReactiveProcessor next,\n         LOGGER.debug(\"Calling before() for '{}' in processor '{}'...\", interceptor,\n                      component.getLocation().getLocation());\n       }\n-\n       try {\n-        withContextClassLoader(interceptor.getClass().getClassLoader(),\n-                               () -> interceptor.before(component.getLocation(),\n-                                                        getResolvedParams(eventWithResolvedParams),\n-                                                        interceptionEvent));\n+        Thread currentThread = currentThread();\n+        ClassLoader currentClassLoader = currentThread.getContextClassLoader();\n+        ClassLoader contextClassLoader = interceptor.getClass().getClassLoader();\n+        setContextClassLoader(currentThread, currentClassLoader, contextClassLoader);\n+        try {\n+          interceptor.before(component.getLocation(),\n+                             getResolvedParams(eventWithResolvedParams),\n+                             interceptionEvent);\n+        } finally {\n+          setContextClassLoader(currentThread, contextClassLoader, currentClassLoader);\n+        }\n+\n         return interceptionEvent.resolve();\n       } catch (Exception e) {\n-        throw propagate(new MessagingException(interceptionEvent.resolve(), e.getCause(), component));\n+        throw propagate(new MessagingException(interceptionEvent.resolve(), e, component));", "originalCommit": "2ee52ec591596a3de5f5016fe6f8d3da0f16e98c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MjMzMw==", "url": "https://github.com/mulesoft/mule/pull/8711#discussion_r388582333", "bodyText": "this is because the functional idiom was wrapping the exception into a MuleRuntimeException, which is why the exception was being unwrapped", "author": "marianogonzalez", "createdAt": "2020-03-05T21:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzQxNg=="}], "type": "inlineReview"}]}