{"pr_number": 8826, "pr_title": "MULE-18102: Concurrent subflow instantiations are corrupting their inner processors location", "pr_createdAt": "2020-04-27T18:09:30Z", "pr_url": "https://github.com/mulesoft/mule/pull/8826", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjIwNQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416056205", "bodyText": "doesn't this affect any other tests?", "author": "elrodro83", "createdAt": "2020-04-27T18:37:52Z", "path": "tests/unit/src/main/java/org/mule/tck/util/MuleContextUtils.java", "diffHunk": "@@ -171,7 +172,7 @@ public static MuleContextWithRegistry mockMuleContext() {\n \n     StreamingManager streamingManager = mock(StreamingManager.class, RETURNS_DEEP_STUBS);\n     try {\n-      MuleRegistry registry = mock(MuleRegistry.class, withSettings().lenient());\n+      MuleRegistry registry = mock(MuleRegistryHelper.class, withSettings().lenient());", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NTM0MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416065340", "bodyText": "Ran all the tests and found no side effects (all passing) Will check again just in case.", "author": "IvanAndresFritzler", "createdAt": "2020-04-27T18:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzMzk0MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417633940", "bodyText": "All tests passing, no side effects.", "author": "IvanAndresFritzler", "createdAt": "2020-04-29T21:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjI5NQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416056295", "bodyText": "formatter", "author": "elrodro83", "createdAt": "2020-04-27T18:38:01Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n+    }, \"Parallel Flow Events\");\n+    flowEvents.start();\n+    parallelFlowEvents.start();\n+    flowEvents.join();\n+    parallelFlowEvents.join();\n+    // Assertions over each parent flow processing strategies\n+    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n+    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n+  }\n+\n+  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n+    try {\n+      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+      initialiseIfNeeded(flowRefProcessor);\n+      startIfNeeded(flowRefProcessor);\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      stopIfNeeded(flowRefProcessor);\n+      disposeIfNeeded(flowRefProcessor, null);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n+    }\n+  }\n+\n+  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n+    MuleArtifactContext muleArtifactContext =\n+            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n+                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n+                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n+\n+              @Override\n+              protected DefaultListableBeanFactory createBeanFactory() {\n+                return mockedBeanFactory;\n+              }\n+\n+              @Override\n+              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean invocation here\n+              }\n+\n+              @Override\n+              protected void registerListeners() {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishRefresh() {\n+                // Bean factory is mocked, so no nothing to do here\n+              }\n+            };\n+    muleArtifactContext.refresh();\n+    return muleArtifactContext;\n+  }\n+\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n+                                                      ApplicationContext applicationContext)\n+          throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(name);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(\"flow\")));\n+    flowRefFactoryBean.setName(referencedFlowName);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n+          throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n-    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n-        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n-                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                  any(ComponentLocation.class), eq(true));\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n+                                                             ApplicationContext applicationContext)\n+          throws Exception {\n     if (targetBuilder != null) {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n+      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     } else {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n+      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-          .cast(CoreEvent.class)\n-          .doOnNext(event -> ((BaseEventContext) event.getContext())\n-              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+              .cast(CoreEvent.class)\n+              .doOnNext(event -> ((BaseEventContext) event.getContext())\n+                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n-      throws Exception {\n-    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-    initialiseIfNeeded(flowRefProcessor);\n-    startIfNeeded(flowRefProcessor);\n-\n-    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n+          throws Exception {\n+    sendEventsThroughFlowRef(flowRefFactoryBean);\n     verify(applicationContext).getBean(anyString());\n-\n     verify(target, times(2)).apply(any(Publisher.class));\n-\n-    stopIfNeeded(flowRefProcessor);\n-    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-      throws Exception {\n+          throws Exception {", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjY5Nw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416056697", "bodyText": "static import", "author": "elrodro83", "createdAt": "2020-04-27T18:38:37Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n+    }, \"Parallel Flow Events\");\n+    flowEvents.start();\n+    parallelFlowEvents.start();\n+    flowEvents.join();\n+    parallelFlowEvents.join();\n+    // Assertions over each parent flow processing strategies\n+    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n+    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n+  }\n+\n+  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n+    try {\n+      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+      initialiseIfNeeded(flowRefProcessor);\n+      startIfNeeded(flowRefProcessor);\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      stopIfNeeded(flowRefProcessor);\n+      disposeIfNeeded(flowRefProcessor, null);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n+    }\n+  }\n+\n+  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n+    MuleArtifactContext muleArtifactContext =\n+            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n+                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n+                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n+\n+              @Override\n+              protected DefaultListableBeanFactory createBeanFactory() {\n+                return mockedBeanFactory;\n+              }\n+\n+              @Override\n+              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean invocation here\n+              }\n+\n+              @Override\n+              protected void registerListeners() {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishRefresh() {\n+                // Bean factory is mocked, so no nothing to do here\n+              }\n+            };\n+    muleArtifactContext.refresh();\n+    return muleArtifactContext;\n+  }\n+\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n+                                                      ApplicationContext applicationContext)\n+          throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(name);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(\"flow\")));\n+    flowRefFactoryBean.setName(referencedFlowName);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n+          throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n-    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n-        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n-                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                  any(ComponentLocation.class), eq(true));\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n+                                                             ApplicationContext applicationContext)\n+          throws Exception {\n     if (targetBuilder != null) {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n+      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     } else {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n+      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NzIyOA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416057228", "bodyText": "add allure @Issue", "author": "elrodro83", "createdAt": "2020-04-27T18:39:26Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzMzcyNg==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417633726", "bodyText": "Added new annotations to AllureConstants", "author": "IvanAndresFritzler", "createdAt": "2020-04-29T21:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NzIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NzU4Nw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416057587", "bodyText": "use an Executor instead of threads", "author": "elrodro83", "createdAt": "2020-04-27T18:40:04Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODAxMw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416058013", "bodyText": "can this be executed more times to force the manifestation of the race condition?", "author": "elrodro83", "createdAt": "2020-04-27T18:40:42Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2ODYzNA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416068634", "bodyText": "Will try. With some modifications it might be possible to make it fail \"almost all the executions\".", "author": "IvanAndresFritzler", "createdAt": "2020-04-27T18:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNDU3MQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417634571", "bodyText": "New version failed 1000 of 1000 runs without the fix", "author": "IvanAndresFritzler", "createdAt": "2020-04-29T21:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODU4MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416058580", "bodyText": "no * imports", "author": "elrodro83", "createdAt": "2020-04-27T18:41:25Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -66,10 +73,12 @@\n import org.mule.runtime.core.privileged.event.BaseEventContext;\n import org.mule.runtime.core.privileged.processor.chain.MessageProcessorChain;\n import org.mule.runtime.core.privileged.routing.RoutePathNotFoundException;\n+import org.mule.runtime.dsl.api.ConfigResource;\n+import org.mule.runtime.dsl.api.component.ComponentBuildingDefinition;\n import org.mule.tck.junit4.AbstractMuleTestCase;\n import org.mule.tck.size.SmallTest;\n \n-import java.util.List;\n+import java.util.*;", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5NjUzOQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417996539", "bodyText": "static imports of these constants", "author": "elrodro83", "createdAt": "2020-04-30T13:09:45Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -273,63 +289,86 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n     getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  @Test\n+  @Test()\n+  @Feature(AllureConstants.SpringConfiguration.SPRING_CONFIGURATION)", "originalCommit": "b5c96a035fdce204358bd0bc575c695b1649e38c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5Nzg2MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417997860", "bodyText": "isn't there allure constants for flow-ref? that would be mor appropriate here.", "author": "elrodro83", "createdAt": "2020-04-30T13:11:54Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -273,63 +289,86 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n     getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  @Test\n+  @Test()\n+  @Feature(AllureConstants.SpringConfiguration.SPRING_CONFIGURATION)", "originalCommit": "b5c96a035fdce204358bd0bc575c695b1649e38c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5ODU1Mw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417998553", "bodyText": "what i mean is, the values of this annotations should match features of the runtime and stories for its users. spring is just an internally used library.", "author": "elrodro83", "createdAt": "2020-04-30T13:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5Nzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MTk5Ng==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r418041996", "bodyText": "Changed to Flow Reference Story", "author": "IvanAndresFritzler", "createdAt": "2020-04-30T14:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5Nzg2MA=="}], "type": "inlineReview"}, {"oid": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "url": "https://github.com/mulesoft/mule/commit/1298de285016d6a1fdfb38b6f04dc12c40877f05", "message": "MULE-18102: Concurrent flow reference instantiation issue", "committedDate": "2020-04-30T19:20:26Z", "type": "commit"}, {"oid": "edaf42b6d633c8530d601f0eb62dc1b4ea811535", "url": "https://github.com/mulesoft/mule/commit/edaf42b6d633c8530d601f0eb62dc1b4ea811535", "message": "MULE-18102: Solution improvements", "committedDate": "2020-04-30T19:20:26Z", "type": "commit"}, {"oid": "333994d88b215473f28d2572da2d5f9ea6dd1e50", "url": "https://github.com/mulesoft/mule/commit/333994d88b215473f28d2572da2d5f9ea6dd1e50", "message": "MULE-18102: Code review changes", "committedDate": "2020-04-30T19:20:26Z", "type": "commit"}, {"oid": "f2b46ce2eb9aaf3ba6daa52f33d6bc41865f3f88", "url": "https://github.com/mulesoft/mule/commit/f2b46ce2eb9aaf3ba6daa52f33d6bc41865f3f88", "message": "Unit testing and minor modifications in code comments", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "f7bd6cae5d8445386e5e7da2a5d18cd6f51c5283", "url": "https://github.com/mulesoft/mule/commit/f7bd6cae5d8445386e5e7da2a5d18cd6f51c5283", "message": "MULE-18102: Imports and MuleContext mocking correction", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "a2ebf8dbbbd67e0b9c73aedad4fbab0be11ba8ac", "url": "https://github.com/mulesoft/mule/commit/a2ebf8dbbbd67e0b9c73aedad4fbab0be11ba8ac", "message": "MULE-18102: Test improvements and Code Review changes", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "54ae9d59205053771ea295f9992d49576a61a38c", "url": "https://github.com/mulesoft/mule/commit/54ae9d59205053771ea295f9992d49576a61a38c", "message": "MULE-18102: Code review changes", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "32e32691931478d632f08b6cecb17758124f3a1b", "url": "https://github.com/mulesoft/mule/commit/32e32691931478d632f08b6cecb17758124f3a1b", "message": "MULE-18102: Fixing rebase issue and adding static import", "committedDate": "2020-04-30T20:50:31Z", "type": "commit"}, {"oid": "e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "url": "https://github.com/mulesoft/mule/commit/e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "message": "MULE-18102: Static import", "committedDate": "2020-04-30T20:51:49Z", "type": "commit"}, {"oid": "e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "url": "https://github.com/mulesoft/mule/commit/e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "message": "MULE-18102: Static import", "committedDate": "2020-04-30T20:51:49Z", "type": "forcePushed"}]}