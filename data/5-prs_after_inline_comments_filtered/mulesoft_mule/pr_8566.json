{"pr_number": 8566, "pr_title": "MULE-17939: Operation considers applied policies regarding thread switches", "pr_createdAt": "2020-01-13T12:54:28Z", "pr_url": "https://github.com/mulesoft/mule/pull/8566", "timeline": [{"oid": "d98364539be12c7ab87aed8c8fbd6350049d5199", "url": "https://github.com/mulesoft/mule/commit/d98364539be12c7ab87aed8c8fbd6350049d5199", "message": "adfgsdf", "committedDate": "2020-01-12T21:44:06Z", "type": "commit"}, {"oid": "10c2666d621f1b8750c3cb39f0e51e4a7eb27e21", "url": "https://github.com/mulesoft/mule/commit/10c2666d621f1b8750c3cb39f0e51e4a7eb27e21", "message": "str", "committedDate": "2020-01-12T21:44:07Z", "type": "commit"}, {"oid": "64e8ad8de55b11a361fe9ff28f671762db5829e5", "url": "https://github.com/mulesoft/mule/commit/64e8ad8de55b11a361fe9ff28f671762db5829e5", "message": "async", "committedDate": "2020-01-12T21:44:08Z", "type": "commit"}, {"oid": "1e10ce209b55c3c8b97088d825764cfa437c0fa5", "url": "https://github.com/mulesoft/mule/commit/1e10ce209b55c3c8b97088d825764cfa437c0fa5", "message": "lalala", "committedDate": "2020-01-12T21:44:09Z", "type": "commit"}, {"oid": "7219ce43162ccba181275f3d441ce434ce43e633", "url": "https://github.com/mulesoft/mule/commit/7219ce43162ccba181275f3d441ce434ce43e633", "message": "lalal", "committedDate": "2020-01-12T21:44:10Z", "type": "commit"}, {"oid": "a4c7ddea74de91080625d3f657426ed55e011fe9", "url": "https://github.com/mulesoft/mule/commit/a4c7ddea74de91080625d3f657426ed55e011fe9", "message": "sdg", "committedDate": "2020-01-12T21:44:11Z", "type": "commit"}, {"oid": "6c272381a4d23c4ffcf3968ffd2d3ed65209d99e", "url": "https://github.com/mulesoft/mule/commit/6c272381a4d23c4ffcf3968ffd2d3ed65209d99e", "message": "sadf", "committedDate": "2020-01-12T21:44:13Z", "type": "commit"}, {"oid": "e5a79f3206c481ffa6e9dbf98a80b6d80190c0b5", "url": "https://github.com/mulesoft/mule/commit/e5a79f3206c481ffa6e9dbf98a80b6d80190c0b5", "message": "Revert \"sadf\"\n\nThis reverts commit 02bf7ccbb00e4ec569a0c99fd724859b1e993e4f.", "committedDate": "2020-01-12T21:44:14Z", "type": "commit"}, {"oid": "d67e4ada81fee09709981abba5be8d8227d9d9ff", "url": "https://github.com/mulesoft/mule/commit/d67e4ada81fee09709981abba5be8d8227d9d9ff", "message": "Revert \"sdg\"\n\nThis reverts commit 86cefe375d16188696631f7aed24bc9954f9bf70.", "committedDate": "2020-01-12T21:44:15Z", "type": "commit"}, {"oid": "1216db73e3f73ed019c7b2b9330079bf291a5399", "url": "https://github.com/mulesoft/mule/commit/1216db73e3f73ed019c7b2b9330079bf291a5399", "message": "asd", "committedDate": "2020-01-12T21:44:16Z", "type": "commit"}, {"oid": "217339a6d47d3a22fea84e06fc1f758181840824", "url": "https://github.com/mulesoft/mule/commit/217339a6d47d3a22fea84e06fc1f758181840824", "message": "fix", "committedDate": "2020-01-12T21:44:17Z", "type": "commit"}, {"oid": "4ea5edfa45979854570a30e401934220c11e50e6", "url": "https://github.com/mulesoft/mule/commit/4ea5edfa45979854570a30e401934220c11e50e6", "message": "sfh", "committedDate": "2020-01-12T21:44:18Z", "type": "commit"}, {"oid": "ded3156a94fe9cd8cbd7d071476114896b0eed8a", "url": "https://github.com/mulesoft/mule/commit/ded3156a94fe9cd8cbd7d071476114896b0eed8a", "message": "more more", "committedDate": "2020-01-12T21:44:20Z", "type": "commit"}, {"oid": "cea50a42abfd314f9bd385c97234f519636847a5", "url": "https://github.com/mulesoft/mule/commit/cea50a42abfd314f9bd385c97234f519636847a5", "message": "agaga", "committedDate": "2020-01-12T21:44:21Z", "type": "commit"}, {"oid": "033b531eb865096d37cadaa9c633fa82ed27b3eb", "url": "https://github.com/mulesoft/mule/commit/033b531eb865096d37cadaa9c633fa82ed27b3eb", "message": "fix for mono users", "committedDate": "2020-01-12T21:44:22Z", "type": "commit"}, {"oid": "9def563524bd6f916c70ac94fe20b0c1b0392778", "url": "https://github.com/mulesoft/mule/commit/9def563524bd6f916c70ac94fe20b0c1b0392778", "message": "fix unit tests", "committedDate": "2020-01-12T21:44:23Z", "type": "commit"}, {"oid": "f2f642894bf571c530ca620586a48e3ceca9e36c", "url": "https://github.com/mulesoft/mule/commit/f2f642894bf571c530ca620586a48e3ceca9e36c", "message": "more fixes", "committedDate": "2020-01-12T21:44:25Z", "type": "commit"}, {"oid": "5338a9bdd2ae83939b6a9480e6108271517e0a27", "url": "https://github.com/mulesoft/mule/commit/5338a9bdd2ae83939b6a9480e6108271517e0a27", "message": "Revert \"more more\"\n\nThis reverts commit 86ecaf6dd81448a8038e0f45bfacff2538998e90.", "committedDate": "2020-01-12T21:44:26Z", "type": "commit"}, {"oid": "f3507a18e28b8dea4a344a35c718036fcbc0d669", "url": "https://github.com/mulesoft/mule/commit/f3507a18e28b8dea4a344a35c718036fcbc0d669", "message": "fix policies again", "committedDate": "2020-01-12T21:44:27Z", "type": "commit"}, {"oid": "86a8d70641d0b26269c2f36fcf3230086cda0741", "url": "https://github.com/mulesoft/mule/commit/86a8d70641d0b26269c2f36fcf3230086cda0741", "message": "possible optimizations to test", "committedDate": "2020-01-12T21:44:29Z", "type": "commit"}, {"oid": "cb3ab5ca1f2695bf5845dc9abf3f3b745dd45c04", "url": "https://github.com/mulesoft/mule/commit/cb3ab5ca1f2695bf5845dc9abf3f3b745dd45c04", "message": "bring tback the synchronous optimization to test it", "committedDate": "2020-01-12T21:44:30Z", "type": "commit"}, {"oid": "d1bdbe852bf44c0292e5b467f6db1adb8d738757", "url": "https://github.com/mulesoft/mule/commit/d1bdbe852bf44c0292e5b467f6db1adb8d738757", "message": "fixes for the perf workaround", "committedDate": "2020-01-12T21:44:31Z", "type": "commit"}, {"oid": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "url": "https://github.com/mulesoft/mule/commit/8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "message": "finally!", "committedDate": "2020-01-13T12:54:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMjA0NA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365832044", "bodyText": "jdoc", "author": "marianogonzalez", "createdAt": "2020-01-13T14:27:30Z", "path": "core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java", "diffHunk": "@@ -48,6 +48,10 @@ default void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresen\n     Flux.from(flux).subscribe();\n   }\n \n+  default Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMjMxNA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365832314", "bodyText": "I would expose this through a getter", "author": "marianogonzalez", "createdAt": "2020-01-13T14:27:56Z", "path": "core/src/main/java/org/mule/runtime/core/internal/policy/DefaultPolicyManager.java", "diffHunk": "@@ -61,7 +61,7 @@\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(DefaultPolicyManager.class);\n \n-  private static final OperationPolicy NO_POLICY_OPERATION =\n+  public static final OperationPolicy NO_POLICY_OPERATION =", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMzAxNA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365833014", "bodyText": "this should be wrapped in FunctionalUtils.safely() so that if this fails, the rest is disposed correctly", "author": "marianogonzalez", "createdAt": "2020-01-13T14:29:05Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -192,15 +198,14 @@ public void start() throws MuleException {\n   public void stop() throws MuleException {\n     super.stop();\n     stopIfNeeded(delegate);\n-\n+    stopIfNeeded(backpressureHandler);", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNDgzMw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365834833", "bodyText": "isn't this too much frequency?\nAlso:\na) isn't a busy wait preferable in cases of high throughput\nb) isn't a wait()/notify() approach preferable in most cases?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:32:35Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -293,4 +309,57 @@ public void setMaxConcurrency(Integer maxConcurrency) {\n     // Lifecycle of inner objects is already handled by this class' lifecycle methods\n     return emptyList();\n   }\n+\n+  private static class QueueBackpressureHandler implements Startable, Stoppable {\n+\n+    private final BlockingQueue<CoreEvent> asyncQueue;\n+    private final SchedulerService schedulerService;\n+    private final Supplier<SchedulerConfig> schedulerConfigSupplier;\n+    private final String location;\n+    private final Consumer<CoreEvent> eventDispatcher;\n+\n+    private Scheduler queueDispatcherScheduler;\n+\n+    public QueueBackpressureHandler(SchedulerService schedulerService, Supplier<SchedulerConfig> schedulerConfigSupplier,\n+                                    Consumer<CoreEvent> eventDispatcher, String location) {\n+      this.schedulerService = schedulerService;\n+      this.schedulerConfigSupplier = schedulerConfigSupplier;\n+\n+      this.asyncQueue = new LinkedBlockingQueue<>();\n+      this.eventDispatcher = eventDispatcher;\n+\n+      this.location = location;\n+    }\n+\n+    public void handleBackpressure(CoreEvent event) {\n+      asyncQueue.offer(event);\n+    }\n+\n+    @Override\n+    public void start() {\n+      final SchedulerConfig schedulerConfig = schedulerConfigSupplier.get().withName(location + \" - queue dispatcher\");\n+      queueDispatcherScheduler = schedulerService.ioScheduler(schedulerConfig);\n+\n+      queueDispatcherScheduler.scheduleWithFixedDelay(() -> {\n+        try {\n+          final CoreEvent event = asyncQueue.peek();\n+          if (event != null) {\n+            eventDispatcher.accept(event);\n+            asyncQueue.remove(event);\n+          }\n+        } catch (FromFlowRejectedExecutionException free) {\n+          // nothing to do, a retry will come next\n+        }\n+      }, 0, 2, MILLISECONDS);", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTE4MA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365835180", "bodyText": "weren't you going to actually increase the size of this buffer to reduce the error rate?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:33:12Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/AbstractProcessingStrategy.java", "diffHunk": "@@ -144,7 +144,7 @@ public final BackPressureReason emit(CoreEvent event) {\n       long remainingCapacity = fluxSink.requestedFromDownstream();\n       if (remainingCapacity == 0) {\n         return EVENTS_ACCUMULATED;\n-      } else if (remainingCapacity > (bufferSize > CORES * 4 ? CORES : 0)) {\n+      } else if (remainingCapacity > (bufferSize > CORES * 2 ? CORES : 0)) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0ODg4OQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365848889", "bodyText": "no need to do that, this remained of a test i made, will revert it", "author": "elrodro83", "createdAt": "2020-01-13T14:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTY2Mg==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365835662", "bodyText": "remove", "author": "marianogonzalez", "createdAt": "2020-01-13T14:34:06Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java", "diffHunk": "@@ -161,6 +150,7 @@ public ReactiveProcessor onProcessor(ReactiveProcessor processor) {\n       }\n     }\n \n+", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365836539", "bodyText": "this is shady.. this is assuming SDK behavior by testing an interface that any component can implement, not just the SDK. Is this wrong or the comment below should be updated?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:35:44Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java", "diffHunk": "@@ -174,10 +164,7 @@ protected ReactiveProcessor proactor(ReactiveProcessor processor, ScheduledExecu\n         return publisher -> scheduleProcessor(processor, retryScheduler, from(publisher))\n             .subscriberContext(ctx -> ctx.put(PROCESSOR_SCHEDULER_CONTEXT_KEY, scheduler));\n       } else if (maxConcurrency == MAX_VALUE) {\n-        if (processor.getProcessingType() == CPU_INTENSIVE\n-            && (processor instanceof InterceptedReactiveProcessor)\n-            && SDK_OPERATION_CLASS != null\n-            && SDK_OPERATION_CLASS.isAssignableFrom(((InterceptedReactiveProcessor) processor).getProcessor().getClass())) {\n+        if (processor instanceof OperationInnerProcessor) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkxMjQ5Mw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365912493", "bodyText": "OperationInnerProcessor is not API", "author": "elrodro83", "createdAt": "2020-01-13T16:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxMDM4MA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366010380", "bodyText": "but still, some other dev which doesn't have the full context could implement that interface and a problem could appear here", "author": "marianogonzalez", "createdAt": "2020-01-13T20:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxNzA1Ng==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366017056", "bodyText": "will add a note on the jdoc for OperationInnerProcessor", "author": "elrodro83", "createdAt": "2020-01-13T20:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzYxMw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365837613", "bodyText": "This method name is not really appropriate.. It seems to be more something like configureFlux or something like this.... Actually, if this were about configuring something internal, then it shouldn't return anything", "author": "marianogonzalez", "createdAt": "2020-01-13T14:37:39Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/StreamEmitterProcessingStrategyFactory.java", "diffHunk": "@@ -206,6 +207,13 @@ public void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresent\n       activeSinksCount.incrementAndGet();\n     }\n \n+    @Override\n+    public Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODYwMQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365838601", "bodyText": "jdoc", "author": "marianogonzalez", "createdAt": "2020-01-13T14:39:30Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.runtime.execution;\n+\n+import static java.util.function.Function.identity;\n+\n+import org.mule.runtime.core.api.event.CoreEvent;\n+import org.mule.runtime.core.internal.message.EventInternalContext;\n+import org.mule.runtime.core.internal.policy.OperationPolicy;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.extension.api.runtime.operation.CompletableComponentExecutor.ExecutorCallback;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import reactor.util.context.Context;\n+\n+public class SdkInternalContext implements EventInternalContext<SdkInternalContext> {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQzOA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365839438", "bodyText": "don't you need to copy the execution params? Is it ok to make a copy in which the callbacks are all the same?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:41:04Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.runtime.execution;\n+\n+import static java.util.function.Function.identity;\n+\n+import org.mule.runtime.core.api.event.CoreEvent;\n+import org.mule.runtime.core.internal.message.EventInternalContext;\n+import org.mule.runtime.core.internal.policy.OperationPolicy;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.extension.api.runtime.operation.CompletableComponentExecutor.ExecutorCallback;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import reactor.util.context.Context;\n+\n+public class SdkInternalContext implements EventInternalContext<SdkInternalContext> {\n+\n+  private OperationExecutionParams operationExecutionParams;\n+\n+  private Function<Context, Context> innerChainSubscriberContextMapping = identity();\n+\n+  private Optional<ConfigurationInstance> configuration;\n+\n+  private Map<String, Object> resolutionResult;\n+\n+  private OperationPolicy policyToApply;\n+\n+  public OperationExecutionParams getOperationExecutionParams() {\n+    return operationExecutionParams;\n+  }\n+\n+  public void setOperationExecutionParams(Optional<ConfigurationInstance> configuration, Map<String, Object> parameters,\n+                                          CoreEvent operationEvent, ExecutorCallback callback) {\n+    this.operationExecutionParams = new OperationExecutionParams(configuration, parameters, operationEvent, callback);\n+  }\n+\n+  public Function<Context, Context> getInnerChainSubscriberContextMapping() {\n+    return innerChainSubscriberContextMapping;\n+  }\n+\n+  public void setInnerChainSubscriberContextMapping(Function<Context, Context> innerChainSubscriberContextMapping) {\n+    this.innerChainSubscriberContextMapping = innerChainSubscriberContextMapping;\n+  }\n+\n+  public Optional<ConfigurationInstance> getConfiguration() {\n+    return configuration;\n+  }\n+\n+  public void setConfiguration(Optional<ConfigurationInstance> configuration) {\n+    this.configuration = configuration;\n+  }\n+\n+  public Map<String, Object> getResolutionResult() {\n+    return resolutionResult;\n+  }\n+\n+  public void setResolutionResult(Map<String, Object> resolutionResult) {\n+    this.resolutionResult = resolutionResult;\n+  }\n+\n+  public OperationPolicy getPolicyToApply() {\n+    return policyToApply;\n+  }\n+\n+  public void setPolicyToApply(OperationPolicy policyToApply) {\n+    this.policyToApply = policyToApply;\n+  }\n+\n+  @Override\n+  public SdkInternalContext copy() {\n+    return this;", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkxNTI4NQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365915285", "bodyText": "this is the most consistent with the current behavior, where all internal parameters are just copied over.", "author": "elrodro83", "createdAt": "2020-01-13T16:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTgwMw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365839803", "bodyText": "group all final fields together", "author": "marianogonzalez", "createdAt": "2020-01-13T14:41:46Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -179,6 +197,15 @@\n   private String resolvedProcessorRepresentation;\n   private boolean initialised = false;\n \n+  private ProcessingStrategy processingStrategy;\n+  private boolean ownedProcessingStrategy = false;\n+  private FluxSinkSupplier<CoreEvent> fluxSupplier;\n+  private final Object fluxSupplierDisposeLock = new Object();", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTg1NQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365839855", "bodyText": "group all final fields together", "author": "marianogonzalez", "createdAt": "2020-01-13T14:41:51Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -179,6 +197,15 @@\n   private String resolvedProcessorRepresentation;\n   private boolean initialised = false;\n \n+  private ProcessingStrategy processingStrategy;\n+  private boolean ownedProcessingStrategy = false;\n+  private FluxSinkSupplier<CoreEvent> fluxSupplier;\n+  private final Object fluxSupplierDisposeLock = new Object();\n+\n+  private Scheduler outerFluxCompletionScheduler;\n+\n+  private final AtomicInteger activeOuterPublishersCount = new AtomicInteger(0);", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDA3Nw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365840077", "bodyText": "hasNestedChain", "author": "marianogonzalez", "createdAt": "2020-01-13T14:42:15Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -161,6 +178,7 @@\n   private final RetryPolicyTemplate fallbackRetryPolicyTemplate = new NoRetryPolicyTemplate();\n \n   protected final ExtensionModel extensionModel;\n+  private final boolean hasChainNested;", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTA0Mg==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365841042", "bodyText": "add comments clarifying or extract to method with meaningful name, or both, or make a netflix documentary explaining this", "author": "marianogonzalez", "createdAt": "2020-01-13T14:44:01Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -212,73 +246,89 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n \n   @Override\n   public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-    Flux<CoreEvent> flux = from(publisher)\n-        .flatMap(event -> subscriberContext().map(ctx -> addContextToEvent(event, ctx)));\n-\n-    if (isAsync()) {\n-      final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n-          getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n-      return flux\n-          // This flatMap allows the operation to run in parallel. The processing strategy relies on this\n-          // (ProactorStreamProcessingStrategy#proactor) to do some performance optimizations.\n-          .flatMap(event -> {\n-            // Force the error mapper from the chain to be used.\n-            // When using Mono.create with sink.error, the error mapper from the context is ignored, so it has to be\n-            // explicitly used here.\n-            DeferredMonoSinkExecutorCallback callback =\n-                new DeferredMonoSinkExecutorCallback<>(t -> localOperatorErrorHook.apply(t, event));\n-\n-            onEvent(event, callback);\n-\n-            return create(callback::setSink);\n-          });\n-    } else {\n-      return flux.handle((event, sink) -> {\n-        try {\n-          onEvent(event, new SynchronousSinkExecutorCallback(sink));\n-        } catch (Throwable t) {\n-          sink.error(unwrap(t));\n-        }\n-      });\n-    }\n+    final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n+        getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n+\n+    return subscriberContext()\n+        .flatMapMany(ctx -> {\n+          final FluxSinkRecorder<Either<Throwable, CoreEvent>> errorSwitchSinkSinkRef = new FluxSinkRecorder<>();\n+\n+          Flux<CoreEvent> transformed = from(propagateCompletion(from(publisher), create(errorSwitchSinkSinkRef)\n+              .map(result -> {\n+                return result.reduce(me -> {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTQ4Ng==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365841486", "bodyText": "turn this condition into a method in the SDK internal context", "author": "marianogonzalez", "createdAt": "2020-01-13T14:44:52Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -212,73 +246,89 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n \n   @Override\n   public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-    Flux<CoreEvent> flux = from(publisher)\n-        .flatMap(event -> subscriberContext().map(ctx -> addContextToEvent(event, ctx)));\n-\n-    if (isAsync()) {\n-      final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n-          getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n-      return flux\n-          // This flatMap allows the operation to run in parallel. The processing strategy relies on this\n-          // (ProactorStreamProcessingStrategy#proactor) to do some performance optimizations.\n-          .flatMap(event -> {\n-            // Force the error mapper from the chain to be used.\n-            // When using Mono.create with sink.error, the error mapper from the context is ignored, so it has to be\n-            // explicitly used here.\n-            DeferredMonoSinkExecutorCallback callback =\n-                new DeferredMonoSinkExecutorCallback<>(t -> localOperatorErrorHook.apply(t, event));\n-\n-            onEvent(event, callback);\n-\n-            return create(callback::setSink);\n-          });\n-    } else {\n-      return flux.handle((event, sink) -> {\n-        try {\n-          onEvent(event, new SynchronousSinkExecutorCallback(sink));\n-        } catch (Throwable t) {\n-          sink.error(unwrap(t));\n-        }\n-      });\n-    }\n+    final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n+        getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n+\n+    return subscriberContext()\n+        .flatMapMany(ctx -> {\n+          final FluxSinkRecorder<Either<Throwable, CoreEvent>> errorSwitchSinkSinkRef = new FluxSinkRecorder<>();\n+\n+          Flux<CoreEvent> transformed = from(propagateCompletion(from(publisher), create(errorSwitchSinkSinkRef)\n+              .map(result -> {\n+                return result.reduce(me -> {\n+                  throw propagateWrappingFatal(me);\n+                }, response -> response);\n+              }), pub -> from(pub)\n+                  .map(event -> {\n+                    try {\n+                      return addContextToEvent(event, ctx);\n+                    } catch (MuleException t) {\n+                      throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+                    }\n+                  })\n+                  .doOnNext(event -> {\n+                    final ExecutorCallback executorCallback = new ExecutorCallback() {\n+\n+                      @Override\n+                      public void error(Throwable e) {\n+                        // if `sink.error` is called here, it will cancel the flux altogether.\n+                        // That's why an `Either` is used here,\n+                        // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                        errorSwitchSinkSinkRef.next(left(\n+                                                         // Force the error mapper from the chain to be used.\n+                                                         // When using Mono.create with sink.error, the error mapper from the\n+                                                         // context is ignored, so it has to be explicitly used here.\n+                                                         localOperatorErrorHook.apply(e, event), CoreEvent.class));\n+                      }\n+\n+                      @Override\n+                      public void complete(Object value) {\n+                        errorSwitchSinkSinkRef.next(right(Throwable.class, (CoreEvent) value));\n+                      }\n+                    };\n+\n+                    if (!isAsync() && NO_POLICY_OPERATION\n+                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MjAwNg==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365842006", "bodyText": "extract to static method in org.mule.runtime.module.extension.api.util.MuleExtensionUtils", "author": "marianogonzalez", "createdAt": "2020-01-13T14:45:52Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -212,73 +246,89 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n \n   @Override\n   public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-    Flux<CoreEvent> flux = from(publisher)\n-        .flatMap(event -> subscriberContext().map(ctx -> addContextToEvent(event, ctx)));\n-\n-    if (isAsync()) {\n-      final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n-          getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n-      return flux\n-          // This flatMap allows the operation to run in parallel. The processing strategy relies on this\n-          // (ProactorStreamProcessingStrategy#proactor) to do some performance optimizations.\n-          .flatMap(event -> {\n-            // Force the error mapper from the chain to be used.\n-            // When using Mono.create with sink.error, the error mapper from the context is ignored, so it has to be\n-            // explicitly used here.\n-            DeferredMonoSinkExecutorCallback callback =\n-                new DeferredMonoSinkExecutorCallback<>(t -> localOperatorErrorHook.apply(t, event));\n-\n-            onEvent(event, callback);\n-\n-            return create(callback::setSink);\n-          });\n-    } else {\n-      return flux.handle((event, sink) -> {\n-        try {\n-          onEvent(event, new SynchronousSinkExecutorCallback(sink));\n-        } catch (Throwable t) {\n-          sink.error(unwrap(t));\n-        }\n-      });\n-    }\n+    final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n+        getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n+\n+    return subscriberContext()\n+        .flatMapMany(ctx -> {\n+          final FluxSinkRecorder<Either<Throwable, CoreEvent>> errorSwitchSinkSinkRef = new FluxSinkRecorder<>();\n+\n+          Flux<CoreEvent> transformed = from(propagateCompletion(from(publisher), create(errorSwitchSinkSinkRef)\n+              .map(result -> {\n+                return result.reduce(me -> {\n+                  throw propagateWrappingFatal(me);\n+                }, response -> response);\n+              }), pub -> from(pub)\n+                  .map(event -> {\n+                    try {\n+                      return addContextToEvent(event, ctx);\n+                    } catch (MuleException t) {\n+                      throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+                    }\n+                  })\n+                  .doOnNext(event -> {\n+                    final ExecutorCallback executorCallback = new ExecutorCallback() {\n+\n+                      @Override\n+                      public void error(Throwable e) {\n+                        // if `sink.error` is called here, it will cancel the flux altogether.\n+                        // That's why an `Either` is used here,\n+                        // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                        errorSwitchSinkSinkRef.next(left(\n+                                                         // Force the error mapper from the chain to be used.\n+                                                         // When using Mono.create with sink.error, the error mapper from the\n+                                                         // context is ignored, so it has to be explicitly used here.\n+                                                         localOperatorErrorHook.apply(e, event), CoreEvent.class));\n+                      }\n+\n+                      @Override\n+                      public void complete(Object value) {\n+                        errorSwitchSinkSinkRef.next(right(Throwable.class, (CoreEvent) value));\n+                      }\n+                    };\n+\n+                    if (!isAsync() && NO_POLICY_OPERATION\n+                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())\n+                            .getPolicyToApply())) {\n+                      onEventSynchronous(event, executorCallback, ctx);\n+                    } else {\n+                      onEvent(event, executorCallback);\n+                    }\n+                  }), () -> errorSwitchSinkSinkRef.complete(), t -> errorSwitchSinkSinkRef.error(t),\n+                                                                 muleContext.getConfiguration().getShutdownTimeout(),\n+                                                                 outerFluxCompletionScheduler));\n+\n+          if (publisher instanceof Flux && !ctx.getOrEmpty(WITHIN_PROCESS_TO_APPLY).isPresent()) {\n+            return transformed\n+                .doAfterTerminate(this::outerPublisherTerminated)\n+                .doOnSubscribe(s -> outerPublisherSubscribedTo());\n+          } else {\n+            // Certain features (ext client, batch, flow runner) use Mono, so we don't want to dispose the inner stuff after the\n+            // first event comes through\n+            return transformed;\n+          }\n+        });\n   }\n \n   private void onEvent(CoreEvent event, ExecutorCallback executorCallback) {\n     try {\n+      SdkInternalContext sdkInternalContext =\n+          ((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext());", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzM2NQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365843365", "bodyText": "where is this context cleared/replaced?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:48:17Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -369,15 +416,120 @@ protected void doInitialise() throws InitialisationException {\n       executionMediator = createExecutionMediator();\n       initialiseIfNeeded(componentExecutor, true, muleContext);\n \n-      if (getLocation() != null) {\n-        resolvedProcessorRepresentation =\n-            resolveProcessorRepresentation(muleContext.getConfiguration().getId(), getLocation().getLocation(), this);\n-      }\n+      resolvedProcessorRepresentation =\n+          resolveProcessorRepresentation(muleContext.getConfiguration().getId(), toString(), this);\n \n+      initProcessingStrategy();\n       initialised = true;\n     }\n   }\n \n+  private void initProcessingStrategy() throws InitialisationException {\n+    final Optional<ProcessingStrategy> processingStrategyFromRootContainer =\n+        getProcessingStrategy(componentLocator, getRootContainerLocation());\n+\n+    processingStrategy = processingStrategyFromRootContainer\n+        .orElseGet(() -> createDefaultProcessingStrategyFactory().create(muleContext, toString() + \".ps\"));\n+\n+    if (!processingStrategyFromRootContainer.isPresent()) {\n+      ownedProcessingStrategy = true;\n+      initialiseIfNeeded(processingStrategy);\n+    }\n+  }\n+\n+  private void startInnerFlux() {\n+    fluxSupplier = createRoundRobinFluxSupplier(p -> {\n+      final OperationInnerProcessor operationInnerProcessor = new OperationInnerProcessor() {\n+\n+        @Override\n+        public ProcessingType getProcessingType() {\n+          return getInnerProcessingType();\n+        }\n+\n+        @Override\n+        public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n+          return subscriberContext()\n+              .flatMapMany(ctx -> from(publisher)\n+                  .doOnNext(event -> prepareAndExecuteOperation(event,\n+                                                                () -> {\n+                                                                  OperationExecutionParams oep =\n+                                                                      ((SdkInternalContext) ((InternalEvent) event)\n+                                                                          .<SdkInternalContext>getSdkInternalContext())\n+                                                                              .getOperationExecutionParams();\n+                                                                  return oep.getCallback();\n+                                                                },\n+                                                                ctx)));\n+        }\n+\n+        @Override\n+        public boolean isAsync() {\n+          return ComponentMessageProcessor.this.isAsync();\n+        }\n+      };\n+\n+      final Flux<CoreEvent> transformed = from(p)\n+          .transform(processingStrategy.onProcessor(operationInnerProcessor))\n+          .onErrorContinue((t, event) -> LOGGER.error(\"Unhandler error in operation (\" + toString() + \") flux\",\n+                                                      t));\n+      return from(processingStrategy.registerInternalFlux(transformed));\n+    },\n+                                                getRuntime().availableProcessors());\n+  }\n+\n+  private CoreEvent addContextToEvent(CoreEvent event, Context ctx) throws MuleException {\n+    SdkInternalContext sdkInternalContext =\n+        (SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext();\n+    if (((InternalEvent) event).getSdkInternalContext() == null) {\n+      sdkInternalContext = new SdkInternalContext();\n+      ((InternalEvent) event).setSdkInternalContext(sdkInternalContext);\n+    }\n+\n+    if (hasChainNested\n+        && (ctx.hasKey(POLICY_NEXT_OPERATION) || ctx.hasKey(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS))) {\n+      sdkInternalContext.setInnerChainSubscriberContextMapping(innerChainCtx -> {\n+        if (ctx.hasKey(POLICY_NEXT_OPERATION)) {\n+          innerChainCtx = innerChainCtx.put(POLICY_NEXT_OPERATION, ctx.get(POLICY_NEXT_OPERATION));\n+        }\n+        if (ctx.hasKey(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS)) {\n+          innerChainCtx = innerChainCtx.put(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS,\n+                                            ctx.get(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS));\n+        }\n+        return innerChainCtx;\n+      });\n+    }\n+\n+    sdkInternalContext.setConfiguration(resolveConfiguration(event));\n+    final Map<String, Object> resolutionResult = getResolutionResult(event, sdkInternalContext.getConfiguration());\n+    sdkInternalContext.setResolutionResult(resolutionResult);\n+    sdkInternalContext.setPolicyToApply(getLocation() != null", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMDYxNw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365920617", "bodyText": "this is create above in this method. Will add a clear for it", "author": "elrodro83", "createdAt": "2020-01-13T17:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0NDI4Nw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365844287", "bodyText": "add a clarifying comment about the inner chain processing type being the one that actually reflects the operation", "author": "marianogonzalez", "createdAt": "2020-01-13T14:49:55Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -666,8 +861,9 @@ protected ParameterValueResolver getParameterValueResolver() {\n     }\n   }\n \n-  @Override\n-  public abstract ProcessingType getProcessingType();\n+  public ProcessingType getInnerProcessingType() {\n+    return CPU_LITE;", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba16df522b269413f0e4ea97dc3629e194b134e2", "url": "https://github.com/mulesoft/mule/commit/ba16df522b269413f0e4ea97dc3629e194b134e2", "message": "review bulk", "committedDate": "2020-01-13T17:48:07Z", "type": "commit"}, {"oid": "5f4c30643c83c801810e16370076b83edeba7ecb", "url": "https://github.com/mulesoft/mule/commit/5f4c30643c83c801810e16370076b83edeba7ecb", "message": "review async", "committedDate": "2020-01-13T18:33:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwOTkwOQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366009909", "bodyText": "is graceful shutdown a particular use case of this method or is the only and sole purpose of it? Depending on that, either change the jdoc or rename to something more specific", "author": "marianogonzalez", "createdAt": "2020-01-13T20:24:00Z", "path": "core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java", "diffHunk": "@@ -48,7 +48,14 @@ default void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresen\n     Flux.from(flux).subscribe();\n   }\n \n-  default Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {\n+  /**\n+   * For fluxes created outside of the main flux for a flow, have them accounted for in the processing strategy for a graceful", "originalCommit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxMTY1OQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366011659", "bodyText": "why do we still need to keep this polling every 200 ms? If this tasks gets scheduled because of a brief high demand lapse, then this task will continue to run every 200ms without need. Can't we use a traditional single threaded wait/notify()?", "author": "marianogonzalez", "createdAt": "2020-01-13T20:28:27Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -335,22 +341,36 @@ public void handleBackpressure(CoreEvent event) {\n       asyncQueue.offer(event);\n     }\n \n+    public void asyncTaskFinished() {\n+      if (scheduledDrain == null) {\n+        synchronized (this) {\n+          if (scheduledDrain == null) {\n+            scheduledDrain = queueDispatcherScheduler.schedule(() -> {\n+              while (asyncQueue.size() > 0) {\n+                try {\n+                  final CoreEvent event = asyncQueue.peek();\n+                  if (event != null) {\n+                    eventDispatcher.accept(event);\n+                    asyncQueue.remove(event);\n+                  }\n+                } catch (FromFlowRejectedExecutionException free) {\n+                  synchronized (this) {\n+                    scheduledDrain = null;\n+                  }\n+                  // nothing to do, a retry will come next\n+                  return;\n+                }\n+              }\n+            }, 200, MILLISECONDS);", "originalCommit": "5f4c30643c83c801810e16370076b83edeba7ecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxNDU0MQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366014541", "bodyText": "the thing is that the wait/notify mechanism will still keep a thread busy waiting for elements to arrive at the queue.\nWith this approach, this task is active only while it makes sense to poll the queue.", "author": "elrodro83", "createdAt": "2020-01-13T20:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxMTY1OQ=="}], "type": "inlineReview"}, {"oid": "4e3bcd179f7b3e1e9e591057186833778ce133cd", "url": "https://github.com/mulesoft/mule/commit/4e3bcd179f7b3e1e9e591057186833778ce133cd", "message": "more review", "committedDate": "2020-01-13T20:55:32Z", "type": "commit"}, {"oid": "a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "url": "https://github.com/mulesoft/mule/commit/a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "message": "more review", "committedDate": "2020-01-13T21:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0MjU0Mw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366042543", "bodyText": "delete method then. Doesn't look like you're actually forced to implement Startable", "author": "marianogonzalez", "createdAt": "2020-01-13T21:39:24Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -318,67 +317,61 @@ public void setMaxConcurrency(Integer maxConcurrency) {\n   private static class QueueBackpressureHandler implements Startable, Stoppable {\n \n     private final BlockingQueue<CoreEvent> asyncQueue;\n-    private final SchedulerService schedulerService;\n-    private final Supplier<SchedulerConfig> schedulerConfigSupplier;\n-    private final String location;\n     private final Consumer<CoreEvent> eventDispatcher;\n \n-    private Scheduler queueDispatcherScheduler;\n-    private volatile ScheduledFuture<?> scheduledDrain;\n+    private final LazyValue<Scheduler> queueDispatcherScheduler;\n \n     public QueueBackpressureHandler(SchedulerService schedulerService, Supplier<SchedulerConfig> schedulerConfigSupplier,\n                                     Consumer<CoreEvent> eventDispatcher, String location) {\n-      this.schedulerService = schedulerService;\n-      this.schedulerConfigSupplier = schedulerConfigSupplier;\n-\n       this.asyncQueue = new LinkedBlockingQueue<>();\n       this.eventDispatcher = eventDispatcher;\n \n-      this.location = location;\n+      this.queueDispatcherScheduler = new LazyValue(() -> {\n+        final SchedulerConfig schedulerConfig = schedulerConfigSupplier.get().withName(location + \" - queue dispatcher\")\n+            .withMaxConcurrentTasks(1);\n+        return schedulerService.customScheduler(schedulerConfig);\n+      });\n     }\n \n     public void handleBackpressure(CoreEvent event) {\n       asyncQueue.offer(event);\n-    }\n \n-    public void asyncTaskFinished() {\n-      if (scheduledDrain == null) {\n-        synchronized (this) {\n-          if (scheduledDrain == null) {\n-            scheduledDrain = queueDispatcherScheduler.schedule(() -> {\n-              while (asyncQueue.size() > 0) {\n-                try {\n-                  final CoreEvent event = asyncQueue.peek();\n-                  if (event != null) {\n-                    eventDispatcher.accept(event);\n-                    asyncQueue.remove(event);\n-                  }\n-                } catch (FromFlowRejectedExecutionException free) {\n-                  synchronized (this) {\n-                    scheduledDrain = null;\n-                  }\n-                  // nothing to do, a retry will come next\n-                  return;\n-                }\n+      synchronized (asyncQueue) {\n+        asyncQueue.notify();\n+      }\n+\n+      queueDispatcherScheduler.get().execute(() -> {\n+        while (!currentThread().isInterrupted()) {\n+          try {\n+            final CoreEvent queuedEvent = asyncQueue.peek();\n+            if (queuedEvent != null) {\n+              eventDispatcher.accept(queuedEvent);\n+              asyncQueue.remove(queuedEvent);\n+            } else {\n+              synchronized (asyncQueue) {\n+                asyncQueue.wait();\n               }\n-            }, 200, MILLISECONDS);\n+            }\n+          } catch (FromFlowRejectedExecutionException free) {\n+            // Nothing to do, let next iteration catch it.\n+            yield();\n+          } catch (InterruptedException e) {\n+            currentThread().interrupt();\n+            return;\n           }\n         }\n-      }\n+      });\n     }\n \n     @Override\n     public void start() {", "originalCommit": "a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34fd9bb610860234c66935b445fd1bc77416df09", "url": "https://github.com/mulesoft/mule/commit/34fd9bb610860234c66935b445fd1bc77416df09", "message": "making MG happy", "committedDate": "2020-01-13T21:43:42Z", "type": "commit"}]}