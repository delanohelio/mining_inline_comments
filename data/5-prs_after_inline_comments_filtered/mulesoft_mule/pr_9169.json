{"pr_number": 9169, "pr_title": "CMTS-34: Support Metadata Types resolution", "pr_createdAt": "2020-08-06T12:31:03Z", "pr_url": "https://github.com/mulesoft/mule/pull/9169", "timeline": [{"oid": "324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "url": "https://github.com/mulesoft/mule/commit/324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "message": "CMTS-34: Support Metadata Types resolution", "committedDate": "2020-08-05T20:31:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTA5Nw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466421097", "bodyText": "@since 4.4", "author": "gsfernandes", "createdAt": "2020-08-06T13:42:22Z", "path": "modules/tooling-support-parent/tooling-support/src/main/java/org/mule/runtime/module/tooling/api/metadata/ComponentMetadataTypes.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.tooling.api.metadata;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.Optional.ofNullable;\n+\n+import org.mule.metadata.api.model.MetadataType;\n+import org.mule.runtime.api.metadata.descriptor.InputMetadataDescriptor;\n+import org.mule.runtime.api.metadata.descriptor.OutputMetadataDescriptor;\n+import org.mule.runtime.api.metadata.descriptor.ParameterMetadataDescriptor;\n+import org.mule.runtime.api.metadata.descriptor.TypeMetadataDescriptor;\n+import org.mule.runtime.api.metadata.resolving.MetadataResult;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * Exposes all the dynamic metadata (input, output, attributes) of a given component.\n+ */", "originalCommit": "324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyMjEyMA==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466522120", "bodyText": "DeclarationSession has @since 4.4.0, should I change it to 4.4 too?", "author": "svacas", "createdAt": "2020-08-06T16:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTQ2OQ==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466421469", "bodyText": "I would move this to a \"builder\" as this object would be used as POJO for sending the response to the client.", "author": "gsfernandes", "createdAt": "2020-08-06T13:42:55Z", "path": "modules/tooling-support-parent/tooling-support/src/main/java/org/mule/runtime/module/tooling/api/metadata/ComponentMetadataTypes.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.tooling.api.metadata;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.Optional.ofNullable;\n+\n+import org.mule.metadata.api.model.MetadataType;\n+import org.mule.runtime.api.metadata.descriptor.InputMetadataDescriptor;\n+import org.mule.runtime.api.metadata.descriptor.OutputMetadataDescriptor;\n+import org.mule.runtime.api.metadata.descriptor.ParameterMetadataDescriptor;\n+import org.mule.runtime.api.metadata.descriptor.TypeMetadataDescriptor;\n+import org.mule.runtime.api.metadata.resolving.MetadataResult;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * Exposes all the dynamic metadata (input, output, attributes) of a given component.\n+ */\n+public class ComponentMetadataTypes {\n+\n+  private Map<String, MetadataType> input = new HashMap<>();\n+  private MetadataType output;\n+  private MetadataType outputAttributes;\n+\n+  public ComponentMetadataTypes(MetadataResult<InputMetadataDescriptor> inputMetadataResult,", "originalCommit": "324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyMzA2MA==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466523060", "bodyText": "Ok, I'll move the constructor logic to a builder.\nAny requirements by the serializer regarding constructors? like having a public no-args one?", "author": "svacas", "createdAt": "2020-08-06T16:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNTc5Mg==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466535792", "bodyText": "Not so far but I would need to move this class lo mule-api. Let's keep it here for now and I will change it in next PR when adding serialization support.", "author": "gsfernandes", "createdAt": "2020-08-06T16:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTY2Nw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466421667", "bodyText": "Static imports.", "author": "gsfernandes", "createdAt": "2020-08-06T13:43:13Z", "path": "modules/tooling-support-parent/tooling-support/src/main/java/org/mule/runtime/module/tooling/internal/config/DefaultDeclarationSession.java", "diffHunk": "@@ -83,6 +88,19 @@ public ValueResult getValues(ParameterizedElementDeclaration component, String p\n     }\n   }\n \n+  @Override\n+  public MetadataResult<ComponentMetadataTypes> getMetadataTypes(ComponentElementDeclaration component) {\n+    try {\n+      return withInternalService().getMetadataTypes(component);\n+    } catch (Exception e) {\n+      return MetadataResult.failure(MetadataFailure.Builder.newFailure()", "originalCommit": "324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyMzM4OQ==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466523389", "bodyText": "already taken by\nimport static org.mule.runtime.api.connection.ConnectionValidationResult.failure;\nimport static org.mule.runtime.api.value.ResolvingFailure.Builder.newFailure;", "author": "svacas", "createdAt": "2020-08-06T16:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNTkyNw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466535927", "bodyText": "\ud83d\udc4d", "author": "gsfernandes", "createdAt": "2020-08-06T16:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMjAyNw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466422027", "bodyText": "static import", "author": "gsfernandes", "createdAt": "2020-08-06T13:43:43Z", "path": "modules/tooling-support-parent/tooling-support/src/main/java/org/mule/runtime/module/tooling/internal/config/InternalDeclarationSession.java", "diffHunk": "@@ -121,6 +147,141 @@ public ValueResult getValues(ParameterizedElementDeclaration component, String p\n     }\n   }\n \n+  @Override\n+  public MetadataResult<ComponentMetadataTypes> getMetadataTypes(ComponentElementDeclaration component) {\n+    return artifactHelper()\n+        .findComponentModel(component)\n+        .map(cm -> {\n+          Optional<ConfigurationInstance> configurationInstance =\n+              ofNullable(component.getConfigRef()).flatMap(name -> artifactHelper().getConfigurationInstance(name));\n+\n+          MetadataKey metadataKey = buildMetadataKey(cm, component);\n+          ClassLoader extensionClassLoader = getClassLoader(artifactHelper().getExtensionModel(component));\n+          return withContextClassLoader(extensionClassLoader, () -> {\n+            MetadataMediator<? extends ComponentModel> metadataMediator = new MetadataMediator<>(cm);\n+            MetadataResult<InputMetadataDescriptor> inputMetadata = metadataMediator\n+                .getInputMetadata(createMetadataContext(configurationInstance, extensionClassLoader),\n+                                  metadataKey);\n+            MetadataResult<OutputMetadataDescriptor> outputMetadata = null;\n+            if (cm instanceof HasOutputModel) {\n+              outputMetadata = metadataMediator\n+                  .getOutputMetadata(createMetadataContext(configurationInstance, extensionClassLoader),\n+                                     metadataKey);\n+            }\n+            return collectMetadata(inputMetadata, outputMetadata);\n+          });\n+        })\n+        .orElseGet(() -> MetadataResult.failure(MetadataFailure.Builder.newFailure()", "originalCommit": "324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyMzQ5Nw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466523497", "bodyText": "already taken by\nimport static org.mule.runtime.api.connection.ConnectionValidationResult.failure;\nimport static org.mule.runtime.api.value.ResolvingFailure.Builder.newFailure;", "author": "svacas", "createdAt": "2020-08-06T16:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMjAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzMDIxNw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466430217", "bodyText": "This would be fine for resolving types but when resolving keys with a partial key as input we should not use default values and request to get the key completed in the declaration instead.", "author": "gsfernandes", "createdAt": "2020-08-06T13:55:13Z", "path": "modules/tooling-support-parent/tooling-support/src/main/java/org/mule/runtime/module/tooling/internal/config/InternalDeclarationSession.java", "diffHunk": "@@ -121,6 +147,141 @@ public ValueResult getValues(ParameterizedElementDeclaration component, String p\n     }\n   }\n \n+  @Override\n+  public MetadataResult<ComponentMetadataTypes> getMetadataTypes(ComponentElementDeclaration component) {\n+    return artifactHelper()\n+        .findComponentModel(component)\n+        .map(cm -> {\n+          Optional<ConfigurationInstance> configurationInstance =\n+              ofNullable(component.getConfigRef()).flatMap(name -> artifactHelper().getConfigurationInstance(name));\n+\n+          MetadataKey metadataKey = buildMetadataKey(cm, component);\n+          ClassLoader extensionClassLoader = getClassLoader(artifactHelper().getExtensionModel(component));\n+          return withContextClassLoader(extensionClassLoader, () -> {\n+            MetadataMediator<? extends ComponentModel> metadataMediator = new MetadataMediator<>(cm);\n+            MetadataResult<InputMetadataDescriptor> inputMetadata = metadataMediator\n+                .getInputMetadata(createMetadataContext(configurationInstance, extensionClassLoader),\n+                                  metadataKey);\n+            MetadataResult<OutputMetadataDescriptor> outputMetadata = null;\n+            if (cm instanceof HasOutputModel) {\n+              outputMetadata = metadataMediator\n+                  .getOutputMetadata(createMetadataContext(configurationInstance, extensionClassLoader),\n+                                     metadataKey);\n+            }\n+            return collectMetadata(inputMetadata, outputMetadata);\n+          });\n+        })\n+        .orElseGet(() -> MetadataResult.failure(MetadataFailure.Builder.newFailure()\n+            .withMessage(format(\"Error resolving metadata for the [%s:%s] component\",\n+                                component.getDeclaringExtension(), component.getName()))\n+            .withFailureCode(COMPONENT_NOT_FOUND)\n+            .onComponent()));\n+  }\n+\n+  private MetadataResult<ComponentMetadataTypes> collectMetadata(@Nonnull MetadataResult<InputMetadataDescriptor> inputMetadataResult,\n+                                                                 @Nullable MetadataResult<OutputMetadataDescriptor> outputMetadataResult) {\n+    if (inputMetadataResult.isSuccess() && (outputMetadataResult == null || outputMetadataResult.isSuccess())) {\n+      return MetadataResult.success(new ComponentMetadataTypes(inputMetadataResult, outputMetadataResult));\n+    }\n+    List<MetadataFailure> failures = new ArrayList<>(inputMetadataResult.getFailures());\n+    if (outputMetadataResult != null) {\n+      failures.addAll(outputMetadataResult.getFailures());\n+    }\n+    return MetadataResult.failure(failures);\n+  }\n+\n+  private DefaultMetadataContext createMetadataContext(Optional<ConfigurationInstance> configurationInstance,\n+                                                       ClassLoader extensionClassLoader) {\n+    return new DefaultMetadataContext(() -> configurationInstance,\n+                                      connectionManager,\n+                                      new DefaultMetadataCache(),\n+                                      new JavaTypeLoader(extensionClassLoader));\n+  }\n+\n+  private MetadataKey buildMetadataKey(ComponentModel componentModel, ComponentElementDeclaration<?> elementDeclaration) {\n+    List<ParameterModel> keyParts = getMetadataKeyParts(componentModel);\n+\n+    if (keyParts.isEmpty()) {\n+      return MetadataKeyBuilder.newKey(NullMetadataKey.ID).build();\n+    }\n+\n+    MetadataKeyBuilder rootMetadataKeyBuilder = null;\n+    MetadataKeyBuilder metadataKeyBuilder = null;\n+    Map<String, Object> componentElementDeclarationParameters =\n+        getComponentElementDeclarationParameters(elementDeclaration, componentModel);\n+    for (ParameterModel parameterModel : keyParts) {\n+      String id;\n+      if (componentElementDeclarationParameters.containsKey(parameterModel.getName())) {\n+        id = (String) componentElementDeclarationParameters.get(parameterModel.getName());\n+      } else {\n+        // It is only supported to defined parts in order\n+        break;\n+      }\n+\n+      if (id != null) {\n+        if (metadataKeyBuilder == null) {\n+          metadataKeyBuilder = MetadataKeyBuilder.newKey(id).withPartName(parameterModel.getName());\n+          rootMetadataKeyBuilder = metadataKeyBuilder;\n+        } else {\n+          MetadataKeyBuilder metadataKeyChildBuilder = MetadataKeyBuilder.newKey(id).withPartName(parameterModel.getName());\n+          metadataKeyBuilder.withChild(metadataKeyChildBuilder);\n+          metadataKeyBuilder = metadataKeyChildBuilder;\n+        }\n+      }\n+    }\n+\n+    if (metadataKeyBuilder == null) {\n+      return MetadataKeyBuilder.newKey(NullMetadataKey.ID).build();\n+    }\n+    return rootMetadataKeyBuilder.build();\n+  }\n+\n+  private List<ParameterModel> getMetadataKeyParts(ComponentModel componentModel) {\n+    return componentModel.getAllParameterModels().stream()\n+        .filter(p -> p.getModelProperty(MetadataKeyPartModelProperty.class).isPresent())\n+        .sorted(comparingInt(p -> p.getModelProperty(MetadataKeyPartModelProperty.class).get().getOrder()))\n+        .collect(toList());\n+  }\n+\n+  private <T extends ComponentModel> Map<String, Object> getComponentElementDeclarationParameters(ComponentElementDeclaration componentElementDeclaration,\n+                                                                                                  T model) {\n+    Map<String, Object> parametersMap = new HashMap<>();\n+\n+    Map<String, ParameterGroupModel> parameterGroups =\n+        model.getParameterGroupModels().stream().collect(toMap(NamedObject::getName, identity()));\n+\n+    List<String> parameterGroupsResolved = new ArrayList<>();\n+\n+    for (ParameterGroupElementDeclaration parameterGroupElement : componentElementDeclaration.getParameterGroups()) {\n+      final String parameterGroupName = parameterGroupElement.getName();\n+      final ParameterGroupModel parameterGroupModel = parameterGroups.get(parameterGroupName);\n+      if (parameterGroupModel == null) {\n+        throw new MuleRuntimeException(createStaticMessage(\"Could not find parameter group with name: %s in model\",\n+                                                           parameterGroupName));\n+      }\n+\n+      parameterGroupsResolved.add(parameterGroupName);\n+\n+      for (ParameterElementDeclaration parameterElement : parameterGroupElement.getParameters()) {\n+        final String parameterName = parameterElement.getName();\n+        final ParameterModel parameterModel = parameterGroupModel.getParameter(parameterName)\n+            .orElseThrow(() -> new MuleRuntimeException(createStaticMessage(\"Could not find parameter with name: %s in parameter group: %s\",\n+                                                                            parameterName, parameterGroupName)));\n+        parametersMap.put(parameterName,\n+                          extractValue(parameterElement.getValue(),\n+                                       artifactHelper().getParameterClass(parameterModel, componentElementDeclaration)));\n+      }\n+    }\n+\n+    // Default values", "originalCommit": "324af2099dc081b7298706c32d9dc5a6bfb1c4ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MDU1Mw==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466540553", "bodyText": "we could add a flag to getComponentElementDeclarationParameters to indicate if defaults should be used or not, that would do?", "author": "svacas", "createdAt": "2020-08-06T16:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzMDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjM5Ng==", "url": "https://github.com/mulesoft/mule/pull/9169#discussion_r466572396", "bodyText": "Yes, we could.", "author": "gsfernandes", "createdAt": "2020-08-06T17:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzMDIxNw=="}], "type": "inlineReview"}, {"oid": "918cecd2f248be06d93e1a5e4d8232fee6e45444", "url": "https://github.com/mulesoft/mule/commit/918cecd2f248be06d93e1a5e4d8232fee6e45444", "message": "PR comments", "committedDate": "2020-08-06T17:25:16Z", "type": "commit"}]}