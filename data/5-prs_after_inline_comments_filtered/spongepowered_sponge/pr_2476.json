{"pr_number": 2476, "pr_title": "PhaseTracker 1.14 Upgrade", "pr_createdAt": "2020-01-12T09:38:24Z", "pr_url": "https://github.com/SpongePowered/Sponge/pull/2476", "timeline": [{"oid": "09412d7085b3d12a332a687da20c51dc1e81035b", "url": "https://github.com/SpongePowered/Sponge/commit/09412d7085b3d12a332a687da20c51dc1e81035b", "message": "Start dicing and slicing. Lost a lot of work from a branch somewhere.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>", "committedDate": "2020-01-11T08:16:38Z", "type": "commit"}, {"oid": "f4f9ed72f8babc0d4ad4f30d6d2f92444f50ffde", "url": "https://github.com/SpongePowered/Sponge/commit/f4f9ed72f8babc0d4ad4f30d6d2f92444f50ffde", "message": "Add back the block change flag registration and handling. Restart documenting the block physics process to re-re-re-re-re-rewrite the core of logging these changes.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>", "committedDate": "2020-01-11T10:07:23Z", "type": "commit"}, {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e", "url": "https://github.com/SpongePowered/Sponge/commit/c74933fbfd73f7f2628aed69d38746e8811e173e", "message": "Work in progress to getting the PhaseTracker hooks working again. Restarted WorldMixin and ServerWorldMixin.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>", "committedDate": "2020-01-12T08:07:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTc2NA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365569764", "bodyText": "@dualspiral @Zidane I'm introducing this due to the nature of now having possibly multiple threads accessing the same values/stacks, and avoiding the cache getting corrupted, I figured this would be optimal, but I'd ask for someone more knowledgeable than I about threading.", "author": "gabizou", "createdAt": "2020-01-12T09:40:24Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PooledPhaseState.java", "diffHunk": "@@ -25,45 +25,62 @@\n package org.spongepowered.common.event.tracking;\n \n import java.util.ArrayDeque;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.annotation.Nullable;\n \n public abstract class PooledPhaseState<C extends PhaseContext<C>> implements IPhaseState<C> {\n \n-    private final ArrayDeque<C> contextPool = PhaseTracker.SERVER.createContextPool(this);\n+    private static final ConcurrentHashMap<IPhaseState<?>, ArrayDeque<? extends PhaseContext<?>>> stateContextPool = new ConcurrentHashMap<>();\n+    private final ArrayDeque<C> contextPool;\n     @Nullable private C cached;\n+    final ReentrantLock lock = new ReentrantLock();\n \n     protected PooledPhaseState() {\n+        final ArrayDeque<C> pool = new ArrayDeque<>();\n+        PooledPhaseState.stateContextPool.put(this, pool);\n+        this.contextPool = pool;\n     }\n \n     @Override\n     public final C createPhaseContext() {\n-        if (this.cached != null && !this.cached.isCompleted) {\n-            final C cached = this.cached;\n-            this.cached = null;\n-            return cached;\n+        this.lock.lock();", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU3OTMwNQ==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365579305", "bodyText": "Hooray, my numerical simulation knowledge comes into play here!\nThis will work, but I'm concerned about the performance penalty of this. Now, I'm not completely versed in the internals of the PhaseTracker, but I know enough about it to know that this code is going to be executed hundereds, if not thousands of times per second.\nConsider this happening on multiple threads. A lock must always be treated as a bottleneck, because you're saying that you know multiple threads might access this so you need them to do it one at a time. That's going to happen a lot here - if we're not careful, the performance benefit of the async world generators will become a performance deficit because phases can only be switched one at a time - and this is happening both on build up and tear down of a phase.\nI think that we may need to give each instance of the phase tracker a UUID that allows us to identify it, and/or let each phase tracker have its own pool of objects. I don't think there will be a massive cost memory wise really and we'll not have to worry about dreadful performance because of many many multi thread contexts switches a second.\n(Aside: I've done this before. I used MPI in my Monte-Carlo simulations but needed everything to sync up at one point. I was too judicious with my sync points and my simulation ended up being three times slower. I also had the risk of deadlock and this affected multiple nodes in a cluster hitting many other users waiting for their code to run! I don't think we have it here but that was hard to resolve...)", "author": "dualspiral", "createdAt": "2020-01-12T12:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU3OTU5NA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365579594", "bodyText": "Looking a slight bit more, the cached context is linked to the state which I'm also guessing is pooled - is the state per phase-tracker instance? If it is, you wouldn't need to lock until after the first if block which would mitigate some of the hit with locking as the cached context would also be per phase-tracker instance.", "author": "dualspiral", "createdAt": "2020-01-12T12:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU4MTIyOA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365581228", "bodyText": "Hooray, my numerical simulation knowledge comes into play here!\n\nYay! Primarily why I ask, since\n\nConsider this happening on multiple threads. A lock must always be treated as a bottleneck, because you're saying that you know multiple threads might access this so you need them to do it one at a time. That's going to happen a lot here - if we're not careful, the performance benefit of the async world generators will become a performance deficit because phases can only be switched one at a time - and this is happening both on build up and tear down of a phase.\n\nRight, suffice to say that this will happen for each Entity, TileEntity, BlockState, FluidState, and BlockState random ticks, along with every single NeighborNotification and possibly NeighborShapeUpdate, so it's going to be \"hot\" to say the least.\n\nI think that we may need to give each instance of the phase tracker a UUID that allows us to identify it, and/or let each phase tracker have its own pool of objects. I don't think there will be a massive cost memory wise really and we'll not have to worry about dreadful performance because of many many multi thread contexts switches a second.\n\nCurrently each PhaseTracker gets it's own Thread and I've contemplated on generating some UUIDs, possibly Type5 based on the \"thread namespace\", thereby guaranteeing the same uuid constant for the server thread and client thread, but world gen threads I've yet to find where those get spun off to hook a new PhaseTracker instance to them. I made this change to avoid the pool of objects existing on the PhaseTracker since it did nothing with the pools except shove them to a map for debugging purposes. If we are to move to per-PhaseTracker context creation, then we'll also need to supply the PhaseTracker instance being used (which is based on thread and expectations).\n\n(Aside: I've done this before. I used MPI in my Monte-Carlo simulations but needed everything to sync up at one point. I was too judicious with my sync points and my simulation ended up being three times slower. I also had the risk of deadlock and this affected multiple nodes in a cluster hitting many other users waiting for their code to run! I don't think we have it here but that was hard to resolve...)\n\nI do understand the possibilities of deadlocking (There's a relatively easy deadlock you can do with a Feature that spawns entities and if any methods in the Entity call to the parent world to get a Chunk, boom, instant deadlock.\n\nLooking a slight bit more, the cached context is linked to the state which I'm also guessing is pooled - is the state per phase-tracker instance? If it is, you wouldn't need to lock until after the first if block which would mitigate some of the hit with locking as the cached context would also be per phase-tracker instance.\n\nCurrently every state instance is considered a singleton. We don't have pooled states since the IPhaseState is effectively a controller while the PhaseContext is the model. It's possible to shove the context pooling to the PhaseTracker instance since the context will know which is being used when it's being \"switched\" in.", "author": "gabizou", "createdAt": "2020-01-12T12:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTk4OQ==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365569989", "bodyText": "@Zidane if you can, please tell me this is the correct way of doing it for Sponge provided types?", "author": "gabizou", "createdAt": "2020-01-12T09:43:47Z", "path": "src/main/java/org/spongepowered/common/registry/builtin/supplier/EventContextKeySupplier.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.spongepowered.common.registry.builtin.supplier;\n+\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.block.BlockSnapshot;\n+import org.spongepowered.api.data.type.HandType;\n+import org.spongepowered.api.entity.living.player.Player;\n+import org.spongepowered.api.entity.living.player.User;\n+import org.spongepowered.api.event.block.ChangeBlockEvent;\n+import org.spongepowered.api.event.cause.EventContextKey;\n+import org.spongepowered.api.event.cause.entity.damage.DamageType;\n+import org.spongepowered.api.event.cause.entity.damage.source.DamageSource;\n+import org.spongepowered.api.event.cause.entity.dismount.DismountType;\n+import org.spongepowered.api.event.cause.entity.spawn.SpawnType;\n+import org.spongepowered.api.event.cause.entity.teleport.TeleportType;\n+import org.spongepowered.api.item.inventory.ItemStackSnapshot;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.api.profile.GameProfile;\n+import org.spongepowered.api.projectile.source.ProjectileSource;\n+import org.spongepowered.api.service.ServiceManager;\n+import org.spongepowered.api.world.LocatableBlock;\n+import org.spongepowered.api.world.World;\n+import org.spongepowered.common.event.SpongeEventContextKey;\n+\n+import java.util.stream.Stream;\n+\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class EventContextKeySupplier {\n+\n+    public static Stream<EventContextKey<?>> stream() {", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDA3Mw==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365594073", "bodyText": "This would go into the Stream package and be named like the other stream classes are.", "author": "Zidane", "createdAt": "2020-01-12T16:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU3OTY4OA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365579688", "bodyText": "Similarly, to my comment above, if this object is per phase tracker instance, you can just lock from here.", "author": "dualspiral", "createdAt": "2020-01-12T12:29:16Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PooledPhaseState.java", "diffHunk": "@@ -25,45 +25,62 @@\n package org.spongepowered.common.event.tracking;\n \n import java.util.ArrayDeque;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.annotation.Nullable;\n \n public abstract class PooledPhaseState<C extends PhaseContext<C>> implements IPhaseState<C> {\n \n-    private final ArrayDeque<C> contextPool = PhaseTracker.SERVER.createContextPool(this);\n+    private static final ConcurrentHashMap<IPhaseState<?>, ArrayDeque<? extends PhaseContext<?>>> stateContextPool = new ConcurrentHashMap<>();\n+    private final ArrayDeque<C> contextPool;\n     @Nullable private C cached;\n+    final ReentrantLock lock = new ReentrantLock();\n \n     protected PooledPhaseState() {\n+        final ArrayDeque<C> pool = new ArrayDeque<>();\n+        PooledPhaseState.stateContextPool.put(this, pool);\n+        this.contextPool = pool;\n     }\n \n     @Override\n     public final C createPhaseContext() {\n-        if (this.cached != null && !this.cached.isCompleted) {\n-            final C cached = this.cached;\n-            this.cached = null;\n-            return cached;\n+        this.lock.lock();\n+        try {\n+            if (this.cached != null && !this.cached.isCompleted) {\n+                final C cached = this.cached;\n+                this.cached = null;\n+                return cached;\n+            }\n+            final C peek = this.contextPool.pollFirst();\n+            if (peek != null) {\n+                this.cached = peek;\n+                return peek;\n+            }\n+            this.cached = this.createNewContext();\n+            return this.cached;\n+        } finally {\n+            this.lock.unlock();\n         }\n-        final C peek = this.contextPool.pollFirst();\n-        if (peek != null) {\n-            this.cached = peek;\n-            return peek;\n-        }\n-        this.cached = this.createNewContext();\n-        return this.cached;\n     }\n \n     final void releaseContextFromPool(final C context) {\n-        if (this.cached == context) {\n-            return;\n-        }\n-        if (this.cached == null) {\n-            // We can cache this context to recycle it if it's requested later.\n-            // If there's no requests and just pushing, then it can be pushed to the\n-            // deque.\n-            this.cached = context;\n-            return;\n+        this.lock.lock();\n+        try {\n+            if (this.cached == context) {\n+                return;\n+            }\n+            if (this.cached == null) {\n+                // We can cache this context to recycle it if it's requested later.\n+                // If there's no requests and just pushing, then it can be pushed to the\n+                // deque.\n+                this.cached = context;\n+                return;\n+            }\n+            this.contextPool.push(context);", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5Mzc4NA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593784", "bodyText": "Could you not grant each PhaseTracker instance it's own pool and avoid the lock altogether?", "author": "Zidane", "createdAt": "2020-01-12T16:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU3OTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDQyOA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365594428", "bodyText": "That was my suggestion too: #2476 (comment)", "author": "dualspiral", "createdAt": "2020-01-12T16:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU3OTY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MjkzOA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365592938", "bodyText": "Delete name parameter unless it is a NamedCatalogType.", "author": "Zidane", "createdAt": "2020-01-12T16:02:28Z", "path": "src/main/java/org/spongepowered/common/data/type/SpongeSpawnType.java", "diffHunk": "@@ -30,7 +30,18 @@\n \n public final class SpongeSpawnType extends SpongeCatalogType implements SpawnType {\n \n-    public SpongeSpawnType(CatalogKey key) {\n+    private boolean isForced = false;\n+\n+    public SpongeSpawnType(CatalogKey key, String name) {", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5Mjk0Ng==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365592946", "bodyText": "id -> key", "author": "Zidane", "createdAt": "2020-01-12T16:02:40Z", "path": "src/main/java/org/spongepowered/common/event/SpongeEventContextKey.java", "diffHunk": "@@ -27,38 +27,34 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.base.MoreObjects;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n import org.spongepowered.api.event.cause.EventContextKey;\n \n+@SuppressWarnings(\"UnstableApiUsage\")\n public final class SpongeEventContextKey<T> implements EventContextKey<T> {\n \n-    private final String id;\n-    private final Class<T> allowed;\n-    private final String name;\n+    private final CatalogKey id;\n+    private final TypeToken<T> allowed;\n \n     SpongeEventContextKey(SpongeEventContextKeyBuilder<T> builder) {\n-        this.id = builder.id;\n+        this.id = builder.key;\n         this.allowed = builder.typeClass;\n-        this.name = builder.name;\n     }\n \n-    public SpongeEventContextKey(String id, String name, Class<T> allowed) {\n+    public SpongeEventContextKey(CatalogKey id, TypeToken<T> allowed) {", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzA2OQ==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593069", "bodyText": "These are not catalogs, correct?", "author": "Zidane", "createdAt": "2020-01-12T16:03:43Z", "path": "src/main/java/org/spongepowered/common/event/tracking/BlockChangeFlagManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.event.tracking;\n+\n+import com.google.common.collect.ImmutableList;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n+import org.spongepowered.api.world.BlockChangeFlag;\n+import org.spongepowered.common.util.Constants;\n+import org.spongepowered.common.world.SpongeBlockChangeFlag;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+public final class BlockChangeFlagManager {", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzI0NA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593244", "bodyText": "type.getKey().getFormatted()", "author": "Zidane", "createdAt": "2020-01-12T16:06:35Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -342,363 +296,77 @@ void completePhase(final IPhaseState<?> prevState) {\n \n     }\n \n-    private void printRunnawayPhaseCompletion(final IPhaseState<?> state) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.hasPrintedAboutRunnawayPhases) {\n-            // Avoiding spam logs.\n-            return;\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60);\n-        printer.add(\"Completing Phase\").centre().hr();\n-        printer.addWrapped(60, \"Detecting a runaway phase! Potentially a problem \"\n-                               + \"where something isn't completing a phase!!! Sponge will stop printing\"\n-                               + \"after three more times to avoid generating extra logs\");\n-        printer.add();\n-        printer.addWrapped(60, \"%s : %s\", \"Completing phase\", state);\n-        printer.add(\" Phases Remaining:\");\n-        printPhaseStackWithException(this, printer, new Exception(\"RunawayPhase\"));\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && this.printRunawayCount++ > 3) {\n-            this.hasPrintedAboutRunnawayPhases = true;\n-        }\n-    }\n-\n-    public void generateVersionInfo(final PrettyPrinter printer) {\n-        for (final PluginContainer pluginContainer : SpongeImpl.getInternalPlugins()) {\n-            pluginContainer.getVersion().ifPresent(version ->\n-                    printer.add(\"%s : %s\", pluginContainer.getName(), version)\n-            );\n-        }\n-    }\n-\n-    private void printIncorrectPhaseCompletion(final IPhaseState<?> prevState, final IPhaseState<?> state) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.completedIncorrectStates.isEmpty()) {\n-            for (final Tuple<IPhaseState<?>, IPhaseState<?>> tuple : this.completedIncorrectStates) {\n-                if ((tuple.getFirst().equals(prevState)\n-                        && tuple.getSecond().equals(state))) {\n-                    // we've already printed once about the previous state and the current state\n-                    // being completed incorrectly. only print it once.\n-                    return;\n-                }\n-            }\n-        }\n-\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Completing incorrect phase\").centre().hr()\n-                .addWrapped(\"Sponge's tracking system is very dependent on knowing when\"\n-                        + \" a change to any world takes place, however, we are attempting\"\n-                        + \" to complete a \\\"phase\\\" other than the one we most recently entered.\"\n-                        + \" This is an error usually on Sponge's part, so a report\"\n-                        + \" is required on the issue tracker on GitHub.\").hr()\n-                .add(\"Expected to exit phase: %s\", prevState)\n-                .add(\"But instead found phase: %s\", state)\n-                .add(\"StackTrace:\")\n-                .add(new Exception());\n-        printer.add(\" Phases Remaining:\");\n-        printPhaseStackWithException(this, printer, new Exception(\"Incorrect Phase Completion\"));\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.completedIncorrectStates.add(new Tuple<>(prevState, state));\n-        }\n-    }\n-\n-    private void printEmptyStackOnCompletion(final PhaseContext<?> context) {\n-        if (this.hasPrintedEmptyOnce) {\n-            // We want to only mention it once that we are completing an\n-            // empty state, of course something is bound to break, but\n-            // we don't want to spam megabytes worth of log files just\n-            // because of it.\n-            return;\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Unexpectedly Completing An Empty Stack\").centre().hr()\n-                .addWrapped(60, \"Sponge's tracking system is very dependent on knowing when\"\n-                                + \" a change to any world takes place, however, we have been told\"\n-                                + \" to complete a \\\"phase\\\" without having entered any phases.\"\n-                                + \" This is an error usually on Sponge's part, so a report\"\n-                                + \" is required on the issue tracker on GitHub.\").hr()\n-                .add(\"StackTrace:\")\n-                .add(new Exception())\n-                .add(\"Phase being completed:\");\n-        PHASE_PRINTER.accept(printer, context);\n-        printer.add();\n-        this.generateVersionInfo(printer);\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.hasPrintedEmptyOnce = true;\n-        }\n-    }\n-\n-    private void printRunawayPhase(final IPhaseState<?> state, final PhaseContext<?> context) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.hasPrintedAboutRunnawayPhases) {\n-            // Avoiding spam logs.\n-            return;\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60);\n-        printer.add(\"Switching Phase\").centre().hr();\n-        printer.addWrapped(60, \"Detecting a runaway phase! Potentially a problem where something isn't completing a phase!!!\");\n-        printer.add(\"  %s : %s\", \"Entering State\", state);\n-        CONTEXT_PRINTER.accept(printer, context);\n-        printer.addWrapped(60, \"%s :\", \"Phases remaining\");\n-        printPhaseStackWithException(this, printer, new Exception(\"RunawayPhase\"));\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && this.printRunawayCount++ > SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().getMaximumRunawayCount()) {\n-            this.hasPrintedAboutRunnawayPhases = true;\n-        }\n-    }\n-\n-    public static void printNullSourceForBlock(final ServerWorld worldServer, final BlockPos pos, final Block blockIn, final BlockPos otherPos,\n-        final NullPointerException e) {\n-        final PhaseTracker instance = PhaseTracker.getInstance();\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Null Source Block from Unknown Source!\").centre().hr()\n-            .addWrapped(\"Hey, Sponge is saving the game from crashing or spamming because some source \"\n-                        + \"put up a \\\"null\\\" Block as it's source for sending out a neighbor notification. \"\n-                        + \"This is usually unsupported as the game will silently ignore some nulls by \"\n-                        + \"performing \\\"==\\\" checks instead of calling methods, potentially making an \"\n-                        + \"NPE. Because Sponge uses the source block to build information for tracking, \"\n-                        + \"Sponge has to save the game from crashing by reporting this issue. Because the \"\n-                        + \"source is unknown, it's recommended to report this issue to SpongeCommon's \"\n-                        + \"issue tracker on GitHub. Please provide the following information: \")\n-            .add()\n-            .add(\" %s : %s\", \"Source position\", pos)\n-            .add(\" %s : %s\", \"World\", ((World) worldServer).getName())\n-            .add(\" %s : %s\", \"Source Block Recovered\", blockIn)\n-            .add(\" %s : %s\", \"Notified Position\", otherPos).add();\n-\n-        printPhaseStackWithException(instance, printer, e);\n-        printer\n-            .log(SpongeImpl.getLogger(), Level.WARN);\n-    }\n-\n-\n-    public static void printNullSourceBlockWithTile(\n-        final BlockPos pos, final Block blockIn, final BlockPos otherPos, final BlockEntityType type, final boolean useTile,\n-        final NullPointerException e) {\n-        final PhaseTracker instance = PhaseTracker.getInstance();\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Null Source Block on TileEntity!\").centre().hr()\n-            .addWrapped(\"Hey, Sponge is saving the game from crashing because a TileEntity \"\n-                        + \"is sending out a \\'null\\' Block as it's source (more likely) and \"\n-                        + \"attempting to perform a neighbor notification with it. Because \"\n-                        + \"this is guaranteed to lead to a crash or a spam of reports, \"\n-                        + \"Sponge is going ahead and fixing the issue. The offending Tile \"\n-                        + \"is \" + type.getId())\n-            .add()\n-            .add(\"%s : %s\", \"Source position\", pos)\n-            .add(\"%s : %s\", \"Source TileEntity\", type)\n-            .add(\"%s : %s\", \"Recovered using TileEntity as Source\", useTile)\n-            .add(\"%s : %s\", \"Source Block Recovered\", blockIn)\n-            .add(\"%s : %s\", \"Notified Position\", otherPos);\n-        printPhaseStackWithException(instance, printer, e);\n-        printer\n-            .log(SpongeImpl.getLogger(), Level.WARN);\n-    }\n-\n-    public static void printNullSourceBlockNeighborNotificationWithNoTileSource(final BlockPos pos, final Block blockIn, final BlockPos otherPos,\n-        final NullPointerException e) {\n-        final PhaseTracker instance = PhaseTracker.getInstance();\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Null Source Block on TileEntity!\").centre().hr()\n-            .addWrapped(\"Hey, Sponge is saving the game from crashing because a TileEntity \"\n-                        + \"is sending out a \\'null\\' Block as it's source (more likely) and \"\n-                        + \"attempting to perform a neighbor notification with it. Because \"\n-                        + \"this is guaranteed to lead to a crash or a spam of reports, \"\n-                        + \"Sponge is going ahead and fixing the issue. The offending Tile \"\n-                        + \"is unknown, so we don't have any way to configure a reporting for you\")\n-            .add()\n-            .add(\"%s : %s\", \"Source position\", pos)\n-            .add(\"%s : %s\", \"Source TileEntity\", \"UNKNOWN\")\n-            .add(\"%s : %s\", \"Recovered using TileEntity as Source\", \"false\")\n-            .add(\"%s : %s\", \"Source Block Recovered\", blockIn)\n-            .add(\"%s : %s\", \"Notified Position\", otherPos);\n-        printPhaseStackWithException(instance, printer, e);\n-        printer\n-            .log(SpongeImpl.getLogger(), Level.WARN);\n-    }\n-\n-    public static void printPhaseStackWithException(final PhaseTracker instance, final PrettyPrinter printer, final Throwable e) {\n-        instance.stack.forEach(data -> PHASE_PRINTER.accept(printer, data));\n-        printer.add()\n-            .add(\" %s :\", \"StackTrace\")\n-            .add(e)\n-            .add();\n-        instance.generateVersionInfo(printer);\n-    }\n-\n-\n-    public void printMessageWithCaughtException(final String header, final String subHeader, @Nullable final Throwable e) {\n-        this.printMessageWithCaughtException(header, subHeader, this.getCurrentState(), this.getCurrentContext(), e);\n-    }\n-\n-    private void printMessageWithCaughtException(final String header, final String subHeader, final IPhaseState<?> state, final PhaseContext<?> context, @Nullable final Throwable t) {\n-        final PrettyPrinter printer = new PrettyPrinter(60);\n-        printer.add(header).centre().hr()\n-                .add(\"%s %s\", subHeader, state)\n-                .addWrapped(60, \"%s :\", \"PhaseContext\");\n-        CONTEXT_PRINTER.accept(printer, context);\n-        printer.addWrapped(60, \"%s :\", \"Phases remaining\");\n-        this.stack.forEach(data -> PHASE_PRINTER.accept(printer, data));\n-        if (t != null) {\n-            printer.add(\"Stacktrace:\")\n-                    .add(t);\n-            if (t.getCause() != null) {\n-                printer.add(t.getCause());\n-            }\n-        }\n-        printer.add();\n-        this.generateVersionInfo(printer);\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-    }\n-\n-    public void printExceptionFromPhase(final Throwable e, final PhaseContext<?> context) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.printedExceptionsForState.isEmpty()) {\n-            for (final IPhaseState<?> iPhaseState : this.printedExceptionsForState) {\n-                if (context.state == iPhaseState) {\n-                    return;\n-                }\n-            }\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Exception occurred during a PhaseState\").centre().hr()\n-            .addWrapped(\"Sponge's tracking system makes a best effort to not throw exceptions randomly but sometimes it is inevitable. In most \"\n-                    + \"cases, something else triggered this exception and Sponge prevented a crash by catching it. The following stacktrace can be \"\n-                    + \"used to help pinpoint the cause.\").hr()\n-            .add(\"The PhaseState having an exception: %s\", context.state)\n-            .add(\"The PhaseContext:\")\n-            ;\n-        printer\n-            .add(context.printCustom(printer, 4));\n-        printPhaseStackWithException(this, printer, e);\n-\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.printedExceptionsForState.add(context.state);\n-        }\n-    }\n \n     private void checkPhaseContextProcessed(final IPhaseState<?> state, final PhaseContext<?> context) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && this.printedExceptionsForUnprocessedState.contains(state)) {\n+        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && PhasePrinter.printedExceptionsForUnprocessedState.contains(state)) {\n             return;\n         }\n \n         if (context.notAllCapturesProcessed()) {\n-            this.printUnprocessedPhaseContextObjects(state, context);\n-            this.printedExceptionsForUnprocessedState.add(state);\n-\n-        }\n-    }\n-\n-    private void printUnprocessedPhaseContextObjects(final IPhaseState<?> state, final PhaseContext<?> context) {\n-        this.printMessageWithCaughtException(\"Failed to process all PhaseContext captured!\",\n-                \"During the processing of a phase, certain objects were captured in a PhaseContext. All of them should have been removed from the PhaseContext by this point\",\n-                state, context, null);\n-    }\n+            PhasePrinter.printUnprocessedPhaseContextObjects(this.stack, state, context);\n+            PhasePrinter.printedExceptionsForUnprocessedState.add(state);\n \n-    private void printBlockTrackingException(final PhaseContext<?> phaseData, final IPhaseState<?> phaseState, final Throwable e) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.printedExceptionsForBlocks.isEmpty()) {\n-            if (this.printedExceptionsForBlocks.contains(phaseState)) {\n-                return;\n-            }\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Exception attempting to capture a block change!\").centre().hr();\n-        this.printPhasestack(phaseData, e, printer);\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.printedExceptionsForBlocks.add(phaseState);\n-        }\n-    }\n-\n-    private void printPhasestack(final PhaseContext<?> phaseData, final Throwable e, final PrettyPrinter printer) {\n-        printer.addWrapped(60, \"%s :\", \"PhaseContext\");\n-        CONTEXT_PRINTER.accept(printer, phaseData);\n-        printer.addWrapped(60, \"%s :\", \"Phases remaining\");\n-        this.stack.forEach(data -> PHASE_PRINTER.accept(printer, data));\n-        printer.add(\"Stacktrace:\");\n-        printer.add(e);\n-    }\n-\n-    private void printUnexpectedBlockChange(final ServerWorldBridge mixinWorld, final BlockPos pos, final net.minecraft.block.BlockState currentState,\n-                                            final net.minecraft.block.BlockState newState) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            return;\n         }\n-        new PrettyPrinter(60).add(\"Unexpected World Change Detected!\").centre().hr()\n-            .add(\"Sponge's tracking system is very dependent on knowing when\\n\"\n-                 + \"a change to any world takes place, however there are chances\\n\"\n-                 + \"where Sponge does not know of changes that mods may perform.\\n\"\n-                 + \"In cases like this, it is best to report to Sponge to get this\\n\"\n-                 + \"change tracked correctly and accurately.\").hr()\n-            .add()\n-            .add(\"%s : %s\", \"World\", mixinWorld)\n-            .add(\"%s : %s\", \"Position\", pos)\n-            .add(\"%s : %s\", \"Current State\", currentState)\n-            .add(\"%s : %s\", \"New State\", newState)\n-            .add()\n-            .add(\"StackTrace:\")\n-            .add(new Exception())\n-            .trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n     }\n \n-    private void printExceptionSpawningEntity(final PhaseContext<?> context, final Throwable e) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.printedExceptionsForEntities.isEmpty()) {\n-            if (this.printedExceptionsForEntities.contains(context.state)) {\n-                return;\n-            }\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Exception attempting to capture or spawn an Entity!\").centre().hr();\n-        this.printPhasestack(context, e, printer);\n-        printer.log(SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.printedExceptionsForEntities.add(context.state);\n-        }\n-    }\n \n     public static Block validateBlockForNeighborNotification(final ServerWorld worldServer, final BlockPos pos, @Nullable Block blockIn,\n         final BlockPos otherPos, final Chunk chunk) {\n         if (blockIn == null) {\n             // If the block is null, check with the PhaseState to see if it can perform a safe way\n-            final PhaseContext<?> currentContext = getInstance().getCurrentContext();\n+            final PhaseContext<?> currentContext = PhaseTracker.getInstance().getCurrentContext();\n             final PhaseTrackerCategory trackerConfig = SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker();\n \n             if (currentContext.state == TickPhase.Tick.TILE_ENTITY) {\n                 // Try to save ourselves\n-                final BlockEntityType type = currentContext\n-                    .getSource(org.spongepowered.api.block.entity.BlockEntity.class)\n-                    .map(org.spongepowered.api.block.entity.BlockEntity::getType)\n-                    .orElse(null);\n+                final TileEntity source = (TileEntity) currentContext.getSource();\n+\n+                final TileEntityType<?> type = Optional.ofNullable(source)\n+                        .map(TileEntity::getType)\n+                        .orElse(null);\n                 if (type != null) {\n+                    ResourceLocation id = TileEntityType.getId(type);\n+                    if (id == null) {\n+                        id = new ResourceLocation(source.getClass().getCanonicalName());\n+                    }\n                     final Map<String, Boolean> autoFixedTiles = trackerConfig.getAutoFixedTiles();\n-                    final boolean contained = autoFixedTiles.containsKey(type.getId());\n+                    final boolean contained = autoFixedTiles.containsKey(type.toString());", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzMyMQ==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593321", "bodyText": "Do not pass back IDs to crash reports, pass their keys", "author": "Zidane", "createdAt": "2020-01-12T16:07:42Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -791,22 +460,22 @@ public void notifyBlockOfStateChange(final ServerWorldBridge mixinWorld, final n\n                 // the try with resources will perform a close without the phase context being entered, leading to issues of closing\n                 // other phase contexts.\n                 // Refer to https://github.com/SpongePowered/SpongeForge/issues/2706\n-                if (PhaseTracker.checkMaxBlockProcessingDepth(state, peek, context.getDepth())) {\n+                if (PhasePrinter.checkMaxBlockProcessingDepth(state, peek, context.getDepth())) {\n                     return;\n                 }\n                 // Sponge End\n \n-                notifyState.neighborChanged(((ServerWorld) mixinWorld), notifyPos, sourceBlock, sourcePos);\n+                notifyState.neighborChanged(((ServerWorld) mixinWorld), notifyPos, sourceBlock, sourcePos, isMoving);\n             }\n         } catch (final Throwable throwable) {\n             final CrashReport crashreport = CrashReport.makeCrashReport(throwable, \"Exception while updating neighbours\");\n             final CrashReportCategory crashreportcategory = crashreport.makeCategory(\"Block being updated\");\n             crashreportcategory.addDetail(\"Source block type\", () -> {\n                 try {\n-                    return String.format(\"ID #%d (%s // %s)\", Block.getIdFromBlock(sourceBlock),\n+                    return String.format(\"ID #%d (%s // %s)\", Registry.BLOCK.getId(sourceBlock),", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzMzMw==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593333", "bodyText": "mixinWorld -> worldBridge", "author": "Zidane", "createdAt": "2020-01-12T16:07:58Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -815,51 +484,51 @@ public void notifyBlockOfStateChange(final ServerWorldBridge mixinWorld, final n\n     }\n \n     /**\n-     * Replacement of {@link WorldServer#setBlockState(BlockPos, IBlockState, int)}\n-     * that adds cause tracking.\n+     * Replacement of {@link ServerWorld#setBlockState(BlockPos, net.minecraft.block.BlockState, int)}\n+     * with the additions of cause tracking\n      *\n      * @param pos The position of the block state to set\n      * @param newState The new state\n      * @param flag The notification flags\n      * @return True if the block was successfully set (or captured)\n      */\n     @SuppressWarnings(\"rawtypes\")\n-    public boolean setBlockState(final ServerWorldBridge mixinWorld, final BlockPos pos, final net.minecraft.block.BlockState newState, final BlockChangeFlag flag) {\n+    public boolean setBlockState(final ServerWorldBridge mixinWorld, final BlockPos pos,", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzM4MA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593380", "bodyText": ".", "author": "Zidane", "createdAt": "2020-01-12T16:08:38Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -871,38 +540,36 @@ public boolean setBlockState(final ServerWorldBridge mixinWorld, final BlockPos\n \n         final PhaseContext<?> context = this.stack.peek();\n         final IPhaseState<?> phaseState = context.state;\n-        final boolean isComplete = phaseState == GeneralPhase.State.COMPLETE;\n-        // Do a sanity check, if we're not in any phase state that accepts block changes, well, why the hell are\n-        // we doing any changes?? The changes themselves will still go through, but we want to be as verbose\n-        // about those changes as possible, if we're configured to do so.\n-        if (isComplete && SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) { // Fail fast.\n-            // The random occurrence that we're told to complete a phase\n-            // while a world is being changed unknowingly.\n-//            this.printUnexpectedBlockChange(mixinWorld, pos, currentState, newState);\n-        }\n+\n         // We can allow the block to get changed, regardless how it's captured, not captured, etc.\n         // because ChunkMixin will perform the necessary changes, and appropriately prevent any specific\n         // physics handling.\n \n         final ChunkBridge mixinChunk = (ChunkBridge) chunk;\n         // Sponge - Use our mixin method that allows using the BlockChangeFlag.\n \n-        final net.minecraft.block.BlockState originalBlockState = mixinChunk.bridge$setBlockState(pos, newState, currentState, spongeFlag);\n+        // Up until this point, we've been setting up sponge stuff, this next line is from vanilla\n+        // where it tells the chunk to set the new state, but we have to call our custom method\n+        // to do transaction handling\n+        // final net.minecraft.block.BlockState blockstate = chunk.setBlockState(pos, newState, (flags & 64) != 0);\n+        final net.minecraft.block.BlockState originalState = mixinChunk.bridge$setBlockState(pos, newState, currentState, spongeFlag);\n         // Sponge End\n-        if (originalBlockState == null) {\n+        if (originalState == null) {\n             return false;\n-        }\n+        } // else { // Sponge - redundant else\n \n-        // else { // Sponge - unnecessary formatting\n-        // Forge changes the BlockState.getLightOpacity to use Forge's hook.\n-        if (SpongeImplHooks.getBlockLightOpacity(newState, minecraftWorld, pos) != oldOpacity || SpongeImplHooks.getChunkPosLight(newState, minecraftWorld, pos) != oldLight) {\n-            // Sponge - End\n-            minecraftWorld.profiler.startSection(\"checkLight\");\n-            minecraftWorld.checkLight(pos);\n-            minecraftWorld.profiler.endSection();\n+        // blockstate1 -> newWorldState\n+        final net.minecraft.block.BlockState newWorldState = world.getBlockState(pos);\n+        if (newWorldState != originalState && (newWorldState.getOpacity(world, pos) != originalState.getOpacity(world, pos) || newWorldState.getLightValue() != originalState.getLightValue() || newWorldState.func_215691_g() || originalState.func_215691_g())) {\n+            // this.profiler.startSection(\"queueCheckLight\");\n+            world.getProfiler().startSection(\"queueCheckLight\");\n+            // this.getChunkProvider().getLightManager().checkBlock(pos);\n+            world.getChunkProvider().getLightManager().checkBlock(pos);\n+            // this.profiler.endSection();\n+            world.getProfiler().endSection();\n         }\n \n-        // Sponge Start - At this point, we can stop and check for captures.\n+        // Sponge Start - At this point, we can stop and check for captures;", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzU0OA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593548", "bodyText": "Use SpongeImpl method to collapse first two branches", "author": "Zidane", "createdAt": "2020-01-12T16:11:09Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -1169,115 +857,21 @@ public boolean spawnEntityWithCause(final World world, final Entity entity) {\n      * @return True if the entity spawn is on the main thread.\n      */\n     public static boolean isEntitySpawnInvalid(final Entity entity) {\n-        if (Sponge.isServerAvailable() && (Sponge.getServer().isMainThread() || SpongeImpl.getServer().isServerStopped())) {\n+        if (Sponge.isServerAvailable() && (Sponge.getServer().onMainThread() || SpongeImpl.getServer().isServerStopped())) {", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzYxMg==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593612", "bodyText": "Do not reference supplier classes in common code. Simply do SpawnTypes.BLAH.get()", "author": "Zidane", "createdAt": "2020-01-12T16:12:01Z", "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -84,25 +85,19 @@\n import org.spongepowered.common.event.tracking.phase.tick.NeighborNotificationContext;\n import org.spongepowered.common.event.tracking.phase.tick.TickPhase;\n import org.spongepowered.common.mixin.accessor.world.server.ServerWorldAccessor;\n-import org.spongepowered.common.registry.type.event.SpawnTypeRegistryModule;\n+import org.spongepowered.common.registry.builtin.supplier.SpawnTypeSupplier;", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyMTYwOA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r367221608", "bodyText": "Can't if the spawn type is an internal one. It's not exposed to the API for the reason that it's internal use only but still detectable for plugins to interpret for their own uses.", "author": "gabizou", "createdAt": "2020-01-16T04:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzgyMA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593820", "bodyText": "mixinEntity -> entityBridge", "author": "Zidane", "createdAt": "2020-01-12T16:14:43Z", "path": "src/main/java/org/spongepowered/common/event/tracking/TrackingUtil.java", "diffHunk": "@@ -142,7 +143,36 @@\n         });\n     public static final int WIDTH = 40;\n \n-    public static void tickEntity(final net.minecraft.entity.Entity entity) {\n+    public static void tickEntity(final Consumer<net.minecraft.entity.Entity> consumer, final net.minecraft.entity.Entity entity) {\n+        checkArgument(entity instanceof Entity, \"Entity %s is not an instance of SpongeAPI's Entity!\", entity);\n+        checkNotNull(entity, \"Cannot capture on a null ticking entity!\");\n+        final EntityBridge mixinEntity = (EntityBridge) entity;", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDA5OQ==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365594099", "bodyText": "Same here, stream package and named like the stream classes.\nIn all honesty, the supplier classes are simply for supplying Vanilla registry entries.", "author": "Zidane", "createdAt": "2020-01-12T16:20:09Z", "path": "src/main/java/org/spongepowered/common/registry/builtin/supplier/SpawnTypeSupplier.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.spongepowered.common.registry.builtin.supplier;\n+\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.event.cause.entity.spawn.SpawnType;\n+import org.spongepowered.common.data.type.SpongeSpawnType;\n+\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+public class SpawnTypeSupplier {", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDExNA==", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365594114", "bodyText": "Is there a reason this is here? Why isn't this in the API?", "author": "Zidane", "createdAt": "2020-01-12T16:20:30Z", "path": "src/main/java/org/spongepowered/common/registry/builtin/supplier/SpawnTypeSupplier.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.spongepowered.common.registry.builtin.supplier;\n+\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.event.cause.entity.spawn.SpawnType;\n+import org.spongepowered.common.data.type.SpongeSpawnType;\n+\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+public class SpawnTypeSupplier {\n+\n+    public static SpawnType FORCED = new SpongeSpawnType(CatalogKey.sponge(\"forced\"), \"Forced\").forced();", "originalCommit": "c74933fbfd73f7f2628aed69d38746e8811e173e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b29db9b5c47ef24ba69359d73ab375c0f605546f", "url": "https://github.com/SpongePowered/Sponge/commit/b29db9b5c47ef24ba69359d73ab375c0f605546f", "message": "Per Thread PhaseTrackers and pooling.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>", "committedDate": "2020-01-13T11:54:30Z", "type": "commit"}, {"oid": "4a68ea25002cd40d42cebba8178bb61096223ec1", "url": "https://github.com/SpongePowered/Sponge/commit/4a68ea25002cd40d42cebba8178bb61096223ec1", "message": "Allow partial rescheduling of asynchronous block changes onto the main thread on server controlled worlds.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>", "committedDate": "2020-01-19T07:15:24Z", "type": "commit"}]}