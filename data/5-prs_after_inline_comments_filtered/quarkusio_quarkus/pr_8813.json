{"pr_number": 8813, "pr_title": "Cache bytecode recording proxies", "pr_createdAt": "2020-04-24T07:45:51Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8813", "timeline": [{"oid": "b430930138ad5c59bf669376e0c01707b4d83dcf", "url": "https://github.com/quarkusio/quarkus/commit/b430930138ad5c59bf669376e0c01707b4d83dcf", "message": "Cache bytecode recording proxies", "committedDate": "2020-04-24T07:46:32Z", "type": "forcePushed"}, {"oid": "e3d028085666f9ae60a024a05d3ebb455e86075a", "url": "https://github.com/quarkusio/quarkus/commit/e3d028085666f9ae60a024a05d3ebb455e86075a", "message": "Cache bytecode recording proxies", "committedDate": "2020-04-24T07:54:14Z", "type": "forcePushed"}, {"oid": "ba24b380be946fda461a516e7385be21b9b2c291", "url": "https://github.com/quarkusio/quarkus/commit/ba24b380be946fda461a516e7385be21b9b2c291", "message": "Cache bytecode recording proxies", "committedDate": "2020-04-24T12:32:21Z", "type": "commit"}, {"oid": "ba24b380be946fda461a516e7385be21b9b2c291", "url": "https://github.com/quarkusio/quarkus/commit/ba24b380be946fda461a516e7385be21b9b2c291", "message": "Cache bytecode recording proxies", "committedDate": "2020-04-24T12:32:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzNzk5NA==", "url": "https://github.com/quarkusio/quarkus/pull/8813#discussion_r415037994", "bodyText": "It's minor but wouldn't we want a stable name here too?", "author": "gsmet", "createdAt": "2020-04-25T10:55:46Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/recording/BytecodeRecorderImpl.java", "diffHunk": "@@ -224,60 +227,66 @@ private static boolean isProxiable(Class<?> returnType) {\n         if (existingProxyClasses.containsKey(theClass)) {\n             return theClass.cast(existingProxyClasses.get(theClass));\n         }\n-        String proxyNameSuffix = \"$$RecordingProxyProxy\" + COUNT.incrementAndGet();\n \n-        ProxyConfiguration<T> proxyConfiguration = new ProxyConfiguration<T>()\n-                .setSuperClass(theClass)\n-                .setClassLoader(classLoader)\n-                .setAnchorClass(getClass())\n-                .setProxyNameSuffix(proxyNameSuffix);\n-        String proxyName = proxyConfiguration.getProxyName();\n-        ProxyFactory<T> factory = new ProxyFactory<T>(proxyConfiguration);\n-        try {\n-            T recordingProxy = factory.newInstance(new InvocationHandler() {\n-                @Override\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    if (staticInit) {\n-                        for (int i = 0; i < args.length; ++i) {\n-                            if (args[i] instanceof ReturnedProxy) {\n-                                ReturnedProxy p = (ReturnedProxy) args[i];\n-                                if (!p.__static$$init()) {\n-                                    throw new RuntimeException(\"Invalid proxy passed to recorder. Parameter \" + i + \" of type \"\n-                                            + method.getParameterTypes()[i]\n-                                            + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n-                                }\n+        InvocationHandler invocationHandler = new InvocationHandler() {\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                if (staticInit) {\n+                    for (int i = 0; i < args.length; ++i) {\n+                        if (args[i] instanceof ReturnedProxy) {\n+                            ReturnedProxy p = (ReturnedProxy) args[i];\n+                            if (!p.__static$$init()) {\n+                                throw new RuntimeException(\"Invalid proxy passed to recorder. Parameter \" + i + \" of type \"\n+                                        + method.getParameterTypes()[i]\n+                                        + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n                             }\n                         }\n                     }\n-                    StoredMethodCall storedMethodCall = new StoredMethodCall(theClass, method, args);\n-                    storedMethodCalls.add(storedMethodCall);\n-                    Class<?> returnType = method.getReturnType();\n-                    if (method.getName().equals(\"toString\")\n-                            && method.getParameterTypes().length == 0\n-                            && returnType.equals(String.class)) {\n-                        return proxyName;\n-                    }\n-\n-                    boolean voidMethod = method.getReturnType().equals(void.class);\n-                    if (!voidMethod && !isProxiable(method.getReturnType())) {\n-                        throw new RuntimeException(\"Cannot use \" + method\n-                                + \" as a recorder method as the return type cannot be proxied. Use RuntimeValue to wrap the return value instead.\");\n-                    }\n-                    if (voidMethod) {\n-                        return null;\n-                    }\n-                    ProxyInstance instance = getProxyInstance(returnType);\n-                    if (instance == null) {\n-                        return null;\n-                    }\n+                }\n+                StoredMethodCall storedMethodCall = new StoredMethodCall(theClass, method, args);\n+                storedMethodCalls.add(storedMethodCall);\n+                Class<?> returnType = method.getReturnType();\n+                if (method.getName().equals(\"toString\")\n+                        && method.getParameterTypes().length == 0\n+                        && returnType.equals(String.class)) {\n+                    return proxy.getClass().getName();\n+                }\n \n-                    storedMethodCall.returnedProxy = instance.proxy;\n-                    storedMethodCall.proxyId = instance.key;\n-                    return instance.proxy;\n+                boolean voidMethod = method.getReturnType().equals(void.class);\n+                if (!voidMethod && !isProxiable(method.getReturnType())) {\n+                    throw new RuntimeException(\"Cannot use \" + method\n+                            + \" as a recorder method as the return type cannot be proxied. Use RuntimeValue to wrap the return value instead.\");\n+                }\n+                if (voidMethod) {\n+                    return null;\n+                }\n+                ProxyInstance instance = getProxyInstance(returnType);\n+                if (instance == null) {\n+                    return null;\n                 }\n \n-            });\n+                storedMethodCall.returnedProxy = instance.proxy;\n+                storedMethodCall.proxyId = instance.key;\n+                return instance.proxy;\n+            }\n+\n+        };\n+\n+        try {\n+            if (recordingProxyFactories.containsKey(theClass)) {\n+                return (T) recordingProxyFactories.get(theClass).newInstance(invocationHandler);\n+            }\n+            String proxyNameSuffix = \"$$RecordingProxyProxy\" + COUNT.incrementAndGet();", "originalCommit": "ba24b380be946fda461a516e7385be21b9b2c291", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODIwNA==", "url": "https://github.com/quarkusio/quarkus/pull/8813#discussion_r415548204", "bodyText": "It does not really matter here, these don't go into the final application, and as all they do is record bytecode they don't show up in any profiles (as this is basically just adding to a list).", "author": "stuartwdouglas", "createdAt": "2020-04-27T06:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzNzk5NA=="}], "type": "inlineReview"}]}