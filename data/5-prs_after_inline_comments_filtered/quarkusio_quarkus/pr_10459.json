{"pr_number": 10459, "pr_title": "init custom gradle tooling model", "pr_createdAt": "2020-07-03T15:56:30Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10459", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAwOTU1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450009556", "bodyText": "Is it not available in the model?", "author": "aloubyansky", "createdAt": "2020-07-06T06:33:12Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java", "diffHunk": "@@ -95,32 +69,17 @@ public void relink(AppArtifact appArtifact, Path localPath) throws AppModelResol\n     @Override\n     public Path resolve(AppArtifact appArtifact) throws AppModelResolverException {\n         if (!appArtifact.isResolved()) {\n-\n-            final DefaultDependencyArtifact dep = new DefaultDependencyArtifact();\n-            dep.setExtension(appArtifact.getType());\n-            dep.setType(appArtifact.getType());\n-            dep.setName(appArtifact.getArtifactId());\n-\n-            final DefaultExternalModuleDependency gradleDep = new DefaultExternalModuleDependency(appArtifact.getGroupId(),\n-                    appArtifact.getArtifactId(), appArtifact.getVersion(), null);\n-            gradleDep.addArtifact(dep);\n-\n-            final Configuration detachedConfig = project.getConfigurations().detachedConfiguration(gradleDep);\n-\n-            final ResolvedConfiguration rc = detachedConfig.getResolvedConfiguration();\n-            Set<ResolvedArtifact> resolvedArtifacts = rc.getResolvedArtifacts();\n-            for (ResolvedArtifact a : resolvedArtifacts) {\n-                if (appArtifact.getArtifactId().equals(a.getName())\n-                        && appArtifact.getType().equals(a.getType())\n-                        && appArtifact.getGroupId().equals(a.getModuleVersion().getId().getGroup())) {\n-                    appArtifact.setPath(a.getFile().toPath());\n+            for (io.quarkus.gradle.workspace.model.Dependency dependency : model.getAppDependencies()) {\n+                // TODO there used to be a check on appArtifact.getType()", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMDU2OA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450010568", "bodyText": "This is actually very limiting, since the scope is limited to the app model only. I'll need to check whether the devtools could be affected.", "author": "aloubyansky", "createdAt": "2020-07-06T06:35:54Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java", "diffHunk": "@@ -95,32 +69,17 @@ public void relink(AppArtifact appArtifact, Path localPath) throws AppModelResol\n     @Override\n     public Path resolve(AppArtifact appArtifact) throws AppModelResolverException {\n         if (!appArtifact.isResolved()) {\n-\n-            final DefaultDependencyArtifact dep = new DefaultDependencyArtifact();\n-            dep.setExtension(appArtifact.getType());\n-            dep.setType(appArtifact.getType());\n-            dep.setName(appArtifact.getArtifactId());\n-\n-            final DefaultExternalModuleDependency gradleDep = new DefaultExternalModuleDependency(appArtifact.getGroupId(),\n-                    appArtifact.getArtifactId(), appArtifact.getVersion(), null);\n-            gradleDep.addArtifact(dep);\n-\n-            final Configuration detachedConfig = project.getConfigurations().detachedConfiguration(gradleDep);\n-\n-            final ResolvedConfiguration rc = detachedConfig.getResolvedConfiguration();\n-            Set<ResolvedArtifact> resolvedArtifacts = rc.getResolvedArtifacts();\n-            for (ResolvedArtifact a : resolvedArtifacts) {\n-                if (appArtifact.getArtifactId().equals(a.getName())\n-                        && appArtifact.getType().equals(a.getType())\n-                        && appArtifact.getGroupId().equals(a.getModuleVersion().getId().getGroup())) {\n-                    appArtifact.setPath(a.getFile().toPath());\n+            for (io.quarkus.gradle.workspace.model.Dependency dependency : model.getAppDependencies()) {", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc1MzUyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450753529", "bodyText": "Have you tried running the full testsuite with these changes? Or more specifically all the gradle tests including the tooling ones, such add/list extensions, create project? I'm wondering whether we should be changing this method at all. What we need to providing at the end is the AppModel and the workspace structure.", "author": "aloubyansky", "createdAt": "2020-07-07T10:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMDU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5NTAwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450795005", "bodyText": "I run some tests on my machine on a sample project and everything was ok. Regarding the testsuite, I still have some failures. I will revert that change as you suggest.", "author": "glefloch", "createdAt": "2020-07-07T11:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMDU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMjk1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450012953", "bodyText": "Are these java sources?", "author": "aloubyansky", "createdAt": "2020-07-06T06:42:28Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java", "diffHunk": "@@ -131,216 +90,65 @@ public Path resolve(AppArtifact appArtifact) throws AppModelResolverException {\n     }\n \n     @Override\n-    public AppModel resolveModel(AppArtifact appArtifact) throws AppModelResolverException {\n+    public AppModel resolveModel(AppArtifact appArtifact) {\n+\n         AppModel.Builder appBuilder = new AppModel.Builder();\n         if (appModel != null && appModel.getAppArtifact().equals(appArtifact)) {\n             return appModel;\n         }\n-        final List<Dependency> directExtensionDeps = new ArrayList<>();\n-\n-        // collect enforced platforms\n-        final Configuration impl = project.getConfigurations().getByName(JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME);\n-        for (Dependency d : impl.getAllDependencies()) {\n-            if (!(d instanceof ModuleDependency)) {\n-                continue;\n-            }\n-            final ModuleDependency module = (ModuleDependency) d;\n-            final Category category = module.getAttributes().getAttribute(Category.CATEGORY_ATTRIBUTE);\n-            if (category != null && Category.ENFORCED_PLATFORM.equals(category.getName())) {\n-                directExtensionDeps.add(d);\n-            }\n-        }\n \n         final List<AppDependency> userDeps = new ArrayList<>();\n-        Map<AppArtifactKey, AppDependency> versionMap = new HashMap<>();\n-        Map<ModuleIdentifier, ModuleVersionIdentifier> userModules = new HashMap<>();\n-\n-        final String classpathConfigName = launchMode == LaunchMode.TEST ? JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME\n-                : JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME;\n-\n-        collectDependencies(project.getConfigurations().getByName(classpathConfigName),\n-                appBuilder, directExtensionDeps, userDeps,\n-                versionMap, userModules);\n-\n-        if (launchMode == LaunchMode.DEVELOPMENT) {\n-            collectDependencies(project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME),\n-                    appBuilder, directExtensionDeps, userDeps,\n-                    versionMap, userModules);\n-        }\n+        model.getAppDependencies().stream().map(this::toAppDependency).forEach(userDeps::add);\n \n         final List<AppDependency> deploymentDeps = new ArrayList<>();\n-        final List<AppDependency> fullDeploymentDeps = new ArrayList<>(userDeps);\n-        if (!directExtensionDeps.isEmpty()) {\n-            final Configuration deploymentConfig = project.getConfigurations()\n-                    .detachedConfiguration(directExtensionDeps.toArray(new Dependency[0]));\n-            final ResolvedConfiguration rc = deploymentConfig.getResolvedConfiguration();\n-            for (ResolvedArtifact a : rc.getResolvedArtifacts()) {\n-                final ModuleVersionIdentifier userVersion = userModules.get(getModuleId(a));\n-                if (userVersion != null || !isDependency(a)) {\n-                    continue;\n-                }\n-                final AppDependency dependency = toAppDependency(a);\n-                fullDeploymentDeps.add(dependency);\n-                if (!userDeps.contains(dependency)) {\n-                    AppDependency deploymentDep = alignVersion(dependency, versionMap);\n-                    deploymentDeps.add(deploymentDep);\n-                }\n-            }\n-        }\n-\n-        if (!appArtifact.isResolved()) {\n-            final Jar jarTask = (Jar) project.getTasks().findByName(JavaPlugin.JAR_TASK_NAME);\n-            if (jarTask == null) {\n-                throw new AppModelResolverException(\"Failed to locate task 'jar' in the project.\");\n-            }\n-            if (jarTask.getDidWork()) {\n-                final Provider<RegularFile> jarProvider = jarTask.getArchiveFile();\n-                Path classesDir = null;\n-                if (jarProvider.isPresent()) {\n-                    final File f = jarProvider.get().getAsFile();\n-                    if (f.exists()) {\n-                        classesDir = f.toPath();\n-                    }\n-                }\n-                if (classesDir == null) {\n-                    throw new AppModelResolverException(\"Failed to locate classes directory for \" + appArtifact);\n-                }\n-                appArtifact.setPaths(PathsCollection.of(classesDir));\n-            } else {\n-                final Convention convention = project.getConvention();\n-                JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n-                if (javaConvention != null) {\n-                    final SourceSet mainSourceSet = javaConvention.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n-                    PathsCollection.Builder paths = PathsCollection.builder();\n-                    mainSourceSet.getOutput().filter(s -> s.exists()).forEach(f -> {\n-                        paths.add(f.toPath());\n-                    });\n-                    for (File resourcesDir : mainSourceSet.getResources().getSourceDirectories()) {\n-                        if (resourcesDir.exists()) {\n-                            paths.add(resourcesDir.toPath());\n-                        }\n-                    }\n-                    appArtifact.setPaths(paths.build());\n-                }\n-            }\n-        }\n-\n-        appBuilder.addRuntimeDeps(userDeps)\n-                .addFullDeploymentDeps(fullDeploymentDeps)\n-                .addDeploymentDeps(deploymentDeps)\n-                .setAppArtifact(appArtifact);\n-        return this.appModel = appBuilder.build();\n-    }\n-\n-    private void collectDependencies(Configuration config, AppModel.Builder appBuilder,\n-            final List<Dependency> directExtensionDeps,\n-            final List<AppDependency> userDeps, Map<AppArtifactKey, AppDependency> versionMap,\n-            Map<ModuleIdentifier, ModuleVersionIdentifier> userModules) {\n-\n-        final ResolvedConfiguration resolvedConfig = config.getResolvedConfiguration();\n-        for (ResolvedArtifact a : resolvedConfig.getResolvedArtifacts()) {\n-            if (!isDependency(a)) {\n-                continue;\n-            }\n-            userModules.put(getModuleId(a), a.getModuleVersion().getId());\n \n-            final AppDependency dependency = toAppDependency(a);\n-            final AppArtifactKey artifactGa = new AppArtifactKey(dependency.getArtifact().getGroupId(),\n-                    dependency.getArtifact().getArtifactId());\n-\n-            // If we are running in dev mode we prefer directories of classes and resources over the JARs\n-            // for local project dependencies\n-            if (LaunchMode.DEVELOPMENT.equals(launchMode)\n-                    && (a.getId().getComponentIdentifier() instanceof ProjectComponentIdentifier)) {\n-                final Project depProject = project.getRootProject()\n-                        .findProject(((ProjectComponentIdentifier) a.getId().getComponentIdentifier()).getProjectPath());\n-                final JavaPluginConvention javaConvention = depProject.getConvention().findPlugin(JavaPluginConvention.class);\n-                if (javaConvention != null) {\n-                    SourceSet mainSourceSet = javaConvention.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n-                    final PathsCollection.Builder paths = PathsCollection.builder();\n-                    final Path classesDir = Paths\n-                            .get(QuarkusGradleUtils.getClassesDir(mainSourceSet, depProject.getBuildDir(), false));\n-                    if (Files.exists(classesDir)) {\n-                        paths.add(classesDir);\n-                    }\n-                    for (File resourcesDir : mainSourceSet.getResources().getSourceDirectories()) {\n-                        if (resourcesDir.exists()) {\n-                            paths.add(resourcesDir.toPath());\n-                        }\n-                    }\n-                    dependency.getArtifact().setPaths(paths.build());\n-                }\n-            }\n-\n-            if (!dependency.getArtifact().isResolved()) {\n-                throw new IllegalStateException(\"Failed to resolve \" + a.getId());\n-            }\n-\n-            userDeps.add(dependency);\n-            versionMap.put(artifactGa, dependency);\n-        }\n-\n-        collectExtensionDeps(resolvedConfig.getFirstLevelModuleDependencies(), versionMap, appBuilder, directExtensionDeps,\n-                true, new HashSet<>());\n-    }\n-\n-    private void collectExtensionDeps(Set<ResolvedDependency> resolvedDeps,\n-            Map<AppArtifactKey, AppDependency> versionMap,\n-            AppModel.Builder appBuilder,\n-            List<Dependency> firstLevelExtensions,\n-            boolean firstLevelExt,\n-            Set<AppArtifactKey> visited) {\n-        for (ResolvedDependency dep : resolvedDeps) {\n-            final AppArtifactKey key = new AppArtifactKey(dep.getModuleGroup(), dep.getModuleName());\n-            if (!visited.add(key)) {\n-                continue;\n-            }\n-            final AppDependency appDep = versionMap.get(key);\n-            if (appDep == null) {\n-                // not a jar\n-                continue;\n-            }\n-\n-            Dependency extDep = null;\n+        for (io.quarkus.gradle.workspace.model.Dependency extensionDependency : model.getExtensionDependencies()) {\n+            AppDependency appDep = toAppDependency(extensionDependency);\n             for (Path artifactPath : appDep.getArtifact().getPaths()) {\n                 if (!Files.exists(artifactPath)) {\n                     continue;\n                 }\n                 if (Files.isDirectory(artifactPath)) {\n-                    extDep = processQuarkusDir(appDep.getArtifact(), artifactPath.resolve(BootstrapConstants.META_INF),\n+                    processQuarkusDir(appDep.getArtifact(), artifactPath.resolve(BootstrapConstants.META_INF),\n                             appBuilder);\n                 } else {\n                     try (FileSystem artifactFs = FileSystems.newFileSystem(artifactPath, null)) {\n-                        extDep = processQuarkusDir(appDep.getArtifact(), artifactFs.getPath(BootstrapConstants.META_INF),\n+                        processQuarkusDir(appDep.getArtifact(), artifactFs.getPath(BootstrapConstants.META_INF),\n                                 appBuilder);\n                     } catch (IOException e) {\n                         throw new GradleException(\"Failed to process \" + artifactPath, e);\n                     }\n                 }\n-                if (extDep != null) {\n-                    break;\n-                }\n             }\n-\n-            boolean addChildExtensions = firstLevelExt;\n-            if (extDep != null && firstLevelExt) {\n-                firstLevelExtensions.add(extDep);\n-                addChildExtensions = false;\n+            if (!userDeps.contains(appDep)) {\n+                deploymentDeps.add(appDep);\n             }\n-            final Set<ResolvedDependency> resolvedChildren = dep.getChildren();\n-            if (!resolvedChildren.isEmpty()) {\n-                collectExtensionDeps(resolvedChildren, versionMap, appBuilder, firstLevelExtensions, addChildExtensions,\n-                        visited);\n+        }\n+\n+        final List<AppDependency> fullDeploymentDeps = new ArrayList<>(userDeps);\n+        fullDeploymentDeps.addAll(deploymentDeps);\n+\n+        if (!appArtifact.isResolved()) {\n+            PathsCollection.Builder paths = PathsCollection.builder();\n+            for (SourceSet sourceSet : model.getSourceSets()) {\n+                sourceSet.getSourceDirectories().stream().filter(File::exists).map(File::toPath).forEach(paths::add);", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MTUxNg==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450091516", "bodyText": "these are more BuildOutput such as build/classes/java/main", "author": "glefloch", "createdAt": "2020-07-06T09:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMjk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMzU4OA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450113588", "bodyText": "well actually it's not, but I will update so it points to classes and not java files", "author": "glefloch", "createdAt": "2020-07-06T09:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMjk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxNDUzNA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450014534", "bodyText": "Looks like this could stay the way it was?", "author": "aloubyansky", "createdAt": "2020-07-06T06:46:35Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusDev.java", "diffHunk": "@@ -284,7 +284,8 @@ public void startDev() {\n             StringBuilder classPathManifest = new StringBuilder();\n \n             final AppModel appModel;\n-            final AppModelResolver modelResolver = extension().getAppModelResolver(LaunchMode.DEVELOPMENT);\n+            final QuarkusModel quarkusModel = extension().getQuarkusModel(LaunchMode.DEVELOPMENT);\n+            final AppModelResolver modelResolver = new AppModelGradleResolver(quarkusModel);", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxNzk4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450017985", "bodyText": "Looks like this could depend on the launch mode.", "author": "aloubyansky", "createdAt": "2020-07-06T06:55:16Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/workspace/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package io.quarkus.gradle.workspace.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ModuleIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.DefaultModuleIdentifier;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.gradle.workspace.model.Dependency;\n+import io.quarkus.gradle.workspace.model.QuarkusModel;\n+import io.quarkus.gradle.workspace.model.impl.DependencyImpl;\n+import io.quarkus.gradle.workspace.model.impl.QuarkusModelImpl;\n+import io.quarkus.gradle.workspace.model.impl.SourceSetImpl;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        LaunchMode mode;\n+        if (project.getExtensions().getExtraProperties().has(\"launchMode\")) {\n+            mode = LaunchMode.valueOf(project.getExtensions().getExtraProperties().get(\"launchMode\").toString());\n+        } else {\n+            mode = LaunchMode.NORMAL;\n+        }\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+        final SourceSet testSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.TEST_SOURCE_SET_NAME);", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMDIxMA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450020210", "bodyText": "Is this used anywhere else then in AppArtifactKey?", "author": "aloubyansky", "createdAt": "2020-07-06T07:00:09Z", "path": "independent-projects/bootstrap/app-model/src/main/java/io/quarkus/bootstrap/model/ArtifactKey.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package io.quarkus.bootstrap.model;\n+\n+public interface ArtifactKey {", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMDc2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450020769", "bodyText": "What is this for? It looks like it also includes all the enforced platforms.", "author": "aloubyansky", "createdAt": "2020-07-06T07:01:27Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/workspace/model/QuarkusModel.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.gradle.workspace.model;\n+\n+import java.util.Collection;\n+\n+public interface QuarkusModel {\n+\n+    Collection<SourceSet> getSourceSets();\n+\n+    Collection<Dependency> getAppDependencies();\n+\n+    Collection<String> getExtensions();", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMzM2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450023365", "bodyText": "I am not sure what platformExtension signifies here. These are application direct extension dependencies, maybe let's call it that?", "author": "aloubyansky", "createdAt": "2020-07-06T07:07:50Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/workspace/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package io.quarkus.gradle.workspace.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ModuleIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.DefaultModuleIdentifier;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.gradle.workspace.model.Dependency;\n+import io.quarkus.gradle.workspace.model.QuarkusModel;\n+import io.quarkus.gradle.workspace.model.impl.DependencyImpl;\n+import io.quarkus.gradle.workspace.model.impl.QuarkusModelImpl;\n+import io.quarkus.gradle.workspace.model.impl.SourceSetImpl;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        LaunchMode mode;\n+        if (project.getExtensions().getExtraProperties().has(\"launchMode\")) {\n+            mode = LaunchMode.valueOf(project.getExtensions().getExtraProperties().get(\"launchMode\").toString());\n+        } else {\n+            mode = LaunchMode.NORMAL;\n+        }\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+        final SourceSet testSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.TEST_SOURCE_SET_NAME);\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> platformExtension = getPlatformExtension(project);", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4MTU0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450081547", "bodyText": "Yes, I agree with you", "author": "glefloch", "createdAt": "2020-07-06T08:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMzM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMzY1OA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r450023658", "bodyText": "Let's call them either extension dependencies or deployment dependencies.", "author": "aloubyansky", "createdAt": "2020-07-06T07:08:30Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/workspace/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package io.quarkus.gradle.workspace.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ModuleIdentifier;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.DefaultModuleIdentifier;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.gradle.workspace.model.Dependency;\n+import io.quarkus.gradle.workspace.model.QuarkusModel;\n+import io.quarkus.gradle.workspace.model.impl.DependencyImpl;\n+import io.quarkus.gradle.workspace.model.impl.QuarkusModelImpl;\n+import io.quarkus.gradle.workspace.model.impl.SourceSetImpl;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        LaunchMode mode;\n+        if (project.getExtensions().getExtraProperties().has(\"launchMode\")) {\n+            mode = LaunchMode.valueOf(project.getExtensions().getExtraProperties().get(\"launchMode\").toString());\n+        } else {\n+            mode = LaunchMode.NORMAL;\n+        }\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+        final SourceSet testSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.TEST_SOURCE_SET_NAME);\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> platformExtension = getPlatformExtension(project);\n+\n+        final Collection<Dependency> appDependencies = new LinkedList<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.addAll(collectDependencies(configuration, configurationName, mode, project));\n+            platformExtension.addAll(getExtensions(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Collection<Dependency> platformDependencies = collectExtensionDependencies(project, platformExtension);", "originalCommit": "96dc2f22c37b02f11726c07d325ab6fbf5f900a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b4139b6351e9eca49928a476082a8ebb1724e9cd", "url": "https://github.com/quarkusio/quarkus/commit/b4139b6351e9eca49928a476082a8ebb1724e9cd", "message": "review fixes", "committedDate": "2020-07-06T15:29:58Z", "type": "forcePushed"}, {"oid": "825847295aef54385140f056a5169e72aa886e41", "url": "https://github.com/quarkusio/quarkus/commit/825847295aef54385140f056a5169e72aa886e41", "message": "init custom gradle tooling model", "committedDate": "2020-07-15T18:58:35Z", "type": "forcePushed"}, {"oid": "be526e262025c1e691a7e69b6021858f04c74526", "url": "https://github.com/quarkusio/quarkus/commit/be526e262025c1e691a7e69b6021858f04c74526", "message": "init custom gradle tooling model", "committedDate": "2020-07-16T13:57:02Z", "type": "forcePushed"}, {"oid": "3375fba2ebb405aa9ddf58d49b5a95ed46bec9b4", "url": "https://github.com/quarkusio/quarkus/commit/3375fba2ebb405aa9ddf58d49b5a95ed46bec9b4", "message": "init custom gradle tooling model", "committedDate": "2020-07-16T20:16:28Z", "type": "forcePushed"}, {"oid": "005e8b14b6248fe535efa16264e5309e981bcffb", "url": "https://github.com/quarkusio/quarkus/commit/005e8b14b6248fe535efa16264e5309e981bcffb", "message": "init custom gradle tooling model", "committedDate": "2020-07-17T19:13:16Z", "type": "forcePushed"}, {"oid": "cce3ac00d27e9f2de4850db4f1b0bed9d77c9940", "url": "https://github.com/quarkusio/quarkus/commit/cce3ac00d27e9f2de4850db4f1b0bed9d77c9940", "message": "init custom gradle tooling model", "committedDate": "2020-07-17T19:46:26Z", "type": "forcePushed"}, {"oid": "00bd99b8bb54f1a1fc1d4bd33e3674b05c5f02a8", "url": "https://github.com/quarkusio/quarkus/commit/00bd99b8bb54f1a1fc1d4bd33e3674b05c5f02a8", "message": "init custom gradle tooling model", "committedDate": "2020-07-17T19:56:48Z", "type": "forcePushed"}, {"oid": "a78aa9be6a1fa3df0769fbaef91c07d3c61281e0", "url": "https://github.com/quarkusio/quarkus/commit/a78aa9be6a1fa3df0769fbaef91c07d3c61281e0", "message": "init custom gradle tooling model", "committedDate": "2020-07-20T14:18:54Z", "type": "forcePushed"}, {"oid": "4503657e03db130aa533f0a5e40bd1ede7163929", "url": "https://github.com/quarkusio/quarkus/commit/4503657e03db130aa533f0a5e40bd1ede7163929", "message": "init custom gradle tooling model", "committedDate": "2020-07-21T06:11:15Z", "type": "forcePushed"}, {"oid": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "url": "https://github.com/quarkusio/quarkus/commit/16632d201cdf746a0adde236ed56e3fa6181b3cf", "message": "init custom gradle tooling model", "committedDate": "2020-07-21T06:24:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1NDQ1MA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458054450", "bodyText": "There is only one workspace that may include multiple projects.", "author": "aloubyansky", "createdAt": "2020-07-21T12:23:26Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.Workspace;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getDirectExtension(project);\n+\n+        final Set<Dependency> appDependencies = new HashSet<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.addAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(getWorkspace(project),\n+                getAdditionalWorkspaces(project.getRootProject(), project.getName()),\n+                appDependencies,\n+                extensionDependencies);\n+    }\n+\n+    private Workspace getWorkspace(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<Workspace> getAdditionalWorkspaces(Project project, String mainProjectName) {", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2NjQzMA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458066430", "bodyText": "Yes, I will introduce a project or module type to only keep one worksapce", "author": "glefloch", "createdAt": "2020-07-21T12:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1NDQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1NjcyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458056729", "bodyText": "This method should be renamed. It's not about extensions here. All it does it collects the enforced platforms. It should reflect that in the name.", "author": "aloubyansky", "createdAt": "2020-07-21T12:27:26Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.Workspace;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getDirectExtension(project);\n+\n+        final Set<Dependency> appDependencies = new HashSet<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.addAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(getWorkspace(project),\n+                getAdditionalWorkspaces(project.getRootProject(), project.getName()),\n+                appDependencies,\n+                extensionDependencies);\n+    }\n+\n+    private Workspace getWorkspace(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<Workspace> getAdditionalWorkspaces(Project project, String mainProjectName) {\n+        Set<Workspace> workspaces = new HashSet<>();\n+        for (Project subproject : project.getSubprojects()) {\n+\n+            if (subproject.getName().equals(mainProjectName)) {\n+                continue;\n+            }\n+            final Convention convention = subproject.getConvention();\n+            JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n+            if (javaConvention == null) {\n+                continue;\n+            }\n+\n+            workspaces.add(getWorkspace(subproject));\n+        }\n+        return workspaces;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtension(Project project) {", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2NjY1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458066655", "bodyText": "\ud83d\udc4d , I will rename it", "author": "glefloch", "createdAt": "2020-07-21T12:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1NjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2OTAwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458069001", "bodyText": "It looks like you are not checking for potential conflicts with the user dependencies. That's what I used the versionMap for.", "author": "aloubyansky", "createdAt": "2020-07-21T12:48:42Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.Workspace;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getDirectExtension(project);\n+\n+        final Set<Dependency> appDependencies = new HashSet<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.addAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(getWorkspace(project),\n+                getAdditionalWorkspaces(project.getRootProject(), project.getName()),\n+                appDependencies,\n+                extensionDependencies);\n+    }\n+\n+    private Workspace getWorkspace(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<Workspace> getAdditionalWorkspaces(Project project, String mainProjectName) {\n+        Set<Workspace> workspaces = new HashSet<>();\n+        for (Project subproject : project.getSubprojects()) {\n+\n+            if (subproject.getName().equals(mainProjectName)) {\n+                continue;\n+            }\n+            final Convention convention = subproject.getConvention();\n+            JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n+            if (javaConvention == null) {\n+                continue;\n+            }\n+\n+            workspaces.add(getWorkspace(subproject));\n+        }\n+        return workspaces;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtension(Project project) {\n+        final Set<org.gradle.api.artifacts.Dependency> directExtension = new HashSet<>();\n+        // collect enforced platforms\n+        final Configuration impl = project.getConfigurations()\n+                .getByName(JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME);\n+        for (org.gradle.api.artifacts.Dependency d : impl.getAllDependencies()) {\n+            if (!(d instanceof ModuleDependency)) {\n+                continue;\n+            }\n+            final ModuleDependency module = (ModuleDependency) d;\n+            final Category category = module.getAttributes().getAttribute(Category.CATEGORY_ATTRIBUTE);\n+            if (category != null && Category.ENFORCED_PLATFORM.equals(category.getName())) {\n+                directExtension.add(d);\n+            }\n+        }\n+        return directExtension;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtensionDependencies(Set<ResolvedDependency> dependencies,\n+            Collection<Dependency> appDependencies) {\n+        Set<org.gradle.api.artifacts.Dependency> extensions = new HashSet<>();\n+        for (ResolvedDependency d : dependencies) {\n+            appDependencies.stream()\n+                    .filter(dep -> dep.getGroupId().equals(d.getModuleGroup()) && dep.getName().equals(d.getModuleName()))\n+                    .map(this::getDeploymentArtifact)\n+                    .filter(Objects::nonNull)\n+                    .forEach(extensions::add);\n+            final Set<ResolvedDependency> resolvedChildren = d.getChildren();\n+            if (!resolvedChildren.isEmpty()) {\n+                extensions.addAll(getDirectExtensionDependencies(resolvedChildren, appDependencies));\n+            }\n+        }\n+        return extensions;\n+    }\n+\n+    private org.gradle.api.artifacts.Dependency getDeploymentArtifact(Dependency dependency) {\n+        for (File file : dependency.getPaths()) {\n+            if (!file.exists()) {\n+                continue;\n+            }\n+            Properties depsProperties;\n+            if (file.isDirectory()) {\n+                Path quarkusDescr = file.toPath()\n+                        .resolve(BootstrapConstants.META_INF)\n+                        .resolve(BootstrapConstants.DESCRIPTOR_FILE_NAME);\n+                if (!Files.exists(quarkusDescr)) {\n+                    continue;\n+                }\n+                depsProperties = QuarkusModelHelper.resolveDescriptor(quarkusDescr);\n+            } else {\n+                try (FileSystem artifactFs = FileSystems.newFileSystem(file.toPath(), getClass().getClassLoader())) {\n+                    Path quarkusDescr = artifactFs.getPath(BootstrapConstants.META_INF)\n+                            .resolve(BootstrapConstants.DESCRIPTOR_FILE_NAME);\n+                    if (!Files.exists(quarkusDescr)) {\n+                        continue;\n+                    }\n+                    depsProperties = QuarkusModelHelper.resolveDescriptor(quarkusDescr);\n+                } catch (IOException e) {\n+                    throw new GradleException(\"Failed to process \" + file, e);\n+                }\n+            }\n+            String value = depsProperties.getProperty(BootstrapConstants.PROP_DEPLOYMENT_ARTIFACT);\n+            String[] split = value.split(\":\");\n+            return new DefaultExternalModuleDependency(split[0], split[1], split[2], null);\n+        }\n+        return null;\n+    }\n+\n+    private Set<Dependency> collectExtensionDependencies(Project project,\n+            Collection<org.gradle.api.artifacts.Dependency> extensions) {\n+        final Set<Dependency> platformDependencies = new HashSet<>();\n+\n+        final Configuration deploymentConfig = project.getConfigurations()\n+                .detachedConfiguration(extensions.toArray(new org.gradle.api.artifacts.Dependency[0]));\n+        final ResolvedConfiguration rc = deploymentConfig.getResolvedConfiguration();\n+        for (ResolvedArtifact a : rc.getResolvedArtifacts()) {\n+            if (!isDependency(a)) {\n+                continue;\n+            }\n+\n+            final Dependency dependency = toDependency(a, deploymentConfig.getName());\n+            platformDependencies.add(dependency);", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MTkyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458081925", "bodyText": "I though it was solved using the alignVersion method when creating the AppModel", "author": "glefloch", "createdAt": "2020-07-21T13:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2OTAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA5NjU5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458096591", "bodyText": "Yes, I found it later in another QuarkusModelHelper.", "author": "aloubyansky", "createdAt": "2020-07-21T13:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2OTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3Njc0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458076743", "bodyText": "this method is supposed to collect only the first met extension artifacts (could be direct or transitive but the first met walking the dependency tree;\nin the original code I was also checking whether I have already visited some deps (that could happen);\njust fyi, we try to stay away from lambda expressions for now for performance reasons.", "author": "aloubyansky", "createdAt": "2020-07-21T13:00:50Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.Workspace;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getDirectExtension(project);\n+\n+        final Set<Dependency> appDependencies = new HashSet<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.addAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(getWorkspace(project),\n+                getAdditionalWorkspaces(project.getRootProject(), project.getName()),\n+                appDependencies,\n+                extensionDependencies);\n+    }\n+\n+    private Workspace getWorkspace(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<Workspace> getAdditionalWorkspaces(Project project, String mainProjectName) {\n+        Set<Workspace> workspaces = new HashSet<>();\n+        for (Project subproject : project.getSubprojects()) {\n+\n+            if (subproject.getName().equals(mainProjectName)) {\n+                continue;\n+            }\n+            final Convention convention = subproject.getConvention();\n+            JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n+            if (javaConvention == null) {\n+                continue;\n+            }\n+\n+            workspaces.add(getWorkspace(subproject));\n+        }\n+        return workspaces;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtension(Project project) {\n+        final Set<org.gradle.api.artifacts.Dependency> directExtension = new HashSet<>();\n+        // collect enforced platforms\n+        final Configuration impl = project.getConfigurations()\n+                .getByName(JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME);\n+        for (org.gradle.api.artifacts.Dependency d : impl.getAllDependencies()) {\n+            if (!(d instanceof ModuleDependency)) {\n+                continue;\n+            }\n+            final ModuleDependency module = (ModuleDependency) d;\n+            final Category category = module.getAttributes().getAttribute(Category.CATEGORY_ATTRIBUTE);\n+            if (category != null && Category.ENFORCED_PLATFORM.equals(category.getName())) {\n+                directExtension.add(d);\n+            }\n+        }\n+        return directExtension;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtensionDependencies(Set<ResolvedDependency> dependencies,\n+            Collection<Dependency> appDependencies) {", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3OTE4MA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458079180", "bodyText": "This should either be removed or logged using getLogger().", "author": "aloubyansky", "createdAt": "2020-07-21T13:04:30Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusPrepare.java", "diffHunk": "@@ -62,36 +62,47 @@ public void prepareQuarkus() {\n             final Convention convention = getProject().getConvention();\n             JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n             if (javaConvention != null) {\n+                System.out.println(\"quarkus prepare java convention found\");", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MDYxOA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458080618", "bodyText": "yes, I will this one", "author": "glefloch", "createdAt": "2020-07-21T13:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3OTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MTExNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458081115", "bodyText": "and all other from that file ;)", "author": "glefloch", "createdAt": "2020-07-21T13:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3OTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NDgwNA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458084804", "bodyText": "As previously mentioned, there should only be one workspace that includes one or more projects or modules.", "author": "aloubyansky", "createdAt": "2020-07-21T13:13:08Z", "path": "independent-projects/bootstrap/gradle-resolver/src/main/java/io/quarkus/bootstrap/resolver/model/QuarkusModel.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.bootstrap.resolver.model;\n+\n+import java.util.Set;\n+\n+public interface QuarkusModel {\n+\n+    Workspace getWorkspace();\n+\n+    Set<Workspace> getAdditionalWorkspace();", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NjE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458086172", "bodyText": "equals/hashCode would be good here just to stay safe.", "author": "aloubyansky", "createdAt": "2020-07-21T13:15:06Z", "path": "independent-projects/bootstrap/gradle-resolver/src/main/java/io/quarkus/bootstrap/resolver/model/impl/ArtifactCoordsImpl.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package io.quarkus.bootstrap.resolver.model.impl;\n+\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import java.io.Serializable;\n+\n+public class ArtifactCoordsImpl implements ArtifactCoords, Serializable {", "originalCommit": "16632d201cdf746a0adde236ed56e3fa6181b3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75c93bc7199f3b3e48607a0238d508342cb16be4", "url": "https://github.com/quarkusio/quarkus/commit/75c93bc7199f3b3e48607a0238d508342cb16be4", "message": "fix review comment", "committedDate": "2020-07-22T08:23:24Z", "type": "forcePushed"}, {"oid": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "url": "https://github.com/quarkusio/quarkus/commit/84a451dbc1a06a8c16d384604e7f1020f68a9f48", "message": "fix review comment", "committedDate": "2020-07-22T08:43:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3MTI5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458771297", "bodyText": "If appModel is not null and the appArtifact does not match, it's an error.", "author": "aloubyansky", "createdAt": "2020-07-22T12:57:51Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java", "diffHunk": "@@ -137,224 +105,11 @@ public Path resolve(AppArtifact appArtifact) throws AppModelResolverException {\n \n     @Override\n     public AppModel resolveModel(AppArtifact appArtifact) throws AppModelResolverException {\n-        AppModel.Builder appBuilder = new AppModel.Builder();\n         if (appModel != null && appModel.getAppArtifact().equals(appArtifact)) {", "originalCommit": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3OTUxOA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458779518", "bodyText": "The project's module is not added to the modules otherwise.", "author": "aloubyansky", "createdAt": "2020-07-22T13:11:24Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceModuleImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getEnforcedPlatform(project);\n+\n+        final Map<ArtifactCoords, Dependency> appDependencies = new HashMap<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.putAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(new WorkspaceImpl(appArtifactCoords, getWorkspace(project.getRootProject())),\n+                new HashSet<>(appDependencies.values()),\n+                extensionDependencies);\n+    }\n+\n+    public Set<WorkspaceModule> getWorkspace(Project project) {\n+        Set<WorkspaceModule> modules = new HashSet<>();\n+        if (project.getSubprojects().isEmpty()) {\n+            return Collections.singleton(getWorkspaceModule(project));", "originalCommit": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5OTk1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458799957", "bodyText": "well, I think you right, as long as, it as some java plugin with source, it should be added", "author": "glefloch", "createdAt": "2020-07-22T13:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3OTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MDg0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458780841", "bodyText": "That's kind of a minor one but it should be plural: platforms :)", "author": "aloubyansky", "createdAt": "2020-07-22T13:13:31Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceModuleImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getEnforcedPlatform(project);\n+\n+        final Map<ArtifactCoords, Dependency> appDependencies = new HashMap<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.putAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(new WorkspaceImpl(appArtifactCoords, getWorkspace(project.getRootProject())),\n+                new HashSet<>(appDependencies.values()),\n+                extensionDependencies);\n+    }\n+\n+    public Set<WorkspaceModule> getWorkspace(Project project) {\n+        Set<WorkspaceModule> modules = new HashSet<>();\n+        if (project.getSubprojects().isEmpty()) {\n+            return Collections.singleton(getWorkspaceModule(project));\n+        }\n+        for (Project subproject : project.getSubprojects()) {\n+            final Convention convention = subproject.getConvention();\n+            JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n+            if (javaConvention == null) {\n+                continue;\n+            }\n+            modules.add(getWorkspaceModule(subproject));\n+        }\n+        return modules;\n+    }\n+\n+    private WorkspaceModule getWorkspaceModule(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceModuleImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getEnforcedPlatform(Project project) {", "originalCommit": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4Mzg5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458783893", "bodyText": "Again, in this method you are collecting all the extensions, while we should be collecting only the first met ones. Which means if you found an extension, you should not be walking though its dependencies.", "author": "aloubyansky", "createdAt": "2020-07-22T13:18:01Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceModuleImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getEnforcedPlatform(project);\n+\n+        final Map<ArtifactCoords, Dependency> appDependencies = new HashMap<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.putAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(new WorkspaceImpl(appArtifactCoords, getWorkspace(project.getRootProject())),\n+                new HashSet<>(appDependencies.values()),\n+                extensionDependencies);\n+    }\n+\n+    public Set<WorkspaceModule> getWorkspace(Project project) {\n+        Set<WorkspaceModule> modules = new HashSet<>();\n+        if (project.getSubprojects().isEmpty()) {\n+            return Collections.singleton(getWorkspaceModule(project));\n+        }\n+        for (Project subproject : project.getSubprojects()) {\n+            final Convention convention = subproject.getConvention();\n+            JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n+            if (javaConvention == null) {\n+                continue;\n+            }\n+            modules.add(getWorkspaceModule(subproject));\n+        }\n+        return modules;\n+    }\n+\n+    private WorkspaceModule getWorkspaceModule(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceModuleImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getEnforcedPlatform(Project project) {\n+        final Set<org.gradle.api.artifacts.Dependency> directExtension = new HashSet<>();\n+        // collect enforced platforms\n+        final Configuration impl = project.getConfigurations()\n+                .getByName(JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME);\n+        for (org.gradle.api.artifacts.Dependency d : impl.getAllDependencies()) {\n+            if (!(d instanceof ModuleDependency)) {\n+                continue;\n+            }\n+            final ModuleDependency module = (ModuleDependency) d;\n+            final Category category = module.getAttributes().getAttribute(Category.CATEGORY_ATTRIBUTE);\n+            if (category != null && Category.ENFORCED_PLATFORM.equals(category.getName())) {\n+                directExtension.add(d);\n+            }\n+        }\n+        return directExtension;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtensionDependencies(Set<ResolvedDependency> dependencies,\n+            Map<ArtifactCoords, Dependency> appDependencies) {\n+        Set<org.gradle.api.artifacts.Dependency> extensions = new HashSet<>();\n+        Set<ArtifactCoords> visited = new HashSet<>();\n+        for (ResolvedDependency d : dependencies) {\n+            ArtifactCoords key = new ArtifactCoordsImpl(d.getModuleGroup(), d.getModuleName(), \"\");\n+            if (!visited.add(key)) {\n+                continue;\n+            }\n+\n+            Dependency appDep = appDependencies.get(key);\n+            if (appDep == null) {\n+                continue;\n+            }\n+            final org.gradle.api.artifacts.Dependency deploymentArtifact = getDeploymentArtifact(appDep);\n+            if (deploymentArtifact != null) {", "originalCommit": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMDI4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458810287", "bodyText": "ok, I now understand the firstLevel boolean, I was also missing something on the visited. I fixed that", "author": "glefloch", "createdAt": "2020-07-22T13:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4Mzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NzgzMw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458797833", "bodyText": "Is this a left-over?", "author": "aloubyansky", "createdAt": "2020-07-22T13:38:09Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusPrepare.java", "diffHunk": "@@ -74,24 +73,26 @@ public void prepareQuarkus() {\n                     throw new GradleException(\"Failed to create quarkus-generated-sources\");\n                 }\n \n-                getLogger().debug(\"Will trigger preparing sources for source directory: {} buildDir: {}\",\n+                getLogger().info(\"Will trigger preparing sources for source directory: {} buildDir: {}\",\n                         sourcesDirectories, getProject().getBuildDir().getAbsolutePath());\n-                QuarkusClassLoader deploymentClassLoader = appCreationContext.createDeploymentClassLoader();\n \n+                QuarkusClassLoader deploymentClassLoader = appCreationContext.createDeploymentClassLoader();\n                 Class<?> codeGenerator = deploymentClassLoader.loadClass(CodeGenerator.class.getName());\n+\n                 Optional<Method> initAndRun = Arrays.stream(codeGenerator.getMethods())\n                         .filter(m -> m.getName().equals(INIT_AND_RUN))\n                         .findAny();\n                 if (!initAndRun.isPresent()) {\n                     throw new GradleException(\"Failed to find \" + INIT_AND_RUN + \" method in \" + CodeGenerator.class.getName());\n                 }\n-\n+                sourcesDirectories.forEach(System.out::println);", "originalCommit": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMDgwMA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458800800", "bodyText": "oupss", "author": "glefloch", "createdAt": "2020-07-22T13:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMDU0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r458800546", "bodyText": "This should be plural, i.e. getAllModules", "author": "aloubyansky", "createdAt": "2020-07-22T13:42:00Z", "path": "independent-projects/bootstrap/gradle-resolver/src/main/java/io/quarkus/bootstrap/resolver/model/Workspace.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package io.quarkus.bootstrap.resolver.model;\n+\n+import java.util.Set;\n+\n+public interface Workspace {\n+\n+    WorkspaceModule getMainModule();\n+\n+    Set<WorkspaceModule> getAllModule();", "originalCommit": "84a451dbc1a06a8c16d384604e7f1020f68a9f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d51fb01b4ef258c968c4b7f5afb574a1e6cb91fa", "url": "https://github.com/quarkusio/quarkus/commit/d51fb01b4ef258c968c4b7f5afb574a1e6cb91fa", "message": "fix review comment", "committedDate": "2020-07-22T19:37:58Z", "type": "forcePushed"}, {"oid": "03fa3c6a079a015b80b12fc034193333a3c341b3", "url": "https://github.com/quarkusio/quarkus/commit/03fa3c6a079a015b80b12fc034193333a3c341b3", "message": "try fixing windows locking issue", "committedDate": "2020-07-23T14:03:10Z", "type": "forcePushed"}, {"oid": "a58138d5399f61ac41920885c39a244645d97efe", "url": "https://github.com/quarkusio/quarkus/commit/a58138d5399f61ac41920885c39a244645d97efe", "message": "init custom gradle tooling model", "committedDate": "2020-07-24T07:51:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NDI5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r459994295", "bodyText": "It'd be good to include the conflicting artifacts into the message.", "author": "aloubyansky", "createdAt": "2020-07-24T11:21:33Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java", "diffHunk": "@@ -137,224 +105,15 @@ public Path resolve(AppArtifact appArtifact) throws AppModelResolverException {\n \n     @Override\n     public AppModel resolveModel(AppArtifact appArtifact) throws AppModelResolverException {\n-        AppModel.Builder appBuilder = new AppModel.Builder();\n-        if (appModel != null && appModel.getAppArtifact().equals(appArtifact)) {\n-            return appModel;\n-        }\n-        final List<Dependency> directExtensionDeps = new ArrayList<>();\n-\n-        // collect enforced platforms\n-        final Configuration impl = project.getConfigurations().getByName(JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME);\n-        for (Dependency d : impl.getAllDependencies()) {\n-            if (!(d instanceof ModuleDependency)) {\n-                continue;\n-            }\n-            final ModuleDependency module = (ModuleDependency) d;\n-            final Category category = module.getAttributes().getAttribute(Category.CATEGORY_ATTRIBUTE);\n-            if (category != null && Category.ENFORCED_PLATFORM.equals(category.getName())) {\n-                directExtensionDeps.add(d);\n-            }\n-        }\n-\n-        final List<AppDependency> userDeps = new ArrayList<>();\n-        Map<AppArtifactKey, AppDependency> versionMap = new HashMap<>();\n-        Map<ModuleIdentifier, ModuleVersionIdentifier> userModules = new HashMap<>();\n-\n-        final String classpathConfigName = launchMode == LaunchMode.TEST ? JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME\n-                : JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME;\n-\n-        collectDependencies(project.getConfigurations().getByName(classpathConfigName),\n-                appBuilder, directExtensionDeps, userDeps,\n-                versionMap, userModules);\n-\n-        if (launchMode == LaunchMode.DEVELOPMENT) {\n-            collectDependencies(project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME),\n-                    appBuilder, directExtensionDeps, userDeps,\n-                    versionMap, userModules);\n-        }\n-\n-        final List<AppDependency> deploymentDeps = new ArrayList<>();\n-        final List<AppDependency> fullDeploymentDeps = new ArrayList<>(userDeps);\n-        if (!directExtensionDeps.isEmpty()) {\n-            final Configuration deploymentConfig = project.getConfigurations()\n-                    .detachedConfiguration(directExtensionDeps.toArray(new Dependency[0]));\n-            final ResolvedConfiguration rc = deploymentConfig.getResolvedConfiguration();\n-            for (ResolvedArtifact a : rc.getResolvedArtifacts()) {\n-                final ModuleVersionIdentifier userVersion = userModules.get(getModuleId(a));\n-                if (userVersion != null || !isDependency(a)) {\n-                    continue;\n-                }\n-                final AppDependency dependency = toAppDependency(a);\n-                fullDeploymentDeps.add(dependency);\n-                if (!userDeps.contains(dependency)) {\n-                    AppDependency deploymentDep = alignVersion(dependency, versionMap);\n-                    deploymentDeps.add(deploymentDep);\n-                }\n-            }\n-        }\n-\n-        if (!appArtifact.isResolved()) {\n-            final Jar jarTask = (Jar) project.getTasks().findByName(JavaPlugin.JAR_TASK_NAME);\n-            if (jarTask == null) {\n-                throw new AppModelResolverException(\"Failed to locate task 'jar' in the project.\");\n-            }\n-            if (jarTask.getDidWork()) {\n-                final Provider<RegularFile> jarProvider = jarTask.getArchiveFile();\n-                Path classesDir = null;\n-                if (jarProvider.isPresent()) {\n-                    final File f = jarProvider.get().getAsFile();\n-                    if (f.exists()) {\n-                        classesDir = f.toPath();\n-                    }\n-                }\n-                if (classesDir == null) {\n-                    throw new AppModelResolverException(\"Failed to locate classes directory for \" + appArtifact);\n-                }\n-                appArtifact.setPaths(PathsCollection.of(classesDir));\n+        if (appModel != null) {\n+            if (appModel.getAppArtifact().equals(appArtifact)) {\n+                return appModel;\n             } else {\n-                final Convention convention = project.getConvention();\n-                JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n-                if (javaConvention != null) {\n-                    final SourceSet mainSourceSet = javaConvention.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n-                    PathsCollection.Builder paths = PathsCollection.builder();\n-                    mainSourceSet.getOutput().filter(s -> s.exists()).forEach(f -> {\n-                        paths.add(f.toPath());\n-                    });\n-                    for (File resourcesDir : mainSourceSet.getResources().getSourceDirectories()) {\n-                        if (resourcesDir.exists()) {\n-                            paths.add(resourcesDir.toPath());\n-                        }\n-                    }\n-                    appArtifact.setPaths(paths.build());\n-                }\n+                throw new AppModelResolverException(\"Requested artifact does not match loaded model\");", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODc4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r459998781", "bodyText": "I had addChildExtension and walked the whole tree because we also used to collect all the extension properties. Given that you are doing it elsewhere, I think you could have changed this if to addChildExtension && !resolvedChildren.isEmpty(). I don't think you need firstLevel arg in your impl.", "author": "aloubyansky", "createdAt": "2020-07-24T11:33:03Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/builder/QuarkusModelBuilder.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package io.quarkus.gradle.builder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ResolvedArtifact;\n+import org.gradle.api.artifacts.ResolvedConfiguration;\n+import org.gradle.api.artifacts.ResolvedDependency;\n+import org.gradle.api.artifacts.component.ProjectComponentIdentifier;\n+import org.gradle.api.attributes.Category;\n+import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;\n+import org.gradle.api.plugins.Convention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.tooling.provider.model.ParameterizedToolingModelBuilder;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.ModelParameter;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import io.quarkus.bootstrap.resolver.model.impl.ArtifactCoordsImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.DependencyImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.ModelParameterImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.QuarkusModelImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.SourceSetImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceImpl;\n+import io.quarkus.bootstrap.resolver.model.impl.WorkspaceModuleImpl;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import io.quarkus.gradle.tasks.QuarkusGradleUtils;\n+import io.quarkus.runtime.LaunchMode;\n+\n+public class QuarkusModelBuilder implements ParameterizedToolingModelBuilder {\n+\n+    private static final List<String> scannedConfigurations = new LinkedList();\n+\n+    @Override\n+    public boolean canBuild(String modelName) {\n+        return modelName.equals(QuarkusModel.class.getName());\n+    }\n+\n+    @Override\n+    public Class getParameterType() {\n+        return ModelParameter.class;\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Project project) {\n+        final ModelParameterImpl modelParameter = new ModelParameterImpl();\n+        modelParameter.setMode(LaunchMode.DEVELOPMENT.toString());\n+        return buildAll(modelName, modelParameter, project);\n+    }\n+\n+    @Override\n+    public Object buildAll(String modelName, Object parameter, Project project) {\n+        LaunchMode mode = LaunchMode.valueOf(((ModelParameter) parameter).getMode());\n+\n+        if (LaunchMode.TEST.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.TEST_RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        } else {\n+            scannedConfigurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);\n+        }\n+\n+        if (LaunchMode.DEVELOPMENT.equals(mode)) {\n+            scannedConfigurations.add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        }\n+\n+        final Collection<org.gradle.api.artifacts.Dependency> directExtensionDependencies = getEnforcedPlatforms(project);\n+\n+        final Map<ArtifactCoords, Dependency> appDependencies = new HashMap<>();\n+        for (String configurationName : scannedConfigurations) {\n+            final ResolvedConfiguration configuration = project.getConfigurations().getByName(configurationName)\n+                    .getResolvedConfiguration();\n+            appDependencies.putAll(collectDependencies(configuration, configurationName, mode, project));\n+            directExtensionDependencies\n+                    .addAll(getDirectExtensionDependencies(configuration.getFirstLevelModuleDependencies(), appDependencies,\n+                            true, new HashSet<>()));\n+        }\n+\n+        final Set<Dependency> extensionDependencies = collectExtensionDependencies(project, directExtensionDependencies);\n+\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+\n+        return new QuarkusModelImpl(new WorkspaceImpl(appArtifactCoords, getWorkspace(project.getRootProject())),\n+                new HashSet<>(appDependencies.values()),\n+                extensionDependencies);\n+    }\n+\n+    public Set<WorkspaceModule> getWorkspace(Project project) {\n+        Set<WorkspaceModule> modules = new HashSet<>();\n+        for (Project subproject : project.getAllprojects()) {\n+            final Convention convention = subproject.getConvention();\n+            JavaPluginConvention javaConvention = convention.findPlugin(JavaPluginConvention.class);\n+            if (javaConvention == null) {\n+                continue;\n+            }\n+            modules.add(getWorkspaceModule(subproject));\n+        }\n+        return modules;\n+    }\n+\n+    private WorkspaceModule getWorkspaceModule(Project project) {\n+        ArtifactCoords appArtifactCoords = new ArtifactCoordsImpl(project.getGroup().toString(), project.getName(),\n+                project.getVersion().toString());\n+        final SourceSet mainSourceSet = QuarkusGradleUtils.getSourceSet(project, SourceSet.MAIN_SOURCE_SET_NAME);\n+\n+        return new WorkspaceModuleImpl(appArtifactCoords, project.getProjectDir().getAbsoluteFile(),\n+                project.getBuildDir().getAbsoluteFile(), getSourceSourceSet(mainSourceSet), convert(mainSourceSet));\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getEnforcedPlatforms(Project project) {\n+        final Set<org.gradle.api.artifacts.Dependency> directExtension = new HashSet<>();\n+        // collect enforced platforms\n+        final Configuration impl = project.getConfigurations()\n+                .getByName(JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME);\n+        for (org.gradle.api.artifacts.Dependency d : impl.getAllDependencies()) {\n+            if (!(d instanceof ModuleDependency)) {\n+                continue;\n+            }\n+            final ModuleDependency module = (ModuleDependency) d;\n+            final Category category = module.getAttributes().getAttribute(Category.CATEGORY_ATTRIBUTE);\n+            if (category != null && Category.ENFORCED_PLATFORM.equals(category.getName())) {\n+                directExtension.add(d);\n+            }\n+        }\n+        return directExtension;\n+    }\n+\n+    private Set<org.gradle.api.artifacts.Dependency> getDirectExtensionDependencies(Set<ResolvedDependency> dependencies,\n+            Map<ArtifactCoords, Dependency> appDependencies, boolean firstLevel, Set<ArtifactCoords> visited) {\n+        Set<org.gradle.api.artifacts.Dependency> extensions = new HashSet<>();\n+        for (ResolvedDependency d : dependencies) {\n+            ArtifactCoords key = new ArtifactCoordsImpl(d.getModuleGroup(), d.getModuleName(), \"\");\n+            if (!visited.add(key)) {\n+                continue;\n+            }\n+\n+            Dependency appDep = appDependencies.get(key);\n+            if (appDep == null) {\n+                continue;\n+            }\n+            final org.gradle.api.artifacts.Dependency deploymentArtifact = getDeploymentArtifact(appDep);\n+\n+            boolean addChildExtension = firstLevel;\n+            if (deploymentArtifact != null && addChildExtension) {\n+                extensions.add(deploymentArtifact);\n+                addChildExtension = false;\n+            }\n+\n+            final Set<ResolvedDependency> resolvedChildren = d.getChildren();\n+            if (!resolvedChildren.isEmpty()) {", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5OTM4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r459999382", "bodyText": "I.e. you could have removed addChildExtension too. We are simply collecting the first met extension dependencies but not its children.", "author": "aloubyansky", "createdAt": "2020-07-24T11:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMjUyNw==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460002527", "bodyText": "Did you copy this from somewhere? This is not a good idea. What kind of path is expected to be passed in? Project root or any path inside a project?\nA little bit better version would be checking each directory for all the recognizable build files instead of walking up to the root of the FS for each build file.", "author": "aloubyansky", "createdAt": "2020-07-24T11:42:41Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/utils/BuildToolHelper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package io.quarkus.bootstrap.utils;\n+\n+import static io.quarkus.bootstrap.util.QuarkusModelHelper.DEVMODE_REQUIRED_TASKS;\n+\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.QuarkusGradleModelFactory;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+/**\n+ * Helper class used to expose build tool used by the project\n+ */\n+public class BuildToolHelper {\n+\n+    public enum BuildTool {\n+        MAVEN(\"pom.xml\"),\n+        GRADLE(\"build.gradle\");\n+\n+        private final String buildFile;\n+\n+        BuildTool(String buildFile) {\n+            this.buildFile = buildFile;\n+        }\n+\n+        public String getBuildFile() {\n+            return buildFile;\n+        }\n+    }\n+\n+    private BuildToolHelper() {\n+\n+    }\n+\n+    public static boolean isMavenProject(Path project) {\n+        Path currentPath = project;\n+        while (currentPath != null) {\n+            if (Files.exists(currentPath.resolve(BuildTool.MAVEN.getBuildFile()))) {\n+                return true;\n+            }\n+            currentPath = currentPath.getParent();", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwNTM5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460005396", "bodyText": "yes I copier that from here: \n  \n    \n      quarkus/independent-projects/bootstrap/maven-resolver/src/main/java/io/quarkus/bootstrap/resolver/maven/workspace/LocalProject.java\n    \n    \n         Line 217\n      in\n      42dbdd0\n    \n    \n    \n    \n\n        \n          \n           private static Path locateCurrentProjectPom(Path path, boolean required) throws BootstrapMavenException {", "author": "glefloch", "createdAt": "2020-07-24T11:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxMzk4OA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460013988", "bodyText": "Ok, that path is derived from a class name (that is in the classes dir of a project) or is a project root.", "author": "aloubyansky", "createdAt": "2020-07-24T12:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMjUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMzQ3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460003476", "bodyText": "If projectRoot is actually the project root we shouldn't be walking up to the root of the FS looking for the pom.xml.", "author": "aloubyansky", "createdAt": "2020-07-24T11:45:06Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/utils/BuildToolHelper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package io.quarkus.bootstrap.utils;\n+\n+import static io.quarkus.bootstrap.util.QuarkusModelHelper.DEVMODE_REQUIRED_TASKS;\n+\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.QuarkusGradleModelFactory;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.util.QuarkusModelHelper;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+/**\n+ * Helper class used to expose build tool used by the project\n+ */\n+public class BuildToolHelper {\n+\n+    public enum BuildTool {\n+        MAVEN(\"pom.xml\"),\n+        GRADLE(\"build.gradle\");\n+\n+        private final String buildFile;\n+\n+        BuildTool(String buildFile) {\n+            this.buildFile = buildFile;\n+        }\n+\n+        public String getBuildFile() {\n+            return buildFile;\n+        }\n+    }\n+\n+    private BuildToolHelper() {\n+\n+    }\n+\n+    public static boolean isMavenProject(Path project) {\n+        Path currentPath = project;\n+        while (currentPath != null) {\n+            if (Files.exists(currentPath.resolve(BuildTool.MAVEN.getBuildFile()))) {\n+                return true;\n+            }\n+            currentPath = currentPath.getParent();\n+        }\n+        return false;\n+    }\n+\n+    public static Path getBuildFile(Path project, BuildTool tool) {\n+        Path currentPath = project;\n+        while (currentPath != null) {\n+            if (Files.exists(currentPath.resolve(tool.getBuildFile()))) {\n+                return currentPath;\n+            }\n+            currentPath = currentPath.getParent();\n+        }\n+        return null;\n+    }\n+\n+    public static QuarkusModel enableGradleAppModel(Path projectRoot, String mode)\n+            throws IOException, AppModelResolverException {\n+        if (isMavenProject(projectRoot)) {", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwNDUxNA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460004514", "bodyText": "WorkspaceModuleImpl does not implement hashCode/equals. It would probably be better to have a map instead here. Also given that there is getModule(key)", "author": "aloubyansky", "createdAt": "2020-07-24T11:47:47Z", "path": "independent-projects/bootstrap/gradle-resolver/src/main/java/io/quarkus/bootstrap/resolver/model/impl/WorkspaceImpl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.bootstrap.resolver.model.impl;\n+\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Workspace;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import java.io.Serializable;\n+import java.util.Set;\n+\n+public class WorkspaceImpl implements Workspace, Serializable {\n+\n+    public ArtifactCoords mainModuleKey;\n+    public Set<WorkspaceModule> modules;", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwNjg0NA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460006844", "bodyText": "you need appDependency.getArtifact().getKey() or something here.", "author": "aloubyansky", "createdAt": "2020-07-24T11:53:19Z", "path": "independent-projects/bootstrap/gradle-resolver/src/main/java/io/quarkus/bootstrap/util/QuarkusModelHelper.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package io.quarkus.bootstrap.util;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.BootstrapGradleException;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.model.PathsCollection;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import org.gradle.api.GradleException;\n+\n+public class QuarkusModelHelper {\n+\n+    private QuarkusModelHelper() {\n+\n+    }\n+\n+    public final static String[] DEVMODE_REQUIRED_TASKS = new String[] { \"classes\" };\n+\n+    public static void exportModel(QuarkusModel model) throws AppModelResolverException, IOException {\n+        Path serializedModel = QuarkusModelHelper\n+                .serializeAppModel(model);\n+        System.setProperty(BootstrapConstants.SERIALIZED_APP_MODEL, serializedModel.toString());\n+    }\n+\n+    public static Path serializeAppModel(QuarkusModel model) throws AppModelResolverException, IOException {\n+        final Path serializedModel = File.createTempFile(\"quarkus-app-model\", \".dat\").toPath();\n+        final ArtifactCoords artifactCoords = model.getWorkspace().getMainModule().getArtifactCoords();\n+        AppArtifact appArtifact = new AppArtifact(artifactCoords.getGroupId(),\n+                artifactCoords.getArtifactId(),\n+                artifactCoords.getVersion());\n+        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(serializedModel))) {\n+            out.writeObject(QuarkusModelHelper.convert(model, appArtifact));\n+        }\n+        return serializedModel;\n+    }\n+\n+    public static Path getClassPath(WorkspaceModule model) throws BootstrapGradleException {\n+        // TODO handle multiple class directory\n+        final Optional<Path> classDir = model.getSourceSet().getSourceDirectories().stream().filter(File::exists)\n+                .map(File::toPath).findFirst();\n+        if (!classDir.isPresent()) {\n+            throw new BootstrapGradleException(\"Failed to locate class directory\");\n+        }\n+        return classDir.get();\n+    }\n+\n+    public static AppModel convert(QuarkusModel model, AppArtifact appArtifact) throws AppModelResolverException {\n+        AppModel.Builder appBuilder = new AppModel.Builder();\n+\n+        final List<AppDependency> userDeps = new ArrayList<>();\n+        Map<AppArtifactKey, AppDependency> versionMap = new HashMap<>();\n+        model.getAppDependencies().stream().map(QuarkusModelHelper::toAppDependency).forEach(appDependency -> {\n+            userDeps.add(appDependency);\n+            versionMap.put(appArtifact.getKey(), appDependency);", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwNzE1NA==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460007154", "bodyText": "This is not correct. You need to be comparing the keys instead. Otherwise, you are not aligning versions here.", "author": "aloubyansky", "createdAt": "2020-07-24T11:54:08Z", "path": "independent-projects/bootstrap/gradle-resolver/src/main/java/io/quarkus/bootstrap/util/QuarkusModelHelper.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package io.quarkus.bootstrap.util;\n+\n+import io.quarkus.bootstrap.BootstrapConstants;\n+import io.quarkus.bootstrap.BootstrapGradleException;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.model.PathsCollection;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.model.ArtifactCoords;\n+import io.quarkus.bootstrap.resolver.model.Dependency;\n+import io.quarkus.bootstrap.resolver.model.QuarkusModel;\n+import io.quarkus.bootstrap.resolver.model.WorkspaceModule;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import org.gradle.api.GradleException;\n+\n+public class QuarkusModelHelper {\n+\n+    private QuarkusModelHelper() {\n+\n+    }\n+\n+    public final static String[] DEVMODE_REQUIRED_TASKS = new String[] { \"classes\" };\n+\n+    public static void exportModel(QuarkusModel model) throws AppModelResolverException, IOException {\n+        Path serializedModel = QuarkusModelHelper\n+                .serializeAppModel(model);\n+        System.setProperty(BootstrapConstants.SERIALIZED_APP_MODEL, serializedModel.toString());\n+    }\n+\n+    public static Path serializeAppModel(QuarkusModel model) throws AppModelResolverException, IOException {\n+        final Path serializedModel = File.createTempFile(\"quarkus-app-model\", \".dat\").toPath();\n+        final ArtifactCoords artifactCoords = model.getWorkspace().getMainModule().getArtifactCoords();\n+        AppArtifact appArtifact = new AppArtifact(artifactCoords.getGroupId(),\n+                artifactCoords.getArtifactId(),\n+                artifactCoords.getVersion());\n+        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(serializedModel))) {\n+            out.writeObject(QuarkusModelHelper.convert(model, appArtifact));\n+        }\n+        return serializedModel;\n+    }\n+\n+    public static Path getClassPath(WorkspaceModule model) throws BootstrapGradleException {\n+        // TODO handle multiple class directory\n+        final Optional<Path> classDir = model.getSourceSet().getSourceDirectories().stream().filter(File::exists)\n+                .map(File::toPath).findFirst();\n+        if (!classDir.isPresent()) {\n+            throw new BootstrapGradleException(\"Failed to locate class directory\");\n+        }\n+        return classDir.get();\n+    }\n+\n+    public static AppModel convert(QuarkusModel model, AppArtifact appArtifact) throws AppModelResolverException {\n+        AppModel.Builder appBuilder = new AppModel.Builder();\n+\n+        final List<AppDependency> userDeps = new ArrayList<>();\n+        Map<AppArtifactKey, AppDependency> versionMap = new HashMap<>();\n+        model.getAppDependencies().stream().map(QuarkusModelHelper::toAppDependency).forEach(appDependency -> {\n+            userDeps.add(appDependency);\n+            versionMap.put(appArtifact.getKey(), appDependency);\n+        });\n+\n+        final List<AppDependency> deploymentDeps = new ArrayList<>();\n+        for (Dependency extensionDependency : model.getExtensionDependencies()) {\n+            AppDependency appDep = toAppDependency(extensionDependency);\n+            for (Path artifactPath : appDep.getArtifact().getPaths()) {\n+                if (!Files.exists(artifactPath) || !extensionDependency.getType().equals(\"jar\")) {\n+                    continue;\n+                }\n+                if (Files.isDirectory(artifactPath)) {\n+                    processQuarkusDir(appDep.getArtifact(), artifactPath.resolve(BootstrapConstants.META_INF),\n+                            appBuilder);\n+                } else {\n+                    try (FileSystem artifactFs = FileSystems.newFileSystem(artifactPath,\n+                            QuarkusModelHelper.class.getClassLoader())) {\n+                        processQuarkusDir(appDep.getArtifact(), artifactFs.getPath(BootstrapConstants.META_INF),\n+                                appBuilder);\n+                    } catch (IOException e) {\n+                        throw new AppModelResolverException(\"Failed to process \" + artifactPath, e);\n+                    }\n+                }\n+            }\n+            if (!userDeps.contains(appDep)) {", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxNDY1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460014659", "bodyText": "This is actually done like this in the current model, should i update it to use the appDep.getArtifact() instead? (\n  \n    \n      quarkus/devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java\n    \n    \n         Line 189\n      in\n      23b3d64\n    \n    \n    \n    \n\n        \n          \n           if (!userDeps.contains(dependency)) { \n        \n    \n  \n\n)", "author": "glefloch", "createdAt": "2020-07-24T12:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwNzE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxOTgzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460019835", "bodyText": "Oh, that's clearly a bug. It should be appDep.getArtifact().getKey()", "author": "aloubyansky", "createdAt": "2020-07-24T12:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwNzE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxMjU1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460012556", "bodyText": "Where is this property set? I see it in exportModel but has it been called by this point?", "author": "aloubyansky", "createdAt": "2020-07-24T12:07:25Z", "path": "test-framework/junit5/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java", "diffHunk": "@@ -168,6 +170,12 @@ private ExtensionState doJavaStart(ExtensionContext context, Class<? extends Qua\n                 rootBuilder.add(appResourcesLocation);\n             }\n \n+            Path root = Paths.get(\"\").normalize().toAbsolutePath();\n+            // If gradle project running directly with IDE\n+            if (System.getProperty(BootstrapConstants.SERIALIZED_APP_MODEL) == null) {", "originalCommit": "a58138d5399f61ac41920885c39a244645d97efe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxMzkyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460013925", "bodyText": "It could already have been set by the gradle plugin in the before test", "author": "glefloch", "createdAt": "2020-07-24T12:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxMjU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxODY0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10459#discussion_r460018646", "bodyText": "We'll need a delegating impl of AppModelResolver. For now it's ok, I think.", "author": "aloubyansky", "createdAt": "2020-07-24T12:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxMjU1Ng=="}], "type": "inlineReview"}, {"oid": "9735fad4b839b05837ee69fcd644895095ea5370", "url": "https://github.com/quarkusio/quarkus/commit/9735fad4b839b05837ee69fcd644895095ea5370", "message": "init custom gradle tooling model", "committedDate": "2020-07-24T13:30:20Z", "type": "commit"}, {"oid": "9735fad4b839b05837ee69fcd644895095ea5370", "url": "https://github.com/quarkusio/quarkus/commit/9735fad4b839b05837ee69fcd644895095ea5370", "message": "init custom gradle tooling model", "committedDate": "2020-07-24T13:30:20Z", "type": "forcePushed"}]}