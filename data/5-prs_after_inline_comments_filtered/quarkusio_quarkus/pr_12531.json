{"pr_number": 12531, "pr_title": "Kafka metrics", "pr_createdAt": "2020-10-05T17:40:11Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/12531", "timeline": [{"oid": "d4598f00a4a2c02e88de354d65d321ced3912fde", "url": "https://github.com/quarkusio/quarkus/commit/d4598f00a4a2c02e88de354d65d321ced3912fde", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-05T19:42:12Z", "type": "forcePushed"}, {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "url": "https://github.com/quarkusio/quarkus/commit/ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-06T02:30:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025573", "bodyText": "Why is Vert.x mentioned here?", "author": "cescoffier", "createdAt": "2020-10-06T06:07:27Z", "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.micrometer.deployment.binder;\n+\n+import java.util.function.BooleanSupplier;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.micrometer.runtime.MicrometerRecorder;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+\n+/**\n+ * Add support for Kafka Producer and Consumer instrumentation. Note that\n+ * various bits of support may not be present at deploy time. Avoid referencing\n+ * classes that in turn import optional dependencies.\n+ */\n+public class KafkaBinderProcessor {\n+    static final String KAFKA_CONSUMER_CLASS_NAME = \"org.apache.kafka.clients.consumer.Consumer\";\n+    static final Class<?> KAFKA_CONSUMER_CLASS_CLASS = MicrometerRecorder.getClassForName(KAFKA_CONSUMER_CLASS_NAME);\n+\n+    static final String KAFKA_EVENT_CONSUMER_CLASS_NAME = \"io.quarkus.micrometer.runtime.binder.kafka.KafkaEventObserver\";\n+\n+    static class KafkaSupportEnabled implements BooleanSupplier {\n+        MicrometerConfig mConfig;\n+\n+        public boolean getAsBoolean() {\n+            return KAFKA_CONSUMER_CLASS_CLASS != null && mConfig.checkBinderEnabledWithDefault(mConfig.binder.kafka);\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = KafkaSupportEnabled.class)\n+    AdditionalBeanBuildItem createCDIEventConsumer() {\n+        // Add Vertx meter adapters", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNDA1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500224055", "bodyText": "copy/paste? =) Will fix.", "author": "ebullient", "createdAt": "2020-10-06T12:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025851", "bodyText": "Should this be logged instead?", "author": "cescoffier", "createdAt": "2020-10-06T06:08:27Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNDA0NA==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500224044", "bodyText": "yes!", "author": "ebullient", "createdAt": "2020-10-06T12:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026377", "bodyText": "Why do you remove it and then computeIfAbsent? Do you expect concurrent access? If I'm not sure it works.", "author": "cescoffier", "createdAt": "2020-10-06T06:10:03Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjUyMw==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026523", "bodyText": "it might be safer to just synchronized the whole method.", "author": "cescoffier", "createdAt": "2020-10-06T06:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNjcxOA==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500226718", "bodyText": "I can change that. I like computeIfAbsent as an atomic operation (personal bias), but I can see that it is confusing.", "author": "ebullient", "createdAt": "2020-10-06T12:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjYyMA==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026620", "bodyText": "Same comment", "author": "cescoffier", "createdAt": "2020-10-06T06:10:45Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    return null;\n+                }\n+            });\n+        } else {\n+            prev.close();\n+        }\n+    }\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n+     * If the producer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the producer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param producer Observed Kafka Producer\n+     */\n+    public void producerCreated(@Observes Producer<?, ?> producer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(producer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(producer, x -> {", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "url": "https://github.com/quarkusio/quarkus/commit/70b007ee99452e8a992b9a190a05aa14f80a6e29", "message": "Warning message for deprecated property", "committedDate": "2020-10-06T13:01:20Z", "type": "commit"}, {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "url": "https://github.com/quarkusio/quarkus/commit/41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-06T13:01:20Z", "type": "commit"}, {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "url": "https://github.com/quarkusio/quarkus/commit/41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-06T13:01:20Z", "type": "forcePushed"}]}