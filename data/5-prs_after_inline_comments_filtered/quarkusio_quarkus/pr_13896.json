{"pr_number": 13896, "pr_title": "Create Extension using codestarts", "pr_createdAt": "2020-12-15T12:19:06Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13896", "timeline": [{"oid": "c3bd9e5ca34d430dafbd2e36c98133aaaa06674b", "url": "https://github.com/quarkusio/quarkus/commit/c3bd9e5ca34d430dafbd2e36c98133aaaa06674b", "message": "Create Extension using codestarts", "committedDate": "2020-12-15T12:29:58Z", "type": "forcePushed"}, {"oid": "4e26bb09e992d4e6b863c5291277f5ef653b4933", "url": "https://github.com/quarkusio/quarkus/commit/4e26bb09e992d4e6b863c5291277f5ef653b4933", "message": "Create Extension using codestarts", "committedDate": "2020-12-15T12:31:20Z", "type": "forcePushed"}, {"oid": "6bc584b2bc598ffc6f7f49b025ddca6259060413", "url": "https://github.com/quarkusio/quarkus/commit/6bc584b2bc598ffc6f7f49b025ddca6259060413", "message": "Create Extension using codestarts", "committedDate": "2021-01-08T10:13:53Z", "type": "forcePushed"}, {"oid": "79c20ca7e85c5d56db6bfcb91af88b6ce22caa88", "url": "https://github.com/quarkusio/quarkus/commit/79c20ca7e85c5d56db6bfcb91af88b6ce22caa88", "message": "Create Extension using codestarts", "committedDate": "2021-01-12T09:30:58Z", "type": "forcePushed"}, {"oid": "2838f0db39ecd93c575f3dda99eafab4faea29dd", "url": "https://github.com/quarkusio/quarkus/commit/2838f0db39ecd93c575f3dda99eafab4faea29dd", "message": "Create Extension using codestarts", "committedDate": "2021-01-15T17:06:39Z", "type": "forcePushed"}, {"oid": "d676b5970112bf04f2a0aee4e2a8002e40a62c07", "url": "https://github.com/quarkusio/quarkus/commit/d676b5970112bf04f2a0aee4e2a8002e40a62c07", "message": "Create Extension using codestarts", "committedDate": "2021-01-15T17:34:02Z", "type": "forcePushed"}, {"oid": "a76ab89fcac3b49ddc58caf9be5618e18b5996b2", "url": "https://github.com/quarkusio/quarkus/commit/a76ab89fcac3b49ddc58caf9be5618e18b5996b2", "message": "Create Extension using codestarts", "committedDate": "2021-01-18T08:53:37Z", "type": "forcePushed"}, {"oid": "f271c95c0184c17ee7d295e98a977d1ea10984cc", "url": "https://github.com/quarkusio/quarkus/commit/f271c95c0184c17ee7d295e98a977d1ea10984cc", "message": "Create Extension using codestarts", "committedDate": "2021-01-18T09:05:41Z", "type": "forcePushed"}, {"oid": "ffa8715b595508268b837f3bf11352963d15bae7", "url": "https://github.com/quarkusio/quarkus/commit/ffa8715b595508268b837f3bf11352963d15bae7", "message": "Create Extension using codestarts", "committedDate": "2021-01-18T09:11:05Z", "type": "forcePushed"}, {"oid": "28812df579df552593708e920be8dd15ba9fb239", "url": "https://github.com/quarkusio/quarkus/commit/28812df579df552593708e920be8dd15ba9fb239", "message": "Create Extension using codestarts", "committedDate": "2021-01-18T09:20:35Z", "type": "forcePushed"}, {"oid": "3c3261eef12c370d81ecc338173b2c32437608a8", "url": "https://github.com/quarkusio/quarkus/commit/3c3261eef12c370d81ecc338173b2c32437608a8", "message": "Create Extension using codestarts", "committedDate": "2021-01-18T10:22:34Z", "type": "forcePushed"}, {"oid": "5ef61acb11cc2e6ce377a30bf100e5c8aad2b78a", "url": "https://github.com/quarkusio/quarkus/commit/5ef61acb11cc2e6ce377a30bf100e5c8aad2b78a", "message": "Create Extension using codestarts", "committedDate": "2021-01-19T11:49:59Z", "type": "forcePushed"}, {"oid": "8dc4eafc2875b1203090dfe4817449975f6fc55a", "url": "https://github.com/quarkusio/quarkus/commit/8dc4eafc2875b1203090dfe4817449975f6fc55a", "message": "Create Extension using codestarts", "committedDate": "2021-01-19T12:13:38Z", "type": "forcePushed"}, {"oid": "191f1121372e4bdcb932f21c05c4ae7b4ac0a0ec", "url": "https://github.com/quarkusio/quarkus/commit/191f1121372e4bdcb932f21c05c4ae7b4ac0a0ec", "message": "Create Extension using codestarts", "committedDate": "2021-01-19T12:47:26Z", "type": "forcePushed"}, {"oid": "6fc679842482ea571f0c332debe8d837d6afe7f6", "url": "https://github.com/quarkusio/quarkus/commit/6fc679842482ea571f0c332debe8d837d6afe7f6", "message": "Create Extension using codestarts", "committedDate": "2021-01-25T13:44:47Z", "type": "forcePushed"}, {"oid": "93d2547da4412fd32fde7cec2605996fa9d9b553", "url": "https://github.com/quarkusio/quarkus/commit/93d2547da4412fd32fde7cec2605996fa9d9b553", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T10:26:44Z", "type": "forcePushed"}, {"oid": "cabbf9c8f9bc51b2fd0e402430948ad89ad46ebc", "url": "https://github.com/quarkusio/quarkus/commit/cabbf9c8f9bc51b2fd0e402430948ad89ad46ebc", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T10:29:11Z", "type": "forcePushed"}, {"oid": "1a52391eb1d2ef9fcba730ac7b4d6c4e6183093c", "url": "https://github.com/quarkusio/quarkus/commit/1a52391eb1d2ef9fcba730ac7b4d6c4e6183093c", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T10:34:06Z", "type": "forcePushed"}, {"oid": "7690295a5a31d4a14fb77cd849a36810370e159f", "url": "https://github.com/quarkusio/quarkus/commit/7690295a5a31d4a14fb77cd849a36810370e159f", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T12:05:29Z", "type": "forcePushed"}, {"oid": "3542cdffc9449e1be50499777645142014f47749", "url": "https://github.com/quarkusio/quarkus/commit/3542cdffc9449e1be50499777645142014f47749", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T12:41:48Z", "type": "forcePushed"}, {"oid": "c07eb2fb4c5025293375b5f8571a83ae2805bc1c", "url": "https://github.com/quarkusio/quarkus/commit/c07eb2fb4c5025293375b5f8571a83ae2805bc1c", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T13:18:18Z", "type": "forcePushed"}, {"oid": "7f22fca1c26138e1892a74edd2f4f5d6cfaa6e35", "url": "https://github.com/quarkusio/quarkus/commit/7f22fca1c26138e1892a74edd2f4f5d6cfaa6e35", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T14:00:43Z", "type": "forcePushed"}, {"oid": "6486bf08d5a2e0324f40d25dcb5431f6794af64e", "url": "https://github.com/quarkusio/quarkus/commit/6486bf08d5a2e0324f40d25dcb5431f6794af64e", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T14:42:29Z", "type": "forcePushed"}, {"oid": "17ea9b608466775a8e59ecda504fedfb39997a92", "url": "https://github.com/quarkusio/quarkus/commit/17ea9b608466775a8e59ecda504fedfb39997a92", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T14:43:29Z", "type": "forcePushed"}, {"oid": "331a616d6fd091a1310798c78297591dda89c683", "url": "https://github.com/quarkusio/quarkus/commit/331a616d6fd091a1310798c78297591dda89c683", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T19:14:44Z", "type": "forcePushed"}, {"oid": "70d586db033106e13e3115db0cd3fc8c531e80b8", "url": "https://github.com/quarkusio/quarkus/commit/70d586db033106e13e3115db0cd3fc8c531e80b8", "message": "Create Extension using codestarts", "committedDate": "2021-01-27T19:17:34Z", "type": "forcePushed"}, {"oid": "055af0bb2a1ab4ad8550211a86cd360f92112c06", "url": "https://github.com/quarkusio/quarkus/commit/055af0bb2a1ab4ad8550211a86cd360f92112c06", "message": "Create Extension using codestarts", "committedDate": "2021-01-28T16:58:12Z", "type": "forcePushed"}, {"oid": "36c13adf5248adc7d63cb59901e0ccb9fb1810ab", "url": "https://github.com/quarkusio/quarkus/commit/36c13adf5248adc7d63cb59901e0ccb9fb1810ab", "message": "Create Extension using codestarts", "committedDate": "2021-01-28T17:13:53Z", "type": "forcePushed"}, {"oid": "f6f1d15939a8479e0c6437c3d5e79c0bb6555775", "url": "https://github.com/quarkusio/quarkus/commit/f6f1d15939a8479e0c6437c3d5e79c0bb6555775", "message": "Create Extension using codestarts", "committedDate": "2021-01-28T17:16:00Z", "type": "forcePushed"}, {"oid": "522ba08f3330b781213e3b01634f32fc495ea692", "url": "https://github.com/quarkusio/quarkus/commit/522ba08f3330b781213e3b01634f32fc495ea692", "message": "Create Extension using codestarts", "committedDate": "2021-01-28T17:30:27Z", "type": "forcePushed"}, {"oid": "73578ff5e8a092e886c85996565a8de97685e098", "url": "https://github.com/quarkusio/quarkus/commit/73578ff5e8a092e886c85996565a8de97685e098", "message": "Create Extension using codestarts", "committedDate": "2021-01-29T09:32:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMDgwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566810804", "bodyText": "Is this System.out necessary or can it use a logger instead?", "author": "gastaldi", "createdAt": "2021-01-29T13:12:01Z", "path": "independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/SnapshotTesting.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package io.quarkus.devtools.testing;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import org.apache.commons.io.FileUtils;\n+import org.assertj.core.api.AbstractPathAssert;\n+import org.assertj.core.api.ListAssert;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.TestInfo;\n+\n+/**\n+ * Test file content and directory tree to make sure they are valid by comparing them to their snapshots.\n+ * The snapshots can easily be updated when necessary and reviewed to confirm they are consistent with the changes.\n+ * <br />\n+ * <br />\n+ * Snapshots are automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+ * <code>-Dupdate-snapshots</code>\n+ * <br />\n+ * Snapshots are created in {@link #SNAPSHOTS_DIR}\n+ */\n+public class SnapshotTesting {\n+\n+    public static final Path SNAPSHOTS_DIR = Paths.get(\"src/test/resources/__snapshots__/\");\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY = \"update-snapshots\";\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY_SHORTCUT = \"snap\";\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to its snapshots.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected\n+     * <br />\n+     * <br />\n+     * example:\n+     *\n+     * <pre>\n+     * assertThatMatchSnapshot(testInfo, projectDir, \"src/main/java/org/acme/GreetingResource.java\")\n+     *         .satisfies(checkContains(\"@Path(\\\"/hello\\\")\"))\n+     * </pre>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param parentDir the parent directory containing the generated files for this test (makes it nicer when checking multiple\n+     *        snapshots)\n+     * @param fileRelativePath the relative path from the directory (used to name the snapshot)\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(TestInfo testInfo, Path parentDir, String fileRelativePath)\n+            throws Throwable {\n+        final String snapshotDirName = getSnapshotDirName(testInfo);\n+        final String normalizedFileName = snapshotDirName + \"/\" + fileRelativePath.replace(\"/\", \"_\");\n+        return assertThatMatchSnapshot(parentDir.resolve(fileRelativePath), normalizedFileName);\n+    }\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected using {@link #checkContains(String)} or {@link #checkMatches(String)}\n+     *\n+     * @param fileToCheck the {@link Path} of the file to check\n+     * @param snapshotIdentifier the snapshotIdentifier of the snapshot (used as a relative path from the {@link #SNAPSHOTS_DIR}\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(Path fileToCheck, String snapshotIdentifier) throws Throwable {\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotIdentifier);\n+        assertThat(fileToCheck).isRegularFile();\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotIdentifier);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotIdentifier, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            FileUtils.copyFile(fileToCheck.toFile(), snapshotFile.toFile());\n+        }\n+\n+        final String snapshotNotFoundDescription = \"corresponding snapshot not found for \" + snapshotIdentifier;\n+        if (isUTF8File(fileToCheck)) {\n+            final String description = \"check snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).exists().usingCharset(StandardCharsets.UTF_8)\n+                    .hasContent(getContent(snapshotFile));\n+        } else {\n+            final String description = \"check binary snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).hasBinaryContent(getBinaryContent(snapshotFile));\n+        }\n+        return assertThat(fileToCheck);\n+    }\n+\n+    /**\n+     * Test directory tree to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param dir the {@link Path} of the directory to test\n+     * @return a {@link ListAssert} with the directory tree as a list\n+     * @throws Throwable\n+     */\n+    public static ListAssert<String> assertThatDirectoryTreeMatchSnapshots(TestInfo testInfo, Path dir) throws Throwable {\n+        final String snapshotName = getSnapshotDirName(testInfo) + \"/dir-tree.snapshot\";\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotName);\n+\n+        assertThat(dir).isDirectory();\n+\n+        final List<String> tree = Files.walk(dir)\n+                .map(p -> {\n+                    final String r = dir.relativize(p).toString().replace('\\\\', '/');\n+                    if (Files.isDirectory(p)) {\n+                        return r + \"/\";\n+                    }\n+                    return r;\n+                })\n+                .collect(toList());\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotName);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotName, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            Files.createDirectories(snapshotFile.getParent());\n+            Files.write(snapshotFile, String.join(\"\\n\", tree).getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        assertThat(snapshotFile).isRegularFile();\n+\n+        final List<String> content = Arrays.stream(getContent(snapshotFile).split(\"\\\\v\"))\n+                .filter(s -> !s.isEmpty())\n+                .collect(toList());\n+\n+        return assertThat(tree).containsExactlyInAnyOrderElementsOf(content);\n+    }\n+\n+    public static byte[] getBinaryContent(Path file) {\n+        try {\n+            return Files.readAllBytes(file);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static String getContent(Path file) {\n+        try {\n+            return new String(Files.readAllBytes(file), StandardCharsets.UTF_8);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static void deleteTestDirectory(final File file) throws IOException {\n+        FileUtils.deleteDirectory(file);\n+\n+        Assertions.assertFalse(\n+                Files.exists(file.toPath()), \"Directory still exists\");\n+    }\n+\n+    /**\n+     * To use with {@link AbstractPathAssert} in order to check the file content contains a specific string.\n+     *\n+     * @param s the string which should be in the file content\n+     * @return a {@link Consumer<Path>} to use with {@link AbstractPathAssert#satisfies(Consumer)}\n+     */\n+    public static Consumer<Path> checkContains(String s) {\n+        return (p) -> assertThat(getContent(p)).contains(s);\n+    }\n+\n+    public static Consumer<Path> checkMatches(String regex) {\n+        return (p) -> assertThat(getContent(p)).matches(regex);\n+    }\n+\n+    private static boolean shouldUpdateSnapshot(String identifier) {\n+        return getUpdateSnapshotsProp().filter(u -> u.isEmpty() || \"true\".equalsIgnoreCase(u) || u.contains(identifier))\n+                .isPresent();\n+    }\n+\n+    private static boolean isUTF8File(final Path file) {\n+        try {\n+            final byte[] inputBytes = Files.readAllBytes(file);\n+            final String converted = new String(inputBytes, StandardCharsets.UTF_8);\n+            final byte[] outputBytes = converted.getBytes(StandardCharsets.UTF_8);\n+            return Arrays.equals(inputBytes, outputBytes);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void deleteExistingSnapshots(String name, Path snapshots) {\n+        System.out.println(\"\\n>>>>>> DELETING EXISTING TEST SNAPSHOTS FOR:\\n>>>>>> \" + name + \"\\n\");", "originalCommit": "73578ff5e8a092e886c85996565a8de97685e098", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMjQ5MA==", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566812490", "bodyText": "It's used only in the tests, goal is to make it really obvious, logs are not always displayed..", "author": "ia3andy", "createdAt": "2021-01-29T13:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMDgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMjgzMw==", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566812833", "bodyText": "You only see it when using -Dsnap", "author": "ia3andy", "createdAt": "2021-01-29T13:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMDgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyNzg3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566827876", "bodyText": "Hint: these properties can be moved as getters inside the LayoutType enum above", "author": "gastaldi", "createdAt": "2021-01-29T13:39:23Z", "path": "independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java", "diffHunk": "@@ -0,0 +1,455 @@\n+package io.quarkus.devtools.commands;\n+\n+import static io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog.QuarkusExtensionData.*;\n+import static io.quarkus.devtools.commands.handlers.CreateExtensionCommandHandler.readPom;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog.QuarkusExtensionData;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartProjectInput;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartProjectInputBuilder;\n+import io.quarkus.devtools.commands.data.QuarkusCommandException;\n+import io.quarkus.devtools.commands.data.QuarkusCommandOutcome;\n+import io.quarkus.devtools.commands.handlers.CreateExtensionCommandHandler;\n+import io.quarkus.devtools.messagewriter.MessageWriter;\n+import io.quarkus.maven.utilities.MojoUtils;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.maven.model.Model;\n+\n+/**\n+ * Instances of this class are not thread-safe. They are created per invocation.\n+ */\n+public class CreateExtension {\n+\n+    public enum LayoutType {\n+        OTHER_PLATFORM,\n+        QUARKUS_CORE,\n+        QUARKIVERSE,\n+        STANDALONE\n+    }\n+\n+    public static final String DEFAULT_BOM_GROUP_ID = \"io.quarkus\";\n+    public static final String DEFAULT_BOM_ARTIFACT_ID = \"quarkus-bom\";\n+    public static final String DEFAULT_BOM_VERSION = \"${quarkus.version}\";\n+    public static final String DEFAULT_VERSION = \"0.0.1-SNAPSHOT\";\n+\n+    public static final String DEFAULT_CORE_NAMESPACE_ID = \"quarkus-\";\n+\n+    public static final String DEFAULT_EXTERNAL_NAMESPACE_ID = \"\";\n+\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_GROUP_ID = \"io.quarkiverse\";\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_ARTIFACT_ID = \"quarkiverse-parent\";\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_VERSION = \"5\";", "originalCommit": "73578ff5e8a092e886c85996565a8de97685e098", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyODY0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566828646", "bodyText": "Good hint \ud83d\ude07", "author": "ia3andy", "createdAt": "2021-01-29T13:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyNzg3Ng=="}], "type": "inlineReview"}, {"oid": "7cdb4c2224bd3db29072ddb442f73db226c1f471", "url": "https://github.com/quarkusio/quarkus/commit/7cdb4c2224bd3db29072ddb442f73db226c1f471", "message": "Create Extension using codestarts", "committedDate": "2021-01-29T15:03:52Z", "type": "forcePushed"}, {"oid": "b340408dee4600123415647a438653714d93c95f", "url": "https://github.com/quarkusio/quarkus/commit/b340408dee4600123415647a438653714d93c95f", "message": "Create Extension using codestarts", "committedDate": "2021-01-29T15:05:00Z", "type": "forcePushed"}, {"oid": "e9f0a9a0170529b2578029d3f47e2fce68c34168", "url": "https://github.com/quarkusio/quarkus/commit/e9f0a9a0170529b2578029d3f47e2fce68c34168", "message": "Create Extension using codestarts", "committedDate": "2021-01-29T16:36:43Z", "type": "commit"}, {"oid": "e9f0a9a0170529b2578029d3f47e2fce68c34168", "url": "https://github.com/quarkusio/quarkus/commit/e9f0a9a0170529b2578029d3f47e2fce68c34168", "message": "Create Extension using codestarts", "committedDate": "2021-01-29T16:36:43Z", "type": "forcePushed"}]}