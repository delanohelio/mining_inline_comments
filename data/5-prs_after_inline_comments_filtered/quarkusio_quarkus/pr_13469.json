{"pr_number": 13469, "pr_title": "Added HTTP and Web Socket reactive messaging connector", "pr_createdAt": "2020-11-25T14:01:09Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13469", "timeline": [{"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "url": "https://github.com/quarkusio/quarkus/commit/58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-11-25T14:19:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2MDQ5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530460492", "bodyText": "If we find a way to use the annotation processor, this won't be used anymore.", "author": "cescoffier", "createdAt": "2020-11-25T15:32:06Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/QuarkusWebSocketConnector.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import static io.quarkus.reactivemessaging.http.runtime.QuarkusWebSocketConnector.DEFAULT_JITTER;\n+import static io.smallrye.reactive.messaging.annotations.ConnectorAttribute.Direction.INCOMING;\n+import static io.smallrye.reactive.messaging.annotations.ConnectorAttribute.Direction.OUTGOING;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.spi.Connector;\n+import org.eclipse.microprofile.reactive.messaging.spi.IncomingConnectorFactory;\n+import org.eclipse.microprofile.reactive.messaging.spi.OutgoingConnectorFactory;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder;\n+\n+import io.quarkus.reactivemessaging.http.runtime.serializers.SerializerFactoryBase;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.reactive.messaging.annotations.ConnectorAttribute;\n+import io.vertx.core.Vertx;\n+\n+/**\n+ * Quarkus-specific reactive messaging connector for web sockets\n+ */\n+@Connector(QuarkusWebSocketConnector.NAME)\n+\n+@ConnectorAttribute(name = \"url\", type = \"string\", direction = OUTGOING, description = \"The target URL\", mandatory = true)\n+@ConnectorAttribute(name = \"serializer\", type = \"string\", direction = OUTGOING, description = \"Message serializer\")\n+@ConnectorAttribute(name = \"maxRetries\", type = \"int\", direction = OUTGOING, description = \"The number of retries to make for sending a message to a remote websocket endpoint. A value greater than 0 is advised. Otherwise, a web socket timeout can result in a dropped message\", defaultValue = QuarkusWebSocketConnector.DEFAULT_MAX_ATTEMPTS_STR)\n+@ConnectorAttribute(name = \"jitter\", type = \"string\", direction = OUTGOING, description = \"Configures the random factor when using back-off with maxAttempts > 1\")\n+@ConnectorAttribute(name = \"delay\", type = \"string\", direction = OUTGOING, description = \"Configures a back-off delay between attempts to send a request. A random factor (jitter) is applied to increase the delay when several failures happen.\", defaultValue = DEFAULT_JITTER)\n+\n+@ConnectorAttribute(name = \"path\", type = \"string\", direction = INCOMING, description = \"The path of the endpoint\", mandatory = true)\n+@ConnectorAttribute(name = \"buffer-size\", type = \"string\", direction = INCOMING, description = \"Web socket endpoint buffers messages if a consumer is not able to keep up. This setting specifies the size of the buffer.\", defaultValue = QuarkusHttpConnector.DEFAULT_SOURCE_BUFFER_STR)\n+@ApplicationScoped\n+public class QuarkusWebSocketConnector implements IncomingConnectorFactory, OutgoingConnectorFactory {\n+    public static final String NAME = \"quarkus-websocket\";\n+\n+    static final String DEFAULT_JITTER = \"0.5\";\n+    static final String DEFAULT_MAX_ATTEMPTS_STR = \"1\";\n+    static final Integer DEFAULT_MAX_ATTEMPTS = Integer.valueOf(DEFAULT_MAX_ATTEMPTS_STR);\n+\n+    static final String DEFAULT_SOURCE_BUFFER_STR = \"8\";\n+\n+    public static final Integer DEFAULT_SOURCE_BUFFER = Integer.valueOf(DEFAULT_SOURCE_BUFFER_STR);\n+\n+    @Inject\n+    ReactiveWebSocketHandlerBean handlerBean;\n+\n+    @Inject\n+    SerializerFactoryBase serializerFactory;\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    @Override\n+    public PublisherBuilder<WebSocketMessage<?>> getPublisherBuilder(Config config) {\n+        String path = getRequiredAttribute(config, \"path\", String.class);\n+\n+        Multi<WebSocketMessage<?>> processor = handlerBean.getProcessor(path);\n+        return ReactiveStreams.fromPublisher(processor);\n+    }\n+\n+    @Override\n+    public SubscriberBuilder<? extends Message<?>, Void> getSubscriberBuilder(Config config) {\n+        String serializer = config.getOptionalValue(\"serializer\", String.class).orElse(null);\n+        Optional<Duration> delay = config.getOptionalValue(\"delay\", Duration.class);\n+        String jitterAsString = config.getOptionalValue(\"jitter\", String.class).orElse(DEFAULT_JITTER);\n+        Integer maxRetries = config.getOptionalValue(\"maxRetries\", Integer.class).orElse(DEFAULT_MAX_ATTEMPTS);\n+        URI url = getRequiredAttribute(config, \"url\", URI.class);\n+\n+        double jitter;\n+        try {\n+            jitter = Double.valueOf(jitterAsString);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"Failed to parse jitter value '\" + jitterAsString + \"' to a double.\");\n+        }\n+\n+        return new WebSocketSink(vertx, url, serializer, serializerFactory, maxRetries, delay, jitter).sink();\n+    }\n+\n+    private <T> T getRequiredAttribute(Config config, String attributeName, Class<T> type) {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2MTI2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530461261", "bodyText": "Maybe wrap that call in a try catch and on exception to rc.fail(exception)", "author": "cescoffier", "createdAt": "2020-11-25T15:33:13Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandler.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class ReactiveHttpHandler implements Handler<RoutingContext> {\n+    private final ReactiveHttpHandlerBean handler;\n+\n+    ReactiveHttpHandler(ReactiveHttpHandlerBean handler) {\n+        this.handler = handler;\n+    }\n+\n+    @Override\n+    public void handle(RoutingContext event) {\n+        handler.handle(event);", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NTc0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530465743", "bodyText": "you have an extra space in the end message.", "author": "cescoffier", "createdAt": "2020-11-25T15:39:36Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530467835", "bodyText": "I'm not totally sure why you don't use the built-in back-pressure support.\nYou could just do:\nif (emitter.requested() > 0) {\n x = ...\n emitter.emit(x);\n} else {\n  event.response().setStatusCode(500).end();\n}", "author": "cescoffier", "createdAt": "2020-11-25T15:42:30Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU3MDE2OA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530570168", "bodyText": "when I tried to marry buffering with checking the number of requested items, I was getting Integer.MAX_VALUE from requested(). Can play with it a bit more, maybe I missed something...", "author": "michalszynkiewicz", "createdAt": "2020-11-25T18:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgwMjIyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530802221", "bodyText": "Did you have an onOverflow()?\nActually, depending on your pipeline, it may request Long.MAX_VALUE. You would need to test with a processor / subscriber emitting requests.", "author": "cescoffier", "createdAt": "2020-11-26T06:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk0OTA2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530949062", "bodyText": "I'm 5 nines sure that I tested both, with onOverflow and without", "author": "michalszynkiewicz", "createdAt": "2020-11-26T11:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU1OTMzMw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531559333", "bodyText": "And I was wrong. If I have onOverflow (even with limited buffer), I'm always getting MAX_VALUE from requested().\nOtherwise, it's 1 or 0.\nIf I understand correctly, without onOverflow, if I'm able to get into onSubscribe and request bufferSize of elements, it should more or less work (the difference being it won't be as strict as the guard solution because multiple threads can check the if with the same value and emit messages).", "author": "michalszynkiewicz", "createdAt": "2020-11-27T11:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU3ODY3OA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531578678", "bodyText": "We can keep the guard.", "author": "cescoffier", "createdAt": "2020-11-27T12:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTA2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530469061", "bodyText": "What about 429 or 503?", "author": "cescoffier", "createdAt": "2020-11-25T15:44:06Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);\n+                    event.response().setStatusCode(500).end();", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgzOTM0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530839346", "bodyText": "The rejected because of the overflow status I chose is 503 (line 65). After reading a bit, it seems to me that 429 is rather for situation when an API user exceeds a defined quota.", "author": "michalszynkiewicz", "createdAt": "2020-11-26T08:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTM5OA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530469398", "bodyText": "Probably indicate that it's lacking of downstream requests.", "author": "cescoffier", "createdAt": "2020-11-25T15:44:35Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgxNTc2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530815769", "bodyText": "The current implementation uses an unbounded buffer and limits the amount of elements put into it with the guard.\nI thought in such set up emit should not throw an exception on lack of downstream requests. Am I misunderstanding something?", "author": "michalszynkiewicz", "createdAt": "2020-11-26T07:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTc5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530469791", "bodyText": "I would keep the message empty. 404 is explicit.", "author": "cescoffier", "createdAt": "2020-11-25T15:45:09Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);\n+                    event.response().setStatusCode(500).end();\n+                }\n+            } else {\n+                event.response().setStatusCode(503).end();\n+            }\n+        } else {\n+            event.response().setStatusCode(404).end(\"No http consumer for the given path and method\");", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDc5OA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530470798", "bodyText": "@jponge We don't have a variant that accepts the buffer size here (in the emitter method). As we added it to onOVerflow we may want to add it here too.", "author": "cescoffier", "createdAt": "2020-11-25T15:46:28Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);\n+                    event.response().setStatusCode(500).end();\n+                }\n+            } else {\n+                event.response().setStatusCode(503).end();\n+            }\n+        } else {\n+            event.response().setStatusCode(404).end(\"No http consumer for the given path and method\");\n+        }\n+    }\n+\n+    private void addHttpProcessor(HttpStreamConfig streamConfig) {\n+        String key = key(streamConfig.path, streamConfig.method);\n+\n+        // emitter with an unbounded queue, we control the size ourselves, with the guard\n+        StrictQueueSizeGuard guard = new StrictQueueSizeGuard(streamConfig.bufferSize);\n+        Bundle<HttpMessage<?>> bundle = new Bundle<>(guard);\n+        Multi<HttpMessage<?>> processor = Multi.createFrom()\n+                .<HttpMessage<?>> emitter(bundle::setEmitter, BackPressureStrategy.BUFFER).onItem().invoke(guard::dequeue);", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3Mjg5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530472892", "bodyText": "I believe there is a build item to request the body handler.", "author": "cescoffier", "createdAt": "2020-11-25T15:49:17Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpRecorder.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+\n+@Recorder\n+public class ReactiveHttpRecorder {\n+\n+    public Handler<RoutingContext> createWebSocketeHandler() {\n+        ReactiveWebSocketHandlerBean bean = Arc.container().instance(ReactiveWebSocketHandlerBean.class).get();\n+        return new ReactiveWebSocketHandler(bean);\n+    }\n+\n+    public Handler<RoutingContext> createHttpHandler() {\n+        ReactiveHttpHandlerBean bean = Arc.container().instance(ReactiveHttpHandlerBean.class).get();\n+        return new ReactiveHttpHandler(bean);\n+    }\n+\n+    public Handler<RoutingContext> createBodyHandler() {\n+        return BodyHandler.create();", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDQwNg==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530474406", "bodyText": "I would just close the web socket and indicate a processing failure.\nAnother approach could be to use a JSON payload wrapping the failure like https://github.com/zalando/problem", "author": "cescoffier", "createdAt": "2020-11-25T15:51:13Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveWebSocketHandlerBean.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.WebSocketStreamConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.ServerWebSocket;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming web socket messages\n+ */\n+@Singleton\n+public class ReactiveWebSocketHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveWebSocketHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<WebSocketMessage<?>>> websocketProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getWebSocketConfigs()\n+                .forEach(this::addWebSocketProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        Bundle<WebSocketMessage<?>> bundle = websocketProcessors.get(path);\n+        if (bundle != null) {\n+            MultiEmitter<? super WebSocketMessage<?>> emitter = bundle.emitter;\n+            StrictQueueSizeGuard guard = bundle.guard;\n+            event.request().toWebSocket(\n+                    websocket -> {\n+                        if (websocket.failed()) {\n+                            log.error(\"failed to connect websocket\", websocket.cause());\n+                        } else {\n+                            ServerWebSocket serverWebSocket = websocket.result();\n+                            serverWebSocket.handler(\n+                                    b -> {\n+                                        if (guard.prepareToEmit()) {\n+                                            try {\n+                                                emitter.emit(new WebSocketMessage<>(b,\n+                                                        () -> serverWebSocket.write(Buffer.buffer(\"ACK\")),\n+                                                        error -> {\n+                                                            log.error(\"Failed to process message.\", error);\n+                                                            // TODO some error message for the client? exception mapper would be best...\n+                                                            serverWebSocket.write(Buffer.buffer(\"Failed to process message\"));", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUyMDAzNA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531520034", "bodyText": "changed to closing websocket", "author": "michalszynkiewicz", "createdAt": "2020-11-27T10:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDkyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530474927", "bodyText": "There is a lot of duplicated code with the HTTP variant. We should have a look to try to reuse some code.", "author": "cescoffier", "createdAt": "2020-11-25T15:51:58Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveWebSocketHandlerBean.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.WebSocketStreamConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.ServerWebSocket;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming web socket messages\n+ */\n+@Singleton\n+public class ReactiveWebSocketHandlerBean {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUyMDI5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531520291", "bodyText": "I pulled out a common superclass for both, WDYT about how it looks now?", "author": "michalszynkiewicz", "createdAt": "2020-11-27T10:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NjU1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530476557", "bodyText": "Don't use runAsync here.\nThe handler is async, so just to:\n() -> {\n  successHandler.run();\n  return CompletableFuture.completed(null); // or something like this\n}\n\nThis also applies to the nack.", "author": "cescoffier", "createdAt": "2020-11-25T15:54:10Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/WebSocketMessage.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+class WebSocketMessage<PayloadType> implements Message<PayloadType> {\n+\n+    private final PayloadType payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+\n+    WebSocketMessage(PayloadType payload, Runnable successHandler, Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+    }\n+\n+    @Override\n+    public PayloadType getPayload() {\n+        return payload;\n+    }\n+\n+    @Override\n+    public Supplier<CompletionStage<Void>> getAck() {\n+        return () -> CompletableFuture.runAsync(successHandler);", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3OTIxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530479213", "bodyText": "Any reason to not use the mutiny API all way long?\nThe switches between the bare and mutiny API are a bit convoluted.", "author": "cescoffier", "createdAt": "2020-11-25T15:57:25Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/WebSocketSink.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.serializers.Serializer;\n+import io.quarkus.reactivemessaging.http.runtime.serializers.SerializerFactoryBase;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.groups.UniRetry;\n+import io.smallrye.mutiny.vertx.AsyncResultUni;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.WebSocket;\n+import io.vertx.core.http.WebSocketConnectOptions;\n+\n+class WebSocketSink {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDQ2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530614469", "bodyText": "I haven't found a Mutiny client for websockets", "author": "michalszynkiewicz", "createdAt": "2020-11-25T20:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3OTIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MDk4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530480983", "bodyText": "Wondering if we should not have these converters directly in Reactive Messaging.\nDefinitely useful!", "author": "cescoffier", "createdAt": "2020-11-25T15:59:41Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/converters/ObjectConverter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package io.quarkus.reactivemessaging.http.runtime.converters;\n+\n+import java.lang.reflect.Type;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import io.smallrye.reactive.messaging.MessageConverter;\n+import io.vertx.core.buffer.Buffer;\n+\n+/**\n+ * Converts message payload to objects of specified class.\n+ *\n+ * Used as the last converter\n+ */\n+@ApplicationScoped\n+public class ObjectConverter implements MessageConverter {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg0MzQ1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530843456", "bodyText": "\ud83d\udc4d  to move them there :)\nCan we have them here first and move them later? I'd really like to close this step of this work soon, it feels like a never ending story already", "author": "michalszynkiewicz", "createdAt": "2020-11-26T08:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MDk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MjYyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530482624", "bodyText": "Dto? Not a Person, Pet, or Pokemon object?\nYou're making tests boring :-D", "author": "cescoffier", "createdAt": "2020-11-25T16:01:54Z", "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/http/sink/app/Dto.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.reactivemessaging.http.sink.app;\n+\n+public class Dto {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NDAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531064024", "bodyText": "I'll do better next time ;p", "author": "michalszynkiewicz", "createdAt": "2020-11-26T14:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MjYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MzQ4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530483487", "bodyText": "Any reason to not use plain payloads here?\nString passThroughWithCustomSerializer(Buffer payload) {\nreturn payload.toString();\n}", "author": "cescoffier", "createdAt": "2020-11-25T16:03:12Z", "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/http/sink/app/HttpEmitter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.quarkus.reactivemessaging.http.sink.app;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+import org.eclipse.microprofile.reactive.messaging.Emitter;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.vertx.core.buffer.Buffer;\n+\n+@ApplicationScoped\n+public class HttpEmitter {\n+\n+    @Channel(\"my-http-sink\")\n+    Emitter<Object> emitter;\n+\n+    @Channel(\"http-sink-with-path-param\")\n+    Emitter<Object> emitterWithPathParam;\n+\n+    @Channel(\"retrying-http-sink\")\n+    Emitter<Object> retryingEmitter;\n+\n+    @Incoming(\"custom-http-source\")\n+    @Outgoing(\"custom-http-sink\")\n+    Message<String> passThroughWithCustomSerializer(Message<Buffer> message) {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NDYwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531064604", "bodyText": "no reason, it's the first time I played a bit more with reactive messaging, I was trying different things. Will switch to plain payloads for simplicity", "author": "michalszynkiewicz", "createdAt": "2020-11-26T14:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MzQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NDk1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530484955", "bodyText": "You should remove the traces", "author": "cescoffier", "createdAt": "2020-11-25T16:05:16Z", "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/websocket/sink/WebSocketSinkTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package io.quarkus.reactivemessaging.websocket.sink;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+import static org.hamcrest.Matchers.hasSize;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.reactivemessaging.utils.ToUpperCaseSerializer;\n+import io.quarkus.reactivemessaging.websocket.sink.app.WsEmitter;\n+import io.quarkus.reactivemessaging.websocket.sink.app.WsEndpoint;\n+import io.quarkus.test.QuarkusUnitTest;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+class WebSocketSinkTest {\n+    @RegisterExtension\n+    static final QuarkusUnitTest config = new QuarkusUnitTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(WsEndpoint.class, WsEmitter.class, ToUpperCaseSerializer.class))\n+            .withConfigurationResource(\"websocket-sink-test-application.properties\");\n+\n+    @Inject\n+    WsEndpoint wsEndpoint;\n+\n+    @Inject\n+    WsEmitter emitter;\n+\n+    @Test\n+    void shouldSerializeBuffer() {\n+        System.out.println(\"buffer\");", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTU2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530485567", "bodyText": "As for web socket, don't use runAsync", "author": "cescoffier", "createdAt": "2020-11-25T16:06:13Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/HttpMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Metadata;\n+\n+/**\n+ * used by http source\n+ * \n+ * @param <T> payload type\n+ */\n+class HttpMessage<T> implements Message<T> {\n+\n+    private final T payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+    private final Metadata metadata;\n+\n+    HttpMessage(T payload, IncomingHttpMetadata requestMetadata, Runnable successHandler,\n+            Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+        metadata = Metadata.of(requestMetadata);\n+    }\n+\n+    @Override\n+    public T getPayload() {\n+        return payload;\n+    }\n+\n+    @Override\n+    public Metadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public Supplier<CompletionStage<Void>> getAck() {\n+        return () -> CompletableFuture.runAsync(successHandler);", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTkwMA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530485900", "bodyText": "@kenfinnigan Should we do something around Open Telemetry tracing here?", "author": "cescoffier", "createdAt": "2020-11-25T16:06:41Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/HttpMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Metadata;\n+\n+/**\n+ * used by http source\n+ * \n+ * @param <T> payload type\n+ */\n+class HttpMessage<T> implements Message<T> {\n+\n+    private final T payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+    private final Metadata metadata;\n+\n+    HttpMessage(T payload, IncomingHttpMetadata requestMetadata, Runnable successHandler,\n+            Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+        metadata = Metadata.of(requestMetadata);", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MjY4MA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530492680", "bodyText": "Ideally yes, but we don't have OpenTelemetry in Quarkus yet. It will need to wait", "author": "kenfinnigan", "createdAt": "2020-11-25T16:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NjQ4OA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530486488", "bodyText": "Can you add an unwrap method returning the request directly?", "author": "cescoffier", "createdAt": "2020-11-25T16:07:29Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/IncomingHttpMetadata.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+/**\n+ * Metadata for Http Source. Provides a way to get headers, method and path from a http request\n+ */\n+public class IncomingHttpMetadata {\n+\n+    private final HttpMethod method;\n+    private final MultiMap headers;\n+    private final String path;\n+\n+    IncomingHttpMetadata(HttpServerRequest request) {\n+        path = request.path();\n+        headers = request.headers();\n+        method = request.method();\n+    }\n+\n+    /**\n+     * http method of the request\n+     * \n+     * @return either POST or PUT\n+     */\n+    public HttpMethod getMethod() {\n+        return method;\n+    }\n+\n+    /**\n+     * headers of the request\n+     * \n+     * @return a MultiMap of headers\n+     */\n+    public MultiMap getHeaders() {\n+        return headers;\n+    }\n+\n+    /**\n+     * path of the request\n+     * \n+     * @return path\n+     */\n+    public String getPath() {\n+        return path;\n+    }", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMzQzMg==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530633432", "bodyText": "I wouldn't use Ws. It can also mean Web Services. Same for the other classes prefixed the same way.\nI know it's test classes but it's better anyway.", "author": "gsmet", "createdAt": "2020-11-25T20:43:30Z", "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/websocket/WsClient.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package io.quarkus.reactivemessaging.websocket;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.WebSocket;\n+\n+public class WsClient {", "originalCommit": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgwMjYxNA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530802614", "bodyText": "I would go for WebSocketClient, it's clear and not that long.", "author": "cescoffier", "createdAt": "2020-11-26T06:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMzQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NjIxMg==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531066212", "bodyText": "will do", "author": "michalszynkiewicz", "createdAt": "2020-11-26T14:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMzQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ0OTk1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531449950", "bodyText": "I'll change it to store request only", "author": "michalszynkiewicz", "createdAt": "2020-11-27T08:31:54Z", "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/IncomingHttpMetadata.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+/**\n+ * Metadata for Http Source. Provides a way to get headers, method and path from a http request\n+ */\n+public class IncomingHttpMetadata {\n+\n+    private final HttpMethod method;\n+    private final MultiMap headers;\n+    private final String path;\n+    private final HttpServerRequest request;\n+\n+    IncomingHttpMetadata(HttpServerRequest request) {", "originalCommit": "b1561cd640ceb74b3f4d8c3c5e3edd8042be59ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "79f62fc0b8d3f7a26114303195e13f8ba0af246f", "url": "https://github.com/quarkusio/quarkus/commit/79f62fc0b8d3f7a26114303195e13f8ba0af246f", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-11-30T21:03:46Z", "type": "forcePushed"}, {"oid": "d04a7e159826027aeb26e0cb90c702cf993b8c67", "url": "https://github.com/quarkusio/quarkus/commit/d04a7e159826027aeb26e0cb90c702cf993b8c67", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-11-30T22:11:35Z", "type": "forcePushed"}, {"oid": "104340a145f9b1330889c2a251be76ba0bf648f6", "url": "https://github.com/quarkusio/quarkus/commit/104340a145f9b1330889c2a251be76ba0bf648f6", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-12-01T12:48:08Z", "type": "forcePushed"}, {"oid": "0f5d29fba275706ef9bc9bd1cb2f0c9ee707e5aa", "url": "https://github.com/quarkusio/quarkus/commit/0f5d29fba275706ef9bc9bd1cb2f0c9ee707e5aa", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-12-01T14:07:55Z", "type": "forcePushed"}, {"oid": "0cbe708183ce0e34a2455fc882d55f9fc073ef3f", "url": "https://github.com/quarkusio/quarkus/commit/0cbe708183ce0e34a2455fc882d55f9fc073ef3f", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-12-01T16:18:29Z", "type": "forcePushed"}, {"oid": "e464b6026684a8d6c527a2ddc7abc1ec40c42848", "url": "https://github.com/quarkusio/quarkus/commit/e464b6026684a8d6c527a2ddc7abc1ec40c42848", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-12-02T18:19:11Z", "type": "commit"}, {"oid": "e464b6026684a8d6c527a2ddc7abc1ec40c42848", "url": "https://github.com/quarkusio/quarkus/commit/e464b6026684a8d6c527a2ddc7abc1ec40c42848", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044", "committedDate": "2020-12-02T18:19:11Z", "type": "forcePushed"}]}