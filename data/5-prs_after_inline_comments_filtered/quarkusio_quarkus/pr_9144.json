{"pr_number": 9144, "pr_title": "Add SmallRye GraphQL extension", "pr_createdAt": "2020-05-07T08:04:24Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9144", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDQxNA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324414", "bodyText": "We don't do @author tags in Quarkus and rely on Git history.", "author": "gsmet", "createdAt": "2020-05-07T08:19:49Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDY1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324656", "bodyText": "Better push that as a parameter of your methods. It's better to keep track of dependencies.", "author": "gsmet", "createdAt": "2020-05-07T08:20:11Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDc4OA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324788", "bodyText": "I would make that a separate class.", "author": "gsmet", "createdAt": "2020-05-07T08:20:24Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTQ1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421325456", "bodyText": "Is this related to SmallRye Metrics, should we test the presence of it?", "author": "gsmet", "createdAt": "2020-05-07T08:21:34Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjQ5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421332496", "bodyText": "Metrics integration is not supposed to be covered by this PR yet, I am planning to add that later, so I think this is some leftover that can be removed for now", "author": "jmartisk", "createdAt": "2020-05-07T08:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MTIyOA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421351228", "bodyText": "No, I added it to load the SPI (Native mode). @jmartisk will this use another service implementation ? I can remove this, then you add it when you do the metrics ?", "author": "phillip-kruger", "createdAt": "2020-05-07T09:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzMyMA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421353320", "bodyText": "Well, yeah, this is just one part of the metrics integration - without the rest, the metrics won't work properly anyway. So yeah I'd say we can remove these six lines for now, I'll do metrics separately later and re-add this", "author": "jmartisk", "createdAt": "2020-05-07T09:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTk0OA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421325948", "bodyText": "This is being worked on by @stuartwdouglas IIUC the issue.", "author": "gsmet", "createdAt": "2020-05-07T08:22:23Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            //BuildProducer<ExtensionSslNativeSupportBuildItem> extensionSslNativeSupportProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MjMwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421352303", "bodyText": "Yes, once his changes is in I can remove this and the special QuarkusClassloadingService class", "author": "phillip-kruger", "createdAt": "2020-05-07T09:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNjI0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421326249", "bodyText": "Why would the extension need SSL? It connects to something?", "author": "gsmet", "createdAt": "2020-05-07T08:22:53Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            //BuildProducer<ExtensionSslNativeSupportBuildItem> extensionSslNativeSupportProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+        // TODO: SSL Support by default ?\n+        // extensionSslNativeSupportProducer.produce(new ExtensionSslNativeSupportBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNjUyOA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421326528", "bodyText": "This should definitely be at the top of the class.", "author": "gsmet", "createdAt": "2020-05-07T08:23:19Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            //BuildProducer<ExtensionSslNativeSupportBuildItem> extensionSslNativeSupportProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+        // TODO: SSL Support by default ?\n+        // extensionSslNativeSupportProducer.produce(new ExtensionSslNativeSupportBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    private String[] getClassesToRegisterForReflection(Schema schema) {\n+        // Unique list of classes we need to do reflection on\n+        Set<String> classes = new HashSet<>();\n+\n+        classes.addAll(getOperationClassNames(schema.getQueries()));\n+        classes.addAll(getOperationClassNames(schema.getMutations()));\n+        classes.addAll(getReferenceClassNames(schema.getTypes().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInputs().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInterfaces().values()));\n+\n+        // TODO: Introspection classes. (In native mode, the graphiQL introspection query fails. Below is not working)\n+//        classes.add(GraphQLObjectType.class.getName());\n+//        classes.add(GraphQLInputObjectType.class.getName());\n+//        classes.add(GraphQLEnumType.class.getName());\n+//        classes.add(GraphQLInputObjectField.class.getName());\n+//        classes.add(GraphQLInterfaceType.class.getName());\n+\n+        String[] arrayOfClassNames = classes.toArray(new String[] {});\n+        return arrayOfClassNames;\n+    }\n+\n+    private Set<String> getOperationClassNames(Set<Operation> operations) {\n+        Set<String> classes = new HashSet<>();\n+        for (Operation operation : operations) {\n+            classes.add(operation.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    private Set<String> getReferenceClassNames(Collection complexGraphQLTypes) {\n+        Set<String> classes = new HashSet<>();\n+        for (Object complexGraphQLType : complexGraphQLTypes) {\n+            Reference reference = Reference.class.cast(complexGraphQLType);\n+            classes.add(reference.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTA5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421329093", "bodyText": "Please put the constants at the top of the class.", "author": "gsmet", "createdAt": "2020-05-07T08:27:26Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLExecutionHandler.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.enterprise.inject.spi.CDI;\n+import javax.json.Json;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonWriter;\n+\n+import io.smallrye.graphql.execution.ExecutionService;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handler that does the execution of GraphQL Requests\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallRyeGraphQLExecutionHandler implements Handler<RoutingContext> {\n+    private static boolean allowGet = false;\n+\n+    public SmallRyeGraphQLExecutionHandler(boolean allowGet) {\n+        this.allowGet = allowGet;\n+    }\n+\n+    @Override\n+    public void handle(final RoutingContext ctx) {\n+        HttpServerRequest request = ctx.request();\n+        HttpServerResponse response = ctx.response();\n+\n+        response.headers().set(HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\");\n+\n+        switch (request.method()) {\n+            case OPTIONS:\n+                response.headers().set(HttpHeaders.ALLOW, getAllowedMethods());\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end();\n+                break;\n+            case POST:\n+                String graphqlPostRequest = ctx.getBodyAsString();\n+                String postResponse = doRequest(graphqlPostRequest);\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end(Buffer.buffer(postResponse));\n+                break;\n+            case GET:\n+                if (allowGet) {\n+                    List<String> queries = ctx.queryParam(QUERY);\n+                    if (queries != null && !queries.isEmpty()) {\n+                        String graphqlGetRequest = queries.get(0);\n+                        String getResponse = doRequest(graphqlGetRequest);\n+                        response.setStatusCode(200)\n+                                .setStatusMessage(OK)\n+                                .end(Buffer.buffer(getResponse));\n+                    } else {\n+                        response.setStatusCode(204).setStatusMessage(\"Provide a query parameter\").end();\n+                    }\n+                } else {\n+                    response.setStatusCode(405).setStatusMessage(\"GET Queries is not enabled\").end();\n+                }\n+                break;\n+            default:\n+                response.setStatusCode(405).setStatusMessage(request.method() + \" Method is not supported\").end();\n+                break;\n+        }\n+    }\n+\n+    private String getAllowedMethods() {\n+        if (allowGet) {\n+            return \"GET, POST, OPTIONS\";\n+        } else {\n+            return \"POST, OPTIONS\";\n+        }\n+    }\n+\n+    private String doRequest(final String body) {\n+        try (StringReader input = new StringReader(body);\n+                final JsonReader jsonReader = Json.createReader(input)) {\n+            JsonObject jsonInput = jsonReader.readObject();\n+            ExecutionService executionService = CDI.current().select(ExecutionService.class).get();\n+            JsonObject outputJson = executionService.execute(jsonInput);\n+            if (outputJson != null) {\n+                try (StringWriter output = new StringWriter();\n+                        final JsonWriter jsonWriter = Json.createWriter(output)) {\n+                    jsonWriter.writeObject(outputJson);\n+                    output.flush();\n+                    return output.toString();\n+                }\n+            }\n+            return null;\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static final String QUERY = \"query\";\n+    private static final String OK = \"OK\";", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTI1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421329257", "bodyText": "Let's drop useless javadoc comments.", "author": "gsmet", "createdAt": "2020-05-07T08:27:39Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLRecorder.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.util.function.Supplier;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.runtime.ShutdownContext;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.smallrye.graphql.runtime.spi.QuarkusClassloadingService;\n+import io.quarkus.vertx.http.runtime.ThreadLocalHandler;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.StaticHandler;\n+\n+/**\n+ * Recorder", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTU2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421329563", "bodyText": "This is incorrect. You probably want a BeanContainerListener.", "author": "gsmet", "createdAt": "2020-05-07T08:28:11Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLRecorder.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.util.function.Supplier;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.runtime.ShutdownContext;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.smallrye.graphql.runtime.spi.QuarkusClassloadingService;\n+import io.quarkus.vertx.http.runtime.ThreadLocalHandler;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.StaticHandler;\n+\n+/**\n+ * Recorder\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+@Recorder\n+public class SmallRyeGraphQLRecorder {\n+\n+    public void createExecutionService(Schema schema) {\n+        Arc.initialize(); // FIXME: why do I need this?", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5NjQzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421396430", "bodyText": "Thanks :)", "author": "phillip-kruger", "createdAt": "2020-05-07T10:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDA2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421330062", "bodyText": "This needs @stuartwdouglas 's attention.", "author": "gsmet", "createdAt": "2020-05-07T08:28:56Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/spi/QuarkusClassloadingService.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package io.quarkus.smallrye.graphql.runtime.spi;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import graphql.schema.PropertyDataFetcherHelper;\n+import io.smallrye.graphql.execution.Classes;\n+import io.smallrye.graphql.spi.ClassloadingService;\n+\n+/**\n+ * Quarkus specific classloading service, that allows\n+ * hot reloading to work in dev mode.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class QuarkusClassloadingService implements ClassloadingService {", "originalCommit": "95364fa8df3489d7a62b1f4789b76f07e9301837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1NTc3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421355777", "bodyText": "Yes, this is the hack until @stuartwdouglas 's fix is in. Same as open-api extension. I'll update both once the fix is in.", "author": "phillip-kruger", "createdAt": "2020-05-07T09:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MTIwMg==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422061202", "bodyText": "Can I resolve this ? As I said as soon as there is a fix I will remove the hack here and in open-api ? @gsmet  ?", "author": "phillip-kruger", "createdAt": "2020-05-08T10:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421362479", "bodyText": "Could we use org.apache.commons.io.IOUtils.toByteArray(InputStream) instead? It seems to be somewhere among the dependencies and some other extensions use it too", "author": "jmartisk", "createdAt": "2020-05-07T09:20:32Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+    \n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            LaunchModeBuildItem launchMode,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+    }\n+\n+    private String[] getClassesToRegisterForReflection(Schema schema) {\n+        // Unique list of classes we need to do reflection on\n+        Set<String> classes = new HashSet<>();\n+\n+        classes.addAll(getOperationClassNames(schema.getQueries()));\n+        classes.addAll(getOperationClassNames(schema.getMutations()));\n+        classes.addAll(getReferenceClassNames(schema.getTypes().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInputs().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInterfaces().values()));\n+\n+        String[] arrayOfClassNames = classes.toArray(new String[] {});\n+        return arrayOfClassNames;\n+    }\n+\n+    private Set<String> getOperationClassNames(Set<Operation> operations) {\n+        Set<String> classes = new HashSet<>();\n+        for (Operation operation : operations) {\n+            classes.add(operation.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    private Set<String> getReferenceClassNames(Collection complexGraphQLTypes) {\n+        Set<String> classes = new HashSet<>();\n+        for (Object complexGraphQLType : complexGraphQLTypes) {\n+            Reference reference = Reference.class.cast(complexGraphQLType);\n+            classes.add(reference.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    @BuildStep\n+    @Record(ExecutionTime.STATIC_INIT)\n+    void registerGraphQLUiServletExtension(\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<GeneratedResourceBuildItem> generatedResourceProducer,\n+            BuildProducer<NativeImageResourceBuildItem> nativeImageResourceProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            LaunchModeBuildItem launchMode,\n+            LiveReloadBuildItem liveReload,\n+            HttpRootPathBuildItem httpRootPath) throws Exception {\n+\n+        if (!quarkusConfig.enableUi) {\n+            return;\n+        }\n+        if (\"/\".equals(quarkusConfig.rootPathUi)) {\n+            throw new ConfigurationError(\n+                    \"quarkus.smallrye-graphql.root-path-ui was set to \\\"/\\\", this is not allowed as it blocks the application from serving anything else.\");\n+        }\n+\n+        String graphQLPath = httpRootPath.adjustPath(quarkusConfig.rootPath);\n+\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            CachedGraphQLUI cached = liveReload.getContextObject(CachedGraphQLUI.class);\n+            boolean extractionNeeded = cached == null;\n+\n+            if (cached != null && !cached.cachedGraphQLPath.equals(graphQLPath)) {\n+                try {\n+                    FileUtil.deleteDirectory(Paths.get(cached.cachedDirectory));\n+                } catch (IOException e) {\n+                    LOG.error(\"Failed to clean GraphQL UI temp directory on restart\", e);\n+                }\n+                extractionNeeded = true;\n+            }\n+            if (extractionNeeded) {\n+                if (cached == null) {\n+                    cached = new CachedGraphQLUI();\n+                    liveReload.setContextObject(CachedGraphQLUI.class, cached);\n+                    Runtime.getRuntime().addShutdownHook(new Thread(cached, \"GraphQL UI Shutdown Hook\"));\n+                }\n+                try {\n+                    ResolvedArtifact artifact = getGraphQLUiArtifact();\n+                    Path tempDir = Files.createTempDirectory(TEMP_DIR_PREFIX).toRealPath();\n+                    extractGraphQLUi(artifact, tempDir);\n+                    updateApiUrl(tempDir.resolve(FILE_TO_UPDATE), graphQLPath);\n+                    cached.cachedDirectory = tempDir.toAbsolutePath().toString();\n+                    cached.cachedGraphQLPath = graphQLPath;\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            Handler<RoutingContext> handler = recorder.uiHandler(cached.cachedDirectory,\n+                    httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPathUi + \"/\"));\n+        } else if (quarkusConfig.alwaysIncludeUi) {\n+            ResolvedArtifact artifact = getGraphQLUiArtifact();\n+            //we are including in a production artifact\n+            //just stick the files in the generated output\n+            //we could do this for dev mode as well but then we need to extract them every time\n+            File artifactFile = artifact.getArtifactPath().toFile();\n+            try (JarFile jarFile = new JarFile(artifactFile)) {\n+                Enumeration<JarEntry> entries = jarFile.entries();\n+\n+                while (entries.hasMoreElements()) {\n+                    JarEntry entry = entries.nextElement();\n+                    if (entry.getName().startsWith(GRAPHQL_UI_WEBJAR_PREFIX) && !entry.isDirectory()) {\n+                        try (InputStream inputStream = jarFile.getInputStream(entry)) {\n+                            String filename = entry.getName().replace(GRAPHQL_UI_WEBJAR_PREFIX + \"/\", \"\");\n+                            byte[] content = FileUtil.readFileContents(inputStream);\n+                            if (entry.getName().endsWith(FILE_TO_UPDATE)) {\n+                                content = updateApiUrl(new String(content, StandardCharsets.UTF_8), graphQLPath)\n+                                        .getBytes(StandardCharsets.UTF_8);\n+                            }\n+                            if (IGNORE_LIST.contains(filename)) {\n+                                ClassLoader classLoader = SmallryeGraphqlProcessor.class.getClassLoader();\n+                                InputStream resourceAsStream = classLoader\n+                                        .getResourceAsStream(OWN_MEDIA_FOLDER + filename);\n+                                content = streamToByte(resourceAsStream);\n+                            }\n+\n+                            String fileName = GRAPHQL_UI_FINAL_DESTINATION + \"/\" + filename;\n+\n+                            generatedResourceProducer\n+                                    .produce(new GeneratedResourceBuildItem(fileName, content));\n+\n+                            nativeImageResourceProducer\n+                                    .produce(new NativeImageResourceBuildItem(fileName));\n+\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Handler<RoutingContext> handler = recorder\n+                    .uiHandler(GRAPHQL_UI_FINAL_DESTINATION, httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+        }\n+    }\n+\n+    private byte[] streamToByte(InputStream is) throws IOException {", "originalCommit": "1ff8048310e426e6220807cb3e94d20c7c3566e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2ODA3OA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421368078", "bodyText": "Happy to use that, did not want to introduce an new dependency, but if it's there it makes sense. Let me know.", "author": "phillip-kruger", "createdAt": "2020-05-07T09:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421373315", "bodyText": "Please check before doing that that the dependency is not there by pure luck (i.e. brought by another one that is not really related to what we do and where it could go away)", "author": "gsmet", "createdAt": "2020-05-07T09:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMzE0NA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421403144", "bodyText": "Seems like it's available:\nGroupId: commons-io\nArtifactId: commons-io\nVersion: 2.6\nType: jar Scope: compile\nVia: maven-shared-utils\nVia: maven-embedder\nVia: quarkus-bootstrap-core\nVia: quarkus-core-deployment\nShould I go ahead and use that ? @gsmet ?", "author": "phillip-kruger", "createdAt": "2020-05-07T10:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0OTQ3OA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421549478", "bodyText": "Given it's coming incidentally from Maven, I wouldn't use it.\nBetter add what you need to io.quarkus.deployment.util.IoUtil.", "author": "gsmet", "createdAt": "2020-05-07T14:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMzQ2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421713463", "bodyText": "No need to add anything, the method was there already. Doing a fix now", "author": "phillip-kruger", "createdAt": "2020-05-07T18:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MTEyNg==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421371126", "bodyText": "I am getting a compile error now, seems you forgot to commit this class after extracting it", "author": "jmartisk", "createdAt": "2020-05-07T09:34:23Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;", "originalCommit": "9116b680e0a81cefb277d3d4d2b82af8e1631ba5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4ODQxOA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421388418", "bodyText": "Sorry. (But it build on my machine :))\nI'll commit now with the other Arc fix", "author": "phillip-kruger", "createdAt": "2020-05-07T10:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5NjY5MA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421396690", "bodyText": "@jmartisk please check now", "author": "phillip-kruger", "createdAt": "2020-05-07T10:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MTEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDIxNw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422740217", "bodyText": "What is the purpose of this? Class.forName(GraphQLProducer.class.getName()) is equivalent to GraphQLProducer.class.", "author": "stuartwdouglas", "createdAt": "2020-05-11T01:52:46Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,373 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+    private static final Logger log = Logger.getLogger(SmallryeGraphqlProcessor.class);\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            BeanContainerBuildItem beanContainer,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        try {\n+            Class<GraphQLProducer> beanClass = (Class<GraphQLProducer>) Class", "originalCommit": "0092cb643cee66fbde04d9bedf9b48e99439f28b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDk3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422740975", "bodyText": "Are you sure you don't need ReflectiveHierachyBuildItem here? ReflectiveClassBuildItem just registers the type, it won't register superclases, and it won't register types used by methods/fields (so a complex return type from a method would not be registered).\nI am not sure exactly how these classes are used, so maybe this is fine, but just something to be aware of.", "author": "stuartwdouglas", "createdAt": "2020-05-11T01:56:26Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,373 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+    private static final Logger log = Logger.getLogger(SmallryeGraphqlProcessor.class);\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            BeanContainerBuildItem beanContainer,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        try {\n+            Class<GraphQLProducer> beanClass = (Class<GraphQLProducer>) Class\n+                    .forName(GraphQLProducer.class.getName());\n+            recorder.createExecutionService(beanContainer.getValue(), beanClass, schema);\n+        } catch (ClassNotFoundException ex) {\n+            log.warn(\"Failed to load GraphQLProducer\", ex);\n+        }\n+\n+        // Make sure the complex object from the application can work in native mode\n+        reflectiveClassProducer", "originalCommit": "0092cb643cee66fbde04d9bedf9b48e99439f28b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4MDMwNg==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422880306", "bodyText": "Cool, thanks. Did not know about this.", "author": "phillip-kruger", "createdAt": "2020-05-11T08:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MjE2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422742166", "bodyText": "This should be in a try with resources block.", "author": "stuartwdouglas", "createdAt": "2020-05-11T02:01:59Z", "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,373 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+    private static final Logger log = Logger.getLogger(SmallryeGraphqlProcessor.class);\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            BeanContainerBuildItem beanContainer,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        try {\n+            Class<GraphQLProducer> beanClass = (Class<GraphQLProducer>) Class\n+                    .forName(GraphQLProducer.class.getName());\n+            recorder.createExecutionService(beanContainer.getValue(), beanClass, schema);\n+        } catch (ClassNotFoundException ex) {\n+            log.warn(\"Failed to load GraphQLProducer\", ex);\n+        }\n+\n+        // Make sure the complex object from the application can work in native mode\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            LaunchModeBuildItem launchMode,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+    }\n+\n+    private String[] getClassesToRegisterForReflection(Schema schema) {\n+        // Unique list of classes we need to do reflection on\n+        Set<String> classes = new HashSet<>();\n+\n+        classes.addAll(getOperationClassNames(schema.getQueries()));\n+        classes.addAll(getOperationClassNames(schema.getMutations()));\n+        classes.addAll(getReferenceClassNames(schema.getTypes().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInputs().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInterfaces().values()));\n+\n+        String[] arrayOfClassNames = classes.toArray(new String[] {});\n+        return arrayOfClassNames;\n+    }\n+\n+    private Set<String> getOperationClassNames(Set<Operation> operations) {\n+        Set<String> classes = new HashSet<>();\n+        for (Operation operation : operations) {\n+            classes.add(operation.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    private Set<String> getReferenceClassNames(Collection complexGraphQLTypes) {\n+        Set<String> classes = new HashSet<>();\n+        for (Object complexGraphQLType : complexGraphQLTypes) {\n+            Reference reference = Reference.class.cast(complexGraphQLType);\n+            classes.add(reference.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    @BuildStep\n+    @Record(ExecutionTime.STATIC_INIT)\n+    void registerGraphQLUiServletExtension(\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<GeneratedResourceBuildItem> generatedResourceProducer,\n+            BuildProducer<NativeImageResourceBuildItem> nativeImageResourceProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            LaunchModeBuildItem launchMode,\n+            LiveReloadBuildItem liveReload,\n+            HttpRootPathBuildItem httpRootPath) throws Exception {\n+\n+        if (!quarkusConfig.enableUi) {\n+            return;\n+        }\n+        if (\"/\".equals(quarkusConfig.rootPathUi)) {\n+            throw new ConfigurationError(\n+                    \"quarkus.smallrye-graphql.root-path-ui was set to \\\"/\\\", this is not allowed as it blocks the application from serving anything else.\");\n+        }\n+\n+        String graphQLPath = httpRootPath.adjustPath(quarkusConfig.rootPath);\n+\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            CachedGraphQLUI cached = liveReload.getContextObject(CachedGraphQLUI.class);\n+            boolean extractionNeeded = cached == null;\n+\n+            if (cached != null && !cached.cachedGraphQLPath.equals(graphQLPath)) {\n+                try {\n+                    FileUtil.deleteDirectory(Paths.get(cached.cachedDirectory));\n+                } catch (IOException e) {\n+                    LOG.error(\"Failed to clean GraphQL UI temp directory on restart\", e);\n+                }\n+                extractionNeeded = true;\n+            }\n+            if (extractionNeeded) {\n+                if (cached == null) {\n+                    cached = new CachedGraphQLUI();\n+                    liveReload.setContextObject(CachedGraphQLUI.class, cached);\n+                    Runtime.getRuntime().addShutdownHook(new Thread(cached, \"GraphQL UI Shutdown Hook\"));\n+                }\n+                try {\n+                    ResolvedArtifact artifact = getGraphQLUiArtifact();\n+                    Path tempDir = Files.createTempDirectory(TEMP_DIR_PREFIX).toRealPath();\n+                    extractGraphQLUi(artifact, tempDir);\n+                    updateApiUrl(tempDir.resolve(FILE_TO_UPDATE), graphQLPath);\n+                    cached.cachedDirectory = tempDir.toAbsolutePath().toString();\n+                    cached.cachedGraphQLPath = graphQLPath;\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            Handler<RoutingContext> handler = recorder.uiHandler(cached.cachedDirectory,\n+                    httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPathUi + \"/\"));\n+        } else if (quarkusConfig.alwaysIncludeUi) {\n+            ResolvedArtifact artifact = getGraphQLUiArtifact();\n+            //we are including in a production artifact\n+            //just stick the files in the generated output\n+            //we could do this for dev mode as well but then we need to extract them every time\n+            File artifactFile = artifact.getArtifactPath().toFile();\n+            try (JarFile jarFile = new JarFile(artifactFile)) {\n+                Enumeration<JarEntry> entries = jarFile.entries();\n+\n+                while (entries.hasMoreElements()) {\n+                    JarEntry entry = entries.nextElement();\n+                    if (entry.getName().startsWith(GRAPHQL_UI_WEBJAR_PREFIX) && !entry.isDirectory()) {\n+                        try (InputStream inputStream = jarFile.getInputStream(entry)) {\n+                            String filename = entry.getName().replace(GRAPHQL_UI_WEBJAR_PREFIX + \"/\", \"\");\n+                            byte[] content = FileUtil.readFileContents(inputStream);\n+                            if (entry.getName().endsWith(FILE_TO_UPDATE)) {\n+                                content = updateApiUrl(new String(content, StandardCharsets.UTF_8), graphQLPath)\n+                                        .getBytes(StandardCharsets.UTF_8);\n+                            }\n+                            if (IGNORE_LIST.contains(filename)) {\n+                                ClassLoader classLoader = SmallryeGraphqlProcessor.class.getClassLoader();\n+                                InputStream resourceAsStream = classLoader\n+                                        .getResourceAsStream(OWN_MEDIA_FOLDER + filename);\n+                                content = IoUtil.readBytes(resourceAsStream);\n+                            }\n+\n+                            String fileName = GRAPHQL_UI_FINAL_DESTINATION + \"/\" + filename;\n+\n+                            generatedResourceProducer\n+                                    .produce(new GeneratedResourceBuildItem(fileName, content));\n+\n+                            nativeImageResourceProducer\n+                                    .produce(new NativeImageResourceBuildItem(fileName));\n+\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Handler<RoutingContext> handler = recorder\n+                    .uiHandler(GRAPHQL_UI_FINAL_DESTINATION, httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+        }\n+    }\n+\n+    private ResolvedArtifact getGraphQLUiArtifact() {\n+        ClassPathArtifactResolver resolver = new ClassPathArtifactResolver(SmallryeGraphqlProcessor.class.getClassLoader());\n+        return resolver.getArtifact(GRAPHQL_UI_WEBJAR_GROUP_ID, GRAPHQL_UI_WEBJAR_ARTIFACT_ID, null);\n+    }\n+\n+    private void extractGraphQLUi(ResolvedArtifact artifact, Path resourceDir) throws IOException {\n+        File artifactFile = artifact.getArtifactPath().toFile();\n+        try (JarFile jarFile = new JarFile(artifactFile)) {\n+            Enumeration<JarEntry> entries = jarFile.entries();\n+\n+            while (entries.hasMoreElements()) {\n+                JarEntry entry = entries.nextElement();\n+                if (entry.getName().startsWith(GRAPHQL_UI_WEBJAR_PREFIX) && !entry.isDirectory()) {\n+                    try (InputStream inputStream = jarFile.getInputStream(entry)) {\n+                        String filename = entry.getName().replace(GRAPHQL_UI_WEBJAR_PREFIX + \"/\", \"\");\n+                        if (!IGNORE_LIST.contains(filename)) {\n+                            Files.copy(inputStream, resourceDir.resolve(filename));\n+                        }\n+                    }\n+                }\n+            }\n+            // Now add our own logo and favicon\n+            ClassLoader classLoader = SmallryeGraphqlProcessor.class.getClassLoader();\n+            for (String ownMedia : IGNORE_LIST) {\n+                InputStream logo = classLoader.getResourceAsStream(OWN_MEDIA_FOLDER + ownMedia);", "originalCommit": "0092cb643cee66fbde04d9bedf9b48e99439f28b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODI0NA==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422748244", "bodyText": "I don't think you need to bother with the status messages, they are not supported with HTTP/2 and are generally considered to have been a bad idea. We don't want to encourage their use as they are basically deprecated.", "author": "stuartwdouglas", "createdAt": "2020-05-11T02:31:31Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLExecutionHandler.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.enterprise.inject.spi.CDI;\n+import javax.json.Json;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonWriter;\n+\n+import io.smallrye.graphql.execution.ExecutionService;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handler that does the execution of GraphQL Requests\n+ */\n+public class SmallRyeGraphQLExecutionHandler implements Handler<RoutingContext> {\n+    private static boolean allowGet = false;\n+    private static final String QUERY = \"query\";\n+    private static final String OK = \"OK\";\n+\n+    public SmallRyeGraphQLExecutionHandler(boolean allowGet) {\n+        this.allowGet = allowGet;\n+    }\n+\n+    @Override\n+    public void handle(final RoutingContext ctx) {\n+        HttpServerRequest request = ctx.request();\n+        HttpServerResponse response = ctx.response();\n+\n+        response.headers().set(HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\");\n+\n+        switch (request.method()) {\n+            case OPTIONS:\n+                response.headers().set(HttpHeaders.ALLOW, getAllowedMethods());\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end();\n+                break;\n+            case POST:\n+                String graphqlPostRequest = ctx.getBodyAsString();\n+                String postResponse = doRequest(graphqlPostRequest);\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end(Buffer.buffer(postResponse));\n+                break;\n+            case GET:\n+                if (allowGet) {\n+                    List<String> queries = ctx.queryParam(QUERY);\n+                    if (queries != null && !queries.isEmpty()) {\n+                        String graphqlGetRequest = queries.get(0);\n+                        String getResponse = doRequest(graphqlGetRequest);\n+                        response.setStatusCode(200)\n+                                .setStatusMessage(OK)\n+                                .end(Buffer.buffer(getResponse));\n+                    } else {\n+                        response.setStatusCode(204).setStatusMessage(\"Provide a query parameter\").end();", "originalCommit": "0092cb643cee66fbde04d9bedf9b48e99439f28b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODQ2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422748462", "bodyText": "You probably want to cache this in a volatile variable. CDI.current().select() is relatively expensive.", "author": "stuartwdouglas", "createdAt": "2020-05-11T02:32:43Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLExecutionHandler.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.enterprise.inject.spi.CDI;\n+import javax.json.Json;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonWriter;\n+\n+import io.smallrye.graphql.execution.ExecutionService;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handler that does the execution of GraphQL Requests\n+ */\n+public class SmallRyeGraphQLExecutionHandler implements Handler<RoutingContext> {\n+    private static boolean allowGet = false;\n+    private static final String QUERY = \"query\";\n+    private static final String OK = \"OK\";\n+\n+    public SmallRyeGraphQLExecutionHandler(boolean allowGet) {\n+        this.allowGet = allowGet;\n+    }\n+\n+    @Override\n+    public void handle(final RoutingContext ctx) {\n+        HttpServerRequest request = ctx.request();\n+        HttpServerResponse response = ctx.response();\n+\n+        response.headers().set(HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\");\n+\n+        switch (request.method()) {\n+            case OPTIONS:\n+                response.headers().set(HttpHeaders.ALLOW, getAllowedMethods());\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end();\n+                break;\n+            case POST:\n+                String graphqlPostRequest = ctx.getBodyAsString();\n+                String postResponse = doRequest(graphqlPostRequest);\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end(Buffer.buffer(postResponse));\n+                break;\n+            case GET:\n+                if (allowGet) {\n+                    List<String> queries = ctx.queryParam(QUERY);\n+                    if (queries != null && !queries.isEmpty()) {\n+                        String graphqlGetRequest = queries.get(0);\n+                        String getResponse = doRequest(graphqlGetRequest);\n+                        response.setStatusCode(200)\n+                                .setStatusMessage(OK)\n+                                .end(Buffer.buffer(getResponse));\n+                    } else {\n+                        response.setStatusCode(204).setStatusMessage(\"Provide a query parameter\").end();\n+                    }\n+                } else {\n+                    response.setStatusCode(405).setStatusMessage(\"GET Queries is not enabled\").end();\n+                }\n+                break;\n+            default:\n+                response.setStatusCode(405).setStatusMessage(request.method() + \" Method is not supported\").end();\n+                break;\n+        }\n+    }\n+\n+    private String getAllowedMethods() {\n+        if (allowGet) {\n+            return \"GET, POST, OPTIONS\";\n+        } else {\n+            return \"POST, OPTIONS\";\n+        }\n+    }\n+\n+    private String doRequest(final String body) {\n+        try (StringReader input = new StringReader(body);\n+                final JsonReader jsonReader = Json.createReader(input)) {\n+            JsonObject jsonInput = jsonReader.readObject();\n+            ExecutionService executionService = CDI.current().select(ExecutionService.class).get();", "originalCommit": "0092cb643cee66fbde04d9bedf9b48e99439f28b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgzMjA5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422832091", "bodyText": "In fact, it does not have to be a volatile field but a final field initialized in the constructor. Also Arc.container().instance() is a bit more effective.", "author": "mkouba", "createdAt": "2020-05-11T07:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4MDY2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422880661", "bodyText": "Did a lazy load with volatile variable.", "author": "phillip-kruger", "createdAt": "2020-05-11T08:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0OTM0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422749343", "bodyText": "Why do you pass the bean class in like this, when it is hard coded anyway? Why not just use GraphQLProducer.class?", "author": "stuartwdouglas", "createdAt": "2020-05-11T02:36:50Z", "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLRecorder.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.util.function.Supplier;\n+\n+import io.quarkus.arc.runtime.BeanContainer;\n+import io.quarkus.runtime.ShutdownContext;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.smallrye.graphql.runtime.spi.QuarkusClassloadingService;\n+import io.quarkus.vertx.http.runtime.ThreadLocalHandler;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.StaticHandler;\n+\n+@Recorder\n+public class SmallRyeGraphQLRecorder {\n+\n+    public void createExecutionService(BeanContainer beanContainer, Class<GraphQLProducer> beanClass, Schema schema) {\n+        GraphQLProducer graphQLProducer = beanContainer.instance(beanClass);", "originalCommit": "0092cb643cee66fbde04d9bedf9b48e99439f28b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c1d024dc2102d342a52b4b27f052836dcdc96be", "url": "https://github.com/quarkusio/quarkus/commit/5c1d024dc2102d342a52b4b27f052836dcdc96be", "message": "Adding SmallRye GraphQL Extension\n\nSigned-off-by: Phillip Kruger <phillip.kruger@gmail.com>", "committedDate": "2020-05-14T13:20:37Z", "type": "commit"}, {"oid": "e8b2b258f15ad6ca9be9fba2994cae7422b79f05", "url": "https://github.com/quarkusio/quarkus/commit/e8b2b258f15ad6ca9be9fba2994cae7422b79f05", "message": "Add GraphQL to the native workflow and reorganize things a bit\n\nAlso the Vault native tests weren't running at all. I hope they are not\nfailing...", "committedDate": "2020-05-14T13:21:46Z", "type": "commit"}]}