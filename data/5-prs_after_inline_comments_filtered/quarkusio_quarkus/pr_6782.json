{"pr_number": 6782, "pr_title": "Allow multiple caching annotations on a single method", "pr_createdAt": "2020-01-24T23:30:04Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6782", "timeline": [{"oid": "d821a6b75de5efd5ffe49b514db0b988f7dbf1de", "url": "https://github.com/quarkusio/quarkus/commit/d821a6b75de5efd5ffe49b514db0b988f7dbf1de", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-24T23:41:25Z", "type": "forcePushed"}, {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e", "url": "https://github.com/quarkusio/quarkus/commit/172dd52342871e41f617273ef48b409e4e0fda9e", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-25T00:01:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2MzQ1MA==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372063450", "bodyText": "Name it List to match the same pattern used in other places (including Bean validation)", "author": "gastaldi", "createdAt": "2020-01-28T21:19:30Z", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheInvalidate.java", "diffHunk": "@@ -1,31 +1,43 @@\n package io.quarkus.cache;\n \n import java.lang.annotation.ElementType;\n+import java.lang.annotation.Repeatable;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import javax.enterprise.util.Nonbinding;\n \n+import io.quarkus.cache.CacheInvalidate.CacheInvalidateContainer;\n+\n /**\n  * When a method annotated with {@link CacheInvalidate} is invoked, Quarkus will compute a cache key and use it to try to\n  * remove an existing entry from the cache. If the method has one or more arguments, the key computation is done from all the\n  * method arguments if none of them is annotated with {@link CacheKey}, or all the arguments annotated with {@link CacheKey}\n  * otherwise. This annotation can also be used on a method with no arguments, a default key derived from the cache name is\n  * generated in that case. If the key does not identify any cache entry, nothing will happen.\n  * <p>\n- * You can only use one of the cache operations (and this annotation) on a given method: {@link CacheResult},\n- * {@link CacheInvalidate} or {@link CacheInvalidateAll}.\n+ * This annotation can be combined with multiple other caching annotations on a single method. Caching operations will always\n+ * be executed in the same order: {@link CacheInvalidateAll} first, then {@link CacheInvalidate} and finally\n+ * {@link CacheResult}.\n  * <p>\n  * The underlying caching provider can be chosen and configured in the Quarkus {@link application.properties} file.\n  */\n-@Retention(value = RetentionPolicy.RUNTIME)\n+@Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.METHOD)\n+@Repeatable(CacheInvalidateContainer.class)\n public @interface CacheInvalidate {\n \n     /**\n      * The name of the cache.\n      */\n     @Nonbinding\n     String cacheName();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface CacheInvalidateContainer {", "originalCommit": "172dd52342871e41f617273ef48b409e4e0fda9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2OTM1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372069351", "bodyText": "Done, thanks for reviewing this!", "author": "gwenneg", "createdAt": "2020-01-28T21:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2MzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2MzY2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372063667", "bodyText": "Same here", "author": "gastaldi", "createdAt": "2020-01-28T21:20:00Z", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheInvalidateAll.java", "diffHunk": "@@ -1,27 +1,39 @@\n package io.quarkus.cache;\n \n import java.lang.annotation.ElementType;\n+import java.lang.annotation.Repeatable;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import javax.enterprise.util.Nonbinding;\n \n+import io.quarkus.cache.CacheInvalidateAll.CacheInvalidateAllContainer;\n+\n /**\n  * When a method annotated with {@link CacheInvalidateAll} is invoked, Quarkus will remove all entries from the cache.\n  * <p>\n- * You can only use one of the cache operations (and this annotation) on a given method: {@link CacheResult},\n- * {@link CacheInvalidate} or {@link CacheInvalidateAll}.\n+ * This annotation can be combined with multiple other caching annotations on a single method. Caching operations will always\n+ * be executed in the same order: {@link CacheInvalidateAll} first, then {@link CacheInvalidate} and finally\n+ * {@link CacheResult}.\n  * <p>\n  * The underlying caching provider can be chosen and configured in the Quarkus {@link application.properties} file.\n  */\n-@Retention(value = RetentionPolicy.RUNTIME)\n+@Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.METHOD)\n+@Repeatable(CacheInvalidateAllContainer.class)\n public @interface CacheInvalidateAll {\n \n     /**\n      * The name of the cache.\n      */\n     @Nonbinding\n     String cacheName();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface CacheInvalidateAllContainer {", "originalCommit": "172dd52342871e41f617273ef48b409e4e0fda9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce", "url": "https://github.com/quarkusio/quarkus/commit/464b091cb5c03845b496287f72a007f921a4b1ce", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-28T21:30:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372668407", "bodyText": "I wonder how efficient this code will be considering it will call declaredAnnotations() (which is a synchronized method) 3 times.", "author": "gsmet", "createdAt": "2020-01-29T22:33:16Z", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheInterceptor.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package io.quarkus.cache.runtime;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.cache.CacheInvalidate;\n+import io.quarkus.cache.CacheInvalidateAll;\n+import io.quarkus.cache.CacheKey;\n+import io.quarkus.cache.CacheResult;\n+import io.quarkus.cache.runtime.caffeine.CaffeineCache;\n+\n+@CacheInterceptorBinding\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class CacheInterceptor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(CacheInterceptor.class);\n+\n+    @Inject\n+    CacheRepository cacheRepository;\n+\n+    @AroundInvoke\n+    public Object intercept(InvocationContext context) throws Exception {\n+        Method method = context.getMethod();\n+\n+        for (CacheInvalidateAll cacheInvalidateAll : method.getDeclaredAnnotationsByType(CacheInvalidateAll.class)) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating all entries from cache [%s]\", cacheInvalidateAll.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidateAll.cacheName());\n+            cache.invalidateAll();\n+        }\n+\n+        for (CacheInvalidate cacheInvalidate : method.getDeclaredAnnotationsByType(CacheInvalidate.class)) {\n+            Object key = getCacheKey(context, cacheInvalidate.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating entry with key [%s] from cache [%s]\", key, cacheInvalidate.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidate.cacheName());\n+            cache.invalidate(key);\n+        }\n+\n+        CacheResult cacheResult = method.getDeclaredAnnotation(CacheResult.class);\n+        if (cacheResult != null) {\n+            Object key = getCacheKey(context, cacheResult.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cacheResult.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheResult.cacheName());\n+            return cache.get(key, () -> context.proceed(), cacheResult.lockTimeout());\n+        }", "originalCommit": "464b091cb5c03845b496287f72a007f921a4b1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc1MDk1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372750952", "bodyText": "This synchronized block should only be called once since the declared annotations will already be parsed when the 2nd and 3rd calls happen, but that's still a very interesting question. Thanks for taking a look at this!", "author": "gwenneg", "createdAt": "2020-01-30T04:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4ODE5OA==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372788198", "bodyText": "FYI, I tried to do things at build time using annotations transformation originally, but there's a limitation in the current Quarkus annotation transformation logic that blocked me (I already had a discussion with @mkouba about it). I'd be happy to remove all reflection calls if that's possible :)", "author": "gwenneg", "createdAt": "2020-01-30T07:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwODAyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372808029", "bodyText": "So I'm a bit disappointed in the sense that witht he build time knowledge, we should be able to add an interceptor with the right state. We should know the annotations effectively present and even the cache name state and it should be burnt into the interceptor instance. I don't know how much of this is doable with the CDI model but that would be a nice improvement. Is that the conversation you had with @mkouba @gwenneg ?", "author": "emmanuelbernard", "createdAt": "2020-01-30T08:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwODY0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372808642", "bodyText": "But as a temp measure, it looks like the synchronize call will only happen the first time the service class is requested its annotations. We could do this in a static_init block to do it at \"startup time\" if we feel its a problem to pay the cost lazily.", "author": "emmanuelbernard", "createdAt": "2020-01-30T08:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NjA2OA==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372856068", "bodyText": "it looks like the synchronize call will only happen the first time the service class is requested its annotations\n\nThat's not what I see as AFAICS declaredAnnotations() will always be called when calling getDeclaredAnnotationsByType(). It will be very fast after the first invocation but you still have the synchronized part. Unless I miss something obvious?", "author": "gsmet", "createdAt": "2020-01-30T10:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372668645", "bodyText": "Same here, I'm pretty sure it will end up calling declaredAnnotations() again.", "author": "gsmet", "createdAt": "2020-01-29T22:33:52Z", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheInterceptor.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package io.quarkus.cache.runtime;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.cache.CacheInvalidate;\n+import io.quarkus.cache.CacheInvalidateAll;\n+import io.quarkus.cache.CacheKey;\n+import io.quarkus.cache.CacheResult;\n+import io.quarkus.cache.runtime.caffeine.CaffeineCache;\n+\n+@CacheInterceptorBinding\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class CacheInterceptor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(CacheInterceptor.class);\n+\n+    @Inject\n+    CacheRepository cacheRepository;\n+\n+    @AroundInvoke\n+    public Object intercept(InvocationContext context) throws Exception {\n+        Method method = context.getMethod();\n+\n+        for (CacheInvalidateAll cacheInvalidateAll : method.getDeclaredAnnotationsByType(CacheInvalidateAll.class)) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating all entries from cache [%s]\", cacheInvalidateAll.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidateAll.cacheName());\n+            cache.invalidateAll();\n+        }\n+\n+        for (CacheInvalidate cacheInvalidate : method.getDeclaredAnnotationsByType(CacheInvalidate.class)) {\n+            Object key = getCacheKey(context, cacheInvalidate.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating entry with key [%s] from cache [%s]\", key, cacheInvalidate.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidate.cacheName());\n+            cache.invalidate(key);\n+        }\n+\n+        CacheResult cacheResult = method.getDeclaredAnnotation(CacheResult.class);\n+        if (cacheResult != null) {\n+            Object key = getCacheKey(context, cacheResult.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cacheResult.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheResult.cacheName());\n+            return cache.get(key, () -> context.proceed(), cacheResult.lockTimeout());\n+        }\n+\n+        return context.proceed();\n+    }\n+\n+    private Object getCacheKey(InvocationContext context, String cacheName) {\n+        // If the method doesn't have any parameter, then a unique default key is generated and used.\n+        if (context.getParameters().length == 0) {\n+            return CacheKeyBuilder.buildDefault(cacheName);\n+        } else {\n+            List<Object> cacheKeyElements = new ArrayList<>();\n+            // If at least one of the method parameters is annotated with @CacheKey, then the key is composed of all\n+            // @CacheKey-annotated parameters.\n+            for (int i = 0; i < context.getParameters().length; i++) {\n+                if (context.getMethod().getParameters()[i].isAnnotationPresent(CacheKey.class)) {", "originalCommit": "464b091cb5c03845b496287f72a007f921a4b1ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d8dedfd57a58dcc7c6605d5afd0f7a0de86db97b", "url": "https://github.com/quarkusio/quarkus/commit/d8dedfd57a58dcc7c6605d5afd0f7a0de86db97b", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-30T03:50:02Z", "type": "forcePushed"}, {"oid": "859c603171fe27074a45cdeda17a047f7accfd43", "url": "https://github.com/quarkusio/quarkus/commit/859c603171fe27074a45cdeda17a047f7accfd43", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-31T22:50:01Z", "type": "forcePushed"}, {"oid": "f7fd77cc19de98463864468e4dbb245e417029a0", "url": "https://github.com/quarkusio/quarkus/commit/f7fd77cc19de98463864468e4dbb245e417029a0", "message": "Allow bytecode generation of short array annotations parameters", "committedDate": "2020-01-31T23:02:18Z", "type": "commit"}, {"oid": "d9fb15af9e154f12acb3cd3129270dc5520fd6bb", "url": "https://github.com/quarkusio/quarkus/commit/d9fb15af9e154f12acb3cd3129270dc5520fd6bb", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-31T23:04:04Z", "type": "forcePushed"}, {"oid": "4646a3d5c3777121d0d4028fb69f03ee8152f86e", "url": "https://github.com/quarkusio/quarkus/commit/4646a3d5c3777121d0d4028fb69f03ee8152f86e", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-01-31T23:30:21Z", "type": "forcePushed"}, {"oid": "1cfc35cbb53eefb88a3df1a9f5aadf9484e99407", "url": "https://github.com/quarkusio/quarkus/commit/1cfc35cbb53eefb88a3df1a9f5aadf9484e99407", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-02-01T20:40:06Z", "type": "forcePushed"}, {"oid": "911f40fd404f10d32654b1e5def7370de80e4bcf", "url": "https://github.com/quarkusio/quarkus/commit/911f40fd404f10d32654b1e5def7370de80e4bcf", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-02-03T22:04:52Z", "type": "commit"}, {"oid": "911f40fd404f10d32654b1e5def7370de80e4bcf", "url": "https://github.com/quarkusio/quarkus/commit/911f40fd404f10d32654b1e5def7370de80e4bcf", "message": "Allow multiple caching annotations on a single method", "committedDate": "2020-02-03T22:04:52Z", "type": "forcePushed"}]}