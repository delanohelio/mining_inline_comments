{"pr_number": 6691, "pr_title": "spring-data-jpa: support custom return type for @Query annotation", "pr_createdAt": "2020-01-21T15:13:08Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6691", "timeline": [{"oid": "d9d5b25646c866746d58c3bc1967c5223bc2a9b5", "url": "https://github.com/quarkusio/quarkus/commit/d9d5b25646c866746d58c3bc1967c5223bc2a9b5", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-21T15:13:56Z", "type": "forcePushed"}, {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "url": "https://github.com/quarkusio/quarkus/commit/8a4b2eacf046d658f5c2e7da8a905316fb792095", "message": "spring-data-jpa: deployment unit tests\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-22T03:52:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5NTkzMg==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369395932", "bodyText": "How about this get changed to Objects.requireNonNull?", "author": "geoand", "createdAt": "2020-01-22T06:59:31Z", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +60,54 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {\n+        List<BookRepository.BookCountByYear> list = bookRepository.findAllByPublicationYear();\n+\n+        // #6205 - Make sure elements in list have been properly cast to the target object type.\n+        // If the type is wrong (Object array), this will throw a ClassNotFoundException\n+        BookRepository.BookCountByYear first = list.get(0);\n+        assert (first != null);", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5ODAzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369398039", "bodyText": "How about we move generatedClasses right after generatedBeans instead of next to additionalBeans. It will make things a tad more consistent I believe.", "author": "geoand", "createdAt": "2020-01-22T07:08:33Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java", "diffHunk": "@@ -58,7 +61,8 @@ void build(CombinedIndexBuildItem index,\n                 indexIndex);\n \n         removeNoRepositoryBeanClasses(interfacesExtendingCrudRepository);\n-        implementCrudRepositories(generatedBeans, additionalBeans, interfacesExtendingCrudRepository, indexIndex);\n+        implementCrudRepositories(generatedBeans, additionalBeans, generatedClasses,", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5ODc5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369398799", "bodyText": "The IDE is telling warning me about Redundant group nesting for (([\\w\\.]+))", "author": "geoand", "createdAt": "2020-01-22T07:11:52Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -2,21 +2,28 @@\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import org.jboss.jandex.ClassInfo;\n import org.jboss.jandex.DotName;\n import org.jboss.jandex.IndexView;\n import org.jboss.jandex.MethodInfo;\n import org.jboss.jandex.Type;\n \n+import io.quarkus.deployment.util.HashUtil;\n import io.quarkus.gizmo.MethodDescriptor;\n import io.quarkus.spring.data.deployment.DotNames;\n \n public final class GenerationUtil {\n \n+    private static final Pattern SELECT_CLAUSE = Pattern.compile(\"select\\\\s+(.+)\\\\s+from\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern FIELD_ALIAS = Pattern.compile(\"\\\\s+[as|AS]+\\\\s+(([\\\\w\\\\.]+))\");", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTYwMA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369399600", "bodyText": "I think this method is unused", "author": "geoand", "createdAt": "2020-01-22T07:14:56Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369399718", "bodyText": "Perhaps this and the other newly added methods should be moved to a different utility class that is more aptly named?", "author": "geoand", "createdAt": "2020-01-22T07:15:28Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {\n+        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n+    }\n+\n+    static DotName createImplDotName(DotName ifaceName) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Njg0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369476845", "bodyText": "This only seems to be used in one class, so could also stay as a private method there.", "author": "gytis", "createdAt": "2020-01-22T10:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNjYyMw==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369616623", "bodyText": "Moved to private methods re: other feedback from @gytis", "author": "ebullient", "createdAt": "2020-01-22T15:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401061", "bodyText": "What happens if it's not an interface?\nIn other places we do have code that can deal with this situation (by instantiating a JavaBean for example), but does Spring Data support that?", "author": "geoand", "createdAt": "2020-01-22T07:20:32Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -218,6 +229,32 @@ public void add(ClassCreator classCreator, FieldDescriptor entityClassFieldDescr\n                         }\n                     }\n \n+                    // Find the type of data used in the result\n+                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    Type resultType = verifyQueryResultType(method.returnType());\n+                    DotName customResultTypeName = resultType.name();\n+\n+                    if (customResultTypeName.equals(entityClassInfo.name())\n+                            || customResultTypeName.equals(DotNames.OBJECT)) {\n+                        // Result is using standard entity or Object result type \n+                        customResultTypeName = null;\n+                    } else {\n+                        // The result is using a custom type.\n+                        List<String> fieldNames = GenerationUtil.getFieldNames(queryString);\n+                        if (fieldNames.isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Custom Query annotations must specify field aliases when used with a custom type. \"\n+                                            + \"Offending query string is \\\"\" + queryString + \"\\\" on method \" + methodName\n+                                            + \" of Repository \" + repositoryName);\n+                        }\n+\n+                        // If the custom type is an interface, we may need to generate the implementation\n+                        ClassInfo resultClassInfo = index.getClassByName(customResultTypeName);\n+                        if (Modifier.isInterface(resultClassInfo.flags())) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3Mjc0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369572747", "bodyText": "I don't know that Spring supports it, I can test. I'll also see if the newInstance works, though I imagine we'll also miss the field ordering.", "author": "ebullient", "createdAt": "2020-01-22T13:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MjM5MA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371242390", "bodyText": "I throw an exception here. I could check to ensure the fields exist, but the code that attempts to convert from one type to the other depends on a method in the generated impl.", "author": "ebullient", "createdAt": "2020-01-27T13:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NzAzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371247039", "bodyText": "Looks good", "author": "geoand", "createdAt": "2020-01-27T13:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTM3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401376", "bodyText": "It seems like this is unused", "author": "geoand", "createdAt": "2020-01-22T07:21:34Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -31,13 +36,18 @@\n \n public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n \n+    private static final Logger log = Logger.getLogger(CustomQueryMethodsAdder.class.getName());", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MDIyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369570225", "bodyText": "Woops! Yes. I had plans to use it..", "author": "ebullient", "createdAt": "2020-01-22T13:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTc3MA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401770", "bodyText": "for each loop perhaps would be nicer?", "author": "geoand", "createdAt": "2020-01-22T07:23:05Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MDUzNg==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369570536", "bodyText": "I can go to a foreach loop now, yes. Remember that thing where I was dependent on order? That's from then. ;) I'll fix", "author": "ebullient", "createdAt": "2020-01-22T13:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369402074", "bodyText": "I think we also need to be checking for default methods and skip over those", "author": "geoand", "createdAt": "2020-01-22T07:24:07Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyNzA3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370627078", "bodyText": "I've changed it a bit to only look for getters .. Given the impl has to be generated, it can't do/won't build anything else. I will follow-up and ask what is allowed, now that I know what question to ask. ;)", "author": "ebullient", "createdAt": "2020-01-24T13:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyODU1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370628557", "bodyText": "Sounds good", "author": "geoand", "createdAt": "2020-01-24T13:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369405666", "bodyText": "Although this does do what it's intended to do, I suspect however that it will be problematic when the same Class is returned from multiple repository methods that don't use the same ordering for fields.\nIn you test you have:\n    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")\n    List<BookCountByYear> findAllByPublicationYear();\n\nWhat happens if I do this:\n    @Query(value = \"SELECT COUNT(*) as count, publicationYear as publicationYear FROM Book GROUP BY publicationYear\")\n    List<BookCountByYear> findAllByPublicationYear2();\n\nI actually did try this and it failed :(", "author": "geoand", "createdAt": "2020-01-22T07:37:10Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+\n+                    String getterName = method.name();\n+                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+                    DotName returnTypeName = method.returnType().name();\n+                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+\n+                    if (!fieldNames.contains(propertyName)) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n+                    }\n+\n+                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                            .getFieldDescriptor();\n+                    fields.put(propertyName, field);\n+\n+                    // create getter (based on the interface)\n+                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                        getter.setModifiers(Modifier.PUBLIC);\n+                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n+                    }\n+                }\n+\n+                // Generate a static 'convert' method, to convert Object[] to field values\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNzA0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369407046", "bodyText": "What I think you'll need to do is take into account the fieldNames in the convert method by adding it as a parameter and then doing some magic to work out the proper order", "author": "geoand", "createdAt": "2020-01-22T07:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NDUxMA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369574510", "bodyText": "I think I'd have to mark the query uniquely, and include that in a separate convert method. The order of the columns is significant, so while those have the same custom return type, it is probably safer to treat as two separate implementations. .. maybe. I will have to see if I still have the field order available when calling convert later.", "author": "ebullient", "createdAt": "2020-01-22T14:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Mjc5NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369472794", "bodyText": "Content of this block could be a private method e.g. generateInterfaceImplementation(...)", "author": "gytis", "createdAt": "2020-01-22T10:14:41Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzcyNA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369473724", "bodyText": "Same for further blocks: generateMethod, generateField, generateConverter etc.. I think it might improve readability.", "author": "gytis", "createdAt": "2020-01-22T10:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Mjc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369480958", "bodyText": "I don't know how it's done in Spring Data, but why can't field name without alias be treated as is? Now publicationYear as publicationYear seems redundant.", "author": "gytis", "createdAt": "2020-01-22T10:30:45Z", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "diffHunk": "@@ -22,4 +23,14 @@\n     boolean existsBookByPublicationYearBetween(Integer start, Integer end);\n \n     Optional<Book> findByPublicationYear(Integer year);\n+\n+    // issue 6205\n+    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NTY0NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369575644", "bodyText": "I can try using the original name if it is otherwise missing. Will see where that gets me", "author": "ebullient", "createdAt": "2020-01-22T14:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzYzNg==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369577636", "bodyText": "Yeah I agree with @gytis . From an implementation perspective it shouldn't be any harder (except probably for a more complex regex)", "author": "geoand", "createdAt": "2020-01-22T14:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNzM0OA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369617348", "bodyText": "agree", "author": "ebullient", "createdAt": "2020-01-22T15:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}], "type": "inlineReview"}, {"oid": "199754ce688b7e5d604185725d9fa12954da954b", "url": "https://github.com/quarkusio/quarkus/commit/199754ce688b7e5d604185725d9fa12954da954b", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-23T21:59:41Z", "type": "forcePushed"}, {"oid": "34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5", "url": "https://github.com/quarkusio/quarkus/commit/34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-23T23:36:15Z", "type": "forcePushed"}, {"oid": "78c2767d8440f23a01399b9a31bfaff360fb2389", "url": "https://github.com/quarkusio/quarkus/commit/78c2767d8440f23a01399b9a31bfaff360fb2389", "message": "Ensure that generated custom query interface implementations are registered for reflection", "committedDate": "2020-01-26T18:31:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371623574", "bodyText": "I am also thinking that the tests should include another custom type as well, just to be sure nothing weird gets tripped", "author": "geoand", "createdAt": "2020-01-28T06:10:15Z", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +59,33 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {", "originalCommit": "78c2767d8440f23a01399b9a31bfaff360fb2389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwMTE5NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371801194", "bodyText": "Will add another. Give me a few. Will use at least one different attribute type. I'm afraid my brain fails at anything useful for a Join query.", "author": "ebullient", "createdAt": "2020-01-28T13:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNDc0NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371804744", "bodyText": "\ud83d\udc4d", "author": "geoand", "createdAt": "2020-01-28T13:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA=="}], "type": "inlineReview"}, {"oid": "97585564a701a507e3efb6682accca1fb9e72251", "url": "https://github.com/quarkusio/quarkus/commit/97585564a701a507e3efb6682accca1fb9e72251", "message": "additional test, review comments\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-28T13:56:54Z", "type": "forcePushed"}, {"oid": "0088903773d108318aba817f5a075b6f9692ccf5", "url": "https://github.com/quarkusio/quarkus/commit/0088903773d108318aba817f5a075b6f9692ccf5", "message": "additional test, review comments\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-29T01:53:06Z", "type": "forcePushed"}, {"oid": "1b2a212f5727590c7c44189662bbc6de3c27a409", "url": "https://github.com/quarkusio/quarkus/commit/1b2a212f5727590c7c44189662bbc6de3c27a409", "message": "Ensure that generated custom query interface implementations are registered for reflection", "committedDate": "2020-01-29T13:32:39Z", "type": "forcePushed"}, {"oid": "a91295622ce9c99b550f9cf409ffb44904e97703", "url": "https://github.com/quarkusio/quarkus/commit/a91295622ce9c99b550f9cf409ffb44904e97703", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-30T06:20:54Z", "type": "commit"}, {"oid": "d0ea1b0eb80477ccaf23cb2156fb5ad3ac5d82a1", "url": "https://github.com/quarkusio/quarkus/commit/d0ea1b0eb80477ccaf23cb2156fb5ad3ac5d82a1", "message": "Ensure that generated custom query interface implementations are registered for reflection", "committedDate": "2020-01-30T06:20:54Z", "type": "commit"}, {"oid": "524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "url": "https://github.com/quarkusio/quarkus/commit/524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "message": "Explicitly include resources in Spring Data QuarkusUnitTest", "committedDate": "2020-01-30T06:31:02Z", "type": "commit"}, {"oid": "524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "url": "https://github.com/quarkusio/quarkus/commit/524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "message": "Explicitly include resources in Spring Data QuarkusUnitTest", "committedDate": "2020-01-30T06:31:02Z", "type": "forcePushed"}]}