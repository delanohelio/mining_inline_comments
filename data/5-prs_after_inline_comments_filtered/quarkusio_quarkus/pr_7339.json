{"pr_number": 7339, "pr_title": "refactor: Kubernetes extension now uses `quarkus.`", "pr_createdAt": "2020-02-21T16:40:32Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7339", "timeline": [{"oid": "3f2da4b4877e26c01885c5325553cfdd2cff06cf", "url": "https://github.com/quarkusio/quarkus/commit/3f2da4b4877e26c01885c5325553cfdd2cff06cf", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-22T23:17:18Z", "type": "forcePushed"}, {"oid": "2bdd4672c6204cd0eafdb715193b44f56e2ec279", "url": "https://github.com/quarkusio/quarkus/commit/2bdd4672c6204cd0eafdb715193b44f56e2ec279", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-22T23:18:54Z", "type": "forcePushed"}, {"oid": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "url": "https://github.com/quarkusio/quarkus/commit/f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-23T00:46:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwODc3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383008772", "bodyText": "Please remove the start imports, we don't use them in the repo", "author": "geoand", "createdAt": "2020-02-23T14:29:33Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -56,6 +67,8 @@\n import io.quarkus.deployment.builditem.GeneratedFileSystemResourceBuildItem;\n import io.quarkus.deployment.pkg.PackageConfig;\n import io.quarkus.deployment.pkg.builditem.OutputTargetBuildItem;\n+import io.quarkus.kubernetes.deployment.config.*;", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwODkyOA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383008928", "bodyText": "With the references to ALLOWED_GENERATORS now gone, I think the field is no longer used.", "author": "geoand", "createdAt": "2020-02-23T14:31:37Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -104,35 +120,24 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n             throw new RuntimeException(\"Unable to setup environment for generating Kubernetes resources\", e);\n         }\n \n-        Config config = ConfigProvider.getConfig();\n-        List<String> deploymentTargets = Arrays\n-                .stream(config.getOptionalValue(DEPLOYMENT_TARGET, String.class)\n-                        .orElse(KUBERNETES).split(\",\"))\n-                .map(String::trim)\n-                .map(String::toLowerCase)\n-                .collect(Collectors.toList());\n+        Map<String, Object> config = KubernetesConfigUtil.toMap();\n+        config.entrySet().forEach(e -> System.out.println(e.getKey() + \"=\" + e.getValue()));\n \n-        Map<String, Object> configAsMap = StreamSupport.stream(config.getPropertyNames().spliterator(), false)\n-                .filter(k -> ALLOWED_GENERATORS.contains(generatorName(k)))", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwODk0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383008941", "bodyText": "I think this is no longer used either", "author": "geoand", "createdAt": "2020-02-23T14:31:54Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -104,35 +120,24 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n             throw new RuntimeException(\"Unable to setup environment for generating Kubernetes resources\", e);\n         }\n \n-        Config config = ConfigProvider.getConfig();\n-        List<String> deploymentTargets = Arrays\n-                .stream(config.getOptionalValue(DEPLOYMENT_TARGET, String.class)\n-                        .orElse(KUBERNETES).split(\",\"))\n-                .map(String::trim)\n-                .map(String::toLowerCase)\n-                .collect(Collectors.toList());\n+        Map<String, Object> config = KubernetesConfigUtil.toMap();\n+        config.entrySet().forEach(e -> System.out.println(e.getKey() + \"=\" + e.getValue()));\n \n-        Map<String, Object> configAsMap = StreamSupport.stream(config.getPropertyNames().spliterator(), false)\n-                .filter(k -> ALLOWED_GENERATORS.contains(generatorName(k)))\n-                .collect(Collectors.toMap(k -> PROPERTY_PREFIX + k, k -> config.getValue(k, String.class)));\n+        Set<String> deploymentTargets = new HashSet<>();\n+        deploymentTargets.addAll(KubernetesConfigUtil.getDeploymentTargets(config));\n+        deploymentTargets.addAll(kubernetesConfig.getDeploymentTarget().stream().map(Enum::name).map(String::toLowerCase)\n+                .collect(Collectors.toList()));\n \n         // this is a hack to get kubernetes.registry working because currently it's not supported as is in Dekorate\n-        Optional<String> dockerRegistry = IMAGE_GENERATORS.stream()", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwODk4MA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383008980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n          \n          \n            \n                //Most of quarkus prefixed properties are handled directly by the config items (KubernetesConfig, OpenshiftConfig, KnativeConfig)", "author": "geoand", "createdAt": "2020-02-23T14:32:45Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTA0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009049", "bodyText": "I suggest to use <> when creating the HashSet to suppress warnings about using raw types", "author": "geoand", "createdAt": "2020-02-23T14:33:39Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n+    //We just need group, name & version parsed here, as we don't have decorators for these (low level properties).\n+    private static final Set<String> QUARKUS_PREFIX_WHITELIST = new HashSet(Arrays.asList(\"group\", \"name\", \"version\"));\n+\n+    private static final Set<String> ALLOWED_GENERATORS = new HashSet(", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTA5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009092", "bodyText": "I don't think this is used anywhere", "author": "geoand", "createdAt": "2020-02-23T14:34:10Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n+    //We just need group, name & version parsed here, as we don't have decorators for these (low level properties).\n+    private static final Set<String> QUARKUS_PREFIX_WHITELIST = new HashSet(Arrays.asList(\"group\", \"name\", \"version\"));\n+\n+    private static final Set<String> ALLOWED_GENERATORS = new HashSet(\n+            Arrays.asList(\"kubernetes\", \"openshift\", \"knative\", \"docker\", \"s2i\"));\n+    private static final Set<String> IMAGE_GENERATORS = new HashSet(Arrays.asList(\"docker\", \"s2i\"));\n+\n+    public static List<String> getDeploymentTargets() {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTEyNA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009124", "bodyText": "p -> p != null could be Objects::nonNull, same for the methods below", "author": "geoand", "createdAt": "2020-02-23T14:34:47Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n+    //We just need group, name & version parsed here, as we don't have decorators for these (low level properties).\n+    private static final Set<String> QUARKUS_PREFIX_WHITELIST = new HashSet(Arrays.asList(\"group\", \"name\", \"version\"));\n+\n+    private static final Set<String> ALLOWED_GENERATORS = new HashSet(\n+            Arrays.asList(\"kubernetes\", \"openshift\", \"knative\", \"docker\", \"s2i\"));\n+    private static final Set<String> IMAGE_GENERATORS = new HashSet(Arrays.asList(\"docker\", \"s2i\"));\n+\n+    public static List<String> getDeploymentTargets() {\n+        return getDeploymentTargets(toMap());\n+    }\n+\n+    public static List<String> getDeploymentTargets(Map<String, Object> map) {\n+        return Arrays.stream(map.getOrDefault(DEKORATE_PREFIX + DEPLOYMENT_TARGET, KUBERNETES).toString().split(\",\"))\n+                .map(String::trim)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+    }\n+\n+    public static Optional<String> getDockerRegistry(Map<String, Object> map) {\n+        return IMAGE_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".registry\")).filter(p -> p != null)", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTE4NA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009184", "bodyText": "dekorate -> Dekorate", "author": "geoand", "createdAt": "2020-02-23T14:35:42Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n+    //We just need group, name & version parsed here, as we don't have decorators for these (low level properties).\n+    private static final Set<String> QUARKUS_PREFIX_WHITELIST = new HashSet(Arrays.asList(\"group\", \"name\", \"version\"));\n+\n+    private static final Set<String> ALLOWED_GENERATORS = new HashSet(\n+            Arrays.asList(\"kubernetes\", \"openshift\", \"knative\", \"docker\", \"s2i\"));\n+    private static final Set<String> IMAGE_GENERATORS = new HashSet(Arrays.asList(\"docker\", \"s2i\"));\n+\n+    public static List<String> getDeploymentTargets() {\n+        return getDeploymentTargets(toMap());\n+    }\n+\n+    public static List<String> getDeploymentTargets(Map<String, Object> map) {\n+        return Arrays.stream(map.getOrDefault(DEKORATE_PREFIX + DEPLOYMENT_TARGET, KUBERNETES).toString().split(\",\"))\n+                .map(String::trim)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+    }\n+\n+    public static Optional<String> getDockerRegistry(Map<String, Object> map) {\n+        return IMAGE_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".registry\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    public static Optional<String> getGroup(Map<String, Object> map) {\n+        return ALLOWED_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".group\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    public static Optional<String> getName(Map<String, Object> map) {\n+        return ALLOWED_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".name\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    /*\n+     * Collects configuration properties for Kubernetes. Reads all properties and\n+     * matches properties that match known dekorate generators. These properties may", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTI5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009299", "bodyText": "UnPrefixed -> unPrefixed", "author": "geoand", "createdAt": "2020-02-23T14:36:47Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n+    //We just need group, name & version parsed here, as we don't have decorators for these (low level properties).\n+    private static final Set<String> QUARKUS_PREFIX_WHITELIST = new HashSet(Arrays.asList(\"group\", \"name\", \"version\"));\n+\n+    private static final Set<String> ALLOWED_GENERATORS = new HashSet(\n+            Arrays.asList(\"kubernetes\", \"openshift\", \"knative\", \"docker\", \"s2i\"));\n+    private static final Set<String> IMAGE_GENERATORS = new HashSet(Arrays.asList(\"docker\", \"s2i\"));\n+\n+    public static List<String> getDeploymentTargets() {\n+        return getDeploymentTargets(toMap());\n+    }\n+\n+    public static List<String> getDeploymentTargets(Map<String, Object> map) {\n+        return Arrays.stream(map.getOrDefault(DEKORATE_PREFIX + DEPLOYMENT_TARGET, KUBERNETES).toString().split(\",\"))\n+                .map(String::trim)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+    }\n+\n+    public static Optional<String> getDockerRegistry(Map<String, Object> map) {\n+        return IMAGE_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".registry\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    public static Optional<String> getGroup(Map<String, Object> map) {\n+        return ALLOWED_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".group\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    public static Optional<String> getName(Map<String, Object> map) {\n+        return ALLOWED_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".name\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    /*\n+     * Collects configuration properties for Kubernetes. Reads all properties and\n+     * matches properties that match known dekorate generators. These properties may\n+     * or may not be prefixed with `quarkus.` though the prefixed ones take\n+     * precedence.\n+     *\n+     * @return A map containing the properties.\n+     */\n+    public static Map<String, Object> toMap() {\n+        Config config = ConfigProvider.getConfig();\n+        Map<String, Object> result = new HashMap<>();\n+\n+        Map<String, Object> quarkusPrefixed = StreamSupport.stream(config.getPropertyNames().spliterator(), false)\n+                .filter(s -> s.startsWith(QUARKUS_PREFIX))\n+                .map(s -> s.replaceFirst(QUARKUS_PREFIX, \"\"))\n+                .filter(k -> ALLOWED_GENERATORS.contains(generatorName(k)))\n+                .filter(k -> QUARKUS_PREFIX_WHITELIST.contains(propertyName(k)))\n+                .filter(k -> config.getOptionalValue(QUARKUS_PREFIX + k, String.class).isPresent())\n+                .collect(Collectors.toMap(k -> DEKORATE_PREFIX + k,\n+                        k -> config.getValue(QUARKUS_PREFIX + k, String.class)));\n+\n+        Map<String, Object> UnPrefixed = StreamSupport.stream(config.getPropertyNames().spliterator(), false)", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTMyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009325", "bodyText": "I don't think this is being used", "author": "geoand", "createdAt": "2020-02-23T14:37:26Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfigUtil.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import static io.quarkus.kubernetes.deployment.Constants.*;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.utils.Strings;\n+\n+public class KubernetesConfigUtil {\n+\n+    private static final String DEKORATE_PREFIX = \"dekorate.\";\n+    private static final String QUARKUS_PREFIX = \"quarkus.\";\n+\n+    //Most of quarkus prefixed properties are handling directly by the config items (KubenretesConfig, OpenshiftConfig, KnativeConfig)\n+    //We just need group, name & version parsed here, as we don't have decorators for these (low level properties).\n+    private static final Set<String> QUARKUS_PREFIX_WHITELIST = new HashSet(Arrays.asList(\"group\", \"name\", \"version\"));\n+\n+    private static final Set<String> ALLOWED_GENERATORS = new HashSet(\n+            Arrays.asList(\"kubernetes\", \"openshift\", \"knative\", \"docker\", \"s2i\"));\n+    private static final Set<String> IMAGE_GENERATORS = new HashSet(Arrays.asList(\"docker\", \"s2i\"));\n+\n+    public static List<String> getDeploymentTargets() {\n+        return getDeploymentTargets(toMap());\n+    }\n+\n+    public static List<String> getDeploymentTargets(Map<String, Object> map) {\n+        return Arrays.stream(map.getOrDefault(DEKORATE_PREFIX + DEPLOYMENT_TARGET, KUBERNETES).toString().split(\",\"))\n+                .map(String::trim)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+    }\n+\n+    public static Optional<String> getDockerRegistry(Map<String, Object> map) {\n+        return IMAGE_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".registry\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    public static Optional<String> getGroup(Map<String, Object> map) {\n+        return ALLOWED_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".group\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    public static Optional<String> getName(Map<String, Object> map) {\n+        return ALLOWED_GENERATORS.stream().map(g -> map.get(DEKORATE_PREFIX + g + \".name\")).filter(p -> p != null)\n+                .map(String::valueOf).findFirst();\n+    }\n+\n+    /*\n+     * Collects configuration properties for Kubernetes. Reads all properties and\n+     * matches properties that match known dekorate generators. These properties may\n+     * or may not be prefixed with `quarkus.` though the prefixed ones take\n+     * precedence.\n+     *\n+     * @return A map containing the properties.\n+     */\n+    public static Map<String, Object> toMap() {\n+        Config config = ConfigProvider.getConfig();\n+        Map<String, Object> result = new HashMap<>();\n+\n+        Map<String, Object> quarkusPrefixed = StreamSupport.stream(config.getPropertyNames().spliterator(), false)\n+                .filter(s -> s.startsWith(QUARKUS_PREFIX))\n+                .map(s -> s.replaceFirst(QUARKUS_PREFIX, \"\"))\n+                .filter(k -> ALLOWED_GENERATORS.contains(generatorName(k)))\n+                .filter(k -> QUARKUS_PREFIX_WHITELIST.contains(propertyName(k)))\n+                .filter(k -> config.getOptionalValue(QUARKUS_PREFIX + k, String.class).isPresent())\n+                .collect(Collectors.toMap(k -> DEKORATE_PREFIX + k,\n+                        k -> config.getValue(QUARKUS_PREFIX + k, String.class)));\n+\n+        Map<String, Object> UnPrefixed = StreamSupport.stream(config.getPropertyNames().spliterator(), false)\n+                .filter(k -> ALLOWED_GENERATORS.contains(generatorName(k)))\n+                .filter(k -> config.getOptionalValue(k, String.class).isPresent())\n+                .collect(Collectors.toMap(k -> DEKORATE_PREFIX + k, k -> config.getValue(k, String.class)));\n+\n+        result.putAll(UnPrefixed);\n+        result.putAll(quarkusPrefixed);\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the name of the generators that can handle the specified key.\n+     *\n+     * @param key The key.\n+     * @return The generator name or null if the key format is unexpected.\n+     */\n+    private static String generatorName(String key) {\n+        if (Strings.isNullOrEmpty(key) || !key.contains(\".\")) {\n+            return null;\n+        }\n+        return key.substring(0, key.indexOf(\".\"));\n+    }\n+\n+    /**\n+     * Returns the name of the property stripped of all prefixes.\n+     *\n+     * @param key The key.\n+     * @return The property name.\n+     */\n+    private static String propertyName(String key) {\n+        if (Strings.isNullOrEmpty(key) || !key.contains(\".\")) {\n+            return key;\n+        }\n+        return key.substring(key.lastIndexOf(\".\") + 1);\n+    }\n+\n+    private <T> T[] toArray(List<T> list) {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTQ4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    config.getPorts().entrySet().stream().forEach(e -> session.configurators().add(new AddPort(PortConverter.convert(e))));\n          \n          \n            \n                    config.getPorts().entrySet().forEach(e -> session.configurators().add(new AddPort(PortConverter.convert(e))));", "author": "geoand", "createdAt": "2020-02-23T14:39:23Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -195,9 +206,120 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n         featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.KUBERNETES));\n     }\n \n+    /**\n+     * Apply global changes\n+     *\n+     * @param session The session to apply the changes\n+     * @param config The {@link KubernetesConfig} instance\n+     */\n+    private void applyGlobalConfig(Session session, KubernetesConfig config) {\n+        //Ports\n+        config.getPorts().entrySet().stream().forEach(e -> session.configurators().add(new AddPort(PortConverter.convert(e))));", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTY0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009646", "bodyText": "Could be:\nconfig.getLabels().forEach((key, value) -> session.resources().decorate(target, new AddLabelDecorator(new Label(key, value))));\n\nSimilar for the maps below", "author": "geoand", "createdAt": "2020-02-23T14:41:22Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -195,9 +206,120 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n         featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.KUBERNETES));\n     }\n \n+    /**\n+     * Apply global changes\n+     *\n+     * @param session The session to apply the changes\n+     * @param config The {@link KubernetesConfig} instance\n+     */\n+    private void applyGlobalConfig(Session session, KubernetesConfig config) {\n+        //Ports\n+        config.getPorts().entrySet().stream().forEach(e -> session.configurators().add(new AddPort(PortConverter.convert(e))));\n+    }\n+\n+    /**\n+     * Apply changes to the target resource group\n+     *\n+     * @param session The session to apply the changes\n+     * @param target The deployment target (e.g. kubernetes, openshift, knative)\n+     * @param name The name of the resource to accept the configuration\n+     * @param config The {@link PlatformConfiguration} instance\n+     */\n+    private void applyConfig(Session session, String target, String name, PlatformConfiguration config) {\n+        //Labels\n+        config.getLabels().entrySet().stream().forEach(e -> {\n+            session.resources().decorate(target, new AddLabelDecorator(new Label(e.getKey(), e.getValue())));\n+        });", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTczNA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383009734", "bodyText": "What's the deal with this one?", "author": "geoand", "createdAt": "2020-02-23T14:42:00Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -195,9 +206,120 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n         featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.KUBERNETES));\n     }\n \n+    /**\n+     * Apply global changes\n+     *\n+     * @param session The session to apply the changes\n+     * @param config The {@link KubernetesConfig} instance\n+     */\n+    private void applyGlobalConfig(Session session, KubernetesConfig config) {\n+        //Ports\n+        config.getPorts().entrySet().stream().forEach(e -> session.configurators().add(new AddPort(PortConverter.convert(e))));\n+    }\n+\n+    /**\n+     * Apply changes to the target resource group\n+     *\n+     * @param session The session to apply the changes\n+     * @param target The deployment target (e.g. kubernetes, openshift, knative)\n+     * @param name The name of the resource to accept the configuration\n+     * @param config The {@link PlatformConfiguration} instance\n+     */\n+    private void applyConfig(Session session, String target, String name, PlatformConfiguration config) {\n+        //Labels\n+        config.getLabels().entrySet().stream().forEach(e -> {\n+            session.resources().decorate(target, new AddLabelDecorator(new Label(e.getKey(), e.getValue())));\n+        });\n+\n+        //Annotations\n+        config.getAnnotations().entrySet().stream().forEach(e -> {\n+            session.resources().decorate(target, new AddAnnotationDecorator(new Annotation(e.getKey(), e.getValue())));\n+        });\n+\n+        //EnvVars\n+        config.getEnvVars().entrySet().stream().forEach(e -> {\n+            session.resources().decorate(target, new AddEnvVarDecorator(EnvConverter.convert(e)));\n+        });\n+\n+        config.getWorkingDir().ifPresent(w -> {\n+            session.resources().decorate(target, new ApplyWorkingDirDecorator(name, DEPLOY));\n+        });\n+\n+        config.getCommand().ifPresent(c -> {\n+            session.resources().decorate(target,\n+                    new ApplyCommandDecorator(name, c.toArray(new String[c.size()])));\n+        });\n+\n+        config.getArguments().ifPresent(a -> {\n+            session.resources().decorate(target, new ApplyArgsDecorator(name, a.toArray(new String[a.size()])));\n+        });\n+\n+        config.getServiceAccount().ifPresent(s -> {\n+            session.resources().decorate(target, new ApplyServiceAccountNamedDecorator(name, s));\n+        });\n+\n+        //Image Pull\n+        session.resources().decorate(new ApplyImagePullPolicyDecorator(config.getImagePullPolicy()));\n+        config.getImagePullSecrets().ifPresent(l -> {\n+            l.forEach(s -> session.resources().decorate(target, new AddImagePullSecretDecorator(name, s)));\n+        });\n+\n+        //Probes\n+        config.getLivenessProbe().ifPresent(p -> {\n+            session.resources().decorate(target, new AddLivenessProbeDecorator(name, ProbeConverter.convert(p)));\n+        });\n+\n+        config.getReadinessProbe().ifPresent(p -> {\n+            session.resources().decorate(target,\n+                    new AddReadinessProbeDecorator(name, ProbeConverter.convert(p)));\n+        });\n+\n+        // Mounts and Volumes\n+        config.getMounts().entrySet().forEach(e -> {\n+            session.resources().decorate(target, new AddMountDecorator(MountConverter.convert(e)));\n+        });\n+\n+        config.getSecretVolumes().entrySet().forEach(e -> {\n+            session.resources().decorate(target, new AddSecretVolumeDecorator(SecretVolumeConverter.convert(e)));\n+        });\n+\n+        config.getConfigMapVolumes().entrySet().forEach(e -> {\n+            session.resources().decorate(target, new AddConfigMapVolumeDecorator(ConfigMapVolumeConverter.convert(e)));\n+        });\n+\n+        //config.getGitRepoVolumes().entrySet().forEach(e -> {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMTAxMw==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383031013", "bodyText": "There is no such decorator. So, until its implemented we cant use it.", "author": "iocanel", "createdAt": "2020-02-23T19:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMTAyMg==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383031022", "bodyText": "I'll remove it.", "author": "iocanel", "createdAt": "2020-02-23T19:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMTYwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383031609", "bodyText": "Thanks", "author": "geoand", "createdAt": "2020-02-23T19:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAwOTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDI1OA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383010258", "bodyText": "I assume this are the converters that you would like to autogenerate in a future iteration?", "author": "geoand", "createdAt": "2020-02-23T14:46:10Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/convert/AwsElasticBlockStoreVolumeConverter.java", "diffHunk": "@@ -0,0 +1,24 @@\n+\n+package io.quarkus.kubernetes.deployment.convert;\n+\n+import java.util.Map;\n+\n+import io.dekorate.kubernetes.config.AwsElasticBlockStoreVolume;\n+import io.dekorate.kubernetes.config.AwsElasticBlockStoreVolumeBuilder;\n+import io.quarkus.kubernetes.deployment.config.AwsElasticBlockStoreVolumeConfig;\n+\n+public class AwsElasticBlockStoreVolumeConverter {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMTI1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383031257", "bodyText": "Yeah", "author": "iocanel", "createdAt": "2020-02-23T19:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDM4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383010382", "bodyText": "This can be private, right? Same for all the other converters", "author": "geoand", "createdAt": "2020-02-23T14:47:01Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/convert/AwsElasticBlockStoreVolumeConverter.java", "diffHunk": "@@ -0,0 +1,24 @@\n+\n+package io.quarkus.kubernetes.deployment.convert;\n+\n+import java.util.Map;\n+\n+import io.dekorate.kubernetes.config.AwsElasticBlockStoreVolume;\n+import io.dekorate.kubernetes.config.AwsElasticBlockStoreVolumeBuilder;\n+import io.quarkus.kubernetes.deployment.config.AwsElasticBlockStoreVolumeConfig;\n+\n+public class AwsElasticBlockStoreVolumeConverter {\n+\n+    public static AwsElasticBlockStoreVolume convert(Map.Entry<String, AwsElasticBlockStoreVolumeConfig> e) {\n+        return convert(e.getValue()).withVolumeName(e.getKey()).build();\n+    }\n+\n+    public static AwsElasticBlockStoreVolumeBuilder convert(AwsElasticBlockStoreVolumeConfig c) {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDY4NA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383010684", "bodyText": "I don't think we want to keep the Bazel reference here since it doesn't apply to the Quarkus case", "author": "geoand", "createdAt": "2020-02-23T14:49:20Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/KubernetesConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.kubernetes.deployment.DeploymentTarget;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class KubernetesConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDcyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383010725", "bodyText": "Does this stuff apply? I don't think it does", "author": "geoand", "createdAt": "2020-02-23T14:49:44Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/KubernetesConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.kubernetes.deployment.DeploymentTarget;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class KubernetesConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the\n+     * name. Else if the system property app.name is present it will be used. Else\n+     * find the project root folder and use its name (root folder detection is done", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDc1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383010754", "bodyText": "Rules seem to be missing :)", "author": "geoand", "createdAt": "2020-02-23T14:50:00Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/KubernetesConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.kubernetes.deployment.DeploymentTarget;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class KubernetesConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the\n+     * name. Else if the system property app.name is present it will be used. Else\n+     * find the project root folder and use its name (root folder detection is done\n+     * by moving to the parent folder until .git is found).\n+     */\n+    @ConfigItem\n+    Optional<String> name;\n+\n+    /**\n+     * The version of the application. This value be used for things like: - The\n+     * docker image tag. If no value specified it will attempt to determine the name\n+     * using the following rules:", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMDgzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383010839", "bodyText": "Let's use Persistent Volume Claim in the Javadoc instead of PVC", "author": "geoand", "createdAt": "2020-02-23T14:50:41Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/KubernetesConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.kubernetes.deployment.DeploymentTarget;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class KubernetesConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the\n+     * name. Else if the system property app.name is present it will be used. Else\n+     * find the project root folder and use its name (root folder detection is done\n+     * by moving to the parent folder until .git is found).\n+     */\n+    @ConfigItem\n+    Optional<String> name;\n+\n+    /**\n+     * The version of the application. This value be used for things like: - The\n+     * docker image tag. If no value specified it will attempt to determine the name\n+     * using the following rules:\n+     */\n+    @ConfigItem\n+    Optional<String> version;\n+\n+    /**\n+     * Custom labels to add to all resources\n+     */\n+    @ConfigItem\n+    Map<String, String> labels;\n+\n+    /**\n+     * Custom annotations to add to all resources\n+     */\n+    @ConfigItem\n+    Map<String, String> annotations;\n+\n+    /**\n+     * Environment variables to add to all containers\n+     */\n+    @ConfigItem\n+    Map<String, EnvConfig> envVars;\n+\n+    /**\n+     * Working directory\n+     */\n+    @ConfigItem\n+    Optional<String> workingDir;\n+\n+    /**\n+     * The commands\n+     */\n+    @ConfigItem\n+    Optional<List<String>> command;\n+\n+    /**\n+     * The arguments\n+     *\n+     * @return The arguments\n+     */\n+    @ConfigItem\n+    Optional<List<String>> arguments;\n+\n+    /**\n+     * The service account\n+     */\n+    @ConfigItem\n+    Optional<String> serviceAccount;\n+\n+    /**\n+     * The host under which the application is going to be exposed\n+     */\n+    @ConfigItem\n+    Optional<String> host;\n+\n+    /**\n+     * The application ports\n+     */\n+    @ConfigItem\n+    Map<String, PortConfig> ports;\n+\n+    /**\n+     * The type of service that will be generated for the application\n+     */\n+    @ConfigItem(defaultValue = \"ClusterIP\")\n+    ServiceType serviceType;\n+\n+    /**\n+     * Image pull policy\n+     */\n+    @ConfigItem(defaultValue = \"IfNotPresent\")\n+    ImagePullPolicy imagePullPolicy;\n+\n+    /**\n+     * The image pull secret\n+     */\n+    @ConfigItem\n+    Optional<List<String>> imagePullSecrets;\n+\n+    /**\n+     * The liveness probe\n+     */\n+    @ConfigItem\n+    Optional<ProbeConfig> livenessProbe;\n+\n+    /**\n+     * The readiness probe\n+     */\n+    @ConfigItem\n+    Optional<ProbeConfig> readinessProbe;\n+\n+    /**\n+     * Volume mounts\n+     */\n+    @ConfigItem\n+    Map<String, MountConfig> mounts;\n+\n+    /**\n+     * Secret volumes\n+     */\n+    @ConfigItem\n+    Map<String, SecretVolumeConfig> secretVolumes;\n+\n+    /**\n+     * ConfigMap volumes\n+     */\n+    @ConfigItem\n+    Map<String, ConfigMapVolumeConfig> configMapVolumes;\n+\n+    /**\n+     * Git Repository volumes\n+     */\n+    @ConfigItem\n+    Map<String, GitRepoVolumeConfig> gitRepoVolumes;\n+\n+    /**\n+     * PVC volumes", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMTAzNA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383011034", "bodyText": "Can we get rid of all the getters and setters? They aren't necessary for the Quarkus config system.\nSame goes for all the other configuration objects that have been added as well", "author": "geoand", "createdAt": "2020-02-23T14:52:11Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/KubernetesConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.kubernetes.deployment.DeploymentTarget;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class KubernetesConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the\n+     * name. Else if the system property app.name is present it will be used. Else\n+     * find the project root folder and use its name (root folder detection is done\n+     * by moving to the parent folder until .git is found).\n+     */\n+    @ConfigItem\n+    Optional<String> name;\n+\n+    /**\n+     * The version of the application. This value be used for things like: - The\n+     * docker image tag. If no value specified it will attempt to determine the name\n+     * using the following rules:\n+     */\n+    @ConfigItem\n+    Optional<String> version;\n+\n+    /**\n+     * Custom labels to add to all resources\n+     */\n+    @ConfigItem\n+    Map<String, String> labels;\n+\n+    /**\n+     * Custom annotations to add to all resources\n+     */\n+    @ConfigItem\n+    Map<String, String> annotations;\n+\n+    /**\n+     * Environment variables to add to all containers\n+     */\n+    @ConfigItem\n+    Map<String, EnvConfig> envVars;\n+\n+    /**\n+     * Working directory\n+     */\n+    @ConfigItem\n+    Optional<String> workingDir;\n+\n+    /**\n+     * The commands\n+     */\n+    @ConfigItem\n+    Optional<List<String>> command;\n+\n+    /**\n+     * The arguments\n+     *\n+     * @return The arguments\n+     */\n+    @ConfigItem\n+    Optional<List<String>> arguments;\n+\n+    /**\n+     * The service account\n+     */\n+    @ConfigItem\n+    Optional<String> serviceAccount;\n+\n+    /**\n+     * The host under which the application is going to be exposed\n+     */\n+    @ConfigItem\n+    Optional<String> host;\n+\n+    /**\n+     * The application ports\n+     */\n+    @ConfigItem\n+    Map<String, PortConfig> ports;\n+\n+    /**\n+     * The type of service that will be generated for the application\n+     */\n+    @ConfigItem(defaultValue = \"ClusterIP\")\n+    ServiceType serviceType;\n+\n+    /**\n+     * Image pull policy\n+     */\n+    @ConfigItem(defaultValue = \"IfNotPresent\")\n+    ImagePullPolicy imagePullPolicy;\n+\n+    /**\n+     * The image pull secret\n+     */\n+    @ConfigItem\n+    Optional<List<String>> imagePullSecrets;\n+\n+    /**\n+     * The liveness probe\n+     */\n+    @ConfigItem\n+    Optional<ProbeConfig> livenessProbe;\n+\n+    /**\n+     * The readiness probe\n+     */\n+    @ConfigItem\n+    Optional<ProbeConfig> readinessProbe;\n+\n+    /**\n+     * Volume mounts\n+     */\n+    @ConfigItem\n+    Map<String, MountConfig> mounts;\n+\n+    /**\n+     * Secret volumes\n+     */\n+    @ConfigItem\n+    Map<String, SecretVolumeConfig> secretVolumes;\n+\n+    /**\n+     * ConfigMap volumes\n+     */\n+    @ConfigItem\n+    Map<String, ConfigMapVolumeConfig> configMapVolumes;\n+\n+    /**\n+     * Git Repository volumes\n+     */\n+    @ConfigItem\n+    Map<String, GitRepoVolumeConfig> gitRepoVolumes;\n+\n+    /**\n+     * PVC volumes\n+     */\n+    @ConfigItem\n+    Map<String, PvcVolumeConfig> pvcVolumes;\n+\n+    /**\n+     * AWS Elastic BlockStore volumes\n+     */\n+    @ConfigItem\n+    Map<String, AwsElasticBlockStoreVolumeConfig> awsElasticBlockStoreVolumes;\n+\n+    /**\n+     * Azure file volumes\n+     */\n+    @ConfigItem\n+    Map<String, AzureFileVolumeConfig> azureFileVolumes;\n+\n+    /**\n+     * Azure disk volumes\n+     */\n+    @ConfigItem\n+    Map<String, AzureDiskVolumeConfig> azureDiskVolumes;\n+\n+    /**\n+     * Init containers\n+     */\n+    @ConfigItem\n+    Map<String, ContainerConfig> initContainers;\n+\n+    /**\n+     * Sidecar containers\n+     */\n+    @ConfigItem\n+    Map<String, ContainerConfig> containers;\n+\n+    /**\n+     * The target deployment platform. Defaults to kubernetes. Can be kubernetes,\n+     * openshift, knative or any combination of the above as comma separated list.\n+     */\n+    @ConfigItem(defaultValue = \"kubernetes\")\n+    List<DeploymentTarget> deploymentTarget;\n+\n+    public Optional<String> getGroup() {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMTA3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383011075", "bodyText": "Same comment from KubernetesConfig", "author": "geoand", "createdAt": "2020-02-23T14:52:44Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/OpenshiftConfig.java", "diffHunk": "@@ -0,0 +1,406 @@\n+\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class OpenshiftConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMTEwMg==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383011102", "bodyText": "Same comment from KubernetesConfig", "author": "geoand", "createdAt": "2020-02-23T14:52:57Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/OpenshiftConfig.java", "diffHunk": "@@ -0,0 +1,406 @@\n+\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class OpenshiftConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the\n+     * name. Else if the system property app.name is present it will be used. Else\n+     * find the project root folder and use its name (root folder detection is done\n+     * by moving to the parent folder until .git is found).\n+     */\n+    @ConfigItem\n+    Optional<String> name;\n+\n+    /**\n+     * The version of the application. This value be used for things like: - The\n+     * docker image tag. If no value specified it will attempt to determine the name\n+     * using the following rules:", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxMTE1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383011154", "bodyText": "Let's please get rid of all the getters and setters in all the configuration objects that were added.", "author": "geoand", "createdAt": "2020-02-23T14:53:27Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/config/OpenshiftConfig.java", "diffHunk": "@@ -0,0 +1,406 @@\n+\n+package io.quarkus.kubernetes.deployment.config;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import io.dekorate.kubernetes.annotation.ImagePullPolicy;\n+import io.dekorate.kubernetes.annotation.ServiceType;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot\n+public class OpenshiftConfig implements PlatformConfiguration {\n+\n+    /**\n+     * The group of the application. This value will be use as: - docker image repo\n+     * - labeling resources\n+     */\n+    @ConfigItem\n+    Optional<String> group;\n+\n+    /**\n+     * The name of the application. This value will be used for naming Kubernetes\n+     * resources like: - Deployment - Service and so on ... If no value is specified\n+     * it will attempt to determine the name using the following rules: If its a\n+     * maven/gradle project use the artifact id. Else if its a bazel project use the\n+     * name. Else if the system property app.name is present it will be used. Else\n+     * find the project root folder and use its name (root folder detection is done\n+     * by moving to the parent folder until .git is found).\n+     */\n+    @ConfigItem\n+    Optional<String> name;\n+\n+    /**\n+     * The version of the application. This value be used for things like: - The\n+     * docker image tag. If no value specified it will attempt to determine the name\n+     * using the following rules:\n+     */\n+    @ConfigItem\n+    Optional<String> version;\n+\n+    /**\n+     * Custom labels to add to all resources\n+     */\n+    @ConfigItem\n+    Map<String, String> labels;\n+\n+    /**\n+     * Custom annotations to add to all resources\n+     */\n+    @ConfigItem\n+    Map<String, String> annotations;\n+\n+    /**\n+     * Environment variables to add to all containers\n+     */\n+    @ConfigItem\n+    Map<String, EnvConfig> envVars;\n+\n+    /**\n+     * Working directory\n+     */\n+    @ConfigItem\n+    Optional<String> workingDir;\n+\n+    /**\n+     * The commands\n+     */\n+    @ConfigItem\n+    Optional<List<String>> command;\n+\n+    /**\n+     * The arguments\n+     *\n+     * @return The arguments\n+     */\n+    @ConfigItem\n+    Optional<List<String>> arguments;\n+\n+    /**\n+     * The service account\n+     */\n+    @ConfigItem\n+    Optional<String> serviceAccount;\n+\n+    /**\n+     * The host under which the application is going to be exposed\n+     */\n+    @ConfigItem\n+    Optional<String> host;\n+\n+    /**\n+     * The application ports\n+     */\n+    @ConfigItem\n+    Map<String, PortConfig> ports;\n+\n+    /**\n+     * The type of service that will be generated for the application\n+     */\n+    @ConfigItem(defaultValue = \"ClusterIP\")\n+    ServiceType serviceType;\n+\n+    /**\n+     * Image pull policy\n+     */\n+    @ConfigItem(defaultValue = \"IfNotPresent\")\n+    ImagePullPolicy imagePullPolicy;\n+\n+    /**\n+     * The image pull secret\n+     */\n+    @ConfigItem\n+    Optional<List<String>> imagePullSecrets;\n+\n+    /**\n+     * The liveness probe\n+     */\n+    @ConfigItem\n+    Optional<ProbeConfig> livenessProbe;\n+\n+    /**\n+     * The readiness probe\n+     */\n+    @ConfigItem\n+    Optional<ProbeConfig> readinessProbe;\n+\n+    /**\n+     * Volume mounts\n+     */\n+    @ConfigItem\n+    Map<String, MountConfig> mounts;\n+\n+    /**\n+     * Secret volumes\n+     */\n+    @ConfigItem\n+    Map<String, SecretVolumeConfig> secretVolumes;\n+\n+    /**\n+     * ConfigMap volumes\n+     */\n+    @ConfigItem\n+    Map<String, ConfigMapVolumeConfig> configMapVolumes;\n+\n+    /**\n+     * Git Repository volumes\n+     */\n+    @ConfigItem\n+    Map<String, GitRepoVolumeConfig> gitRepoVolumes;\n+\n+    /**\n+     * PVC volumes\n+     */\n+    @ConfigItem\n+    Map<String, PvcVolumeConfig> pvcVolumes;\n+\n+    /**\n+     * AWS Elastic BlockStore volumes\n+     */\n+    @ConfigItem\n+    Map<String, AwsElasticBlockStoreVolumeConfig> awsElasticBlockStoreVolumes;\n+\n+    /**\n+     * Azure file volumes\n+     */\n+    @ConfigItem\n+    Map<String, AzureFileVolumeConfig> azureFileVolumes;\n+\n+    /**\n+     * Azure disk volumes\n+     */\n+    @ConfigItem\n+    Map<String, AzureDiskVolumeConfig> azureDiskVolumes;\n+\n+    /**\n+     * Init containers\n+     */\n+    @ConfigItem\n+    Map<String, ContainerConfig> initContainers;\n+\n+    /**\n+     * Sidecar containers\n+     */\n+    @ConfigItem\n+    Map<String, ContainerConfig> containers;\n+\n+    public Optional<String> getGroup() {", "originalCommit": "f8fdbac9d3918c6cc66a149d1db9f6c594da6916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e492c8b87b4341e6cc016a2fae07fa323ea0febd", "url": "https://github.com/quarkusio/quarkus/commit/e492c8b87b4341e6cc016a2fae07fa323ea0febd", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-23T16:07:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAyMzExMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7339#discussion_r383023111", "bodyText": "I assume this was leftover from debugging?", "author": "geoand", "createdAt": "2020-02-23T17:29:34Z", "path": "extensions/kubernetes/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -104,35 +115,24 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n             throw new RuntimeException(\"Unable to setup environment for generating Kubernetes resources\", e);\n         }\n \n-        Config config = ConfigProvider.getConfig();\n-        List<String> deploymentTargets = Arrays\n-                .stream(config.getOptionalValue(DEPLOYMENT_TARGET, String.class)\n-                        .orElse(KUBERNETES).split(\",\"))\n-                .map(String::trim)\n-                .map(String::toLowerCase)\n-                .collect(Collectors.toList());\n+        Map<String, Object> config = KubernetesConfigUtil.toMap();\n+        config.entrySet().forEach(e -> System.out.println(e.getKey() + \"=\" + e.getValue()));", "originalCommit": "e492c8b87b4341e6cc016a2fae07fa323ea0febd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e2bf5a6cb775af898371e0b6b9a3ac593837d45", "url": "https://github.com/quarkusio/quarkus/commit/6e2bf5a6cb775af898371e0b6b9a3ac593837d45", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-23T18:05:30Z", "type": "forcePushed"}, {"oid": "2d97a42e277e703e28f44203986cea29a723f2eb", "url": "https://github.com/quarkusio/quarkus/commit/2d97a42e277e703e28f44203986cea29a723f2eb", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-23T19:30:07Z", "type": "commit"}, {"oid": "2d97a42e277e703e28f44203986cea29a723f2eb", "url": "https://github.com/quarkusio/quarkus/commit/2d97a42e277e703e28f44203986cea29a723f2eb", "message": "refactor: Kubernetes extension now uses `quarkus.`", "committedDate": "2020-02-23T19:30:07Z", "type": "forcePushed"}]}