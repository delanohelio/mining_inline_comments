{"pr_number": 13641, "pr_title": "Add oidc-client, oidc-client-filter and oidc-token-propagation extensions", "pr_createdAt": "2020-12-02T18:17:57Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13641", "timeline": [{"oid": "0812300c4efd836611b341a780e4f9d8bae0108c", "url": "https://github.com/quarkusio/quarkus/commit/0812300c4efd836611b341a780e4f9d8bae0108c", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-03T10:48:16Z", "type": "forcePushed"}, {"oid": "707f92d67b58d85b9aaf2475b99da11c53686a14", "url": "https://github.com/quarkusio/quarkus/commit/707f92d67b58d85b9aaf2475b99da11c53686a14", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-03T11:26:10Z", "type": "forcePushed"}, {"oid": "f1e0d6c8561c05ce2472136344868fd69eb0140f", "url": "https://github.com/quarkusio/quarkus/commit/f1e0d6c8561c05ce2472136344868fd69eb0140f", "message": "Load OidcClient filter with a custom annotation", "committedDate": "2020-12-06T18:14:05Z", "type": "forcePushed"}, {"oid": "2e0898d96a990bfee805722d65d28078cb1f7d28", "url": "https://github.com/quarkusio/quarkus/commit/2e0898d96a990bfee805722d65d28078cb1f7d28", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-07T16:57:09Z", "type": "forcePushed"}, {"oid": "65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "url": "https://github.com/quarkusio/quarkus/commit/65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-07T18:04:45Z", "type": "forcePushed"}, {"oid": "751cdae20a5608a237ce62d58ee66c66603695c8", "url": "https://github.com/quarkusio/quarkus/commit/751cdae20a5608a237ce62d58ee66c66603695c8", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-08T16:18:53Z", "type": "forcePushed"}, {"oid": "2422a13b7db944049b6bba2ea349d465d3fd5073", "url": "https://github.com/quarkusio/quarkus/commit/2422a13b7db944049b6bba2ea349d465d3fd5073", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-08T18:41:38Z", "type": "forcePushed"}, {"oid": "cfd565c07074242f9f179b666e957004b873285a", "url": "https://github.com/quarkusio/quarkus/commit/cfd565c07074242f9f179b666e957004b873285a", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-09T14:35:54Z", "type": "forcePushed"}, {"oid": "912c0ec5069e490b7ee7c52829b3fcf47f13d453", "url": "https://github.com/quarkusio/quarkus/commit/912c0ec5069e490b7ee7c52829b3fcf47f13d453", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-09T17:04:02Z", "type": "forcePushed"}, {"oid": "94290cd2810ac5d0fa63f305dfeeb353d41634e2", "url": "https://github.com/quarkusio/quarkus/commit/94290cd2810ac5d0fa63f305dfeeb353d41634e2", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-09T17:11:35Z", "type": "forcePushed"}, {"oid": "7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "url": "https://github.com/quarkusio/quarkus/commit/7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-10T10:12:20Z", "type": "forcePushed"}, {"oid": "52540c3947f4a824c2454d222cf303839b17485e", "url": "https://github.com/quarkusio/quarkus/commit/52540c3947f4a824c2454d222cf303839b17485e", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-10T11:04:07Z", "type": "forcePushed"}, {"oid": "113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "url": "https://github.com/quarkusio/quarkus/commit/113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-11T18:02:31Z", "type": "forcePushed"}, {"oid": "ec0c79dc843b29701bd94b83645e17aad807abb7", "url": "https://github.com/quarkusio/quarkus/commit/ec0c79dc843b29701bd94b83645e17aad807abb7", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-13T17:37:14Z", "type": "forcePushed"}, {"oid": "b600f42fc6923d2a92f5398db8a20ec198ee8290", "url": "https://github.com/quarkusio/quarkus/commit/b600f42fc6923d2a92f5398db8a20ec198ee8290", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-14T18:47:38Z", "type": "forcePushed"}, {"oid": "16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "url": "https://github.com/quarkusio/quarkus/commit/16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-14T22:35:08Z", "type": "forcePushed"}, {"oid": "ab55074a7b2a0765b87ac55db192e4a3b5c9e271", "url": "https://github.com/quarkusio/quarkus/commit/ab55074a7b2a0765b87ac55db192e4a3b5c9e271", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-15T13:06:46Z", "type": "forcePushed"}, {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "url": "https://github.com/quarkusio/quarkus/commit/5092b249c039f4376f9602ea6a5e9f18235f9c9e", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-15T17:51:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543754952", "bodyText": "You probably have a reason for that ... Wouldn't be better Tokens ?", "author": "pedroigor", "createdAt": "2020-12-15T23:11:56Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/GrantTokens.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.oidc.client;\n+\n+/**\n+ * Access and Refresh tokens returned from a token grant request\n+ */\n+public class GrantTokens {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxNzAxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544217015", "bodyText": "I did not like GrantTokens first but then somehow got used to it :-), no particular reason, just wanted to say the tokens is product of the grant request, but just Tokens is simpler I guess", "author": "sberyozkin", "createdAt": "2020-12-16T11:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MzU1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544643559", "bodyText": "done", "author": "sberyozkin", "createdAt": "2020-12-16T21:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NTkyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543755927", "bodyText": "Maybe a no-arg refreshTokens would help to avoid boilerplate code to get refresh token and then call this method?", "author": "pedroigor", "createdAt": "2020-12-15T23:14:02Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/OidcClient.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.quarkus.oidc.client;\n+\n+import java.io.Closeable;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Token grant client\n+ */\n+public interface OidcClient extends Closeable {\n+\n+    /**\n+     * Returns the grant tokens\n+     */\n+    Uni<GrantTokens> getTokens();\n+\n+    /**\n+     * Refreshes the grant tokens\n+     */\n+    Uni<GrantTokens> refreshTokens(String refreshToken);", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxODI5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544218297", "bodyText": "But OidcClientImpl is not keeping the tokens itself. I guess in a good number of cases the users won't use this client directly but via the filter which is hiding these expiry and refresh tokens checks. It will be used directly only if the users are comfortable with using this client manually or the existing filters don't really fit their cases", "author": "sberyozkin", "createdAt": "2020-12-16T11:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543770047", "bodyText": "Shouldn't this guard against concurrent refresh? If you send off multiple client requests at once (e.g. when using a reactive client), you need to track if there is an operation in progress and piggy back on the existing operation rather than attempting another concurrent refresh.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:46:49Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensHelper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.smallrye.mutiny.Uni;\n+\n+public class GrantTokensHelper {\n+\n+    private volatile GrantTokens grantTokens;\n+\n+    public GrantTokens prepareTokens(OidcClient oidcClient) {\n+        if (grantTokens == null) {\n+            grantTokens = oidcClient.getTokens().await().indefinitely();\n+        }\n+        return grantTokens;\n+    }\n+\n+    public Uni<GrantTokens> getTokens(OidcClient oidcClient) {\n+\n+        GrantTokens currentTokens = prepareTokens(oidcClient);\n+\n+        if (currentTokens.isAccessTokenExpired()) {\n+            // Particularly, a client_credentials response is not guaranteed to return a refresh token\n+            Uni<GrantTokens> newTokensUni = currentTokens.getRefreshToken() != null", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzI4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544223281", "bodyText": "@stuartwdouglas yes there is a (very) small window there for the concurrent refresh or token acquisition but I thought it was not critical, this operation in itself can be repeated, OIDC servers will control a number of times the tokens will be refreshed but a a few extra refresh operations won't affect it.\nAs opposed to having to sync, or did you mean implementing  you need to track if there is an operation in progress and piggy back on the existing operation in terms of Uni ? It sounds right, just need to figure how to do it :-)", "author": "sberyozkin", "createdAt": "2020-12-16T11:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MDc0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545970743", "bodyText": "@stuartwdouglas I've added some code there to make sure no unnecessary refresh or a postponed token acquisition occurs, have a look please, that should be fine.", "author": "sberyozkin", "createdAt": "2020-12-18T17:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTExNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543771117", "bodyText": "I don't think this is the correct scope? It means you will be getting a new token for every request?", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:49:27Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensProducer.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@RequestScoped\n+public class GrantTokensProducer extends AbstractGrantTokensProducer {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNDAwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544224004", "bodyText": "This producer gets the initial set of tokens on the initialization time, and it needs to be called on every request for this producer to check if the token has expired", "author": "sberyozkin", "createdAt": "2020-12-16T11:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543771566", "bodyText": "These tokens are dependent scoped, so they will have the same lifecycle as the object they are injected into. If you inject them into an @ApplicationScoped bean or a singleton they will never be refreshed.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:50:30Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensProducer.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@RequestScoped\n+public class GrantTokensProducer extends AbstractGrantTokensProducer {\n+\n+    @Produces\n+    public GrantTokens produceTokens() {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNjA3NA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544226074", "bodyText": "@stuartwdouglas I'll check, sure, I have a test checking the logs which confirm the tokens have been refreshed (with the filter which uses @OidcClient) and I have a test which verifies the tokens have been refreshed with @GrantTokensProducer/@GrantTokens but I'll add the log check there as well :-)", "author": "sberyozkin", "createdAt": "2020-12-16T11:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMTA1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544711050", "bodyText": "Your test works because you have explicitly marker the filter as @RequestScoped. But this means that every request will require a request to KC to get the keys.\nI think the keys should be stored in a singleton, which will mean that most requests don't need to make any requests to KC. When they keys expire the singleton can manage the refresh process and make sure they are only refreshed once.", "author": "stuartwdouglas", "createdAt": "2020-12-17T00:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1Mjc1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544952756", "bodyText": "@stuartwdouglas Oh, do you mean the filter is re-initialized on every request ? that is not good then yeah", "author": "sberyozkin", "createdAt": "2020-12-17T09:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MjEwMg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543772102", "bodyText": "I think a lot of these should be final.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:51:35Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543773682", "bodyText": "I think you can just use transform rather than transformToUni here, as emitGrantTokens does not do anything async.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:55:07Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543773928", "bodyText": "Why would this happen? Shouldn't this give some kind of user feedback?", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:55:46Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));\n+    }\n+\n+    private Uni<GrantTokens> emitGrantTokens(HttpResponse<Buffer> resp, boolean refresh) {\n+        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super GrantTokens>>() {\n+            @Override\n+            public void accept(UniEmitter<? super GrantTokens> emitter) {\n+                if (resp.statusCode() == 200) {\n+                    LOG.debugf(\"Tokens have been %s\", refresh ? \"refreshed\" : \"acquired\");\n+                    JsonObject json = resp.bodyAsJsonObject();\n+                    final String accessToken = json.getString(ACCESS_TOKEN);\n+                    final String refreshToken = json.getString(REFRESH_TOKEN);\n+                    Long accessTokenExpiresAt = json.getLong(EXPIRES_AT);\n+                    if (accessTokenExpiresAt == null) {\n+                        accessTokenExpiresAt = getExpiresJwtClaim(accessToken);\n+                    }\n+                    emitter.complete(new GrantTokens(accessToken, accessTokenExpiresAt, refreshToken));\n+                } else {\n+                    LOG.errorf(\"%s token grant request has failed: %s\", (refresh ? \"refresh\" : grantType), resp.bodyAsString());\n+                    emitter.fail(new OidcClientException());\n+                }\n+            }\n+        });\n+    }\n+\n+    private static Long getExpiresJwtClaim(String accessToken) {\n+        String[] parts = accessToken.split(\"\\\\.\");\n+        if (parts.length == 3) {\n+            try {\n+                JsonObject claims = new JsonObject(new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8));\n+                return claims.getLong(Claims.exp.name());\n+            } catch (IllegalArgumentException ex) {\n+                return null;", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MjYxNg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r546962616", "bodyText": "This still needs to be addressed.", "author": "stuartwdouglas", "createdAt": "2020-12-21T22:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE5ODAyOA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547198028", "bodyText": "@stuartwdouglas sorry, missed it. OK, a token grant response should include an expiry time, but if it is not included, (as in case of Keycloak) then an attempt is made to decode the access token as JWT token and get the exp claim - this exception is only to handle the JsonObject.getLong exception - should not ever happen in practice - but indeed, some debug message should be added", "author": "sberyozkin", "createdAt": "2020-12-22T10:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NDM2MA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543774360", "bodyText": "It does not really matter, but you don't have to use RuntimeValue unless the item can't be proxied. OidcClients is an interface so it is not really needed.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:56:52Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543775013", "bodyText": "There are lots of these 'magic constants' everywhere. I think we should add an OIDCConstants class somewhere with constants for all these.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:58:33Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        OidcClient defaultClient = createOidcClient(oidcClientsConfig.defaultClient, \"Default\", tlsConfig, vertx);\n+\n+        Map<String, OidcClient> staticOidcClients = new HashMap<>();\n+\n+        for (Map.Entry<String, OidcClientConfig> clientConfig : oidcClientsConfig.namedClients.entrySet()) {\n+            staticOidcClients.put(clientConfig.getKey(),\n+                    createOidcClient(clientConfig.getValue(), clientConfig.getKey(), tlsConfig, vertx));\n+        }\n+\n+        return new RuntimeValue<>(new OidcClientsImpl(defaultClient, staticOidcClients));\n+    }\n+\n+    public Supplier<OidcClient> createOidcClientBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClient>() {\n+\n+            @Override\n+            public OidcClient get() {\n+                return clients.getValue().getClient();\n+            }\n+        };\n+    }\n+\n+    public Supplier<OidcClients> createOidcClientsBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClients>() {\n+\n+            @Override\n+            public OidcClients get() {\n+                return clients.getValue();\n+            }\n+        };\n+    }\n+\n+    protected static OidcClient createOidcClient(OidcClientConfig oidcConfig, String oidcClientId,\n+            TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        if (!oidcConfig.clientEnabled) {\n+            String message = String.format(\"'%s' client configuration is disabled\", oidcClientId);\n+            LOG.debug(message);\n+            return new OidcClient() {\n+\n+                @Override\n+                public Uni<GrantTokens> getTokens() {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            };\n+        }\n+\n+        OidcCommonUtils.verifyCommonConfiguration(oidcConfig);\n+\n+        String authServerUriString = OidcCommonUtils.getAuthServerUrl(oidcConfig);\n+\n+        WebClientOptions options = new WebClientOptions();\n+\n+        URI authServerUri = URI.create(authServerUriString);\n+        if (authServerUri.getPort() != -1) {\n+            options.setDefaultPort(authServerUri.getPort());\n+        }\n+        OidcCommonUtils.setHttpClientOptions(oidcConfig, tlsConfig, options);\n+\n+        WebClient client = WebClient.create(new io.vertx.mutiny.core.Vertx(vertx.get()), options);\n+\n+        String tokenRequestUri = null;\n+        if (!oidcConfig.discoveryEnabled) {\n+            tokenRequestUri = OidcCommonUtils.getOidcEndpointUrl(authServerUriString, oidcConfig.tokenPath);\n+        } else {\n+            tokenRequestUri = discoverTokenRequestUri(client, authServerUriString, oidcConfig);\n+        }\n+        if (tokenRequestUri == null) {\n+            throw new ConfigurationException(\n+                    \"OpenId Connect Provider token endpoint URL is not configured and can not be discovered\");\n+        }\n+\n+        MultiMap tokenGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, tokenGrantParams,\n+                oidcConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\");\n+        if (oidcConfig.grant.type == Grant.Type.USER) {\n+            Map<String, String> passwordGrantOptions = oidcConfig.grantOptions.get(\"user\");\n+            tokenGrantParams.add(\"username\", passwordGrantOptions.get(\"name\"));\n+            tokenGrantParams.add(\"password\", passwordGrantOptions.get(\"password\"));\n+        }\n+\n+        MultiMap commonRefreshGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, commonRefreshGrantParams, \"refresh_token\");\n+\n+        return new OidcClientImpl(client, tokenRequestUri, tokenGrantParams, commonRefreshGrantParams, oidcConfig);\n+    }\n+\n+    private static void setGrantClientParams(OidcClientConfig oidcConfig, MultiMap grantParams, String grantType) {\n+        grantParams.add(\"grant_type\", grantType);\n+        Credentials creds = oidcConfig.getCredentials();\n+        if (OidcCommonUtils.isClientSecretPostAuthRequired(creds)) {\n+            grantParams.add(\"client_id\", oidcConfig.clientId.get());", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyODAzMA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544228030", "bodyText": "@stuartwdouglas good point, now that this PR introduces oidc-common we can have OIDCConstants there, I'll see how it goes, if I have time I'll do it with this PR otheriwise I'll create a follow up issue and take care of it there", "author": "sberyozkin", "createdAt": "2020-12-16T11:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MjQyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545292427", "bodyText": "@stuartwdouglas Just did it, definitely worth it :-), moved a good number of those magic constants from quarkus-oidc-client and a few from quarkus-oidc, more common ones will be added there from now on", "author": "sberyozkin", "createdAt": "2020-12-17T18:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTU5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543775597", "bodyText": "Shouldn't this throw an exception to trigger the retry code above?", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:59:58Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        OidcClient defaultClient = createOidcClient(oidcClientsConfig.defaultClient, \"Default\", tlsConfig, vertx);\n+\n+        Map<String, OidcClient> staticOidcClients = new HashMap<>();\n+\n+        for (Map.Entry<String, OidcClientConfig> clientConfig : oidcClientsConfig.namedClients.entrySet()) {\n+            staticOidcClients.put(clientConfig.getKey(),\n+                    createOidcClient(clientConfig.getValue(), clientConfig.getKey(), tlsConfig, vertx));\n+        }\n+\n+        return new RuntimeValue<>(new OidcClientsImpl(defaultClient, staticOidcClients));\n+    }\n+\n+    public Supplier<OidcClient> createOidcClientBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClient>() {\n+\n+            @Override\n+            public OidcClient get() {\n+                return clients.getValue().getClient();\n+            }\n+        };\n+    }\n+\n+    public Supplier<OidcClients> createOidcClientsBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClients>() {\n+\n+            @Override\n+            public OidcClients get() {\n+                return clients.getValue();\n+            }\n+        };\n+    }\n+\n+    protected static OidcClient createOidcClient(OidcClientConfig oidcConfig, String oidcClientId,\n+            TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        if (!oidcConfig.clientEnabled) {\n+            String message = String.format(\"'%s' client configuration is disabled\", oidcClientId);\n+            LOG.debug(message);\n+            return new OidcClient() {\n+\n+                @Override\n+                public Uni<GrantTokens> getTokens() {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            };\n+        }\n+\n+        OidcCommonUtils.verifyCommonConfiguration(oidcConfig);\n+\n+        String authServerUriString = OidcCommonUtils.getAuthServerUrl(oidcConfig);\n+\n+        WebClientOptions options = new WebClientOptions();\n+\n+        URI authServerUri = URI.create(authServerUriString);\n+        if (authServerUri.getPort() != -1) {\n+            options.setDefaultPort(authServerUri.getPort());\n+        }\n+        OidcCommonUtils.setHttpClientOptions(oidcConfig, tlsConfig, options);\n+\n+        WebClient client = WebClient.create(new io.vertx.mutiny.core.Vertx(vertx.get()), options);\n+\n+        String tokenRequestUri = null;\n+        if (!oidcConfig.discoveryEnabled) {\n+            tokenRequestUri = OidcCommonUtils.getOidcEndpointUrl(authServerUriString, oidcConfig.tokenPath);\n+        } else {\n+            tokenRequestUri = discoverTokenRequestUri(client, authServerUriString, oidcConfig);\n+        }\n+        if (tokenRequestUri == null) {\n+            throw new ConfigurationException(\n+                    \"OpenId Connect Provider token endpoint URL is not configured and can not be discovered\");\n+        }\n+\n+        MultiMap tokenGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, tokenGrantParams,\n+                oidcConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\");\n+        if (oidcConfig.grant.type == Grant.Type.USER) {\n+            Map<String, String> passwordGrantOptions = oidcConfig.grantOptions.get(\"user\");\n+            tokenGrantParams.add(\"username\", passwordGrantOptions.get(\"name\"));\n+            tokenGrantParams.add(\"password\", passwordGrantOptions.get(\"password\"));\n+        }\n+\n+        MultiMap commonRefreshGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, commonRefreshGrantParams, \"refresh_token\");\n+\n+        return new OidcClientImpl(client, tokenRequestUri, tokenGrantParams, commonRefreshGrantParams, oidcConfig);\n+    }\n+\n+    private static void setGrantClientParams(OidcClientConfig oidcConfig, MultiMap grantParams, String grantType) {\n+        grantParams.add(\"grant_type\", grantType);\n+        Credentials creds = oidcConfig.getCredentials();\n+        if (OidcCommonUtils.isClientSecretPostAuthRequired(creds)) {\n+            grantParams.add(\"client_id\", oidcConfig.clientId.get());\n+            grantParams.add(\"client_secret\", OidcCommonUtils.clientSecret(creds));\n+        }\n+        if (oidcConfig.scopes.isPresent()) {\n+            grantParams.add(\"scope\", oidcConfig.scopes.get().stream().collect(Collectors.joining(\" \")));\n+        }\n+    }\n+\n+    private static String discoverTokenRequestUri(WebClient client, String authServerUrl, OidcClientConfig oidcConfig) {\n+        final long connectionRetryCount = OidcCommonUtils.getConnectionRetryCount(oidcConfig);\n+        if (connectionRetryCount > 1) {\n+            LOG.infof(\"Connecting to IDP for up to %d times every 2 seconds\", connectionRetryCount);\n+        }\n+\n+        for (long i = 0; i < connectionRetryCount; i++) {\n+            try {\n+                if (oidcConfig.discoveryEnabled) {\n+                    return discoverTokenEndpoint(client, authServerUrl);\n+                }\n+                break;\n+            } catch (Throwable throwable) {\n+                while (throwable instanceof CompletionException && throwable.getCause() != null) {\n+                    throwable = throwable.getCause();\n+                }\n+                if (throwable instanceof OidcClientException) {\n+                    if (i + 1 < connectionRetryCount) {\n+                        try {\n+                            Thread.sleep(2000);\n+                        } catch (InterruptedException iex) {\n+                            // continue connecting\n+                        }\n+                    } else {\n+                        throw (OidcClientException) throwable;\n+                    }\n+                } else {\n+                    throw new OidcClientException(throwable);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String discoverTokenEndpoint(WebClient client, String authServerUrl) {\n+        String discoveryUrl = authServerUrl + \"/.well-known/openid-configuration\";\n+        return client.get(discoveryUrl).send().onItem().transform(resp -> {\n+            if (resp.statusCode() == 200) {\n+                JsonObject json = resp.bodyAsJsonObject();\n+                return json.getString(\"token_endpoint\");\n+            } else {\n+                LOG.tracef(\"Discovery has failed, status code: %d\", resp.statusCode());", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNjkwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544226905", "bodyText": "@stuartwdouglas Likely not as it is not a connection error, but the discovery document retrieval problem", "author": "sberyozkin", "createdAt": "2020-12-16T11:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543776877", "bodyText": "At some point we should look at consolidating these into some kind of common utility. It could actually be useful for end users as well to have an easy way to setup keycloak for tests.", "author": "stuartwdouglas", "createdAt": "2020-12-16T00:03:08Z", "path": "extensions/oidc-rest-client/deployment/src/test/java/io/quarkus/oidc/rest/client/KeycloakRealmResourceManager.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.oidc.rest.client;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.keycloak.representations.AccessTokenResponse;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.CredentialRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.RoleRepresentation;\n+import org.keycloak.representations.idm.RolesRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.util.JsonSerialization;\n+\n+import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n+import io.restassured.RestAssured;\n+\n+public class KeycloakRealmResourceManager implements QuarkusTestResourceLifecycleManager {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyODUzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544228537", "bodyText": "@stuartwdouglas +1, @cemnura is helping out with improving the test support for OIDC so we can work with him on it", "author": "sberyozkin", "createdAt": "2020-12-16T11:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5OTgzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545299837", "bodyText": "@stuartwdouglas see #13957", "author": "sberyozkin", "createdAt": "2020-12-17T18:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw=="}], "type": "inlineReview"}, {"oid": "37c86c2405c6ea7ae8021dea17c8827ac20d8377", "url": "https://github.com/quarkusio/quarkus/commit/37c86c2405c6ea7ae8021dea17c8827ac20d8377", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-16T21:41:37Z", "type": "forcePushed"}, {"oid": "5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "url": "https://github.com/quarkusio/quarkus/commit/5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-16T21:46:52Z", "type": "forcePushed"}, {"oid": "b910a9e70b2690f6ca594f7efc4453e0ac282f92", "url": "https://github.com/quarkusio/quarkus/commit/b910a9e70b2690f6ca594f7efc4453e0ac282f92", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-17T11:39:33Z", "type": "forcePushed"}, {"oid": "f3f12eb0a773169a92ce1c9d00e46df49785efe2", "url": "https://github.com/quarkusio/quarkus/commit/f3f12eb0a773169a92ce1c9d00e46df49785efe2", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-17T18:00:08Z", "type": "forcePushed"}, {"oid": "b474c40b2c37ffdb9b79471e235be7f53532f510", "url": "https://github.com/quarkusio/quarkus/commit/b474c40b2c37ffdb9b79471e235be7f53532f510", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-18T17:07:05Z", "type": "forcePushed"}, {"oid": "1250071f3f142be3eac4f7ab81f3488a4f4c788a", "url": "https://github.com/quarkusio/quarkus/commit/1250071f3f142be3eac4f7ab81f3488a4f4c788a", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-20T17:33:14Z", "type": "forcePushed"}, {"oid": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "url": "https://github.com/quarkusio/quarkus/commit/d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-21T18:21:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r546965437", "bodyText": "We can't really do this via locks when you are dealing with reactive code. getTokens() can be called by the same thread for reactive code, but for different requests. The logic below also has a few issues.", "author": "stuartwdouglas", "createdAt": "2020-12-21T22:41:34Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/TokensHelper.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.Tokens;\n+import io.smallrye.mutiny.Uni;\n+\n+public class TokensHelper {\n+\n+    private volatile Tokens tokens;\n+    private ReentrantLock tokenAcquisitionLock = new ReentrantLock();", "originalCommit": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwMDg5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547200896", "bodyText": "@stuartwdouglas, thanks a lot; I have to admit this possibility did not occur to me :-) - I was primarily focused on running this code from the client filter which at this moment of time is not reactive ready yet as if I understand it correctly - Steph said he was only planning to support the reactive client filters in 'regular' RestEasy - but you are right it has to be done right - as I'd like to have these filters running eventually in the reactive mode :-)\nAlso, thanks for getting this code right, let me learn what has changed, cheers", "author": "sberyozkin", "createdAt": "2020-12-22T10:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwNTk0MA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547205940", "bodyText": "@stuartwdouglas - compare and swap :-) - I'm getting inspired here and I've just pulled Java Concurrentcy in Practice 2nd edition from the bookshelf though I suspect it may've gone a bit outdated :-)", "author": "sberyozkin", "createdAt": "2020-12-22T10:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwOTY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547209649", "bodyText": "@stuartwdouglas - actually - I'm finally getting how to make sure Uni can be kept as a state property, it must be deferred, I've been thinking of keeping it in quarkus-oidc somewhere as a state value but could not get how to do it :-)", "author": "sberyozkin", "createdAt": "2020-12-22T10:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw=="}], "type": "inlineReview"}, {"oid": "267932b6873b65d1ff8a4fd6e39455035912c8b8", "url": "https://github.com/quarkusio/quarkus/commit/267932b6873b65d1ff8a4fd6e39455035912c8b8", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-22T11:44:32Z", "type": "forcePushed"}, {"oid": "e60427e1941a788757c7e92851b0b401d0c4beea", "url": "https://github.com/quarkusio/quarkus/commit/e60427e1941a788757c7e92851b0b401d0c4beea", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-22T17:27:00Z", "type": "forcePushed"}, {"oid": "3050a142d3d65fa8819744ead91007c7bd6e61a6", "url": "https://github.com/quarkusio/quarkus/commit/3050a142d3d65fa8819744ead91007c7bd6e61a6", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-22T17:42:57Z", "type": "forcePushed"}, {"oid": "43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "url": "https://github.com/quarkusio/quarkus/commit/43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-24T12:15:56Z", "type": "forcePushed"}, {"oid": "981960220cc86d2a7763b601d9a9ceaed04118b5", "url": "https://github.com/quarkusio/quarkus/commit/981960220cc86d2a7763b601d9a9ceaed04118b5", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-24T14:52:45Z", "type": "forcePushed"}, {"oid": "879348a03ebdd576caab0938ffa3b9db8c1b7331", "url": "https://github.com/quarkusio/quarkus/commit/879348a03ebdd576caab0938ffa3b9db8c1b7331", "message": "Update the runtime pom descriptions and extension resources", "committedDate": "2021-01-05T12:11:38Z", "type": "forcePushed"}, {"oid": "d3c6b25759011c6623fa93fea296821d963de36d", "url": "https://github.com/quarkusio/quarkus/commit/d3c6b25759011c6623fa93fea296821d963de36d", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2021-01-05T13:15:06Z", "type": "commit"}, {"oid": "d3c6b25759011c6623fa93fea296821d963de36d", "url": "https://github.com/quarkusio/quarkus/commit/d3c6b25759011c6623fa93fea296821d963de36d", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2021-01-05T13:15:06Z", "type": "forcePushed"}]}