{"pr_number": 11724, "pr_title": "Reduce the amount of duplicate/redundant code shared between the jpa/mongo/java/kotlin/imperative/reactive panache implementations", "pr_createdAt": "2020-08-28T23:22:18Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11724", "timeline": [{"oid": "fe07492c872a6b6b5485bc6d4453987d26c60fad", "url": "https://github.com/quarkusio/quarkus/commit/fe07492c872a6b6b5485bc6d4453987d26c60fad", "message": "all the modules currently working except for spring-data-jpa", "committedDate": "2020-10-07T15:38:47Z", "type": "forcePushed"}, {"oid": "7a4ebe1672580bf899e9bd9aac54f043953f11e4", "url": "https://github.com/quarkusio/quarkus/commit/7a4ebe1672580bf899e9bd9aac54f043953f11e4", "message": "refactoring to common code", "committedDate": "2020-10-08T18:46:24Z", "type": "forcePushed"}, {"oid": "43382aa5390e01c9c097c2914095361b4ba1906a", "url": "https://github.com/quarkusio/quarkus/commit/43382aa5390e01c9c097c2914095361b4ba1906a", "message": "update reactive hibernate to use the new code", "committedDate": "2020-10-08T23:46:40Z", "type": "forcePushed"}, {"oid": "be137266e13ecd43c66633588bd96d3856ce25bc", "url": "https://github.com/quarkusio/quarkus/commit/be137266e13ecd43c66633588bd96d3856ce25bc", "message": "refactoring to common code", "committedDate": "2020-10-12T16:13:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyNjU4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r503826582", "bodyText": "As a side note, we should really find a way for users to not use our Operation classes.", "author": "loicmathieu", "createdAt": "2020-10-13T10:03:10Z", "path": "extensions/panache/hibernate-orm-panache-kotlin/runtime/src/main/java/io/quarkus/hibernate/orm/panache/kotlin/runtime/KotlinJpaOperations.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package io.quarkus.hibernate.orm.panache.kotlin.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import javax.persistence.EntityManager;\n+\n+import io.quarkus.hibernate.orm.panache.common.runtime.AbstractJpaOperations;\n+\n+public class KotlinJpaOperations extends AbstractJpaOperations<PanacheQueryImpl<?>> {", "originalCommit": "66d59d24f0f8d7cf43c23d5f69a063814dbb8216", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5OTY5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r503899696", "bodyText": "That would be lovely, for sure.  I've tried to document them as private but that's not really going to stop anyone.", "author": "evanchooly", "createdAt": "2020-10-13T12:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyNjU4Mg=="}], "type": "inlineReview"}, {"oid": "16d50cdec94df1d9898f63ae2701733229541749", "url": "https://github.com/quarkusio/quarkus/commit/16d50cdec94df1d9898f63ae2701733229541749", "message": "refactoring to common code", "committedDate": "2020-10-13T14:05:06Z", "type": "forcePushed"}, {"oid": "6136922d6e718ee3b165d54fa3bb02dcf348e63b", "url": "https://github.com/quarkusio/quarkus/commit/6136922d6e718ee3b165d54fa3bb02dcf348e63b", "message": "refactoring to common code", "committedDate": "2020-10-13T15:49:27Z", "type": "forcePushed"}, {"oid": "8d36b2486c172e37cde95ab553f1004f7c684cf3", "url": "https://github.com/quarkusio/quarkus/commit/8d36b2486c172e37cde95ab553f1004f7c684cf3", "message": "refactoring to common code", "committedDate": "2020-10-13T21:38:01Z", "type": "forcePushed"}, {"oid": "444eaf2f014218cf326a2daae25e0d664165d34e", "url": "https://github.com/quarkusio/quarkus/commit/444eaf2f014218cf326a2daae25e0d664165d34e", "message": "refactoring to common code", "committedDate": "2020-10-16T16:20:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0Njk5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r507546999", "bodyText": "wildcard imports are prohibited", "author": "loicmathieu", "createdAt": "2020-10-19T08:00:51Z", "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -1,5 +1,7 @@\n package io.quarkus.hibernate.orm.panache.common.runtime;\n \n+import static io.quarkus.hibernate.orm.runtime.PersistenceUnitUtil.*;", "originalCommit": "444eaf2f014218cf326a2daae25e0d664165d34e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc2MTIzNw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r507761237", "bodyText": "grumble grumble  between my IDE formatting and the build formatting that should've never made it in.  :)", "author": "evanchooly", "createdAt": "2020-10-19T13:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0Njk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU1Mzg4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r507553881", "bodyText": "This class should be on hibernate-orm-panache-common not panache-common.", "author": "loicmathieu", "createdAt": "2020-10-19T08:12:27Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheJpaEntityClassVisitor.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package io.quarkus.panache.common.deployment.visitors;\n+\n+import java.util.List;\n+\n+import org.hibernate.bytecode.enhance.spi.EnhancerConstants;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.IndexView;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+\n+import io.quarkus.panache.common.deployment.EntityField;\n+import io.quarkus.panache.common.deployment.EntityModel;\n+import io.quarkus.panache.common.deployment.MetamodelInfo;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizer;\n+import io.quarkus.panache.common.deployment.TypeBundle;\n+\n+public class PanacheJpaEntityClassVisitor extends PanacheEntityClassVisitor<EntityField> {", "originalCommit": "444eaf2f014218cf326a2daae25e0d664165d34e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "737fda02e65ea5700365998780c69c521cd0100d", "url": "https://github.com/quarkusio/quarkus/commit/737fda02e65ea5700365998780c69c521cd0100d", "message": "refactoring to common code", "committedDate": "2020-10-19T14:59:03Z", "type": "forcePushed"}, {"oid": "daf0114f6c9b191d64492ffa125cae23c898e7cc", "url": "https://github.com/quarkusio/quarkus/commit/daf0114f6c9b191d64492ffa125cae23c898e7cc", "message": "refactoring to common code", "committedDate": "2020-10-19T17:42:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r511856972", "bodyText": "This is user-facing API, and it's lacking methods compared to the current version so it's not compatible.", "author": "FroMage", "createdAt": "2020-10-26T10:26:45Z", "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/Panache.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package io.quarkus.hibernate.orm.panache;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.transaction.TransactionManager;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.hibernate.orm.PersistenceUnit;\n+import io.quarkus.hibernate.orm.runtime.PersistenceUnitUtil;\n+\n+/**\n+ * Utility class for Panache.\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ */\n+public class Panache {", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MTM0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512191349", "bodyText": "ah.  i wasn't aware that was intended for public consumption.  i'll see what's drifted and restore it.", "author": "evanchooly", "createdAt": "2020-10-26T18:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcxMDQ1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512710453", "bodyText": "The problem with these methods is that they treat JpaOperations as a bag of static methods but it's not any more.  So those methods would have to either change to take in the the operations reference, which would be a weird API, or just go away.  Are users actually actively using these methods?  Because I'm not seeing a non-breaking way for them to remain with everything else as it is.", "author": "evanchooly", "createdAt": "2020-10-27T13:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg1NDcwOA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512854708", "bodyText": "Well, yes, those methods are used in the wild, that's the public API. I'm not sure what you mean, we currently already have several versions of this class (different packages), so as long as we keep them we know what instance of operations they delegate to, no?", "author": "FroMage", "createdAt": "2020-10-27T16:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MTI0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512891246", "bodyText": "right.  they would need to have a reference to an operations instance.  not sure how to get that in there without changing the API.  but then, we don't want them using the operations classes directly because those are not public.", "author": "evanchooly", "createdAt": "2020-10-27T17:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4NDgzNg==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r513284836", "bodyText": "Just make them forward to the right INSTANCE, I don't see the problem.", "author": "FroMage", "createdAt": "2020-10-28T09:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzOTE1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r513439153", "bodyText": "well, there are two issues is see off hand (and @loicmathieu can probably weigh in here):\n\nThat's still a breaking change to a public API.  I personally don't see the value in this public API but that might be a discussion for another time.\nWe've been mostly working on the assumption that the operations implementation classes are internal implementation details and discouraging use outside of the generated delegations from entity/repository types.  this would officially commit us to a public, stable API.  That's not necessarily a bad thing as that API is unlikely to radically change but I do think it's a decision we should consciously make.\n\nAdding that as a param is by far the simplest thing to do I just want to make sure we're actively choosing the consequences of it.", "author": "evanchooly", "createdAt": "2020-10-28T13:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwODg0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r513508841", "bodyText": "Definitely not as a param:\npublic class Panache {\n  public static void setRollbackOnly() {\n    JpaOperations.INSTANCE.setRollbackOnly();\n }\n}\nAnd do the same for the other existing Panache classes and other methods, and we're done.", "author": "FroMage", "createdAt": "2020-10-28T14:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNzA3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r513517073", "bodyText": "That would create a hard dep on hibernate-orm-panache even for kotlin apps which could be awkward/confusing.  fwiw, the reactive form of Panache is a much smaller API which suggest some asymmetry in requirements/design.  Do users really need another helper class like this?", "author": "evanchooly", "createdAt": "2020-10-28T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNDUzMA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r513604530", "bodyText": "I'm not sure what you mean about this. Currently every Panache extension has that Panache class. You're trying to remove it. I think you can't because people are using it. I'm not proposing to add anything new.", "author": "FroMage", "createdAt": "2020-10-28T16:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1MTI4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r513651283", "bodyText": "JpaOperations.INSTANCE lives in hibernate-orm-panache which quarkus-hibernate-orm-panache-kotlin does not depend on.  In order for Panache to function, those kotlin apps would have to import the java implementation as well.  the kotlin module does not define its Panache so it can't be bound to a different reference.  Now we can push down the Panache definitions to the language specific modules but it'd be one more point of duplication.  I have plans in the works to monitor all such duplications for divergence so maybe that's not a big deal.  But, again, it should be a conscious choice we all make.", "author": "evanchooly", "createdAt": "2020-10-28T17:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0OTE5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r514149195", "bodyText": "If the Kotlin version doesn't have this interface ATM, then it differs from the Java one, just move it back to the ORM module where it started. The Mongo ones have it, under their own package, so no problem there.", "author": "FroMage", "createdAt": "2020-10-29T10:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2MDMzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r514560339", "bodyText": "I can definitely push these types down to the specific modules.  Still trying to track down why switching from the envers dep to hibernate-orm results in that arc/injection failure.", "author": "evanchooly", "createdAt": "2020-10-29T20:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM3MDU2NA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r518370564", "bodyText": "OK.  Simpler solution:  I can simply make those methods static on AbstractJpaOperations since they don't need any specialization of types between java/kotlin, e.g.  I have tests running locally now and will push as soon as they pass here.", "author": "evanchooly", "createdAt": "2020-11-05T21:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODAxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r518388011", "bodyText": "everything seems to be passing now.  I've done a little bit of pom clean up where we had redundant deps.  it helped me to better track where the changes needed to be made to resolve some of the envers bits.", "author": "evanchooly", "createdAt": "2020-11-05T21:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1Njk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg3MjQzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r511872435", "bodyText": "Again, this is public API, you can't remove that.", "author": "FroMage", "createdAt": "2020-10-26T10:53:03Z", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/Panache.java", "diffHunk": "@@ -38,36 +36,4 @@\n         return getSession().withTransaction(t -> work.get());\n     }\n \n-    /**\n-     * Executes a database update operation and return the number of rows operated on.\n-     * \n-     * @param query a normal HQL query\n-     * @param params optional list of indexed parameters\n-     * @return the number of rows operated on.\n-     */\n-    public static Uni<Integer> executeUpdate(String query, Object... params) {", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3NTU0NA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512075544", "bodyText": "We have two elements in typeArguments right? And we just put them in right above, so this stream is pretty weird, so is the block below.", "author": "FroMage", "createdAt": "2020-10-26T16:00:04Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheEntityClassVisitor.java", "diffHunk": "@@ -145,58 +185,122 @@ public void visitEnd() {\n         super.visitEnd();\n     }\n \n+    protected void discoverTypeParameters(ClassInfo classInfo, IndexView indexView, TypeBundle types, ByteCodeType baseType) {\n+        List<ByteCodeType> foundTypeArguments = recursivelyFindEntityTypeArguments(indexView,\n+                classInfo.name(), baseType.dotName());\n+\n+        ByteCodeType entityType = (foundTypeArguments.size() > 0) ? foundTypeArguments.get(0) : OBJECT;\n+        ByteCodeType idType = (foundTypeArguments.size() > 1) ? foundTypeArguments.get(1) : OBJECT;\n+\n+        typeArguments.put(\"Entity\", entityType);\n+        typeArguments.put(\"Id\", idType);\n+        typeArguments.keySet().stream()", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3NjU0OA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512076548", "bodyText": "name1?", "author": "FroMage", "createdAt": "2020-10-26T16:01:22Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheEntityClassVisitor.java", "diffHunk": "@@ -145,58 +185,122 @@ public void visitEnd() {\n         super.visitEnd();\n     }\n \n+    protected void discoverTypeParameters(ClassInfo classInfo, IndexView indexView, TypeBundle types, ByteCodeType baseType) {\n+        List<ByteCodeType> foundTypeArguments = recursivelyFindEntityTypeArguments(indexView,\n+                classInfo.name(), baseType.dotName());\n+\n+        ByteCodeType entityType = (foundTypeArguments.size() > 0) ? foundTypeArguments.get(0) : OBJECT;\n+        ByteCodeType idType = (foundTypeArguments.size() > 1) ? foundTypeArguments.get(1) : OBJECT;\n+\n+        typeArguments.put(\"Entity\", entityType);\n+        typeArguments.put(\"Id\", idType);\n+        typeArguments.keySet().stream()\n+                .filter(k -> !k.equals(\"Id\"))\n+                .forEach(k -> erasures.put(k, OBJECT.descriptor()));\n+        try {\n+            ByteCodeType entity = typeArguments.get(\"Entity\");\n+            if (entity != null) {\n+                erasures.put(entity.dotName().toString(), entity.descriptor());\n+            }\n+            erasures.put(types.queryType().dotName().toString(), OBJECT.descriptor());\n+            erasures.put(types.updateType().dotName().toString(), OBJECT.descriptor());\n+        } catch (UnsupportedOperationException ignored) {\n+        }\n+    }\n+\n     protected void generateMethod(MethodInfo method, AnnotationValue targetReturnTypeErased) {\n-        String descriptor = AsmUtil.getDescriptor(method, name -> null);\n-        String signature = AsmUtil.getSignature(method, name -> null);\n         List<org.jboss.jandex.Type> parameters = method.parameters();\n-        String castTo = null;\n-        if (targetReturnTypeErased != null && targetReturnTypeErased.asBoolean()) {\n-            castTo = method.returnType().name().toString('/');\n-        }\n \n         MethodVisitor mv = super.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,\n                 method.name(),\n-                descriptor,\n-                signature,\n+                AsmUtil.getDescriptor(method, name -> null),\n+                AsmUtil.getSignature(method, name1 -> null),", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDI0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512080247", "bodyText": "Are you sure a primitive maps to the Object descriptor?", "author": "FroMage", "createdAt": "2020-10-26T16:06:29Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheEntityClassVisitor.java", "diffHunk": "@@ -145,58 +185,122 @@ public void visitEnd() {\n         super.visitEnd();\n     }\n \n+    protected void discoverTypeParameters(ClassInfo classInfo, IndexView indexView, TypeBundle types, ByteCodeType baseType) {\n+        List<ByteCodeType> foundTypeArguments = recursivelyFindEntityTypeArguments(indexView,\n+                classInfo.name(), baseType.dotName());\n+\n+        ByteCodeType entityType = (foundTypeArguments.size() > 0) ? foundTypeArguments.get(0) : OBJECT;\n+        ByteCodeType idType = (foundTypeArguments.size() > 1) ? foundTypeArguments.get(1) : OBJECT;\n+\n+        typeArguments.put(\"Entity\", entityType);\n+        typeArguments.put(\"Id\", idType);\n+        typeArguments.keySet().stream()\n+                .filter(k -> !k.equals(\"Id\"))\n+                .forEach(k -> erasures.put(k, OBJECT.descriptor()));\n+        try {\n+            ByteCodeType entity = typeArguments.get(\"Entity\");\n+            if (entity != null) {\n+                erasures.put(entity.dotName().toString(), entity.descriptor());\n+            }\n+            erasures.put(types.queryType().dotName().toString(), OBJECT.descriptor());\n+            erasures.put(types.updateType().dotName().toString(), OBJECT.descriptor());\n+        } catch (UnsupportedOperationException ignored) {\n+        }\n+    }\n+\n     protected void generateMethod(MethodInfo method, AnnotationValue targetReturnTypeErased) {\n-        String descriptor = AsmUtil.getDescriptor(method, name -> null);\n-        String signature = AsmUtil.getSignature(method, name -> null);\n         List<org.jboss.jandex.Type> parameters = method.parameters();\n-        String castTo = null;\n-        if (targetReturnTypeErased != null && targetReturnTypeErased.asBoolean()) {\n-            castTo = method.returnType().name().toString('/');\n-        }\n \n         MethodVisitor mv = super.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,\n                 method.name(),\n-                descriptor,\n-                signature,\n+                AsmUtil.getDescriptor(method, name -> null),\n+                AsmUtil.getSignature(method, name1 -> null),\n                 null);\n         AsmUtil.copyParameterNames(mv, method);\n         mv.visitCode();\n         for (PanacheMethodCustomizer customizer : methodCustomizers) {\n             customizer.customize(thisClass, method, mv);\n         }\n-        // inject model\n+        loadOperations(mv);\n+        loadArguments(mv, parameters);\n+        invokeOperations(mv, method);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void loadOperations(MethodVisitor mv) {\n+        mv.visitFieldInsn(Opcodes.GETSTATIC, typeBundle.operations().internalName(), \"INSTANCE\",\n+                typeBundle.operations().descriptor());\n+    }\n+\n+    private void loadArguments(MethodVisitor mv, List<org.jboss.jandex.Type> parameters) {\n+        // inject Class\n         injectModel(mv);\n         for (int i = 0; i < parameters.size(); i++) {\n             mv.visitIntInsn(Opcodes.ALOAD, i);\n         }\n-        // inject Class\n-        String forwardingDescriptor = \"(\" + getModelDescriptor() + descriptor.substring(1);\n-        if (castTo != null) {\n-            // return type is erased to Object\n-            int lastParen = forwardingDescriptor.lastIndexOf(')');\n-            forwardingDescriptor = forwardingDescriptor.substring(0, lastParen + 1) + \"Ljava/lang/Object;\";\n-        }\n-        invokeOperation(method, mv, forwardingDescriptor);\n-        if (castTo != null)\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, castTo);\n-        String returnTypeDescriptor = descriptor.substring(descriptor.lastIndexOf(\")\") + 1);\n-        mv.visitInsn(AsmUtil.getReturnInstruction(returnTypeDescriptor));\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n     }\n \n-    protected void invokeOperation(MethodInfo method, MethodVisitor mv, String forwardingDescriptor) {\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC,\n-                getPanacheOperationsInternalName(),\n-                method.name(),\n-                forwardingDescriptor, false);\n+    private void invokeOperations(MethodVisitor mv, MethodInfo method) {\n+        String operationDescriptor;\n+\n+        StringJoiner joiner = new StringJoiner(\"\", \"(\", \")\");\n+        joiner.add(CLASS.descriptor());\n+        descriptors(method, joiner);\n+\n+        org.jboss.jandex.Type returnType = method.returnType();\n+        String descriptor = getDescriptor(returnType, argMapper);\n+        String key = returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                ? returnType.asTypeVariable().identifier()\n+                : returnType.name().toString();\n+        operationDescriptor = joiner + erasures.getOrDefault(key, descriptor);\n+\n+        mv.visitMethodInsn(INVOKEVIRTUAL, typeBundle.operations().internalName(), method.name(),\n+                operationDescriptor, false);\n+        if (returnType.kind() != org.jboss.jandex.Type.Kind.PRIMITIVE) {\n+            String cast;\n+            if (returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE) {\n+                TypeVariable typeVariable = returnType.asTypeVariable();\n+                ByteCodeType type = typeArguments.get(typeVariable.identifier());\n+                if (type == null && typeVariable.bounds().size() != 1) {\n+                    type = OBJECT;\n+                } else {\n+                    type = new ByteCodeType(typeVariable.bounds().get(0));\n+                }\n+                cast = type.internalName();\n+            } else {\n+                cast = returnType.name().toString().replace('.', '/');\n+            }\n+            mv.visitTypeInsn(CHECKCAST, cast);\n+        }\n+        mv.visitInsn(AsmUtil.getReturnInstruction(returnType));\n     }\n \n-    protected String getModelDescriptor() {\n-        return \"Ljava/lang/Class;\";\n+    private void descriptors(MethodInfo method, StringJoiner joiner) {\n+        for (org.jboss.jandex.Type parameter : method.parameters()) {\n+            if (parameter.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                    || method.name().endsWith(\"ById\")\n+                            && parameter.name().equals(typeArguments.get(\"Id\").dotName())) {\n+                joiner.add(OBJECT.descriptor());\n+            } else {\n+                joiner.add(mapType(parameter));\n+            }\n+        }\n     }\n \n-    protected abstract String getPanacheOperationsInternalName();\n+    private String mapType(org.jboss.jandex.Type parameter) {\n+        String descriptor;\n+        switch (parameter.kind()) {\n+            case PRIMITIVE:\n+            case TYPE_VARIABLE:", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MjExNg==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512192116", "bodyText": "I'll double check the context but reasonably comfortable with it since everything works.  but it wouldn't hurt to double check.", "author": "evanchooly", "createdAt": "2020-10-26T18:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcxNTU2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512715563", "bodyText": "Yes.  In this case this is specific to Kotlin and how nullability is implemented.  An ID type might be Int but it's represented in the byte code as if it were an int in java.  so when mapping the entity api to the operations api, we need to map those primitive bytecode values to Object to resolve the generic method signature for the operation to invoke.", "author": "evanchooly", "createdAt": "2020-10-27T13:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDg2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512080861", "bodyText": "That looks like a weird special case when we have the list of typeArguments", "author": "FroMage", "createdAt": "2020-10-26T16:07:21Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheEntityClassVisitor.java", "diffHunk": "@@ -145,58 +185,122 @@ public void visitEnd() {\n         super.visitEnd();\n     }\n \n+    protected void discoverTypeParameters(ClassInfo classInfo, IndexView indexView, TypeBundle types, ByteCodeType baseType) {\n+        List<ByteCodeType> foundTypeArguments = recursivelyFindEntityTypeArguments(indexView,\n+                classInfo.name(), baseType.dotName());\n+\n+        ByteCodeType entityType = (foundTypeArguments.size() > 0) ? foundTypeArguments.get(0) : OBJECT;\n+        ByteCodeType idType = (foundTypeArguments.size() > 1) ? foundTypeArguments.get(1) : OBJECT;\n+\n+        typeArguments.put(\"Entity\", entityType);\n+        typeArguments.put(\"Id\", idType);\n+        typeArguments.keySet().stream()\n+                .filter(k -> !k.equals(\"Id\"))\n+                .forEach(k -> erasures.put(k, OBJECT.descriptor()));\n+        try {\n+            ByteCodeType entity = typeArguments.get(\"Entity\");\n+            if (entity != null) {\n+                erasures.put(entity.dotName().toString(), entity.descriptor());\n+            }\n+            erasures.put(types.queryType().dotName().toString(), OBJECT.descriptor());\n+            erasures.put(types.updateType().dotName().toString(), OBJECT.descriptor());\n+        } catch (UnsupportedOperationException ignored) {\n+        }\n+    }\n+\n     protected void generateMethod(MethodInfo method, AnnotationValue targetReturnTypeErased) {\n-        String descriptor = AsmUtil.getDescriptor(method, name -> null);\n-        String signature = AsmUtil.getSignature(method, name -> null);\n         List<org.jboss.jandex.Type> parameters = method.parameters();\n-        String castTo = null;\n-        if (targetReturnTypeErased != null && targetReturnTypeErased.asBoolean()) {\n-            castTo = method.returnType().name().toString('/');\n-        }\n \n         MethodVisitor mv = super.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,\n                 method.name(),\n-                descriptor,\n-                signature,\n+                AsmUtil.getDescriptor(method, name -> null),\n+                AsmUtil.getSignature(method, name1 -> null),\n                 null);\n         AsmUtil.copyParameterNames(mv, method);\n         mv.visitCode();\n         for (PanacheMethodCustomizer customizer : methodCustomizers) {\n             customizer.customize(thisClass, method, mv);\n         }\n-        // inject model\n+        loadOperations(mv);\n+        loadArguments(mv, parameters);\n+        invokeOperations(mv, method);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void loadOperations(MethodVisitor mv) {\n+        mv.visitFieldInsn(Opcodes.GETSTATIC, typeBundle.operations().internalName(), \"INSTANCE\",\n+                typeBundle.operations().descriptor());\n+    }\n+\n+    private void loadArguments(MethodVisitor mv, List<org.jboss.jandex.Type> parameters) {\n+        // inject Class\n         injectModel(mv);\n         for (int i = 0; i < parameters.size(); i++) {\n             mv.visitIntInsn(Opcodes.ALOAD, i);\n         }\n-        // inject Class\n-        String forwardingDescriptor = \"(\" + getModelDescriptor() + descriptor.substring(1);\n-        if (castTo != null) {\n-            // return type is erased to Object\n-            int lastParen = forwardingDescriptor.lastIndexOf(')');\n-            forwardingDescriptor = forwardingDescriptor.substring(0, lastParen + 1) + \"Ljava/lang/Object;\";\n-        }\n-        invokeOperation(method, mv, forwardingDescriptor);\n-        if (castTo != null)\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, castTo);\n-        String returnTypeDescriptor = descriptor.substring(descriptor.lastIndexOf(\")\") + 1);\n-        mv.visitInsn(AsmUtil.getReturnInstruction(returnTypeDescriptor));\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n     }\n \n-    protected void invokeOperation(MethodInfo method, MethodVisitor mv, String forwardingDescriptor) {\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC,\n-                getPanacheOperationsInternalName(),\n-                method.name(),\n-                forwardingDescriptor, false);\n+    private void invokeOperations(MethodVisitor mv, MethodInfo method) {\n+        String operationDescriptor;\n+\n+        StringJoiner joiner = new StringJoiner(\"\", \"(\", \")\");\n+        joiner.add(CLASS.descriptor());\n+        descriptors(method, joiner);\n+\n+        org.jboss.jandex.Type returnType = method.returnType();\n+        String descriptor = getDescriptor(returnType, argMapper);\n+        String key = returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                ? returnType.asTypeVariable().identifier()\n+                : returnType.name().toString();\n+        operationDescriptor = joiner + erasures.getOrDefault(key, descriptor);\n+\n+        mv.visitMethodInsn(INVOKEVIRTUAL, typeBundle.operations().internalName(), method.name(),\n+                operationDescriptor, false);\n+        if (returnType.kind() != org.jboss.jandex.Type.Kind.PRIMITIVE) {\n+            String cast;\n+            if (returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE) {\n+                TypeVariable typeVariable = returnType.asTypeVariable();\n+                ByteCodeType type = typeArguments.get(typeVariable.identifier());\n+                if (type == null && typeVariable.bounds().size() != 1) {\n+                    type = OBJECT;\n+                } else {\n+                    type = new ByteCodeType(typeVariable.bounds().get(0));\n+                }\n+                cast = type.internalName();\n+            } else {\n+                cast = returnType.name().toString().replace('.', '/');\n+            }\n+            mv.visitTypeInsn(CHECKCAST, cast);\n+        }\n+        mv.visitInsn(AsmUtil.getReturnInstruction(returnType));\n     }\n \n-    protected String getModelDescriptor() {\n-        return \"Ljava/lang/Class;\";\n+    private void descriptors(MethodInfo method, StringJoiner joiner) {\n+        for (org.jboss.jandex.Type parameter : method.parameters()) {\n+            if (parameter.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                    || method.name().endsWith(\"ById\")", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcxNjU4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512716581", "bodyText": "This is essentially the same case as above and how nulllables are handled for \"primitive\" types.", "author": "evanchooly", "createdAt": "2020-10-27T14:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MTUzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512081539", "bodyText": "Same remarks as for the other visitor.", "author": "FroMage", "createdAt": "2020-10-26T16:08:18Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheRepositoryClassVisitor.java", "diffHunk": "@@ -65,70 +67,65 @@ protected void injectModel(MethodVisitor mv) {\n     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n         super.visit(version, access, name, signature, superName, interfaces);\n \n-        final String repositoryClassName = name.replace('/', '.');\n+        DotName baseType = typeBundle.repositoryBase().dotName();\n \n-        String[] foundTypeArguments = findEntityTypeArgumentsForPanacheRepository(indexView, repositoryClassName,\n-                getPanacheRepositoryBaseDotName());\n+        List<TypeVariable> typeVariables = indexView.getClassByName(baseType).typeParameters();\n+        entityUpperBound = !typeVariables.isEmpty()\n+                ? new ByteCodeType(typeVariables.get(0).bounds().get(0))\n+                : OBJECT;\n \n-        entityBinaryType = foundTypeArguments[0];\n-        entitySignature = \"L\" + entityBinaryType + \";\";\n-        this.entityType = Type.getType(entitySignature);\n-        idBinaryType = foundTypeArguments[1];\n-        idSignature = \"L\" + idBinaryType + \";\";\n-        Type idType = Type.getType(idSignature);\n+        discoverTypeParameters(daoClassInfo, indexView, typeBundle, typeBundle.repositoryBase());\n \n-        typeArguments.put(\"Entity\", this.entityType.getDescriptor());\n-        typeArguments.put(\"Id\", idType.getDescriptor());\n-        this.panacheRepositoryBaseClassInfo = indexView.getClassByName(getPanacheRepositoryBaseDotName());\n-    }\n+        this.entityType = typeArguments.getOrDefault(\"Entity\", OBJECT).type();\n \n-    @Override\n-    public MethodVisitor visitMethod(int access, String methodName, String descriptor, String signature,\n-            String[] exceptions) {\n-        userMethods.add(methodName + \"/\" + descriptor);\n-        return super.visitMethod(access, methodName, descriptor, signature, exceptions);\n-    }\n+        this.panacheRepositoryBaseClassInfo = indexView.getClassByName(baseType);\n \n-    public static String[] findEntityTypeArgumentsForPanacheRepository(IndexView indexView,\n-            String repositoryClassName,\n-            DotName repositoryDotName) {\n-        for (ClassInfo classInfo : indexView.getAllKnownImplementors(repositoryDotName)) {\n-            if (repositoryClassName.equals(classInfo.name().toString())) {\n-                return recursivelyFindEntityTypeArgumentsFromClass(indexView, classInfo.name(), repositoryDotName);\n-            }\n-        }\n+        argMapper = type -> {\n+            ByteCodeType byteCodeType = typeArguments.get(type);\n+            return byteCodeType != null\n+                    ? byteCodeType.descriptor()\n+                    : type;\n+        };\n \n-        return null;\n     }\n \n-    public static String[] recursivelyFindEntityTypeArgumentsFromClass(IndexView indexView, DotName clazz,\n-            DotName repositoryDotName) {\n-        if (clazz.equals(JandexUtil.DOTNAME_OBJECT)) {\n-            return null;\n+    protected void discoverTypeParameters(ClassInfo classInfo, IndexView indexView, TypeBundle types, ByteCodeType baseType) {\n+        List<ByteCodeType> foundTypeArguments = recursivelyFindEntityTypeArguments(indexView,\n+                classInfo.name(), baseType.dotName());\n+\n+        ByteCodeType entityType = (foundTypeArguments.size() > 0) ? foundTypeArguments.get(0) : OBJECT;\n+        ByteCodeType idType = (foundTypeArguments.size() > 1) ? foundTypeArguments.get(1) : OBJECT;\n+\n+        typeArguments.put(\"Entity\", entityType);", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MjY3NA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512192674", "bodyText": "I believe that stems from whether or not the ID is parameterized or not which does vary from java to kotlin and jpa to mongodb", "author": "evanchooly", "createdAt": "2020-10-26T18:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4OTI2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512089265", "bodyText": "Same remark as for the other visitor.", "author": "FroMage", "createdAt": "2020-10-26T16:19:08Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheRepositoryClassVisitor.java", "diffHunk": "@@ -202,53 +199,90 @@ protected void generateJvmBridge(MethodInfo method) {\n \n     }\n \n-    protected void generateModelBridge(MethodInfo method, AnnotationValue targetReturnTypeErased) {\n-        String descriptor = AsmUtil.getDescriptor(method, name -> typeArguments.get(name));\n+    protected void generateModelBridge(MethodInfo method) {\n         // JpaOperations erases the Id type to Object\n-        String descriptorForJpaOperations = AsmUtil.getDescriptor(method,\n-                name -> name.equals(\"Entity\") ? entitySignature : null);\n-        String signature = AsmUtil.getSignature(method, name -> typeArguments.get(name));\n         List<org.jboss.jandex.Type> parameters = method.parameters();\n \n-        String castTo = null;\n-        if (targetReturnTypeErased != null && targetReturnTypeErased.asBoolean()) {\n-            org.jboss.jandex.Type type = method.returnType();\n-            if (type.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE &&\n-                    type.asTypeVariable().identifier().equals(\"Entity\")) {\n-                castTo = entityBinaryType;\n-            }\n-            if (castTo == null)\n-                castTo = type.name().toString('/');\n-        }\n-\n         // Note: we can't use SYNTHETIC here because otherwise Mockito will never mock these methods\n         MethodVisitor mv = super.visitMethod(Opcodes.ACC_PUBLIC,\n                 method.name(),\n-                descriptor,\n-                signature,\n+                AsmUtil.getDescriptor(method, argMapper),\n+                AsmUtil.getSignature(method, argMapper),\n                 null);\n         AsmUtil.copyParameterNames(mv, method);\n         mv.visitCode();\n+        loadOperations(mv);\n+        loadArguments(parameters, mv);\n+        invokeOperations(mv, method);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void invokeOperations(MethodVisitor mv, MethodInfo method) {\n+        String operationDescriptor;\n+\n+        StringJoiner joiner = new StringJoiner(\"\", \"(\", \")\");\n+        joiner.add(CLASS.descriptor());\n+        descriptors(method, joiner);\n+\n+        org.jboss.jandex.Type returnType = method.returnType();\n+        String descriptor = getDescriptor(returnType, argMapper);\n+        String key = returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                ? returnType.asTypeVariable().identifier()\n+                : returnType.name().toString();\n+        operationDescriptor = joiner + erasures.getOrDefault(key, descriptor);\n+\n+        mv.visitMethodInsn(INVOKEVIRTUAL, typeBundle.operations().internalName(), method.name(),\n+                operationDescriptor, false);\n+        if (returnType.kind() != org.jboss.jandex.Type.Kind.PRIMITIVE) {\n+            String cast;\n+            if (returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE) {\n+                ByteCodeType type = typeArguments.getOrDefault(returnType.asTypeVariable().identifier(), entityUpperBound);\n+                cast = type.internalName();\n+            } else {\n+                cast = returnType.name().toString().replace('.', '/');\n+            }\n+            mv.visitTypeInsn(CHECKCAST, cast);\n+        }\n+        mv.visitInsn(AsmUtil.getReturnInstruction(returnType));\n+    }\n+\n+    private void descriptors(MethodInfo method, StringJoiner joiner) {\n+        for (org.jboss.jandex.Type parameter : method.parameters()) {\n+            if (parameter.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                    || method.name().endsWith(\"ById\")\n+                            && parameter.name().equals(typeArguments.get(\"Id\").dotName())) {", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4OTQxOA==", "url": "https://github.com/quarkusio/quarkus/pull/11724#discussion_r512089418", "bodyText": "Same remark as for the other visitor.", "author": "FroMage", "createdAt": "2020-10-26T16:19:22Z", "path": "extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/PanacheRepositoryClassVisitor.java", "diffHunk": "@@ -202,53 +199,90 @@ protected void generateJvmBridge(MethodInfo method) {\n \n     }\n \n-    protected void generateModelBridge(MethodInfo method, AnnotationValue targetReturnTypeErased) {\n-        String descriptor = AsmUtil.getDescriptor(method, name -> typeArguments.get(name));\n+    protected void generateModelBridge(MethodInfo method) {\n         // JpaOperations erases the Id type to Object\n-        String descriptorForJpaOperations = AsmUtil.getDescriptor(method,\n-                name -> name.equals(\"Entity\") ? entitySignature : null);\n-        String signature = AsmUtil.getSignature(method, name -> typeArguments.get(name));\n         List<org.jboss.jandex.Type> parameters = method.parameters();\n \n-        String castTo = null;\n-        if (targetReturnTypeErased != null && targetReturnTypeErased.asBoolean()) {\n-            org.jboss.jandex.Type type = method.returnType();\n-            if (type.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE &&\n-                    type.asTypeVariable().identifier().equals(\"Entity\")) {\n-                castTo = entityBinaryType;\n-            }\n-            if (castTo == null)\n-                castTo = type.name().toString('/');\n-        }\n-\n         // Note: we can't use SYNTHETIC here because otherwise Mockito will never mock these methods\n         MethodVisitor mv = super.visitMethod(Opcodes.ACC_PUBLIC,\n                 method.name(),\n-                descriptor,\n-                signature,\n+                AsmUtil.getDescriptor(method, argMapper),\n+                AsmUtil.getSignature(method, argMapper),\n                 null);\n         AsmUtil.copyParameterNames(mv, method);\n         mv.visitCode();\n+        loadOperations(mv);\n+        loadArguments(parameters, mv);\n+        invokeOperations(mv, method);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void invokeOperations(MethodVisitor mv, MethodInfo method) {\n+        String operationDescriptor;\n+\n+        StringJoiner joiner = new StringJoiner(\"\", \"(\", \")\");\n+        joiner.add(CLASS.descriptor());\n+        descriptors(method, joiner);\n+\n+        org.jboss.jandex.Type returnType = method.returnType();\n+        String descriptor = getDescriptor(returnType, argMapper);\n+        String key = returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                ? returnType.asTypeVariable().identifier()\n+                : returnType.name().toString();\n+        operationDescriptor = joiner + erasures.getOrDefault(key, descriptor);\n+\n+        mv.visitMethodInsn(INVOKEVIRTUAL, typeBundle.operations().internalName(), method.name(),\n+                operationDescriptor, false);\n+        if (returnType.kind() != org.jboss.jandex.Type.Kind.PRIMITIVE) {\n+            String cast;\n+            if (returnType.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE) {\n+                ByteCodeType type = typeArguments.getOrDefault(returnType.asTypeVariable().identifier(), entityUpperBound);\n+                cast = type.internalName();\n+            } else {\n+                cast = returnType.name().toString().replace('.', '/');\n+            }\n+            mv.visitTypeInsn(CHECKCAST, cast);\n+        }\n+        mv.visitInsn(AsmUtil.getReturnInstruction(returnType));\n+    }\n+\n+    private void descriptors(MethodInfo method, StringJoiner joiner) {\n+        for (org.jboss.jandex.Type parameter : method.parameters()) {\n+            if (parameter.kind() == org.jboss.jandex.Type.Kind.TYPE_VARIABLE\n+                    || method.name().endsWith(\"ById\")\n+                            && parameter.name().equals(typeArguments.get(\"Id\").dotName())) {\n+                joiner.add(OBJECT.descriptor());\n+            } else {\n+                joiner.add(mapType(parameter));\n+            }\n+        }\n+    }\n+\n+    private String mapType(org.jboss.jandex.Type parameter) {\n+        String descriptor;\n+        switch (parameter.kind()) {\n+            case PRIMITIVE:", "originalCommit": "ee7f8957e5b43895057916d6a16bddc153f56981", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d247d8270d176932a24610b700845761978789a1", "url": "https://github.com/quarkusio/quarkus/commit/d247d8270d176932a24610b700845761978789a1", "message": "refactoring to common code", "committedDate": "2020-11-03T15:01:40Z", "type": "forcePushed"}, {"oid": "eca5ada3807ddd9cbc39ec713cbc371ee571d822", "url": "https://github.com/quarkusio/quarkus/commit/eca5ada3807ddd9cbc39ec713cbc371ee571d822", "message": "finally tracked down conflicting deps", "committedDate": "2020-11-05T17:21:53Z", "type": "forcePushed"}, {"oid": "2a182cd020de5ba429521d41bd00d7846325add8", "url": "https://github.com/quarkusio/quarkus/commit/2a182cd020de5ba429521d41bd00d7846325add8", "message": "refactoring to common code", "committedDate": "2020-11-05T22:46:57Z", "type": "forcePushed"}, {"oid": "5d4e39d2d93c3e3a0fa69ae4a72a4af0c8aa9be3", "url": "https://github.com/quarkusio/quarkus/commit/5d4e39d2d93c3e3a0fa69ae4a72a4af0c8aa9be3", "message": "refactoring to common code", "committedDate": "2020-11-05T23:53:50Z", "type": "forcePushed"}, {"oid": "fea10581c12c6523b2c92b053e7e25ac0932486d", "url": "https://github.com/quarkusio/quarkus/commit/fea10581c12c6523b2c92b053e7e25ac0932486d", "message": "refactoring to common code", "committedDate": "2020-11-09T20:47:45Z", "type": "forcePushed"}, {"oid": "2b7f0c397d064f6dd1ebd466179aa61d6a33a121", "url": "https://github.com/quarkusio/quarkus/commit/2b7f0c397d064f6dd1ebd466179aa61d6a33a121", "message": "refactoring to common code", "committedDate": "2020-11-10T18:01:29Z", "type": "commit"}, {"oid": "2b7f0c397d064f6dd1ebd466179aa61d6a33a121", "url": "https://github.com/quarkusio/quarkus/commit/2b7f0c397d064f6dd1ebd466179aa61d6a33a121", "message": "refactoring to common code", "committedDate": "2020-11-10T18:01:29Z", "type": "forcePushed"}]}