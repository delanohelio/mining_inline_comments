{"pr_number": 11217, "pr_title": "ArC - cleanup and optimizations", "pr_createdAt": "2020-08-05T06:55:38Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11217", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNTE5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465635192", "bodyText": "Wondering if we should make beans a LinkedHashSet instead? Not sure how iterating on the bean list for each synthetic bean will slow us down at bootstrap for large number of beans.", "author": "gsmet", "createdAt": "2020-08-05T10:42:15Z", "path": "independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java", "diffHunk": "@@ -966,6 +966,13 @@ private RegistrationContext registerSyntheticBeans(List<BeanRegistrar> beanRegis\n     }\n \n     private void addSyntheticBean(BeanInfo bean) {\n+        for (BeanInfo b : beans) {", "originalCommit": "edb01354f80f0d5cb72ccd885a9eafc67f2cd859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0MjMwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465642305", "bodyText": "Hm, we do iterate over all beans quite often and since a typical quarkus apps will have hundreds of beans at most I don't think it's worth the effort...", "author": "mkouba", "createdAt": "2020-08-05T10:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNjgyOA==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465636828", "bodyText": "I'm surprised by the ifFalse here?", "author": "gsmet", "createdAt": "2020-08-05T10:45:50Z", "path": "independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java", "diffHunk": "@@ -1606,6 +1614,36 @@ protected void implementGetIdentifier(BeanInfo bean, ClassCreator beanCreator) {\n         getScope.returnValue(getScope.load(bean.getIdentifier()));\n     }\n \n+    protected void implementEquals(BeanInfo bean, ClassCreator beanCreator) {\n+        MethodCreator equals = beanCreator.getMethodCreator(\"equals\", boolean.class, Object.class).setModifiers(ACC_PUBLIC);\n+        // if (this == obj) {\n+        //    return true;\n+        // }\n+        equals.ifFalse(equals.invokeStaticMethod(MethodDescriptors.OBJECTS_REFERENCE_EQUALS, equals.getThis(),", "originalCommit": "edb01354f80f0d5cb72ccd885a9eafc67f2cd859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0Mzk1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465643951", "bodyText": "Great catch! ;-)", "author": "mkouba", "createdAt": "2020-08-05T11:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNjgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzODk1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465638953", "bodyText": "Could we avoid the lambda in runtime code?", "author": "gsmet", "createdAt": "2020-08-05T10:50:06Z", "path": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/ComputingCache.java", "diffHunk": "@@ -21,18 +22,42 @@\n public class ComputingCache<K, V> {\n \n     private final ConcurrentMap<K, LazyValue<V>> map;\n+    private final Function<K, V> computingFunction;\n \n-    private final Function<K, LazyValue<V>> function;\n+    /**\n+     * Note that {@link #getValue(Object)} cannot be used if no default computing function is specified.\n+     */\n+    public ComputingCache() {\n+        this(null);\n+    }\n \n     public ComputingCache(Function<K, V> computingFunction) {\n         this.map = new ConcurrentHashMap<>();\n-        this.function = new CacheFunction(computingFunction);\n+        this.computingFunction = computingFunction;\n     }\n \n     public V getValue(K key) {\n+        return computeIfAbsent(key, computingFunction);\n+    }\n+\n+    public V getValueIfPresent(K key) {\n+        LazyValue<V> value = map.get(key);\n+        return value != null ? value.getIfPresent() : null;\n+    }\n+\n+    public V computeIfAbsent(K key,\n+            Function<? super K, ? extends V> computingFunction) {\n+        return computeIfAbsent(key, () -> computingFunction.apply(key));", "originalCommit": "edb01354f80f0d5cb72ccd885a9eafc67f2cd859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0NTUyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465645529", "bodyText": "Of course we could ;-). Although we used lambdas even before this PR...", "author": "mkouba", "createdAt": "2020-08-05T11:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzODk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzOTIzNA==", "url": "https://github.com/quarkusio/quarkus/pull/11217#discussion_r465639234", "bodyText": "Could we avoid the lambda in runtime code?", "author": "gsmet", "createdAt": "2020-08-05T10:50:37Z", "path": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/AbstractSharedContext.java", "diffHunk": "@@ -5,30 +5,31 @@\n import io.quarkus.arc.InjectableContext;\n import java.util.Iterator;\n import java.util.Map;\n-import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import javax.enterprise.context.spi.Contextual;\n import javax.enterprise.context.spi.CreationalContext;\n \n abstract class AbstractSharedContext implements InjectableContext, InjectableContext.ContextState {\n \n-    private final ComputingCache<Key<?>, ContextInstanceHandle<?>> instances;\n+    private final ComputingCache<String, ContextInstanceHandle<?>> instances;\n \n     public AbstractSharedContext() {\n-        this.instances = new ComputingCache<>(AbstractSharedContext::createInstanceHandle);\n+        this.instances = new ComputingCache<>();\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> T get(Contextual<T> contextual, CreationalContext<T> creationalContext) {\n-        return (T) instances.getValue(new Key<>(contextual, creationalContext)).get();\n+        InjectableBean<T> bean = (InjectableBean<T>) contextual;\n+        return (T) instances.computeIfAbsent(bean.getIdentifier(), () -> createInstanceHandle(bean, creationalContext)).get();", "originalCommit": "edb01354f80f0d5cb72ccd885a9eafc67f2cd859", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "98b0e6509fcad0dde90263cf8c3f9c163dfee8cf", "url": "https://github.com/quarkusio/quarkus/commit/98b0e6509fcad0dde90263cf8c3f9c163dfee8cf", "message": "ArC - cleanup and optimizations\n\n- AbstractSharedContext - replace Key with bean identifier\n- ComputingCache - add computeIfAbsent() methods\n- Generated beans implement equals()/hashCode() (based on bean\nidentifier)\n- fail fast if multiple synthetic beans have the same bean identifier", "committedDate": "2020-08-05T11:09:28Z", "type": "commit"}, {"oid": "98b0e6509fcad0dde90263cf8c3f9c163dfee8cf", "url": "https://github.com/quarkusio/quarkus/commit/98b0e6509fcad0dde90263cf8c3f9c163dfee8cf", "message": "ArC - cleanup and optimizations\n\n- AbstractSharedContext - replace Key with bean identifier\n- ComputingCache - add computeIfAbsent() methods\n- Generated beans implement equals()/hashCode() (based on bean\nidentifier)\n- fail fast if multiple synthetic beans have the same bean identifier", "committedDate": "2020-08-05T11:09:28Z", "type": "forcePushed"}]}