{"pr_number": 10221, "pr_title": "Reactive sql client pool in thread local", "pr_createdAt": "2020-06-24T11:58:25Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10221", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444848142", "bodyText": "I'm not too familiar with loggers and junit extensions, but isn't this going to leak in the testsuite?\nLooks like it will keep adding new InMemoryLogHandler instances, and also it's not emptying each of them after usage. I suppose the rootLogger is a global static so this might get nasty?", "author": "Sanne", "createdAt": "2020-06-24T12:11:04Z", "path": "test-framework/junit5-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java", "diffHunk": "@@ -110,6 +127,7 @@ public Object createTestInstance(TestInstanceFactoryContext factoryContext, Exte\n \n     @Override\n     public void beforeEach(ExtensionContext extensionContext) throws Exception {\n+        rootLogger.addHandler(inMemoryLogHandler);", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2MTI3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444861275", "bodyText": "@geoand any opinion? I copied this from your QuarkusProdModeTest.", "author": "FroMage", "createdAt": "2020-06-24T12:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2NjEwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444866109", "bodyText": "In QuarkusProdModeTest this is done in beforeAll, is there any specific reason why it was added to beforeEach here?", "author": "geoand", "createdAt": "2020-06-24T12:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2NzI3MA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444867270", "bodyText": "Having it in beforeAll might be slightly better, but would still leak no?", "author": "Sanne", "createdAt": "2020-06-24T12:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2Nzg4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444867881", "bodyText": "Sorry I don't follow, what would leak?", "author": "geoand", "createdAt": "2020-06-24T12:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2ODMyNA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444868324", "bodyText": "Maybe just add it in a static block, so you're sure it's done once across the whole classloader.\nThen, I'd use an \"afterEach\" or \"afterAll\" to clear its contents after each unit of testing.", "author": "Sanne", "createdAt": "2020-06-24T12:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3MTQxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444871411", "bodyText": "Sorry I don't follow, what would leak?\n\nI suspect two leaks, although I haven't debugged this and I'm not too familiar with this code so I might be wrong:\n\n\nThe root logger is a global static instance, so each time we invoke addHandler we're adding more and more loghandlers.\n\n\neach such logHandler will keep containing all messages, from since it was added to the root onwards - so also all text generated from other tests running later in the testsuite.", "author": "Sanne", "createdAt": "2020-06-24T12:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3NTQyMw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444875423", "bodyText": "@geoand I've put it where we start the dev mode, which is in \"beforeEach\", while the prod test is started in \"beforeAll\".", "author": "FroMage", "createdAt": "2020-06-24T13:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3NzIwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444877205", "bodyText": "I've now removed it in afterEach, should be enough no?", "author": "FroMage", "createdAt": "2020-06-24T13:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3OTYwNw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444879607", "bodyText": "That isn't really needed because each time a the extension is run (that is each time we write a QuarkusDevModeTest or QuarkusProdModeTest), the handler that is used for that test replaces the global static.", "author": "geoand", "createdAt": "2020-06-24T13:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MTcwNA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444881704", "bodyText": "the handler that is used for that test replaces the global static.\n\nBut the private static final Logger rootLogger; isn't replaced is it? Or is each test running in its own classloader?", "author": "Sanne", "createdAt": "2020-06-24T13:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg5NTUwOA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444895508", "bodyText": "The rootLogger is the same for all tests (they don't run in isolared classloaders), but because each test replaces it, it shouldn't be a problem.\nThere could be an issue when running QuarkusDevModeTest other tests inside the same test execution (read surefire execution) as in that case indeed the handler set from QuarkusDevModeTest will persist.\nSo the safest thing would indeed be to restore the original handlers.\nShould just be a matter of calling and saving getHandlers before addHandler and then in the afterAll, restoring the handlers using setHandlers (after casting to org.jboss.logmanager.Logger).\nWould you like me to do that @FroMage or do you want to include it here?\nAll in all, although it's unlikely to cause a problem, we should fix it and it's a very good catch @Sanne", "author": "geoand", "createdAt": "2020-06-24T13:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4ODA2MA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444988060", "bodyText": "I'm still not understanding what you mean by \"but because each test replaces it, it shouldn't be a problem\" but it's ok, we can avoid blocking this PR just because I don't get it :)\nWith @FroMage having added the afterEach I'm happy.", "author": "Sanne", "createdAt": "2020-06-24T15:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk5Njg0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444996847", "bodyText": "I mean that each new instance of QuarkusDevModeTest will provide a new handler thus replacing the old one.\nBut for sure the best solution is to get a hold of the initial handlers in beforeAll and then restore them in afterAll", "author": "geoand", "createdAt": "2020-06-24T15:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk5ODU1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444998555", "bodyText": "it's adding handlers, not replacing existing ones.", "author": "Sanne", "createdAt": "2020-06-24T15:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3Njk4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445076983", "bodyText": "I'll take care of this in a separate PR", "author": "geoand", "createdAt": "2020-06-24T18:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMTAzMw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445501033", "bodyText": "#10262", "author": "geoand", "createdAt": "2020-06-25T11:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODgyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444848825", "bodyText": "what is the goal of this replacement? Might need a comment?", "author": "Sanne", "createdAt": "2020-06-24T12:12:31Z", "path": "integration-tests/reactive-pg-client/src/test/java/io/quarkus/it/reactive/pg/client/HotReloadTestCase.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package io.quarkus.it.reactive.pg.client;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.logging.LogRecord;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.test.QuarkusDevModeTest;\n+\n+public class HotReloadTestCase {\n+    @RegisterExtension\n+    final static QuarkusDevModeTest TEST = new QuarkusDevModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(HotReloadFruitResource.class)\n+                    .addAsResource(\"application-tl.properties\", \"application.properties\"))\n+            .setLogRecordPredicate(record -> {\n+                return record.getLoggerName().startsWith(\"io.quarkus.reactive.datasource\");\n+            });\n+\n+    @AfterAll\n+    public static void afterAll() {\n+        List<LogRecord> records = TEST.getLogRecords();\n+        Assertions.assertEquals(8, records.size());\n+        // make sure that we closed all thread-local pools on reload and close\n+        Assertions.assertEquals(\"Making pool for thread: %s\", records.get(0).getMessage());\n+        Assertions.assertEquals(\"Making pool for thread: %s\", records.get(1).getMessage());\n+        Assertions.assertEquals(\"Closing pool: %s\", records.get(2).getMessage());\n+        Assertions.assertEquals(\"Closing pool: %s\", records.get(3).getMessage());\n+        Assertions.assertEquals(\"Making pool for thread: %s\", records.get(4).getMessage());\n+        Assertions.assertEquals(\"Making pool for thread: %s\", records.get(5).getMessage());\n+        Assertions.assertEquals(\"Closing pool: %s\", records.get(6).getMessage());\n+        Assertions.assertEquals(\"Closing pool: %s\", records.get(7).getMessage());\n+    }\n+\n+    @Test\n+    public void testAddNewFieldToEntity() {\n+        checkRequest(\"Orange\");\n+        TEST.modifySourceFile(HotReloadFruitResource.class, new Function<String, String>() {\n+            @Override\n+            public String apply(String s) {\n+                return s.replace(\"'Orange'\", \"'Strawberry'\");\n+            }\n+        });\n+        TEST.modifyResourceFile(\"application.properties\", new Function<String, String>() {\n+            @Override\n+            public String apply(String s) {\n+                return s.replace(\"quarkus.datasource.reactive.thread-local=true\",\n+                        \"quarkus.datasource.reactive.thread-local = true\");", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2MTQwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444861409", "bodyText": "Just to trigger a hot reload.", "author": "FroMage", "createdAt": "2020-06-24T12:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2MjEwOA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444862108", "bodyText": "Please add a comment. And is the change to the entity not enought to trigger one?", "author": "Sanne", "createdAt": "2020-06-24T12:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3NzU2OA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444877568", "bodyText": "No, it does not reload the pools. The entity change is to verify that a reload happened. I've added a comment.", "author": "FroMage", "createdAt": "2020-06-24T13:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg5MTU5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444891597", "bodyText": "Ok thanks. Off topic, but I wonder if we should improve on that: the configuration isn't really different so there shouldn't be any need to reload :)", "author": "Sanne", "createdAt": "2020-06-24T13:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0ODgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0OTY4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444849685", "bodyText": "make it final ?", "author": "Sanne", "createdAt": "2020-06-24T12:14:17Z", "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/ThreadLocalPgPool.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package io.quarkus.reactive.pg.client.runtime;\n+\n+import io.quarkus.reactive.datasource.runtime.ThreadLocalPool;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.PgPool;\n+import io.vertx.sqlclient.PoolOptions;\n+\n+public class ThreadLocalPgPool extends ThreadLocalPool<PgPool> implements PgPool {\n+\n+    private PgConnectOptions pgConnectOptions;", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0OTg2OA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444849868", "bodyText": "I think it requires final", "author": "Sanne", "createdAt": "2020-06-24T12:14:37Z", "path": "extensions/reactive-mysql-client/runtime/src/main/java/io/quarkus/reactive/mysql/client/runtime/ThreadLocalMySQLPool.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package io.quarkus.reactive.mysql.client.runtime;\n+\n+import io.quarkus.reactive.datasource.runtime.ThreadLocalPool;\n+import io.vertx.core.Vertx;\n+import io.vertx.mysqlclient.MySQLConnectOptions;\n+import io.vertx.mysqlclient.MySQLPool;\n+import io.vertx.sqlclient.PoolOptions;\n+\n+public class ThreadLocalMySQLPool extends ThreadLocalPool<MySQLPool> implements MySQLPool {\n+\n+    private MySQLConnectOptions mySQLConnectOptions;", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MDA4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444850089", "bodyText": "Needs final", "author": "Sanne", "createdAt": "2020-06-24T12:15:03Z", "path": "extensions/reactive-db2-client/runtime/src/main/java/io/quarkus/reactive/db2/client/runtime/ThreadLocalDB2Pool.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package io.quarkus.reactive.db2.client.runtime;\n+\n+import io.quarkus.reactive.datasource.runtime.ThreadLocalPool;\n+import io.vertx.core.Vertx;\n+import io.vertx.db2client.DB2ConnectOptions;\n+import io.vertx.db2client.DB2Pool;\n+import io.vertx.sqlclient.PoolOptions;\n+\n+public class ThreadLocalDB2Pool extends ThreadLocalPool<DB2Pool> implements DB2Pool {\n+\n+    private DB2ConnectOptions db2ConnectOptions;", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MTI1MA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444851250", "bodyText": "This will likely need either volatile or an AtomicReference ?\nI'd suggest using an AtomicReference, so that we can grab & clear it atomically and make sure no other concurreent user manages to race within the close().", "author": "Sanne", "createdAt": "2020-06-24T12:17:19Z", "path": "extensions/reactive-datasource/runtime/src/main/java/io/quarkus/reactive/datasource/runtime/ThreadLocalPool.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.reactive.datasource.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.sqlclient.Pool;\n+import io.vertx.sqlclient.PoolOptions;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlConnection;\n+import io.vertx.sqlclient.Transaction;\n+\n+public abstract class ThreadLocalPool<PoolType extends Pool> implements Pool {\n+\n+    private static final Logger log = Logger.getLogger(ThreadLocalPool.class);\n+\n+    private ThreadLocal<PoolType> pool = new ThreadLocal<>();", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2NzU1MA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444867550", "bodyText": "OK done", "author": "FroMage", "createdAt": "2020-06-24T12:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MjQzNw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444852437", "bodyText": "Seems like this need to be a Vector, and final. Or just final and synchronized..", "author": "Sanne", "createdAt": "2020-06-24T12:19:35Z", "path": "extensions/reactive-datasource/runtime/src/main/java/io/quarkus/reactive/datasource/runtime/ThreadLocalPool.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.reactive.datasource.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.sqlclient.Pool;\n+import io.vertx.sqlclient.PoolOptions;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlConnection;\n+import io.vertx.sqlclient.Transaction;\n+\n+public abstract class ThreadLocalPool<PoolType extends Pool> implements Pool {\n+\n+    private static final Logger log = Logger.getLogger(ThreadLocalPool.class);\n+\n+    private ThreadLocal<PoolType> pool = new ThreadLocal<>();\n+    private static List<Pool> threadLocalPools = new ArrayList<>();", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg2NzM1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444867355", "bodyText": "I added some synchronization, is it enough?", "author": "FroMage", "createdAt": "2020-06-24T12:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MjQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3NjIzOA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444876238", "bodyText": "Looks good. I found one more possible race, but I don't think it's possible in practice: one thread might be doing pool() and could get a live reference to the tlocal while another thread is closing.\nThis shouldn't happen while we're closing so I'd say this is good enough - I might send a follow-up PR just for fun :)", "author": "Sanne", "createdAt": "2020-06-24T13:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MjQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3ODEwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444878101", "bodyText": "Fair enough :)", "author": "FroMage", "createdAt": "2020-06-24T13:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MjQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1MjYzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r444852639", "bodyText": "Best to make these both final as well.", "author": "Sanne", "createdAt": "2020-06-24T12:19:56Z", "path": "extensions/reactive-datasource/runtime/src/main/java/io/quarkus/reactive/datasource/runtime/ThreadLocalPool.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.reactive.datasource.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.sqlclient.Pool;\n+import io.vertx.sqlclient.PoolOptions;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlConnection;\n+import io.vertx.sqlclient.Transaction;\n+\n+public abstract class ThreadLocalPool<PoolType extends Pool> implements Pool {\n+\n+    private static final Logger log = Logger.getLogger(ThreadLocalPool.class);\n+\n+    private ThreadLocal<PoolType> pool = new ThreadLocal<>();\n+    private static List<Pool> threadLocalPools = new ArrayList<>();\n+\n+    protected PoolOptions poolOptions;\n+    protected Vertx vertx;", "originalCommit": "307b35ad2918c56b8b817fee5604a426938f8742", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f66f865d7ce2d77ddb5d0223ce123c21bbec1803", "url": "https://github.com/quarkusio/quarkus/commit/f66f865d7ce2d77ddb5d0223ce123c21bbec1803", "message": "Added a setting to turn the reactive Pools into thread-local pools\n\nOnly tested it for pg-client because they all use the same code", "committedDate": "2020-06-24T12:46:53Z", "type": "forcePushed"}, {"oid": "0c0b348ef0d46cba42de7ab9221679e01b614cdf", "url": "https://github.com/quarkusio/quarkus/commit/0c0b348ef0d46cba42de7ab9221679e01b614cdf", "message": "QuarkusDevModeTest: added ability to collect logs", "committedDate": "2020-06-24T13:03:52Z", "type": "commit"}, {"oid": "d2433d84651bbb714b4bafd8a2a2b8cf7734f36c", "url": "https://github.com/quarkusio/quarkus/commit/d2433d84651bbb714b4bafd8a2a2b8cf7734f36c", "message": "Added a setting to turn the reactive Pools into thread-local pools", "committedDate": "2020-06-24T13:03:52Z", "type": "commit"}, {"oid": "d2433d84651bbb714b4bafd8a2a2b8cf7734f36c", "url": "https://github.com/quarkusio/quarkus/commit/d2433d84651bbb714b4bafd8a2a2b8cf7734f36c", "message": "Added a setting to turn the reactive Pools into thread-local pools", "committedDate": "2020-06-24T13:03:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNzc0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445417749", "bodyText": "This could be a copy on write list and relieve from synchronization, given the list will not change often.", "author": "tsegismont", "createdAt": "2020-06-25T09:10:32Z", "path": "extensions/reactive-datasource/runtime/src/main/java/io/quarkus/reactive/datasource/runtime/ThreadLocalPool.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package io.quarkus.reactive.datasource.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.sqlclient.Pool;\n+import io.vertx.sqlclient.PoolOptions;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlConnection;\n+import io.vertx.sqlclient.Transaction;\n+\n+public abstract class ThreadLocalPool<PoolType extends Pool> implements Pool {\n+\n+    private static final Logger log = Logger.getLogger(ThreadLocalPool.class);\n+\n+    private final AtomicReference<ThreadLocal<PoolType>> pool = new AtomicReference<>(new ThreadLocal<>());\n+    private static final List<Pool> threadLocalPools = new ArrayList<>();", "originalCommit": "d2433d84651bbb714b4bafd8a2a2b8cf7734f36c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMDk5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445430995", "bodyText": "+1 that's probably a good idea.", "author": "Sanne", "createdAt": "2020-06-25T09:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNzc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMjU0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445432549", "bodyText": "BTW github UI seems confusing: we're now commenting on FroMage 's original PR but looking at the version of code I had modified further in a follow-up PR..  weird.", "author": "Sanne", "createdAt": "2020-06-25T09:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNzc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzNTgwMA==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445435800", "bodyText": "ah nevermind, for some reason it looked like my follow up PR. Please check the new version, now in master ;)", "author": "Sanne", "createdAt": "2020-06-25T09:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNzc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMDI1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445420253", "bodyText": "Since you have an AtomicReference, you could use compare and swap and avoid adding a superfluous ThreadLocalPool to the list if two threads execute this part concurrently.", "author": "tsegismont", "createdAt": "2020-06-25T09:15:02Z", "path": "extensions/reactive-datasource/runtime/src/main/java/io/quarkus/reactive/datasource/runtime/ThreadLocalPool.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package io.quarkus.reactive.datasource.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.sqlclient.Pool;\n+import io.vertx.sqlclient.PoolOptions;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlConnection;\n+import io.vertx.sqlclient.Transaction;\n+\n+public abstract class ThreadLocalPool<PoolType extends Pool> implements Pool {\n+\n+    private static final Logger log = Logger.getLogger(ThreadLocalPool.class);\n+\n+    private final AtomicReference<ThreadLocal<PoolType>> pool = new AtomicReference<>(new ThreadLocal<>());\n+    private static final List<Pool> threadLocalPools = new ArrayList<>();\n+\n+    protected final PoolOptions poolOptions;\n+    protected final Vertx vertx;\n+\n+    public ThreadLocalPool(Vertx vertx, PoolOptions poolOptions) {\n+        this.vertx = vertx;\n+        this.poolOptions = poolOptions;\n+    }\n+\n+    private PoolType pool() {\n+        ThreadLocal<PoolType> poolThreadLocal = pool.get();\n+        PoolType ret = poolThreadLocal.get();\n+        if (ret == null) {", "originalCommit": "d2433d84651bbb714b4bafd8a2a2b8cf7734f36c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzQ2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445473463", "bodyText": "+1 I've done something similar in the follow-up PR, I was more concerned about making sure we'd not leak than getting most performance out of it: having chatted with @johnaohara we believe there's actually room for a better design (similar to what Agroal and Hikari have) and we should do that, but then contribute it into the pgclient project.", "author": "Sanne", "createdAt": "2020-06-25T10:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10221#discussion_r445574682", "bodyText": "Ok, looking forward to it", "author": "tsegismont", "createdAt": "2020-06-25T13:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMDI1Mw=="}], "type": "inlineReview"}]}