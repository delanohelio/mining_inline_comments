{"pr_number": 11331, "pr_title": "Minimal *-deployment dependencies for integration-tests", "pr_createdAt": "2020-08-11T17:37:10Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11331", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r468757928", "bodyText": "Example:\n$ mvn clean validate -f integration-tests/cache/\n[INFO] Scanning for projects...\n[INFO]\n[INFO] -------------< io.quarkus:quarkus-integration-test-cache >--------------\n[INFO] Building Quarkus - Integration Tests - Cache 999-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:3.1.0:clean (default-clean) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce-java-version) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce-maven-version) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce-deployment-deps) @ quarkus-integration-test-cache ---\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-junit5:jar:999-SNAPSHOT:test\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-resteasy-jsonb:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-hibernate-orm-panache:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-cache:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-smallrye-context-propagation:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-jdbc-h2:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-test-h2:jar:999-SNAPSHOT:test\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n\nThe warnings vanish when test is used instead of validate and the build will fail (because some deployment deps are missing).\nThis is not ideal, but I'd say it is sufficient for what the rule is supposed to do, which is to enforce the build order primarily in CI.\nCI will always use a \"late\" phase/goal (at least test).", "author": "famod", "createdAt": "2020-08-11T17:49:08Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        Map<String, Artifact> nonDeploymentQuarkusArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> artifact.getGroupId().equals(GROUP_ID_FILTER))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(\"-deployment\"))\n+                .collect(Collectors.toMap(a -> a.getGroupId() + \":\" + a.getArtifactId() + \":\" + a.getVersion(), a -> a));\n+\n+        String missingDeploymentDeps = nonDeploymentQuarkusArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directQuarkusDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinimalDeploymentDepPresent(deploymentGAV, directQuarkusDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.joining(\"\\n    \"));\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            throw new EnforcerRuleException(\"The following *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps\n+                    + \"\\n\\nEach of these dependencies has to be configured as follows to get a consistent build order:\\n\"\n+                    + \"    <dependency>\\n\"\n+                    + \"        <groupId>GROUP-IP</groupId>\\n\"\n+                    + \"        <artifactId>ARTIFACT-ID</artifactId>\\n\"\n+                    + \"        <version>${project.version}</version>\\n\"\n+                    + \"        <type>pom</type>\\n\"\n+                    + \"        <scope>test</scope>\\n\"\n+                    + \"        <exclusions>\\n\"\n+                    + \"            <exclusion>\\n\"\n+                    + \"                <groupId>*</groupId>\\n\"\n+                    + \"                <artifactId>*</artifactId>\\n\"\n+                    + \"            </exclusion>\\n\"\n+                    + \"        </exclusions>\\n\"\n+                    + \"    </dependency>\");\n+        }\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        if (!artifact.isResolved()) {\n+            // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+            // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+            logger.warn(\"Artifact is not resolved, consider using a later build goal like 'package': \" + artifact);", "originalCommit": "b606b3670d63f2389796bb519be51dee6ac2ff30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExMjYwNg==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469112606", "bodyText": "@famod , do I understand it correctly test  vs validate makes difference only if you build the whole project and not when you only select -f integration-tests/cache/?", "author": "michalszynkiewicz", "createdAt": "2020-08-12T09:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0NDE2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469544166", "bodyText": "It also makes a difference when building the entire project.\nmvn validate called from root would then log many warnings, but failing the build just because artifacts have not yet been resolved would be worse, IMO.\nTo me, this is an edge case, because usually everyone (including CI) is at least using compile, test, package or even install.\nI could also squash this into a single warning making it less noisy. WDYT?", "author": "famod", "createdAt": "2020-08-12T21:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxNDczNw==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473314737", "bodyText": "I squashed it to a single message for less noise, e.g.:\n[INFO] --- maven-enforcer-plugin:3.0.0-M2:enforce (enforce-deployment-deps) @ quarkus-integration-test-cache ---\n[WARNING] Skipping rule RequiresMinimalDeploymentDependency: Artifacts are not resolved, consider using a later build goal like 'package'.", "author": "famod", "createdAt": "2020-08-19T20:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1OTcxNA==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r468759714", "bodyText": "Note: This shall avoid re-checking for (and eventually re-parsing of) quarkus-extension.properties for dependencies that are used multiple times throughout the entire build reactor.", "author": "famod", "createdAt": "2020-08-11T17:52:00Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();", "originalCommit": "b606b3670d63f2389796bb519be51dee6ac2ff30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTM2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469021369", "bodyText": "It would be good to have some message for this exception", "author": "michalszynkiewicz", "createdAt": "2020-08-12T05:56:30Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);", "originalCommit": "b606b3670d63f2389796bb519be51dee6ac2ff30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyOTI4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469529282", "bodyText": "This should never happen but you are right, adding a message is best practise.", "author": "famod", "createdAt": "2020-08-12T20:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMjQxNg==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473312416", "bodyText": "Message added as suggested.", "author": "famod", "createdAt": "2020-08-19T20:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469031553", "bodyText": "just a note, I'm wondering if startsWith won't be safer here (and in line 55) in case we e.g. wanted to move grpc stuff to io.quarkus.grpc", "author": "michalszynkiewicz", "createdAt": "2020-08-12T06:25:41Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))", "originalCommit": "b606b3670d63f2389796bb519be51dee6ac2ff30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMjMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473312315", "bodyText": "Replaced with startsWith as suggested.", "author": "famod", "createdAt": "2020-08-19T20:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473954377", "bodyText": "This is a bit fishy, but I had to introduce this check for at least one it-submodule (forgot the name).\nIt almost feels like that submodule is violating the \"no runtime deps in deployment modules\" rule...", "author": "famod", "createdAt": "2020-08-20T13:06:50Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"\n+                    + requiredDeps);\n+        }\n+    }\n+\n+    private String buildGAVKey(Artifact artifact) {\n+        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        File artifactFile = artifact.getFile();\n+        if (artifactFile == null || !artifactFile.exists()) {\n+            throw new IllegalStateException(\"Artifact file not found for \" + artifact);\n+        }\n+\n+        Properties extProperties = new Properties();\n+        try (ZipFile zipFile = new ZipFile(artifactFile)) {\n+            ZipEntry entry = zipFile.getEntry(EXT_PROPERTIES_PATH);\n+            if (entry == null) {\n+                return Optional.empty();\n+            }\n+            extProperties.load(new InputStreamReader(zipFile.getInputStream(entry), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to read \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile, e);\n+        }\n+\n+        String deploymentGAV = extProperties.getProperty(\"deployment-artifact\");\n+        if (deploymentGAV == null) {\n+            throw new IllegalStateException(\n+                    \"deployment-artifact artifact not found in \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile);\n+        }\n+        return Optional.of(deploymentGAV);\n+    }\n+\n+    private boolean isMinDeploymentDepPresent(String deploymentGAV, String projArtifactKey,\n+            Map<String, Dependency> directDepsByGAV) {\n+        return deploymentGAV.equals(projArtifactKey) // special case: current project itself is the \"required dependency\"", "originalCommit": "849fd61afbcda043afb07565aacbf6575c1f0a55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMzk5NA==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475423994", "bodyText": "I think the rule is opposite, \"no deployment deps in runtime modules\", and if there's a violation, then I guess we really want to know :-) Though I'm not sure if this indicates violation of that rule.", "author": "Ladicek", "createdAt": "2020-08-24T08:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNTA3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475435073", "bodyText": "\"no deployment deps in runtime modules\" makes sense as well but I meant: #11174", "author": "famod", "createdAt": "2020-08-24T08:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NTI1OA==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475445258", "bodyText": "Ah interesting, I didn't know about that one! Thanks.", "author": "Ladicek", "createdAt": "2020-08-24T09:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwNzUyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477707525", "bodyText": "I just realized that #11174 is about runtime dependencies of other extensions.\nIt is perfectly valid (and required!) that the deployment module of an extension A has a dependency on the runtime artifact of extension A.\nIt would not be valid if that deployment module would depend on the runtime artifact of an extension B!\nLong story short: This check is not \"fishy\". I reworded #11174 a little for clarification.", "author": "famod", "createdAt": "2020-08-26T23:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475422282", "bodyText": "I'd just remove the \"Symbolic\" part, they are in no way symbolic, they are perfectly real :-) And their purpose is explained by \"for consistent build order\". We could add something like (not needed for any other reason) to the end, but I think that wouldn't be necessary.", "author": "Ladicek", "createdAt": "2020-08-24T08:23:36Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d,\n+                        (a, b) -> a));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"", "originalCommit": "760ecadc9c783a18e2f3be9a843571eeceba18eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyNzQ1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475427459", "bodyText": "Glad you see it this way because I was not entirely happy with \"symbolic\" vs./+ \"minimal\" either.\nHow about replacing \"Symbolic\" with \"Minimal\", hinting at the rule class and adding some javadoc to the rule?", "author": "famod", "createdAt": "2020-08-24T08:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NjU4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475446582", "bodyText": "Minimal makes a lot more sense, as the enforcer rule attempts to find a minimal set of -deployment dependencies to add. I personally don't think it's necessary, but I'll leave it to you :-)", "author": "Ladicek", "createdAt": "2020-08-24T09:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNTk4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r476315983", "bodyText": "Done.", "author": "famod", "createdAt": "2020-08-25T09:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477621228", "bodyText": "One thing to keep in mind for the future is other extension projects (out there in the community) may want to benefit from this too. In which case GROUP_ID_PREFIX should be either configurable or simply removed in favor of a different approach. E.g. these artifacts are supposed to be resolved at this point, aren't they? We could simply check for the presence of the extension descriptor and also filter based on the resolved path (to collect only those that are found in the current workspace).", "author": "aloubyansky", "createdAt": "2020-08-26T22:20:02Z", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+/**\n+ * Enforces that for each direct \"runtime\" dependency the current project also defines a direct minimal \"*-deployment\"\n+ * dependency to produce a consistent build order.\n+ */\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));", "originalCommit": "3260a3f5ce255e113aaeda090f914339e93da602", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyNzkwMA==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477627900", "bodyText": "E.g. these artifacts are supposed to be resolved at this point, aren't they?\n\nYes!\n\nIn which case GROUP_ID_PREFIX should be either configurable\n\nRules can have parameters so this would be pretty simple, yes.\n\nWe could simply check for the presence of the extension descriptor\n\nIf I understood you correctly, this would mean we would \"open\" each jar artifact to check whether it contains a descriptor file. This will come at a price, but maybe it is just a few additional milliseconds in the end.\n\nalso filter based on the resolved path (to collect only those that are found in the current workspace)\n\nCertainly possible but I see problems when building only a subtree of the repo (reactor does not contain all modules in this case).", "author": "famod", "createdAt": "2020-08-26T22:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEwNDA3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r478104076", "bodyText": "I don't think checking for the presence of the descriptor will be a bottle neck. We are actually doing this check everywhere where we are analyzing the classpath.\nAs to the subtree, you could use Quarkus bootstrap MavenArtifactResolver instead. There we discover the workspace and it'll work consistently for every build phase and won't depend on the module which was targeted by the mvn cli. I've done this trick in other mojos.", "author": "aloubyansky", "createdAt": "2020-08-27T04:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDQ4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r478354481", "bodyText": "As to the subtree, you could use Quarkus bootstrap MavenArtifactResolver instead\n\nI actually thought about that when I hit that artifact resolve problem but I decided for KISS until we really, really need it.\nIn the current form, the rule is really \"independent\".", "author": "famod", "createdAt": "2020-08-27T11:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA=="}], "type": "inlineReview"}, {"oid": "5658025582f8738280bbd74136c50f911cf8b3f6", "url": "https://github.com/quarkusio/quarkus/commit/5658025582f8738280bbd74136c50f911cf8b3f6", "message": "Minimal *-deployment dependencies for integration-tests + enforcer rule\n\nFixes #10859 by enforcing a consistent build order.\n\nPresence of such minimal dependencies is enforced by the new RequiresMinimalDeploymentDependency rule.\n\nMore details: https://github.com/quarkusio/quarkus/pull/11331#issuecomment-680306828", "committedDate": "2020-08-26T22:47:00Z", "type": "commit"}, {"oid": "82cc7dcef550128834e91bc3b82d96c78af5d801", "url": "https://github.com/quarkusio/quarkus/commit/82cc7dcef550128834e91bc3b82d96c78af5d801", "message": "Update maven-enforcer-plugin from 3.0.0-M2 to -M3", "committedDate": "2020-08-26T22:47:56Z", "type": "commit"}]}