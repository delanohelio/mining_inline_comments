{"pr_number": 8726, "pr_title": "Add support for enabling CDI beans based on build time properties", "pr_createdAt": "2020-04-21T12:52:23Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8726", "timeline": [{"oid": "9e3dd7890f7e692afe57a3a4f955122cdac9f55c", "url": "https://github.com/quarkusio/quarkus/commit/9e3dd7890f7e692afe57a3a4f955122cdac9f55c", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-21T13:45:54Z", "type": "forcePushed"}, {"oid": "7e447e79d058f240a2715778d7702bb4b47d5720", "url": "https://github.com/quarkusio/quarkus/commit/7e447e79d058f240a2715778d7702bb4b47d5720", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-21T14:26:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMjEyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412812129", "bodyText": "matche -> matches\nbuilt -> build", "author": "manovotn", "createdAt": "2020-04-22T09:13:00Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -109,8 +117,82 @@ public void transform(TransformationContext ctx) {\n         }));\n     }\n \n+    /**\n+     * Uses {@link AnnotationsTransformer} to do the following:\n+     *\n+     * Adds the {@code @Alternative} annotation to any class or producer that is annotated with {code @IfBuildProperty}\n+     * when the value of property specified by the annotation does not matche the user defined built time property.", "originalCommit": "7e447e79d058f240a2715778d7702bb4b47d5720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5MDU3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412890575", "bodyText": "Fixed both", "author": "geoand", "createdAt": "2020-04-22T11:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMjEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMjI3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412812277", "bodyText": "built -> build", "author": "manovotn", "createdAt": "2020-04-22T09:13:13Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -109,8 +117,82 @@ public void transform(TransformationContext ctx) {\n         }));\n     }\n \n+    /**\n+     * Uses {@link AnnotationsTransformer} to do the following:\n+     *\n+     * Adds the {@code @Alternative} annotation to any class or producer that is annotated with {code @IfBuildProperty}\n+     * when the value of property specified by the annotation does not matche the user defined built time property.\n+     *\n+     * Adds the {@code @AlternativePriority} annotation to any class or producer that is annotated with\n+     * {code @IfBuildProperty} when the value of property specified by the annotation matches the user defined built time", "originalCommit": "7e447e79d058f240a2715778d7702bb4b47d5720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5MDQ5NA==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412890494", "bodyText": "Fixed", "author": "geoand", "createdAt": "2020-04-22T11:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMzU1MA==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412813550", "bodyText": "springValue? :-)", "author": "manovotn", "createdAt": "2020-04-22T09:15:03Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -109,8 +117,82 @@ public void transform(TransformationContext ctx) {\n         }));\n     }\n \n+    /**\n+     * Uses {@link AnnotationsTransformer} to do the following:\n+     *\n+     * Adds the {@code @Alternative} annotation to any class or producer that is annotated with {code @IfBuildProperty}\n+     * when the value of property specified by the annotation does not matche the user defined built time property.\n+     *\n+     * Adds the {@code @AlternativePriority} annotation to any class or producer that is annotated with\n+     * {code @IfBuildProperty} when the value of property specified by the annotation matches the user defined built time\n+     * property.\n+     *\n+     * This effectively means that a bean annotated with {@code @IfBuildProperty} is only enabled when\n+     * the property specified in the annotation matches the actual value of the build property.\n+     */\n+    @BuildStep\n+    void ifBuildProperty(BuildProducer<AnnotationsTransformerBuildItem> annotationsTransformer) {\n+        annotationsTransformer.produce(new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD || kind == AnnotationTarget.Kind.CLASS\n+                        || kind == AnnotationTarget.Kind.FIELD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext ctx) {\n+                AnnotationInstance annotationInstance = find(ctx.getAnnotations(), IF_BUILD_PROPERTY);\n+                if (annotationInstance == null) {\n+                    return;\n+                }\n+\n+                String propertyName = annotationInstance.value(\"name\").asString();\n+                String expectedSpringValue = annotationInstance.value(\"stringValue\").asString();", "originalCommit": "7e447e79d058f240a2715778d7702bb4b47d5720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5MDMzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412890335", "bodyText": "Haha, I just can't get away from Spring :)\nFixed", "author": "geoand", "createdAt": "2020-04-22T11:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMzU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNDUyOA==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412814528", "bodyText": "I'd also add a line that mentions that by default if the property is missing you don't enable the bean but it's configurable.", "author": "manovotn", "createdAt": "2020-04-22T09:16:20Z", "path": "extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package io.quarkus.arc.properties;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * When applied to a bean class or producer method (or field), the bean will only be enabled\n+ * if the Quarkus build time property matches the provided value.", "originalCommit": "7e447e79d058f240a2715778d7702bb4b47d5720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5MDY1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412890657", "bodyText": "Done", "author": "geoand", "createdAt": "2020-04-22T11:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNDUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNTEwMg==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412815102", "bodyText": "bean is to enabled -> bean is to be enabled\nhas not specified  -> has not been specified", "author": "manovotn", "createdAt": "2020-04-22T09:17:07Z", "path": "extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package io.quarkus.arc.properties;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * When applied to a bean class or producer method (or field), the bean will only be enabled\n+ * if the Quarkus build time property matches the provided value.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ ElementType.METHOD, ElementType.TYPE, ElementType.FIELD })\n+public @interface IfBuildProperty {\n+\n+    /**\n+     * Name of the build time property to check\n+     */\n+    String name();\n+\n+    /**\n+     * Expected {@code String} value of the build time property (specified by {@code name}) if the bean is to be enabled\n+     */\n+    String stringValue();\n+\n+    /**\n+     * Determines if the bean is to enabled when the property name specified by {@code name} has not specified at all", "originalCommit": "7e447e79d058f240a2715778d7702bb4b47d5720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5MDgxMw==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r412890813", "bodyText": "Fixed both", "author": "geoand", "createdAt": "2020-04-22T11:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNTEwMg=="}], "type": "inlineReview"}, {"oid": "8eee53f9ef914094c412628eddf349b214eeb510", "url": "https://github.com/quarkusio/quarkus/commit/8eee53f9ef914094c412628eddf349b214eeb510", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-22T11:12:07Z", "type": "forcePushed"}, {"oid": "96d17f5fed5a248a22648e71ddc76e3fc361a23d", "url": "https://github.com/quarkusio/quarkus/commit/96d17f5fed5a248a22648e71ddc76e3fc361a23d", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-22T11:19:14Z", "type": "forcePushed"}, {"oid": "627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "url": "https://github.com/quarkusio/quarkus/commit/627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-22T13:12:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MTU2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413751562", "bodyText": "I wonder if it makes to place this annotation in a separate package? I think that it would make sense to place all of them (@IfBuildProfile) in a single package?", "author": "mkouba", "createdAt": "2020-04-23T11:54:58Z", "path": "extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package io.quarkus.arc.properties;", "originalCommit": "627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc4NDQxMA==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413784410", "bodyText": "Problem is that @IfBuildProfile is under io.quarkus.arc.profile. That would make things weird, no?", "author": "geoand", "createdAt": "2020-04-23T12:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MTU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1NTcxMw==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r414355713", "bodyText": "Hm, yes, You're right.", "author": "mkouba", "createdAt": "2020-04-24T07:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MTU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MTkxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413751915", "bodyText": "Wrong logger class?", "author": "mkouba", "createdAt": "2020-04-23T11:55:33Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package io.quarkus.arc.deployment;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.Transformation;\n+import io.quarkus.arc.profile.IfBuildProfile;\n+import io.quarkus.arc.profile.UnlessBuildProfile;\n+import io.quarkus.arc.properties.IfBuildProperty;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.runtime.configuration.ProfileManager;\n+\n+public class BuildTimeEnabledProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AutoInjectFieldProcessor.class);", "originalCommit": "627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc4OTYzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413789631", "bodyText": "Fixed", "author": "geoand", "createdAt": "2020-04-23T12:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MzA1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413753051", "bodyText": "Hm, the key for fieldTargets is String...", "author": "mkouba", "createdAt": "2020-04-23T11:57:23Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package io.quarkus.arc.deployment;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.Transformation;\n+import io.quarkus.arc.profile.IfBuildProfile;\n+import io.quarkus.arc.profile.UnlessBuildProfile;\n+import io.quarkus.arc.properties.IfBuildProperty;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.runtime.configuration.ProfileManager;\n+\n+public class BuildTimeEnabledProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AutoInjectFieldProcessor.class);\n+\n+    private static final DotName IF_BUILD_PROFILE = DotName.createSimple(IfBuildProfile.class.getName());\n+    private static final DotName UNLESS_BUILD_PROFILE = DotName.createSimple(UnlessBuildProfile.class.getName());\n+\n+    private static final DotName IF_BUILD_PROPERTY = DotName.createSimple(IfBuildProperty.class.getName());\n+\n+    @BuildStep\n+    void ifBuildProfile(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {\n+        Collection<AnnotationInstance> annotationInstances = index.getIndex().getAnnotations(IF_BUILD_PROFILE);\n+        for (AnnotationInstance instance : annotationInstances) {\n+            String profileOnInstance = instance.value().asString();\n+            boolean enabled = profileOnInstance.equals(ProfileManager.getActiveProfile());\n+            if (enabled) {\n+                LOGGER.debug(\"Enabling \" + instance + \" since the profile value matches the active profile.\");\n+            } else {\n+                LOGGER.debug(\"Disabling \" + instance + \" since the profile value does not match the active profile.\");\n+            }\n+            producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled));\n+        }\n+    }\n+\n+    @BuildStep\n+    void unlessBuildProfile(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {\n+        Collection<AnnotationInstance> annotationInstances = index.getIndex().getAnnotations(UNLESS_BUILD_PROFILE);\n+        for (AnnotationInstance instance : annotationInstances) {\n+            String profileOnInstance = instance.value().asString();\n+            boolean enabled = !profileOnInstance.equals(ProfileManager.getActiveProfile());\n+            if (enabled) {\n+                LOGGER.debug(\"Enabling \" + instance + \" since the profile value does not match the active profile.\");\n+            } else {\n+                LOGGER.debug(\"Disabling \" + instance + \" since the profile value matches the active profile.\");\n+            }\n+            producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled));\n+        }\n+    }\n+\n+    @BuildStep\n+    void ifBuildProperty(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {\n+        Config config = ConfigProviderResolver.instance().getConfig();\n+        Collection<AnnotationInstance> annotationInstances = index.getIndex().getAnnotations(IF_BUILD_PROPERTY);\n+        for (AnnotationInstance instance : annotationInstances) {\n+            String propertyName = instance.value(\"name\").asString();\n+            String expectedStringValue = instance.value(\"stringValue\").asString();\n+            AnnotationValue enableIfMissingValue = instance.value(\"enableIfMissing\");\n+            boolean enableIfMissing = enableIfMissingValue != null && enableIfMissingValue.asBoolean();\n+\n+            Optional<String> optionalValue = config.getOptionalValue(propertyName, String.class);\n+            boolean enabled;\n+            if (optionalValue.isPresent()) {\n+                if (optionalValue.get().equals(expectedStringValue)) {\n+                    LOGGER.debug(\"Enabling \" + instance + \" since the property value matches the expected one.\");\n+                    enabled = true;\n+                } else {\n+                    LOGGER.debug(\"Disabling \" + instance\n+                            + \" since the property value does not match the expected one.\");\n+                    enabled = false;\n+                }\n+            } else {\n+                if (enableIfMissing) {\n+                    LOGGER.debug(\"Enabling \" + instance\n+                            + \" since the property has not been set and 'enableIfMissing' is set to 'true'.\");\n+                    enabled = true;\n+                } else {\n+                    LOGGER.debug(\"Disabling \" + instance\n+                            + \" since the property has not been set and 'enableIfMissing' is set to 'false'.\");\n+                    enabled = false;\n+                }\n+            }\n+\n+            producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled));\n+        }\n+    }\n+\n+    @BuildStep\n+    void conditionTransformer(List<BuildTimeConditionBuildItem> buildTimeConditions,\n+            BuildProducer<AnnotationsTransformerBuildItem> annotationsTransformer) {\n+        if (buildTimeConditions.isEmpty()) {\n+            return;\n+        }\n+\n+        /*\n+         * Determine whether each of the targets was enabled or not by combining their 'enabled' values\n+         * Done this way in order to support having different annotation specify different conditions\n+         * under which the bean is enabled and then combining all of them using a logical 'AND'\n+         */\n+        final Map<DotName, Boolean> classTargets = new HashMap<>(); //don't use ClassInfo because it doesn't implement equals and hashCode\n+        final Map<String, Boolean> fieldTargets = new HashMap<>(); // don't use FieldInfo because it doesn't implement equals and hashCode\n+        final Map<MethodInfo, Boolean> methodTargets = new HashMap<>();\n+        for (BuildTimeConditionBuildItem buildTimeCondition : buildTimeConditions) {\n+            AnnotationTarget target = buildTimeCondition.getTarget();\n+            AnnotationTarget.Kind kind = target.kind();\n+            if (kind == AnnotationTarget.Kind.CLASS) {\n+                DotName classDotName = target.asClass().name();\n+                Boolean allPreviousConditionsTrue = classTargets.getOrDefault(classDotName, true);\n+                classTargets.put(classDotName, allPreviousConditionsTrue && buildTimeCondition.isEnabled());\n+            } else if (kind == AnnotationTarget.Kind.METHOD) {\n+                MethodInfo method = target.asMethod();\n+                Boolean allPreviousConditionsTrue = methodTargets.getOrDefault(method, true);\n+                methodTargets.put(method, allPreviousConditionsTrue && buildTimeCondition.isEnabled());\n+            } else if (kind == AnnotationTarget.Kind.FIELD) {\n+                FieldInfo field = target.asField();\n+                Boolean allPreviousConditionsTrue = fieldTargets.getOrDefault(field, true);", "originalCommit": "627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc4NTY2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413785666", "bodyText": "Great catch!", "author": "geoand", "createdAt": "2020-04-23T12:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1MzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1Mzg5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413753896", "bodyText": "Just use ctx.isClas() and friends?", "author": "mkouba", "createdAt": "2020-04-23T11:58:40Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package io.quarkus.arc.deployment;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.Transformation;\n+import io.quarkus.arc.profile.IfBuildProfile;\n+import io.quarkus.arc.profile.UnlessBuildProfile;\n+import io.quarkus.arc.properties.IfBuildProperty;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.runtime.configuration.ProfileManager;\n+\n+public class BuildTimeEnabledProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AutoInjectFieldProcessor.class);\n+\n+    private static final DotName IF_BUILD_PROFILE = DotName.createSimple(IfBuildProfile.class.getName());\n+    private static final DotName UNLESS_BUILD_PROFILE = DotName.createSimple(UnlessBuildProfile.class.getName());\n+\n+    private static final DotName IF_BUILD_PROPERTY = DotName.createSimple(IfBuildProperty.class.getName());\n+\n+    @BuildStep\n+    void ifBuildProfile(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {\n+        Collection<AnnotationInstance> annotationInstances = index.getIndex().getAnnotations(IF_BUILD_PROFILE);\n+        for (AnnotationInstance instance : annotationInstances) {\n+            String profileOnInstance = instance.value().asString();\n+            boolean enabled = profileOnInstance.equals(ProfileManager.getActiveProfile());\n+            if (enabled) {\n+                LOGGER.debug(\"Enabling \" + instance + \" since the profile value matches the active profile.\");\n+            } else {\n+                LOGGER.debug(\"Disabling \" + instance + \" since the profile value does not match the active profile.\");\n+            }\n+            producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled));\n+        }\n+    }\n+\n+    @BuildStep\n+    void unlessBuildProfile(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {\n+        Collection<AnnotationInstance> annotationInstances = index.getIndex().getAnnotations(UNLESS_BUILD_PROFILE);\n+        for (AnnotationInstance instance : annotationInstances) {\n+            String profileOnInstance = instance.value().asString();\n+            boolean enabled = !profileOnInstance.equals(ProfileManager.getActiveProfile());\n+            if (enabled) {\n+                LOGGER.debug(\"Enabling \" + instance + \" since the profile value does not match the active profile.\");\n+            } else {\n+                LOGGER.debug(\"Disabling \" + instance + \" since the profile value matches the active profile.\");\n+            }\n+            producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled));\n+        }\n+    }\n+\n+    @BuildStep\n+    void ifBuildProperty(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {\n+        Config config = ConfigProviderResolver.instance().getConfig();\n+        Collection<AnnotationInstance> annotationInstances = index.getIndex().getAnnotations(IF_BUILD_PROPERTY);\n+        for (AnnotationInstance instance : annotationInstances) {\n+            String propertyName = instance.value(\"name\").asString();\n+            String expectedStringValue = instance.value(\"stringValue\").asString();\n+            AnnotationValue enableIfMissingValue = instance.value(\"enableIfMissing\");\n+            boolean enableIfMissing = enableIfMissingValue != null && enableIfMissingValue.asBoolean();\n+\n+            Optional<String> optionalValue = config.getOptionalValue(propertyName, String.class);\n+            boolean enabled;\n+            if (optionalValue.isPresent()) {\n+                if (optionalValue.get().equals(expectedStringValue)) {\n+                    LOGGER.debug(\"Enabling \" + instance + \" since the property value matches the expected one.\");\n+                    enabled = true;\n+                } else {\n+                    LOGGER.debug(\"Disabling \" + instance\n+                            + \" since the property value does not match the expected one.\");\n+                    enabled = false;\n+                }\n+            } else {\n+                if (enableIfMissing) {\n+                    LOGGER.debug(\"Enabling \" + instance\n+                            + \" since the property has not been set and 'enableIfMissing' is set to 'true'.\");\n+                    enabled = true;\n+                } else {\n+                    LOGGER.debug(\"Disabling \" + instance\n+                            + \" since the property has not been set and 'enableIfMissing' is set to 'false'.\");\n+                    enabled = false;\n+                }\n+            }\n+\n+            producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled));\n+        }\n+    }\n+\n+    @BuildStep\n+    void conditionTransformer(List<BuildTimeConditionBuildItem> buildTimeConditions,\n+            BuildProducer<AnnotationsTransformerBuildItem> annotationsTransformer) {\n+        if (buildTimeConditions.isEmpty()) {\n+            return;\n+        }\n+\n+        /*\n+         * Determine whether each of the targets was enabled or not by combining their 'enabled' values\n+         * Done this way in order to support having different annotation specify different conditions\n+         * under which the bean is enabled and then combining all of them using a logical 'AND'\n+         */\n+        final Map<DotName, Boolean> classTargets = new HashMap<>(); //don't use ClassInfo because it doesn't implement equals and hashCode\n+        final Map<String, Boolean> fieldTargets = new HashMap<>(); // don't use FieldInfo because it doesn't implement equals and hashCode\n+        final Map<MethodInfo, Boolean> methodTargets = new HashMap<>();\n+        for (BuildTimeConditionBuildItem buildTimeCondition : buildTimeConditions) {\n+            AnnotationTarget target = buildTimeCondition.getTarget();\n+            AnnotationTarget.Kind kind = target.kind();\n+            if (kind == AnnotationTarget.Kind.CLASS) {\n+                DotName classDotName = target.asClass().name();\n+                Boolean allPreviousConditionsTrue = classTargets.getOrDefault(classDotName, true);\n+                classTargets.put(classDotName, allPreviousConditionsTrue && buildTimeCondition.isEnabled());\n+            } else if (kind == AnnotationTarget.Kind.METHOD) {\n+                MethodInfo method = target.asMethod();\n+                Boolean allPreviousConditionsTrue = methodTargets.getOrDefault(method, true);\n+                methodTargets.put(method, allPreviousConditionsTrue && buildTimeCondition.isEnabled());\n+            } else if (kind == AnnotationTarget.Kind.FIELD) {\n+                FieldInfo field = target.asField();\n+                Boolean allPreviousConditionsTrue = fieldTargets.getOrDefault(field, true);\n+                fieldTargets.put(toUniqueString(field), allPreviousConditionsTrue && buildTimeCondition.isEnabled());\n+            }\n+        }\n+\n+        // the transformer just tries to match targets and then enables or disables the bean accordingly\n+        annotationsTransformer.produce(new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD || kind == AnnotationTarget.Kind.CLASS\n+                        || kind == AnnotationTarget.Kind.FIELD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext ctx) {\n+                AnnotationTarget target = ctx.getTarget();\n+                AnnotationTarget.Kind kind = target.kind();\n+                if (kind == AnnotationTarget.Kind.CLASS) {", "originalCommit": "627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1NTUzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413755535", "bodyText": "I think that you should use the BeanArchiveIndexBuildItem here because you're only working with beans, right?", "author": "mkouba", "createdAt": "2020-04-23T12:01:15Z", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package io.quarkus.arc.deployment;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.Transformation;\n+import io.quarkus.arc.profile.IfBuildProfile;\n+import io.quarkus.arc.profile.UnlessBuildProfile;\n+import io.quarkus.arc.properties.IfBuildProperty;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.runtime.configuration.ProfileManager;\n+\n+public class BuildTimeEnabledProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AutoInjectFieldProcessor.class);\n+\n+    private static final DotName IF_BUILD_PROFILE = DotName.createSimple(IfBuildProfile.class.getName());\n+    private static final DotName UNLESS_BUILD_PROFILE = DotName.createSimple(UnlessBuildProfile.class.getName());\n+\n+    private static final DotName IF_BUILD_PROPERTY = DotName.createSimple(IfBuildProperty.class.getName());\n+\n+    @BuildStep\n+    void ifBuildProfile(CombinedIndexBuildItem index, BuildProducer<BuildTimeConditionBuildItem> producer) {", "originalCommit": "627e71a13e1ec1d3aaf5c3ff7c7ccd058ead15b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc4OTQ4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r413789481", "bodyText": "Makes sense, fixed", "author": "geoand", "createdAt": "2020-04-23T12:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1NTUzNQ=="}], "type": "inlineReview"}, {"oid": "3d5d9816780a05b3414c8411b2d852da4a705d64", "url": "https://github.com/quarkusio/quarkus/commit/3d5d9816780a05b3414c8411b2d852da4a705d64", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-23T12:52:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxOTY4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r414219681", "bodyText": "Just curious, would it make sense to use a regular expression here? eg. v.*\nIf so, perhaps String matches() would be more appropriate", "author": "gastaldi", "createdAt": "2020-04-24T00:53:15Z", "path": "extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package io.quarkus.arc.properties;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * When applied to a bean class or producer method (or field), the bean will only be enabled\n+ * if the Quarkus build time property matches the provided value.\n+ * By default, the bean is not enabled when the build time property is not defined at all, but this behavior is configurable\n+ * via the {#code enableIfMissing} property.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ ElementType.METHOD, ElementType.TYPE, ElementType.FIELD })\n+public @interface IfBuildProperty {\n+\n+    /**\n+     * Name of the build time property to check\n+     */\n+    String name();\n+\n+    /**\n+     * Expected {@code String} value of the build time property (specified by {@code name}) if the bean is to be enabled\n+     */\n+    String stringValue();", "originalCommit": "3d5d9816780a05b3414c8411b2d852da4a705d64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI5OTU0NA==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r414299544", "bodyText": "I'm ambivalent because perhpaps that would lead to suprising results for the user. I'll let @manovotn and @mkouba decide.", "author": "geoand", "createdAt": "2020-04-24T05:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxOTY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1NjU0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8726#discussion_r414356541", "bodyText": "Well, regular expressions are powerful but tricky. I'd prefer to keep it simple for now.", "author": "mkouba", "createdAt": "2020-04-24T07:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxOTY4MQ=="}], "type": "inlineReview"}, {"oid": "689a6e4122595dd8791b945544a436419b5e43d4", "url": "https://github.com/quarkusio/quarkus/commit/689a6e4122595dd8791b945544a436419b5e43d4", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-24T07:44:21Z", "type": "commit"}, {"oid": "689a6e4122595dd8791b945544a436419b5e43d4", "url": "https://github.com/quarkusio/quarkus/commit/689a6e4122595dd8791b945544a436419b5e43d4", "message": "Add support for enabling CDI beans based on build time properties", "committedDate": "2020-04-24T07:44:21Z", "type": "forcePushed"}]}