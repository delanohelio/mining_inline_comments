{"pr_number": 8840, "pr_title": "Use a specific value for nodePort when the type of Service is NodePort", "pr_createdAt": "2020-04-24T22:16:16Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8840", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMDc5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415630795", "bodyText": "This https://kubernetes.io/docs/concepts/services-networking/service/#nodeport says that the default range is 30000-32767, and apparently it's configurable.", "author": "Ladicek", "createdAt": "2020-04-27T08:51:30Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddNodePortDecorator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import io.dekorate.deps.kubernetes.api.model.ObjectMeta;\n+import io.dekorate.deps.kubernetes.api.model.ServiceSpecFluent;\n+import io.dekorate.kubernetes.decorator.Decorator;\n+import io.dekorate.kubernetes.decorator.NamedResourceDecorator;\n+\n+public class AddNodePortDecorator extends NamedResourceDecorator<ServiceSpecFluent> {\n+\n+    private static final int MIN_VALUE = 30000;\n+    private static final int MAX_VALUE = 31999;\n+\n+    private final int nodePort;\n+\n+    public AddNodePortDecorator(String name, int nodePort) {\n+        super(name);\n+        if (nodePort < MIN_VALUE || nodePort > MAX_VALUE) {", "originalCommit": "62540bc9f388b4ef28b2e30326a5abccd2e12f72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMjg0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415632847", "bodyText": "Ah, nice find! I need to remove these checks then.", "author": "geoand", "createdAt": "2020-04-27T08:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415631791", "bodyText": "Is there a way to not specify the concrete nodePort and let Kubernetes assign a port automatically? Perhaps allow the 0 value, which typically means \"port should be auto-assigned\"?", "author": "Ladicek", "createdAt": "2020-04-27T08:53:01Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -107,6 +107,12 @@\n     @ConfigItem(defaultValue = \"ClusterIP\")\n     ServiceType serviceType;\n \n+    /**\n+     * The nodePort to set when serviceType is set to nodePort\n+     */\n+    @ConfigItem(defaultValue = \"31987\")", "originalCommit": "62540bc9f388b4ef28b2e30326a5abccd2e12f72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMjY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415632649", "bodyText": "When you don't set it, it gets assigned automatically. The problem is that it gets re-assigned to another value when you update the application and that's what I am trying to avoid.", "author": "geoand", "createdAt": "2020-04-27T08:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTM0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415639349", "bodyText": "Sure. What I'm trying to say is: is there a way how to get back to the default behavior?", "author": "Ladicek", "createdAt": "2020-04-27T09:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MjkwNg==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415642906", "bodyText": "Yeah, that essentially boils down to what @iocanel  is asking for :)", "author": "geoand", "createdAt": "2020-04-27T09:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ=="}], "type": "inlineReview"}, {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36", "url": "https://github.com/quarkusio/quarkus/commit/05e0c788cfe11ba8f63e412094a9d888fc1faa36", "message": "Introduce a Minikube specific deployment target for Kubernetes", "committedDate": "2020-04-30T10:20:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMzk0MA==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417923940", "bodyText": "Is it deployment-target or deploymentTarget?", "author": "Ladicek", "createdAt": "2020-04-30T10:52:09Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesDeployer.java", "diffHunk": "@@ -65,23 +67,72 @@ public void deploy(KubernetesClientBuildItem kubernetesClient,\n                             + CONTAINER_IMAGE_EXTENSIONS_STR + \".\");\n         }\n \n-        boolean isContainerImageS2IPresent = Capabilities.CONTAINER_IMAGE_S2I.equals(activeContainerImageCapability.get());\n-        if (ContainerImageUtil.isRegistryMissingAndNotS2I(capabilities, containerImageInfo)) {\n+        final KubernetesDeploymentTargetBuildItem selectedKubernetesDeploymentTargetBuildItem = determineDeploymentTarget(\n+                containerImageInfo, kubernetesDeploymentTargets, activeContainerImageCapability.get());\n+\n+        final KubernetesClient client = Clients.fromConfig(kubernetesClient.getClient().getConfiguration());\n+        deploymentResult\n+                .produce(deploy(selectedKubernetesDeploymentTargetBuildItem, client, outputTarget.getOutputDirectory()));\n+    }\n+\n+    /**\n+     * Determine a single deployment target out of the possible options.\n+     *\n+     * When there is none selected, we choose vanilla kubernetes.\n+     * When multiple options exist, we choose openshift if it exists, then minikube if it exists.\n+     * If none of the above conditions match, we select the single option if there is only one, otherwise we thrown\n+     * an {@code IllegalStateException} if there are multiple options to choose from, as there is no way clear way to\n+     * pick one. This is better than picking one at random, which because the order in the list isn't fixed would lead\n+     * to non-deterministic behavior.\n+     */\n+    private KubernetesDeploymentTargetBuildItem determineDeploymentTarget(ContainerImageInfoBuildItem containerImageInfo,\n+            List<KubernetesDeploymentTargetBuildItem> kubernetesDeploymentTargets, String activeContainerImageCapability) {\n+        final KubernetesDeploymentTargetBuildItem selectedKubernetesDeploymentTargetBuildItem;\n+        if (kubernetesDeploymentTargets.isEmpty()) {\n+            log.debug(\"No Kubernetes Deployment target was explicitly set. Defaulting to 'kubernetes'.\");\n+            return new KubernetesDeploymentTargetBuildItem(KUBERNETES, DEPLOYMENT);\n+        }\n+\n+        Optional<KubernetesDeploymentTargetBuildItem> openshiftDeploymentTarget = getOptionalDeploymentTarget(\n+                kubernetesDeploymentTargets, OPENSHIFT);\n+        boolean checkForMissingRegistry = true;\n+        if (openshiftDeploymentTarget.isPresent()) {\n+            if (kubernetesDeploymentTargets.size() > 1) {\n+                log.info(\"Multiple Kubernetes deployment targets were set. 'openshift' will be selected.\");\n+            }\n+            selectedKubernetesDeploymentTargetBuildItem = openshiftDeploymentTarget.get();\n+            // If we are using s2i there is no need warn about the missing registry\n+            checkForMissingRegistry = Capabilities.CONTAINER_IMAGE_S2I.equals(activeContainerImageCapability);\n+        } else {\n+            Optional<KubernetesDeploymentTargetBuildItem> minikubeDeploymentTarget = getOptionalDeploymentTarget(\n+                    kubernetesDeploymentTargets, MINIKUBE);\n+            if (minikubeDeploymentTarget.isPresent()) {\n+                if (kubernetesDeploymentTargets.size() > 1) {\n+                    log.info(\"Multiple Kubernetes deployment targets were set. 'minikube' will be selected.\");\n+                }\n+                selectedKubernetesDeploymentTargetBuildItem = minikubeDeploymentTarget.get();\n+                // No need to check for a registry when using Minikube since Minikube can work with the local docker daemon\n+                // Futhermore, the 'ImagePullPolicy' has already been set to 'IfNotPresent' for Minikube\n+                checkForMissingRegistry = false;\n+            } else if (kubernetesDeploymentTargets.size() > 1) {\n+                throw new IllegalStateException(\n+                        \"Multiple Kubernetes deployment targets present with no known priorities. Please select a single deployment target using the \\\"quarkus.kubernetes.deploymentTarget\\\" property.\");", "originalCommit": "05e0c788cfe11ba8f63e412094a9d888fc1faa36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDkzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417924931", "bodyText": "It's obviously the latter :P", "author": "geoand", "createdAt": "2020-04-30T10:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMzk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDM1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417924356", "bodyText": "Minikube, not Minishift :-)", "author": "Ladicek", "createdAt": "2020-04-30T10:53:02Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -118,6 +125,13 @@ public void checkKubernetes(BuildProducer<KubernetesDeploymentTargetBuildItem> d\n         }\n     }\n \n+    @BuildStep\n+    public void checkMinishift(BuildProducer<KubernetesDeploymentTargetBuildItem> deploymentTargets) {", "originalCommit": "05e0c788cfe11ba8f63e412094a9d888fc1faa36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTAzOA==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417925038", "bodyText": "Oh man.. I don't know how many times I made that mistake...", "author": "geoand", "createdAt": "2020-04-30T10:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTMzMw==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417925333", "bodyText": "... && deploymentTargets.contains(MINIKUBE) should work", "author": "Ladicek", "createdAt": "2020-04-30T10:54:50Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -405,12 +422,19 @@ private void applyConfig(Session session, Project project, String target, String\n      * This case comes up when users want to deploy their application to a cluster like Minikube where no registry is used\n      * and instead they rely on the image being built directly into the docker daemon that the cluster uses.\n      */\n-    private boolean needToForceUpdateImagePullPolicy(Optional<ContainerImageInfoBuildItem> containerImage,\n+    private boolean needToForceUpdateImagePullPolicy(Collection<String> deploymentTargets,\n+            Optional<ContainerImageInfoBuildItem> containerImage,\n             Capabilities capabilities) {\n+\n+        // no need to change when we use Minikube only\n+        if ((deploymentTargets.size() == 1) && MINIKUBE.equals(deploymentTargets.iterator().next())) {", "originalCommit": "05e0c788cfe11ba8f63e412094a9d888fc1faa36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTgwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417925801", "bodyText": "Right, it's left over from what I was doing in an earlier iteration", "author": "geoand", "createdAt": "2020-04-30T10:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTMzMw=="}], "type": "inlineReview"}, {"oid": "ac0182199159d4defe1de6b9345af8cef54dc756", "url": "https://github.com/quarkusio/quarkus/commit/ac0182199159d4defe1de6b9345af8cef54dc756", "message": "Introduce a Minikube specific deployment target for Kubernetes", "committedDate": "2020-04-30T10:55:13Z", "type": "forcePushed"}, {"oid": "fe61b7919e4a7c8ac2ef254c1fa9bbdd454cbb47", "url": "https://github.com/quarkusio/quarkus/commit/fe61b7919e4a7c8ac2ef254c1fa9bbdd454cbb47", "message": "Introduce a Minikube specific deployment target for Kubernetes", "committedDate": "2020-04-30T10:56:20Z", "type": "forcePushed"}, {"oid": "01b1a3a239de3d09afac8e878d633ee9599832c2", "url": "https://github.com/quarkusio/quarkus/commit/01b1a3a239de3d09afac8e878d633ee9599832c2", "message": "Add a minikube extension as convenience for deploying to Minikube", "committedDate": "2020-04-30T17:33:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzODkxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r419938919", "bodyText": "I guess that Optional is introduced in order to be able to easily tell when this is a default value or a user provided one?", "author": "iocanel", "createdAt": "2020-05-05T08:19:09Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -193,11 +199,12 @@\n \n     /**\n      * The target deployment platform.\n-     * Defaults to kubernetes. Can be kubernetes, openshift, knative etc, or any combination of the above as comma separated\n+     * Defaults to kubernetes. Can be kubernetes, openshift, knative, minikube etc, or any combination of the above as comma\n+     * separated\n      * list.\n      */\n-    @ConfigItem(defaultValue = \"kubernetes\")\n-    List<String> deploymentTarget;\n+    @ConfigItem\n+    Optional<List<String>> deploymentTarget;", "originalCommit": "01b1a3a239de3d09afac8e878d633ee9599832c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0ODc1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r419948752", "bodyText": "Yes, exactly", "author": "geoand", "createdAt": "2020-05-05T08:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzODkxOQ=="}], "type": "inlineReview"}, {"oid": "0c2b5f723fca9a4bd0fb43fca97f8b259db5758e", "url": "https://github.com/quarkusio/quarkus/commit/0c2b5f723fca9a4bd0fb43fca97f8b259db5758e", "message": "Add a minikube extension as convenience for deploying to Minikube", "committedDate": "2020-05-06T07:18:17Z", "type": "forcePushed"}, {"oid": "60d9b202f73c11e4434cc4a70a23bdb475a39216", "url": "https://github.com/quarkusio/quarkus/commit/60d9b202f73c11e4434cc4a70a23bdb475a39216", "message": "Introduce a Minikube specific deployment target for Kubernetes", "committedDate": "2020-05-06T11:01:28Z", "type": "commit"}, {"oid": "fb025d04883ae2eb30bfa4254ef8cc3b9b7c96ef", "url": "https://github.com/quarkusio/quarkus/commit/fb025d04883ae2eb30bfa4254ef8cc3b9b7c96ef", "message": "Sanitize the way quarkus.kubernetes.deployment-target works\n\nEssentially now the first user supplied value is used to deploy.\nWhen no user supplied value exists, then priorities are used to\ndetermine which target should be deployed", "committedDate": "2020-05-06T11:01:28Z", "type": "commit"}, {"oid": "981e54627d55b3f745e26b95a38995145fcf6e05", "url": "https://github.com/quarkusio/quarkus/commit/981e54627d55b3f745e26b95a38995145fcf6e05", "message": "Add a minikube extension as convenience for deploying to Minikube", "committedDate": "2020-05-06T11:01:28Z", "type": "commit"}, {"oid": "981e54627d55b3f745e26b95a38995145fcf6e05", "url": "https://github.com/quarkusio/quarkus/commit/981e54627d55b3f745e26b95a38995145fcf6e05", "message": "Add a minikube extension as convenience for deploying to Minikube", "committedDate": "2020-05-06T11:01:28Z", "type": "forcePushed"}]}