{"pr_number": 11760, "pr_title": "OpenShift container image extension", "pr_createdAt": "2020-08-31T19:16:53Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11760", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NjgzMA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480386830", "bodyText": "Super minor nitpick: Best use single().satisfies(h -> {...}) as hasOnlyOneElementSatisfying has been deprecated", "author": "geoand", "createdAt": "2020-08-31T20:40:49Z", "path": "integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/OpenshiftWithDockerBuildStrategyTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package io.quarkus.it.kubernetes;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.assertj.core.api.AbstractObjectAssert;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.openshift.api.model.DockerBuildStrategy;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.builder.Version;\n+import io.quarkus.test.ProdBuildResults;\n+import io.quarkus.test.ProdModeTestResults;\n+import io.quarkus.test.QuarkusProdModeTest;\n+\n+public class OpenshiftWithDockerBuildStrategyTest {\n+\n+    @RegisterExtension\n+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class).addClasses(GreetingResource.class))\n+            .setApplicationName(\"openshift-s2i\").setApplicationVersion(\"0.1-SNAPSHOT\")\n+            .withConfigurationResource(\"openshift-with-docker-build-strategy.properties\")\n+            .setForcedDependencies(Collections\n+                    .singletonList(new AppArtifact(\"io.quarkus\", \"quarkus-openshift\", Version.getVersion())));\n+\n+    @ProdBuildResults\n+    private ProdModeTestResults prodModeTestResults;\n+\n+    @Test\n+    public void assertGeneratedResources() throws IOException {\n+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve(\"kubernetes\");\n+\n+        assertThat(kubernetesDir).isDirectoryContaining(p -> p.getFileName().endsWith(\"openshift.json\"))\n+                .isDirectoryContaining(p -> p.getFileName().endsWith(\"openshift.yml\"));\n+        List<HasMetadata> openshiftList = DeserializationUtil.deserializeAsList(kubernetesDir.resolve(\"openshift.yml\"));\n+\n+        assertThat(openshiftList).filteredOn(h -> \"BuildConfig\".equals(h.getKind())).hasOnlyOneElementSatisfying(h -> {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MjY1OA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480392658", "bodyText": "We should probably move findMainSourcesRoot some utility common to all container-image extensions - It doesn't need to be now of course", "author": "geoand", "createdAt": "2020-08-31T20:53:04Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java", "diffHunk": "@@ -65,12 +83,36 @@ public CapabilityBuildItem capability() {\n         return new CapabilityBuildItem(Capability.CONTAINER_IMAGE_S2I);\n     }\n \n+    @BuildStep(onlyIf = { S2iBuild.class }, onlyIfNot = NativeBuild.class)\n+    public void s2iPrepareJvmDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.jvmDockerfile))));\n+            decorator.produce(new DecoratorBuildItem(new RemoveEnvVarDecorator(null, \"JAVA_APP_JAR\")));\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = { S2iBuild.class, NativeBuild.class })\n+    public void s2iPrepareNativeDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.nativeDockerfile))));", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTU5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r493659593", "bodyText": "This is already in the quarkus container image util module.", "author": "iocanel", "createdAt": "2020-09-23T14:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MjY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDY1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480394656", "bodyText": "This seems to be unused", "author": "geoand", "createdAt": "2020-08-31T20:57:11Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java", "diffHunk": "@@ -65,12 +83,36 @@ public CapabilityBuildItem capability() {\n         return new CapabilityBuildItem(Capability.CONTAINER_IMAGE_S2I);\n     }\n \n+    @BuildStep(onlyIf = { S2iBuild.class }, onlyIfNot = NativeBuild.class)\n+    public void s2iPrepareJvmDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.jvmDockerfile))));\n+            decorator.produce(new DecoratorBuildItem(new RemoveEnvVarDecorator(null, \"JAVA_APP_JAR\")));\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = { S2iBuild.class, NativeBuild.class })\n+    public void s2iPrepareNativeDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.nativeDockerfile))));\n+        }\n+        //Let's remove this for all kinds of native build\n+        decorator.produce(new DecoratorBuildItem(new RemoveEnvVarDecorator(null, \"JAVA_APP_JAR\")));\n+    }\n+\n     @BuildStep(onlyIf = { IsNormal.class, S2iBuild.class }, onlyIfNot = NativeBuild.class)\n     public void s2iRequirementsJvm(S2iConfig s2iConfig,\n             CurateOutcomeBuildItem curateOutcomeBuildItem,\n             OutputTargetBuildItem out,\n             PackageConfig packageConfig,\n             JarBuildItem jarBuildItem,\n+            BuildProducer<DecoratorBuildItem> decorator,", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NTQ0OA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480395448", "bodyText": "Can we get some comments in this?\nMentioning it because this looks like where most of the problems could arise - the rest of the changes seem pretty straighforward, but this one is a mouth full :)", "author": "geoand", "createdAt": "2020-08-31T20:58:42Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MjI3NA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r488752274", "bodyText": "This is copied from dekorate and modified so that it can support custom entry prefix paths.\nThis should be fixed upstream. See: dekorateio/dekorate#621", "author": "iocanel", "createdAt": "2020-09-15T15:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg0OTkzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480849939", "bodyText": "This seems to be unused", "author": "geoand", "createdAt": "2020-09-01T05:56:34Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {\n+\n+    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n+    private static final String DOCKER_IGNORE = \".dockerignore\";\n+\n+    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n+    protected static final String DOCKER_PREFIX = \"docker-\";\n+    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n+\n+    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+    public static File packageFile(String path) {\n+        return packageFile(path, null);\n+    }\n+\n+    public static File packageFile(String path, String base) {\n+        try {\n+            final Path root = Paths.get(path).getParent();\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!path.equals(absolutePath)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw DekorateException.launderThrowable(e);\n+        }\n+    }\n+\n+    public static File packageFile(Path root, Path... additional) {\n+        return packageFile(root, null, additional);\n+    }\n+\n+    public static File packageFile(Path root, String base, Path... additional) {\n+        try {\n+            final Set<String> includes = Arrays\n+                    .stream(additional)\n+                    .map(p -> p.toAbsolutePath().toString())\n+                    .collect(Collectors.toSet());\n+\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!shouldInclude(absolutePath, includes)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void putTarEntry(TarArchiveOutputStream tarArchiveOutputStream, TarArchiveEntry tarArchiveEntry,\n+            Path inputPath) throws IOException {\n+        tarArchiveEntry.setSize(Files.size(inputPath));\n+        tarArchiveOutputStream.putArchiveEntry(tarArchiveEntry);\n+        Files.copy(inputPath, tarArchiveOutputStream);\n+        tarArchiveOutputStream.closeArchiveEntry();\n+    }\n+\n+    public static TarArchiveOutputStream buildTarStream(File outputPath) throws IOException {\n+        FileOutputStream fout = new FileOutputStream(outputPath);\n+        BufferedOutputStream bout = new BufferedOutputStream(fout);\n+        //BZip2CompressorOutputStream bzout = new BZip2CompressorOutputStream(bout);\n+        TarArchiveOutputStream stream = new TarArchiveOutputStream(bout);\n+        stream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n+        return stream;\n+    }\n+\n+    public static void tar(Path inputPath, Path outputPath) throws IOException {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MjUzNA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r488752534", "bodyText": "Same as above.", "author": "iocanel", "createdAt": "2020-09-15T15:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg0OTkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MTUwNw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480851507", "bodyText": "Are you sure that using 0755 like this is correct?", "author": "geoand", "createdAt": "2020-09-01T05:58:59Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {\n+\n+    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n+    private static final String DOCKER_IGNORE = \".dockerignore\";\n+\n+    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n+    protected static final String DOCKER_PREFIX = \"docker-\";\n+    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n+\n+    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+    public static File packageFile(String path) {\n+        return packageFile(path, null);\n+    }\n+\n+    public static File packageFile(String path, String base) {\n+        try {\n+            final Path root = Paths.get(path).getParent();\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!path.equals(absolutePath)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw DekorateException.launderThrowable(e);\n+        }\n+    }\n+\n+    public static File packageFile(Path root, Path... additional) {\n+        return packageFile(root, null, additional);\n+    }\n+\n+    public static File packageFile(Path root, String base, Path... additional) {\n+        try {\n+            final Set<String> includes = Arrays\n+                    .stream(additional)\n+                    .map(p -> p.toAbsolutePath().toString())\n+                    .collect(Collectors.toSet());\n+\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!shouldInclude(absolutePath, includes)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MjgwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r488752801", "bodyText": "Yeah", "author": "iocanel", "createdAt": "2020-09-15T15:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MjA3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480852071", "bodyText": "This method seems to have plenty of similarities with packageFile. Can the common code be extracted?", "author": "geoand", "createdAt": "2020-09-01T05:59:46Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {\n+\n+    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n+    private static final String DOCKER_IGNORE = \".dockerignore\";\n+\n+    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n+    protected static final String DOCKER_PREFIX = \"docker-\";\n+    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n+\n+    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+    public static File packageFile(String path) {\n+        return packageFile(path, null);\n+    }\n+\n+    public static File packageFile(String path, String base) {\n+        try {\n+            final Path root = Paths.get(path).getParent();\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!path.equals(absolutePath)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw DekorateException.launderThrowable(e);\n+        }\n+    }\n+\n+    public static File packageFile(Path root, Path... additional) {\n+        return packageFile(root, null, additional);\n+    }\n+\n+    public static File packageFile(Path root, String base, Path... additional) {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5228a7c88a361ea80f7cc141838a405413b8526", "url": "https://github.com/quarkusio/quarkus/commit/a5228a7c88a361ea80f7cc141838a405413b8526", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-23T14:41:12Z", "type": "forcePushed"}, {"oid": "71e488fbd7079f8c5894cb65061b401484fef71c", "url": "https://github.com/quarkusio/quarkus/commit/71e488fbd7079f8c5894cb65061b401484fef71c", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-24T06:01:40Z", "type": "forcePushed"}, {"oid": "520c69d93862d9d8a1ba00e04936d0227314b15b", "url": "https://github.com/quarkusio/quarkus/commit/520c69d93862d9d8a1ba00e04936d0227314b15b", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-24T07:52:48Z", "type": "forcePushed"}, {"oid": "12d812a47b136a16cfd5b37b322e09f824f68de8", "url": "https://github.com/quarkusio/quarkus/commit/12d812a47b136a16cfd5b37b322e09f824f68de8", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-24T07:53:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzODQwMg==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494938402", "bodyText": "Probably best to have these capitalized?", "author": "geoand", "createdAt": "2020-09-25T11:58:10Z", "path": "extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/BuildStrategy.java", "diffHunk": "@@ -0,0 +1,9 @@\n+\n+package io.quarkus.container.image.openshift.deployment;\n+\n+public enum BuildStrategy {\n+\n+    binary,", "originalCommit": "12d812a47b136a16cfd5b37b322e09f824f68de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1MDUyMA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494950520", "bodyText": "The are lowercase, as they read better when passed to application.properties.", "author": "iocanel", "createdAt": "2020-09-25T12:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzODQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MDQ0OA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494940448", "bodyText": "This name is too vague IMHO. I would prefer if it were named mergeConfig", "author": "geoand", "createdAt": "2020-09-25T12:02:38Z", "path": "extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/OpenshiftUtils.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package io.quarkus.container.image.openshift.deployment;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.deps.kubernetes.api.model.HasMetadata;\n+import io.dekorate.deps.kubernetes.api.model.KubernetesListBuilder;\n+import io.dekorate.deps.kubernetes.api.model.ObjectReference;\n+import io.dekorate.deps.openshift.api.model.ImageStreamTag;\n+import io.dekorate.deps.openshift.api.model.SourceBuildStrategyFluent;\n+import io.dekorate.deps.openshift.client.OpenShiftClient;\n+import io.dekorate.kubernetes.decorator.Decorator;\n+\n+/**\n+ * This class is copied from Dekorate, with the difference that the {@code waitForImageStreamTags} method\n+ * take a client as the argument\n+ *\n+ * TODO: Update dekorate to take the client as an argument and then remove this class\n+ */\n+public class OpenshiftUtils {\n+\n+    /**\n+     * Wait for the references ImageStreamTags to become available.\n+     *\n+     * @param client The openshift client used to check the status of the ImageStream\n+     * @param items A list of items, possibly referencing image stream tags.\n+     * @param amount The max amount of time to wait.\n+     * @param timeUnit The time unit of the time to wait.\n+     * @return True if the items became available false otherwise.\n+     */\n+    public static boolean waitForImageStreamTags(OpenShiftClient client, Collection<HasMetadata> items, long amount,\n+            TimeUnit timeUnit) {\n+        if (items == null || items.isEmpty()) {\n+            return true;\n+        }\n+        final List<String> tags = new ArrayList<>();\n+        new KubernetesListBuilder()\n+                .withItems(new ArrayList<>(items))\n+                .accept(new Decorator<SourceBuildStrategyFluent>() {\n+                    @Override\n+                    public void visit(SourceBuildStrategyFluent strategy) {\n+                        ObjectReference from = strategy.buildFrom();\n+                        if (from.getKind().equals(\"ImageStreamTag\")) {\n+                            tags.add(from.getName());\n+                        }\n+                    }\n+                }).build();\n+\n+        boolean tagsMissing = true;\n+        long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+\n+        while (tagsMissing && elapsed < timeUnit.toMillis(amount) && !Thread.interrupted()) {\n+            tagsMissing = false;\n+            for (String tag : tags) {\n+                ImageStreamTag t = client.imageStreamTags().withName(tag).get();\n+                if (t == null) {\n+                    tagsMissing = true;\n+                }\n+            }\n+\n+            if (tagsMissing) {\n+                try {\n+                    Thread.sleep(1000);\n+                    elapsed = System.currentTimeMillis() - started;\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+        }\n+        return !tagsMissing;\n+    }\n+\n+    /**\n+     * Merges {@link OpenshiftConfig} with {@link S2iConfig} prioritizing in the former.\n+     * \n+     * @param openshiftConfig the Openshift config\n+     * @param s2iConfig the s2i config\n+     * @param an instance of {@link OpenshiftConfig} with the merged configuration.\n+     */\n+    public static OpenshiftConfig merge(OpenshiftConfig openshiftConfig, S2iConfig s2iConfig) {", "originalCommit": "12d812a47b136a16cfd5b37b322e09f824f68de8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MjIwNw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494942207", "bodyText": "What's the rationale of this change? I think we at least need a comment about it", "author": "geoand", "createdAt": "2020-09-25T12:06:22Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -378,6 +383,16 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n                     kubernetesHealthLivenessPath,\n                     kubernetesHealthReadinessPath);\n \n+            decorators.stream().filter(d -> d.matches(Decorator.class)).forEach(i -> {", "originalCommit": "12d812a47b136a16cfd5b37b322e09f824f68de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1MjkyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494952925", "bodyText": "As I didn't felt comfortable is exposing Decorate specific classes in the kubernetes spi. Decorators are passed to build items as Objects. So, at some point we need to check if the build item is indeed holding an instance of the Decorator.class.\nDefinitely not the most elegant solution, but I feel it's somehow better than dragging decorate to the kubernetes spi.\nI am open about it though.", "author": "iocanel", "createdAt": "2020-09-25T12:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MjIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1NTU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494955553", "bodyText": "Understood. I'm fine with it, but let's please add some relevant comments to the source", "author": "geoand", "createdAt": "2020-09-25T12:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MjIwNw=="}], "type": "inlineReview"}, {"oid": "8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "url": "https://github.com/quarkusio/quarkus/commit/8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-29T08:04:10Z", "type": "forcePushed"}, {"oid": "4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "url": "https://github.com/quarkusio/quarkus/commit/4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "message": "feat: Allow passing decorators via kubernetes spi", "committedDate": "2020-09-29T08:04:10Z", "type": "commit"}, {"oid": "fc712d823431068bc52d65d7c306964139e76ee4", "url": "https://github.com/quarkusio/quarkus/commit/fc712d823431068bc52d65d7c306964139e76ee4", "message": "feat: Implement docker strategy for Openshift BuildConfig", "committedDate": "2020-09-29T08:04:10Z", "type": "commit"}, {"oid": "f507274a95675539f247aee9b6a16804e9ed14c5", "url": "https://github.com/quarkusio/quarkus/commit/f507274a95675539f247aee9b6a16804e9ed14c5", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-29T10:00:52Z", "type": "forcePushed"}, {"oid": "f507274a95675539f247aee9b6a16804e9ed14c5", "url": "https://github.com/quarkusio/quarkus/commit/f507274a95675539f247aee9b6a16804e9ed14c5", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-29T10:00:52Z", "type": "commit"}]}