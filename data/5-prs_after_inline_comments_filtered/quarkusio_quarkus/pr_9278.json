{"pr_number": 9278, "pr_title": "Introduce support for Spring's @Scheduled", "pr_createdAt": "2020-05-13T19:35:26Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9278", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjI2NA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424712264", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A simple processor that maps annotations Spring DI annotation to CDI annotation\n          \n          \n            \n             * A simple processor that maps Spring DI annotations to Quarkus annotations", "author": "gsmet", "createdAt": "2020-05-13T20:29:29Z", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation", "originalCommit": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjg1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424712852", "bodyText": "I suppose you plan to not hardcode it?", "author": "gsmet", "createdAt": "2020-05-13T20:30:32Z", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))\n+                        .collect(Collectors.toList());\n+                if (!collect.isEmpty()) {\n+                    context.transform()\n+                            .add(QUARKUS_SCHEDULED, AnnotationValue.createStringValue(\"cron\", \"0/1 * * * * ?\")).done();", "originalCommit": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNzgxMA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424717810", "bodyText": "Of course not, I need to work on this more. It was just to put the basics in place and see if it works :-)", "author": "aureamunoz", "createdAt": "2020-05-13T20:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzE0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424713146", "bodyText": "Is this annotation repeatable? If so, there's a good chance the repeatable container will need some special handling (and a test).", "author": "gsmet", "createdAt": "2020-05-13T20:31:07Z", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))", "originalCommit": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxODg5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424718896", "bodyText": "I don't get what do you mean. Yes, this annotation is repeatable.", "author": "aureamunoz", "createdAt": "2020-05-13T20:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzUyMw==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425007523", "bodyText": "@gsmet means that you will also have to handle @Schedules", "author": "geoand", "createdAt": "2020-05-14T09:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNjQxOA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425006418", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@code @Scheduled}\n          \n          \n            \n             * {@code @org.springframework.scheduling.annotation.Scheduled}", "author": "geoand", "createdAt": "2020-05-14T09:41:43Z", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringScheduledAnnotatedMethodBuildItem.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.Map;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.MethodInfo;\n+\n+import io.quarkus.builder.item.SimpleBuildItem;\n+\n+/**\n+ * Build Item recording all the methods that have been effectively annotated with\n+ * {@code @Scheduled}", "originalCommit": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwODY3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425008679", "bodyText": "This is a little weird TBH - Does regular Spring make a class a bean by simply annotating with @Scheduled or does it already have to be a bean (by having @Component for example)?", "author": "geoand", "createdAt": "2020-05-14T09:45:17Z", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))\n+                        .collect(Collectors.toList());\n+                if (!collect.isEmpty()) {\n+                    context.transform()\n+                            .add(QUARKUS_SCHEDULED, AnnotationValue.createStringValue(\"cron\", \"0/1 * * * * ?\")).done();\n+                }\n+            }\n+        });\n+    }\n+\n+    @BuildStep\n+    public void collectSpringScheduledMethods(CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<SpringScheduledAnnotatedMethodBuildItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+\n+        // first first go through the list of annotated methods\n+        for (AnnotationInstance instance : combinedIndex.getIndex().getAnnotations(SPRING_SCHEDULED)) {\n+            if (instance.target().kind() != AnnotationTarget.Kind.METHOD) {\n+                throw new IllegalArgumentException(\"Unsupported annotation target kind \" + instance.target().kind().name());\n+            }\n+            MethodInfo methodInfo = instance.target().asMethod();\n+            result.put(methodInfo, instance);\n+            LOGGER.debugf(\"Found Spring scheduled business method %s declared on %s\", methodInfo.name(),\n+                    methodInfo.declaringClass().name());\n+        }\n+        scheduledBusinessMethods.produce(new SpringScheduledAnnotatedMethodBuildItem(result));\n+    }\n+\n+    @BuildStep\n+    void registerBeans(SpringScheduledAnnotatedMethodBuildItem methodBuildItem,\n+            BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        Map<MethodInfo, AnnotationInstance> methodToInstanceMap = methodBuildItem.getMethodToInstanceMap();\n+        Set<String> beanClasses = new HashSet<>();\n+        for (MethodInfo methodInfo : methodToInstanceMap.keySet()) {\n+            beanClasses.add(methodInfo.declaringClass().asClass().name().toString());\n+        }\n+        additionalBeans.produce(AdditionalBeanBuildItem.builder().addBeanClasses(beanClasses).setUnremovable()", "originalCommit": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMzNjUxOA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425336518", "bodyText": "Ok. No, Spring does not make a class a bean by annotating with @scheduled. It has to be already a bean in order to Spring can detect the method annotated with @scheduled.", "author": "aureamunoz", "createdAt": "2020-05-14T18:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwODY3OQ=="}], "type": "inlineReview"}, {"oid": "8fa93028c3b987b79855b262f37a7fce1a50827f", "url": "https://github.com/quarkusio/quarkus/commit/8fa93028c3b987b79855b262f37a7fce1a50827f", "message": "refactor: search for the annotations only on beans", "committedDate": "2020-05-20T14:19:56Z", "type": "forcePushed"}, {"oid": "412f225a7b030c94aec2ca91911a30261936f145", "url": "https://github.com/quarkusio/quarkus/commit/412f225a7b030c94aec2ca91911a30261936f145", "message": "feature: add spring-scheduling extension", "committedDate": "2020-05-22T15:29:54Z", "type": "forcePushed"}, {"oid": "acd3a60da5b543ad10c3f695167cba7039957066", "url": "https://github.com/quarkusio/quarkus/commit/acd3a60da5b543ad10c3f695167cba7039957066", "message": "add more test and use cases + refactor", "committedDate": "2020-05-26T15:57:09Z", "type": "forcePushed"}, {"oid": "2f6976d4ec2d7a8228d78a7262cd8e59d4f016d3", "url": "https://github.com/quarkusio/quarkus/commit/2f6976d4ec2d7a8228d78a7262cd8e59d4f016d3", "message": "fix cron expression from config", "committedDate": "2020-05-27T20:55:07Z", "type": "forcePushed"}, {"oid": "6ad16a8379bef491ddb4bfc2b0f560fc5ff2d353", "url": "https://github.com/quarkusio/quarkus/commit/6ad16a8379bef491ddb4bfc2b0f560fc5ff2d353", "message": "read fixeRate from config", "committedDate": "2020-05-28T06:15:56Z", "type": "forcePushed"}, {"oid": "d5bb24e627475b12a855bddc1bfd6364b3fdeef4", "url": "https://github.com/quarkusio/quarkus/commit/d5bb24e627475b12a855bddc1bfd6364b3fdeef4", "message": "feature: add spring-scheduling extension", "committedDate": "2020-05-28T14:10:46Z", "type": "forcePushed"}, {"oid": "0d3788668067ea5fa5b9a462fd0981ab38603219", "url": "https://github.com/quarkusio/quarkus/commit/0d3788668067ea5fa5b9a462fd0981ab38603219", "message": "bump spring-context-api version and refactor delayed tests", "committedDate": "2020-05-29T15:45:16Z", "type": "forcePushed"}, {"oid": "189fe49e8f785ce3fe72de3362b9de25b37a8b37", "url": "https://github.com/quarkusio/quarkus/commit/189fe49e8f785ce3fe72de3362b9de25b37a8b37", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-01T08:45:20Z", "type": "forcePushed"}, {"oid": "eac118fe30f6bd3c476cb8f15e8270344c0c721c", "url": "https://github.com/quarkusio/quarkus/commit/eac118fe30f6bd3c476cb8f15e8270344c0c721c", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-01T14:01:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMjY4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433302685", "bodyText": "This should probably be spring-scheduled", "author": "geoand", "createdAt": "2020-06-01T15:26:52Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/FeatureBuildItem.java", "diffHunk": "@@ -106,6 +106,7 @@\n     public static final String SPRING_BOOT_PROPERTIES = \"spring-boot-properties\";\n     public static final String SPRING_CACHE = \"spring-cache\";\n     public static final String SPRING_CLOUD_CONFIG_CLIENT = \"spring-cloud-config-client\";\n+    public static final String SPRING_SCHEDULING = \"spring-scheduling\";", "originalCommit": "eac118fe30f6bd3c476cb8f15e8270344c0c721c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMzg5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433303892", "bodyText": "The comment is kind of hard to read. Can you try and make it a little better?", "author": "geoand", "createdAt": "2020-06-01T15:28:24Z", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/*\n+ * A simple processor that maps annotations Spring Scheduled annotation to Quarkus annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly", "originalCommit": "eac118fe30f6bd3c476cb8f15e8270344c0c721c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwODU3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433308574", "bodyText": "We don't really use underscores, can you please stick to camel case?", "author": "geoand", "createdAt": "2020-06-01T15:33:16Z", "path": "extensions/spring-scheduling/deployment/src/test/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessorTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Indexer;\n+import org.jboss.jandex.MethodInfo;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.scheduling.annotation.Scheduled;\n+\n+import io.quarkus.arc.processor.BeanArchives;\n+import io.quarkus.deployment.util.IoUtil;\n+\n+public class SpringSchedulingProcessorTest {\n+\n+    final SpringSchedulingProcessor springSchedulingProcessor = new SpringSchedulingProcessor();\n+    final IndexView index = getIndex(SpringScheduledMethodsBean.class);\n+\n+    @Test\n+    public void test_buildCronParam() {", "originalCommit": "eac118fe30f6bd3c476cb8f15e8270344c0c721c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738", "url": "https://github.com/quarkusio/quarkus/commit/cdb890811c2da55b355b7e254e18b6f10dce5738", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-01T19:48:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433643901", "bodyText": "What does this do?", "author": "geoand", "createdAt": "2020-06-02T06:18:51Z", "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");\n+        return AnnotationValue.createStringValue(\"cron\", cronExpression);\n+    }\n+\n+    AnnotationValue buildEveryParam(List<AnnotationValue> springAnnotationValues) {\n+        long fixedRate = getLongValueFromParam(springAnnotationValues, \"fixedRate\");\n+        String fixedRateString;\n+        fixedRateString = Duration.ofMillis(fixedRate).toString();\n+        AnnotationValue every = AnnotationValue.createStringValue(\"every\", fixedRateString);\n+        return every;\n+    }\n+\n+    List<AnnotationValue> buildDelayParams(List<AnnotationValue> springAnnotationValues) {\n+        List<AnnotationValue> confValues = new ArrayList<>();\n+        long delay = getLongValueFromParam(springAnnotationValues, \"initialDelay\");\n+        confValues.add(AnnotationValue.createLongValue(\"delay\", delay));\n+        confValues.add(AnnotationValue.createEnumValue(\"delayUnit\",\n+                DotName.createSimple(\"java.util.concurrent.TimeUnit\"),\n+                TimeUnit.MILLISECONDS.name()));\n+        return confValues;\n+    }\n+\n+    private long getLongValueFromParam(List<AnnotationValue> springAnnotationValues, String paramName) {\n+        long paramValue = 0;\n+        String paramValueString = \"\";\n+        if (annotationsValuesContain(springAnnotationValues, paramName)) {\n+            paramValue = getAnnotationValueByName(springAnnotationValues, paramName).get().asLong();\n+        } else { //param value as String e.g. a placeholder ${value.from.conf}\n+            paramValueString = getAnnotationValueByName(springAnnotationValues, paramName + \"String\")\n+                    .get().asString();\n+            paramValueString = paramValueString.replace(\"${\", \"{\").trim();", "originalCommit": "cdb890811c2da55b355b7e254e18b6f10dce5738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NTgzNA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433695834", "bodyText": "It reads the value from fixedRateString and initialDelayString params in Spring @Scheduled. This params are used to read values from application.properties", "author": "aureamunoz", "createdAt": "2020-06-02T08:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5ODc0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433698747", "bodyText": "I see, thanks! Do we have tests to verify both kinds of behavior?\nAlso, we need to note that in Quarkus this support is for build-time properties, not runtime properties", "author": "geoand", "createdAt": "2020-06-02T08:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwODAxNw==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433708017", "bodyText": "Yes, we have tests for both of them.\nOk, I note it for the documentation.", "author": "aureamunoz", "createdAt": "2020-06-02T08:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NDQzNw==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433644437", "bodyText": "We should have a consistent format for the error messages.  Also, we should probable use IllegalArgumentException instead of IllegalStateException", "author": "geoand", "createdAt": "2020-06-02T06:20:18Z", "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(", "originalCommit": "cdb890811c2da55b355b7e254e18b6f10dce5738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTczMA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433801730", "bodyText": "I changed the exception type and homogenized the message, wdyt @geoand", "author": "aureamunoz", "createdAt": "2020-06-02T11:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NDQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwODA4OA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433808088", "bodyText": "\ud83d\udc4d", "author": "geoand", "createdAt": "2020-06-02T11:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NDQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjI2MA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433692260", "bodyText": "@aureamunoz, IIUC correctly from your Pull Request, Spring's ability to read the cron expression from application.properties using ${} isn't supported, right? If not, is there a proper error message?\n\nYes @geoand , it is supported.", "author": "aureamunoz", "createdAt": "2020-06-02T08:02:28Z", "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");", "originalCommit": "cdb890811c2da55b355b7e254e18b6f10dce5738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MzI1OA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433693258", "bodyText": "Is there a test that shows this functionality? I mean adding a cron expression in application.properties and making sure that it works.", "author": "geoand", "createdAt": "2020-06-02T08:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDYxNA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433700614", "bodyText": "Yes, in SpringScheduledMethodTest.java I add the cron expression in application.properties and have a test. And SpringScheduledMethodsBean#checkEverySecondCronConfig is the method.", "author": "aureamunoz", "createdAt": "2020-06-02T08:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjI2MA=="}], "type": "inlineReview"}, {"oid": "de5cde5c40a0078837c112edd634bc8bfd501845", "url": "https://github.com/quarkusio/quarkus/commit/de5cde5c40a0078837c112edd634bc8bfd501845", "message": "feature: add spring-scheduling extension\n\nrefactor: error cases", "committedDate": "2020-06-02T11:18:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434042561", "bodyText": "Hm, why did you need to add this?", "author": "geoand", "createdAt": "2020-06-02T17:17:46Z", "path": "extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/SimpleJobs.java", "diffHunk": "@@ -4,8 +4,11 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n \n+import javax.enterprise.context.ApplicationScoped;\n+\n import io.quarkus.scheduler.Scheduled;\n \n+@ApplicationScoped", "originalCommit": "de5cde5c40a0078837c112edd634bc8bfd501845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjQ5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434152493", "bodyText": "It has to be a bean in order to detect the method annotated with @scheduled", "author": "aureamunoz", "createdAt": "2020-06-02T20:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzQ4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434153487", "bodyText": "But why did you have to add it as part of the PR?\nHow did it work before?", "author": "geoand", "createdAt": "2020-06-02T20:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1Njk0MA==", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434156940", "bodyText": "Ah, sorry, my bad. I thought I was watching at SimpleJobs.java in spring-scheduled extension. I should have added it to test something and it slipped through the cracks :-S Let me remove it", "author": "aureamunoz", "createdAt": "2020-06-02T20:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ=="}], "type": "inlineReview"}, {"oid": "e2953c21d7764b16d3084e314da91d0c2d4c30de", "url": "https://github.com/quarkusio/quarkus/commit/e2953c21d7764b16d3084e314da91d0c2d4c30de", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-04T20:48:57Z", "type": "forcePushed"}, {"oid": "0f4f58d90ee8a37ce5a1b0bdbe2d1f4734d198ec", "url": "https://github.com/quarkusio/quarkus/commit/0f4f58d90ee8a37ce5a1b0bdbe2d1f4734d198ec", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-17T08:27:28Z", "type": "forcePushed"}, {"oid": "2f6fd58c9d89edca3a5c60b7fd7c64e56063424a", "url": "https://github.com/quarkusio/quarkus/commit/2f6fd58c9d89edca3a5c60b7fd7c64e56063424a", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-17T10:20:50Z", "type": "commit"}, {"oid": "2f6fd58c9d89edca3a5c60b7fd7c64e56063424a", "url": "https://github.com/quarkusio/quarkus/commit/2f6fd58c9d89edca3a5c60b7fd7c64e56063424a", "message": "feature: add spring-scheduling extension", "committedDate": "2020-06-17T10:20:50Z", "type": "forcePushed"}]}