{"pr_number": 11271, "pr_title": "Move cache lock timeout logic to CacheResultInterceptor", "pr_createdAt": "2020-08-06T22:44:37Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11271", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MjgxNA==", "url": "https://github.com/quarkusio/quarkus/pull/11271#discussion_r467752814", "bodyText": "General comment on this class: we try to avoid lambdas in runtime code.", "author": "gsmet", "createdAt": "2020-08-10T08:21:51Z", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheResultInterceptor.java", "diffHunk": "@@ -19,11 +24,63 @@\n     @AroundInvoke\n     public Object intercept(InvocationContext context) throws Exception {\n         CacheResultInterceptorBinding binding = getInterceptorBinding(context, CacheResultInterceptorBinding.class);\n+\n         CaffeineCache cache = cacheRepository.getCache(binding.cacheName());\n         Object key = getCacheKey(cache, binding.cacheKeyParameterPositions(), context.getParameters());\n         if (LOGGER.isDebugEnabled()) {\n             LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cache.getName());\n         }\n-        return cache.get(key, () -> context.proceed(), binding.lockTimeout());\n+\n+        if (binding.lockTimeout() <= 0) {\n+            CompletableFuture<Object> cacheValue = cache.get(key, (k, executor) -> {\n+                return getValueLoader(context, executor);\n+            });\n+            return cacheValue.get();\n+        } else {\n+\n+            // The lock timeout logic starts here.\n+\n+            /*\n+             * If the current key is not already associated with a value in the Caffeine cache, there's no way to know if the\n+             * current thread or another one started the missing value computation. The following variable will be used to\n+             * determine whether or not a timeout should be triggered during the computation depending on which thread started\n+             * it.\n+             */\n+            boolean[] isCurrentThreadComputation = { false };\n+\n+            CompletableFuture<Object> cacheValue = cache.get(key, (k, executor) -> {\n+                isCurrentThreadComputation[0] = true;\n+                return getValueLoader(context, executor);\n+            });\n+\n+            if (isCurrentThreadComputation[0]) {\n+                // The value is missing and its computation was started from the current thread.\n+                // We'll wait for the result no matter how long it takes.\n+                return cacheValue.get();\n+            } else {\n+                // The value is either already present in the cache or missing and its computation was started from another thread.\n+                // We want to retrieve it from the cache within the lock timeout delay.\n+                try {\n+                    return cacheValue.get(binding.lockTimeout(), TimeUnit.MILLISECONDS);\n+                } catch (TimeoutException e) {\n+                    // Timeout triggered! We don't want to wait any longer for the value computation and we'll simply invoke the\n+                    // cached method and return its result without caching it.\n+                    // TODO: Add statistics here to monitor the timeout.\n+                    return context.proceed();\n+                }\n+            }\n+        }\n+    }\n+\n+    private CompletableFuture<Object> getValueLoader(InvocationContext context, Executor executor) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            try {\n+                return context.proceed();\n+            } catch (RuntimeException e) {\n+                throw e;\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, executor);", "originalCommit": "00686bdc2542d003368d32cf657dc50440730edc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3OTU4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11271#discussion_r467779583", "bodyText": "Thanks for reviewing this!\nI already knew about lambdas being the enemy in runtime code but there are only functional interfaces instances in this class (BiFunction for lines 35 and 51 and Supplier for line 76) which were already present before the PR (with a few differences). Are those nasty lambdas which should be eliminated as well?", "author": "gwenneg", "createdAt": "2020-08-10T09:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MjM0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11271#discussion_r467882341", "bodyText": "You can do it in a subsequent PR if you prefer but I would get rid of all the lambdas in this class.", "author": "gsmet", "createdAt": "2020-08-10T12:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNDM0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11271#discussion_r468124341", "bodyText": "I removed all lambdas from the extension runtime code, it should be good now.", "author": "gwenneg", "createdAt": "2020-08-10T19:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MjgxNA=="}], "type": "inlineReview"}, {"oid": "0ce7f22b38803e5586b6a6fb4f1208c3d9fc4f09", "url": "https://github.com/quarkusio/quarkus/commit/0ce7f22b38803e5586b6a6fb4f1208c3d9fc4f09", "message": "Move cache lock timeout logic to CacheResultInterceptor", "committedDate": "2020-08-10T19:13:31Z", "type": "commit"}, {"oid": "0ce7f22b38803e5586b6a6fb4f1208c3d9fc4f09", "url": "https://github.com/quarkusio/quarkus/commit/0ce7f22b38803e5586b6a6fb4f1208c3d9fc4f09", "message": "Move cache lock timeout logic to CacheResultInterceptor", "committedDate": "2020-08-10T19:13:31Z", "type": "forcePushed"}]}