{"pr_number": 8545, "pr_title": "Hibernate ORM Multitenancy", "pr_createdAt": "2020-04-13T07:30:57Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8545", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415831016", "bodyText": "Resolving the reference to the right TenantResolver via Arc is not necessary and actually a problem as we want to be able to start multiple instances of Hibernate ORM, which could be configured differently.\nYou should be able to simply inject the HibernateCurrentTenantIdentifierResolver instance into the ORM configuration; for example this should work:\nconfiguration.put( org.hibernate.cfg.AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, new HibernateCurrentTenantIdentifierResolver( tenantResolver ) );\n\nThis way you can store the tenant into a final field, properly and simply initialized in its constructor.", "author": "Sanne", "createdAt": "2020-04-27T13:52:21Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        TenantResolver resolver = tenantResolver();\n+\n+        // Make sure that we're in a request or return default tenant\n+        if (!Arc.container().requestContext().isActive()) {\n+            return resolver.getDefaultHibernateOrmTenantId();\n+        }\n+\n+        RoutingContext routingContext = routingContext();\n+        String tenantId = resolver.resolveHibernateOrmTenantId(routingContext);\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'CurrentTenantIdentifierResolver.\"\n+                    + \"resolveHibernateOrmTenantId(RoutingContext)' returned a null value. \"\n+                    + \"Unfortunately Hibernate ORM does not allow null for tenant identifiers. \"\n+                    + \"Please use a non-null value!\");\n+        }\n+        LOG.debugv(\"resolveCurrentTenantIdentifier(): {0}\", tenantId);\n+        return tenantId;\n+\n+    }\n+\n+    @Override\n+    public boolean validateExistingCurrentSessions() {\n+        return jpaConfig().isValidateTenantInCurrentSessions();\n+    }\n+\n+    /**\n+     * Returns the singleton JPA configuration instance.\n+     * \n+     * @return JPA configuration.\n+     */\n+    private static JPAConfig jpaConfig() {\n+        InstanceHandle<JPAConfig> jpaConfigInstance = Arc.container().instance(JPAConfig.class);\n+        if (!jpaConfigInstance.isAvailable()) {\n+            throw new IllegalStateException(\"No instance of JPAConfig found\");\n+        }\n+        return jpaConfigInstance.get();\n+    }\n+\n+    /**\n+     * Retrieves the routing context or fails if it is not available.\n+     * \n+     * @return Current routing context.\n+     */\n+    private static RoutingContext routingContext() {\n+        InstanceHandle<RoutingContext> routingContextInstance = Arc.container().instance(RoutingContext.class);\n+        if (!routingContextInstance.isAvailable()) {\n+            throw new IllegalStateException(\"No instance of \" + RoutingContext.class.getName() + \" was found.\");\n+        }\n+        return routingContextInstance.get();\n+    }\n+\n+    /**\n+     * Retrieves the tenant resolver or fails if it is not available.\n+     * \n+     * @return Current tenant resolver.\n+     */\n+    private static TenantResolver tenantResolver() {\n+        InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(TenantResolver.class);", "originalCommit": "a24a32087d6f107eb5fe4fff8f757a1baf928850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5Mzc0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415893743", "bodyText": "Which \" ORM configuration\" do you exactly refer to?", "author": "michael-schnell", "createdAt": "2020-04-27T15:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk0NjAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415946024", "bodyText": "It's the cfg Map variable you can see in io.quarkus.hibernate.orm.runtime.boot.FastBootMetadataBuilder#mergeSettings, were we set most other automatically inferred configuration properties.", "author": "Sanne", "createdAt": "2020-04-27T16:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMDAwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416010001", "bodyText": "OK, I guess it is then not the \"FastBootMetadataBuilder\", but the FastBootEntityManagerFactoryBuilder as the instance of HibernateCurrentTenantIdentifierResolver is created there.\nBut I assume this will not work as the \"FastBootEntityManagerFactoryBuilder\" will be created at startup (maybe application scope), but the \"TenantResolver\" needs to be resolved within a request scope.\nIs there really a need to support multiple instances of Hibernate ORM with multiple different implementations of the \"TenantResolver\"? This will get much more complicated. I guess the only way then would be to configure the class name of the actual \"TenantResolver\" per Hibernate ORM instance. But how do I configure multiple instances of Hibernate ORM? I haven't seen such a feature anywhere in the docs.", "author": "michael-schnell", "createdAt": "2020-04-27T17:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTc1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416131751", "bodyText": "Is there really a need to support multiple instances of Hibernate ORM with multiple different implementations of the \"TenantResolver\"?\n\nI'm afraid so: if we take such shortcuts it would all get confusing to use.\n\nBut how do I configure multiple instances of Hibernate ORM? I haven't seen such a feature anywhere in the docs.\n\nWe don't have the capability yet but it is in high demand; the problem is that as lots of people keep adding features and changes that make it conceptually harder we'll never be able to complete that.. which is why I please need some help in making sure all newly merged code at least take the requirement into account.\nI do understand it gets a little bit more complicated but I just want to make sure the design will make it possible at a conceptual level - not asking you to actually implement it.\nThanks!", "author": "Sanne", "createdAt": "2020-04-27T20:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMzODMzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416338331", "bodyText": "OK, let's assume we have multiple instances of Hibernate ORM. Then we will need to distinguish multiple instances of the tenant resolver and the resolvers may have different types. This could be achieved using CDI qualifiers and explicitly naming the resolver class.\nThen the solution would have two parts:\n\nDefine the type of the resolver by having it's fully qualified class name in the config\nDefine a qualifier in the config that maps somehow to the Hibernate ORM instance\n\nExample:\nquarkus.hibernate-orm.one.multitenant=SCHEMA\nquarkus.hibernate-orm.one.multitenancy-resolver=a.b.c.MyResolver // Implements TenantResolver\nquarkus.hibernate-orm.one.multitenancy-qualifier=one // Qualifier\nquarkus.hibernate-orm.two.multitenant=DATABASE\nquarkus.hibernate-orm.two.multitenancy-resolver=a.b.c.OtherResolver // Implements TenantResolver\nquarkus.hibernate-orm.two.multitenancy-qualifier=two // Qualifier\n\nCurrently we don't have multiple instances and we don't want to bother the user with such edge case configurations. The \"95% case\" will simply be one instance. Therefore we need a way to keep it still simple. This is exactly how it is implemented now and it is open to above future design.\nIn the FastBootEntityManagerFactoryBuilder the HibernateCurrentTenantIdentifierResolver instance is created and might use some configuration options later on, that are not needed now:\nif (strategy != null && strategy != MultiTenancyStrategy.NONE) {\n    options.applyMultiTenancyStrategy(strategy);\n    options.applyCurrentTenantIdentifierResolver(new HibernateCurrentTenantIdentifierResolver());\n}\nIn the HibernateCurrentTenantIdentifierResolver class we still resolve the TenantResolver dynamically (using Arc), because it is RequestScoped and we cannot create it at boot time in the FastBootEntityManagerFactoryBuilder:\nprivate static TenantResolver tenantResolver() {\n    InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(TenantResolver.class);\n    ....\n}\nLater on, when multiple Hibernate ORM instances are available you could use the qualifier and class from the configuration similar to this one:\nprivate static TenantResolver tenantResolver(Class<TenantResolver> resolverClass, String qualifierName) {\n    InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(resolverClass,\n            new AnnotationLiteral() {\n                public String value() {\n                    return qualifierName;\n                };\n            });\n      ...\nOne thing we could indeed move into the FastBootEntityManagerFactoryBuilder is the JPAConfig.\nSummary\nIf we do the changes you proposed in regard to the vertx module dependency and make the TenantResolver request scoped (as suggested above), the HibernateCurrentTenantIdentifierResolver can stay as it is now. JPAConfig will be passed to HibernateCurrentTenantIdentifierResolver as constructor parameter.\nIf you are OK with that, I will commit and squash my changes accordingly.", "author": "michael-schnell", "createdAt": "2020-04-28T05:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1OTMxNw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416559317", "bodyText": "Currently we don't have multiple instances and we don't want to bother the user with such edge case configurations. The \"95% case\" will simply be one instance. Therefore we need a way to keep it still simple. This is exactly how it is implemented now and it is open to above future design.\n\nI like what you're saying here and totally agree that we should keep it simple for the 95% of users.\nReferring to your example:\nI might be missing something since I've never used CDI, but wouldn't we conceptually need the user to just specify either the qualifier or the class? I would expect it to be possible to only need to express a \"single choice\".\nFurther more, consider that via the Jandex index we have a full analysis of the application; this implies that we can enumerate the implementations of, for example, a TenantResolver implementation and choose it as default when only a single implementation is found.\n(should we go with a single TenantResolver implementation and use qualifiers instead - assuming it's possible to use only one approach as mention in the previous paragraph - then resolving the default bean rather than using qualifiers should come even more natural?)\nThat would be sweet as it means the components could be bound correctly without any configuration at all; requiring configuration only for multiple persistence units which require to differentiate their settings.\n@manovotn / @mkouba would you have some time to review and correct my ramblings about ArC? I'd really hope we could keep this both flexible and straight forward to use :)\nThanks!", "author": "Sanne", "createdAt": "2020-04-28T12:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY0OTE1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416649155", "bodyText": "I have quite limited understanding of what you're trying to achieve and might need some more context, but broadly speaking - if you want to have multiple implementations of, say, TenantResolver, then you will end up with ambiguity if you try to just inject it based on type TenantResolver. You'd have to either use qualifiers, or resolve it based on the implementing class.\nAs for simple cases and having one TenantResolver by default, that's doable, you just have to have a singular existing bean with that type and without CDI qualifiers. From the above comments I understood that this is something you already have.\nIf the impl of TenantResolver is something that user defines, then they can define the qualifiers used with it as well. And if you then need to retrieve all impls of TenantResolver via CDI (regardless of qualifiers) you can do that too with (for instance) Arc.container().instance(TenantResolver.class, Any.Literal.INSTANCE) and then iterate over them.", "author": "manovotn", "createdAt": "2020-04-28T14:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1MDQ2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416650467", "bodyText": "If I am blabbering about something else then what you wanted to know, then please give me some more info and I'll try to help some more :-)", "author": "manovotn", "createdAt": "2020-04-28T14:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcwMzQxMA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416703410", "bodyText": "At the end I just wanted to show that using \"Arc.container().instance(..)\" is not \"evil\" here. It is required, because we need to resolve a request scoped bean and therefore we cannot do it at boot time. In addition to that it allows us in a later stage to change this as needed in HibernateCurrentTenantIdentifierResolver. But no need to do it now as we don't have multiple Hibernate ORM instances yet. So no need for qualifiers and other stuff now, but a way to go in the future.\nI already tested the new classes with the new Hibernate ORM multitenancy quickstart and it still works finr with the changes above. I will now commit them to continue here with the next review steps.", "author": "michael-schnell", "createdAt": "2020-04-28T15:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTk1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423881953", "bodyText": "Returning null here is illegal. Is this were you plan to use getDefaultTenantId() ?\nPerhaps an runtime exception is more suited?", "author": "Sanne", "createdAt": "2020-05-12T16:46:13Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    private final JPAConfig jpaConfig;\n+\n+    public HibernateCurrentTenantIdentifierResolver(final JPAConfig jpaConfig) {\n+        super();\n+        this.jpaConfig = jpaConfig;\n+    }\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        // Make sure that we're in a request\n+        if (!Arc.container().requestContext().isActive()) {\n+            return null;", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDIxMg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220212", "bodyText": "It is actually OK here. I checked this with the Hibernate source and it is not required to have a non-null value. The case is caused by calls to this method during early startup phase. At that time there is no request context so the only chance is to return null. For Hibernate there is in this case simply no tenant information available, which is fine.", "author": "michael-schnell", "createdAt": "2020-05-17T05:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mzk0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423883946", "bodyText": "It seems this is the only use for the jpaConfig object. Does this stricly need some lazy initialization, or could you read the field earlier and store only an immutable boolean field rather than keeping a reference to the bootstrap proxy?", "author": "Sanne", "createdAt": "2020-05-12T16:49:16Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    private final JPAConfig jpaConfig;\n+\n+    public HibernateCurrentTenantIdentifierResolver(final JPAConfig jpaConfig) {\n+        super();\n+        this.jpaConfig = jpaConfig;\n+    }\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        // Make sure that we're in a request\n+        if (!Arc.container().requestContext().isActive()) {\n+            return null;\n+        }\n+\n+        TenantResolver resolver = tenantResolver();\n+        String tenantId = resolver.resolveTenantId();\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'TenantResolver.resolveTenantId()' returned a null value. \"\n+                    + \"Unfortunately Hibernate ORM does not allow null for tenant identifiers. \"\n+                    + \"Please use a non-null value!\");\n+        }\n+        LOG.debugv(\"resolveCurrentTenantIdentifier(): {0}\", tenantId);\n+        return tenantId;\n+\n+    }\n+\n+    @Override\n+    public boolean validateExistingCurrentSessions() {\n+        return jpaConfig.isValidateTenantInCurrentSessions();", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNjUwMw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426226503", "bodyText": "Already removed when removing config 'ValidateTenantInCurrentSessions'.", "author": "michael-schnell", "createdAt": "2020-05-17T07:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4NDYzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423884635", "bodyText": "this should be safe to remove; we generally don't use Serialization, and when we do we prefer to not declare serial version ids as constants.", "author": "Sanne", "createdAt": "2020-05-12T16:50:11Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDMzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220335", "bodyText": "I removed it", "author": "michael-schnell", "createdAt": "2020-05-17T05:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4NDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MDcwOA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423890708", "bodyText": "Why is this static ? Let's try to avoid that, especially as this Service doesn't have any stop/destroy facility.\nFYI there's the option to implement org.hibernate.service.spi.Stoppable if you need a callback, but I believe removing the static should be done as well.", "author": "Sanne", "createdAt": "2020-05-12T16:59:12Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateMultiTenantConnectionProvider.class);\n+\n+    private static final Map<String, ConnectionProvider> PROVIDER_MAP = new ConcurrentHashMap<>();", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDU4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220586", "bodyText": "You're right, I changed it This was a leftover from setting the provider statically as a kind of singleton.", "author": "michael-schnell", "createdAt": "2020-05-17T05:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5Mzg5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423893891", "bodyText": "I'd prefer if you could use an \"old fashioned get\" here first, only falling back to a computeIfAbsent operation if your local cache doesn't have it so to avoid contention in the implementation of ConcurrentHashMap#computeIfAbsent since there is no need to have contention.", "author": "Sanne", "createdAt": "2020-05-12T17:04:24Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateMultiTenantConnectionProvider.class);\n+\n+    private static final Map<String, ConnectionProvider> PROVIDER_MAP = new ConcurrentHashMap<>();\n+\n+    @Override\n+    protected ConnectionProvider getAnyConnectionProvider() {\n+        String tenantId = tenantResolver().getDefaultTenantId();\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'TenantResolver.getDefaultTenantId()' returned a null value. \"\n+                    + \"This violates the contract of the interface!\");\n+        }\n+        return selectConnectionProvider(tenantId);\n+    }\n+\n+    @Override\n+    protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {\n+        LOG.debugv(\"selectConnectionProvider({0})\", tenantIdentifier);\n+\n+        return PROVIDER_MAP.computeIfAbsent(tenantIdentifier, tid -> {", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDkxNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220914", "bodyText": "OK, I changed it", "author": "michael-schnell", "createdAt": "2020-05-17T05:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5Mzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTMyMA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423899320", "bodyText": "I'm wondering if it wouldn't be better to refrain from exposing this option. AFAIR Quarkus we don't expose org.hibernate.context.spi.CurrentSessionContext, which makes this check useless?\nI'd prefer to omit this, as less is more - especially when it's easy to add things, but never easy to remove something.\nAlso, removing this configuration option would resolve a couple more comments I had :)", "author": "Sanne", "createdAt": "2020-05-12T17:13:08Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenant;\n+\n+    /**\n+     * Defines the name of the data source to use in case of SCHEMA approach. The default data source will be used if not set.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenantSchemaDatasource;\n+\n+    /**\n+     * Defines if the tenant identifier of the \"current sessions\" should be validated every time the tenant identifier is", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMTM5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426221392", "bodyText": "OK, I removed it", "author": "michael-schnell", "createdAt": "2020-05-17T06:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTYwMw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423899603", "bodyText": "Could you also clarify that NONE is the default?", "author": "Sanne", "createdAt": "2020-05-12T17:13:35Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMjg5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426222895", "bodyText": "OK, I added a hint for the default.", "author": "michael-schnell", "createdAt": "2020-05-17T06:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjY1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423906655", "bodyText": "Could you avoid registering this bean as \"unremovable\" when multitenancy is not being used?", "author": "Sanne", "createdAt": "2020-05-12T17:25:09Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -405,7 +417,7 @@ void registerBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans, Combi\n \n         additionalBeans.produce(AdditionalBeanBuildItem.builder().setUnremovable()\n                 .addBeanClasses(JPAConfig.class, TransactionEntityManagers.class,\n-                        RequestScopedEntityManagerHolder.class)\n+                        RequestScopedEntityManagerHolder.class, DataSourceTenantConnectionResolver.class)", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNTQ4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426225482", "bodyText": "OK, I changed it.", "author": "michael-schnell", "createdAt": "2020-05-17T06:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxMDQ2OA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423910468", "bodyText": "So assuming I set it to \"schema\" approach, why would I ever want to set this to a different value than what I'm configuring Hiberante ORM to use in the database.defaultSchema setting?\nI would prefer to imply (and enforce) a reasonable default rather than exposing another configuration option. Unless I'm missing something of course.", "author": "Sanne", "createdAt": "2020-05-12T17:31:19Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenant;\n+\n+    /**\n+     * Defines the name of the data source to use in case of SCHEMA approach. The default data source will be used if not set.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenantSchemaDatasource;", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNTk3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426225976", "bodyText": "This could be helpful if you for example want to separate the default database from the one used for tenant schemas. I would prefer to leave it as it is, to allow separation in case this is needed. We also have  a good default if the user does not set it. But there is now still the option to separate the tenant stuff from the default data source.", "author": "michael-schnell", "createdAt": "2020-05-17T07:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxMDQ2OA=="}], "type": "inlineReview"}, {"oid": "24b81ab92d3d927cc666dc2685d803188015aa3a", "url": "https://github.com/quarkusio/quarkus/commit/24b81ab92d3d927cc666dc2685d803188015aa3a", "message": "Hibernate ORM Multitenancy", "committedDate": "2020-05-17T07:15:01Z", "type": "commit"}]}