{"pr_number": 9370, "pr_title": "Add a Redis extension", "pr_createdAt": "2020-05-16T09:00:22Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9370", "timeline": [{"oid": "f83ccaca2c929572b1ef5d8291ac9138be2f18bd", "url": "https://github.com/quarkusio/quarkus/commit/f83ccaca2c929572b1ef5d8291ac9138be2f18bd", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T09:09:33Z", "type": "forcePushed"}, {"oid": "5b6f88cfa294ef70e9e3af2a96ba30bea80f0792", "url": "https://github.com/quarkusio/quarkus/commit/5b6f88cfa294ef70e9e3af2a96ba30bea80f0792", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T12:44:54Z", "type": "forcePushed"}, {"oid": "b10c8c791ef519a097880e67c702b4de691e8567", "url": "https://github.com/quarkusio/quarkus/commit/b10c8c791ef519a097880e67c702b4de691e8567", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T13:04:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426156079", "bodyText": "Let's try and not use this style anymore.\nRecently we have updated, Data source, Mongo, Mailer and Flyway (for Liquibase I just opened a PR) to avoid this old ugly pattern.\nSo let's try and use the new better pattern with this extension please.", "author": "geoand", "createdAt": "2020-05-16T14:00:20Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisAPIsProducer.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+public class RedisAPIsProducer {\n+    static long timeout = 10;\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    Redis redisClient;\n+\n+    RedisAPI redisAPI;\n+\n+    SyncRedisAPI syncRedisAPI;\n+\n+    io.vertx.axle.redis.client.Redis axleRedisClient;\n+\n+    io.vertx.axle.redis.client.RedisAPI axleRedisAPI;\n+\n+    io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;\n+\n+    void initialize(RedisOptions redisOptions) {", "originalCommit": "b10c8c791ef519a097880e67c702b4de691e8567", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NjQyNA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426166424", "bodyText": "I had this pattern hanging in for a while, but I honestly do not think it is ugly. I'll try to change it for consistency with the other.", "author": "machi1990", "createdAt": "2020-05-16T16:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Nzc1OA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426167758", "bodyText": "It's ugly in the sense that a CDI bean is created without having it's state fully populated. That goes against what CDI is meant for and was only done in the older versions of code because we had no better alternative.\nWith the advent of synthetic beans, we now have a much more consistent way of handling things.", "author": "geoand", "createdAt": "2020-05-16T16:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3MDUwNA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426170504", "bodyText": "Thanks for clarifying it. I do not think we need here right? I mean, I needed the .initialize() method because in the earlier version of the extension there was no better way of injecting runtime config roots, now that we can I think we can make use of that. And remove other unnecessary bits. So good eye for spotting this one :-)", "author": "machi1990", "createdAt": "2020-05-16T16:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3MDc1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426170757", "bodyText": "Yes exactly my point. Config roots can just be infected into the beans.\nAny extra options not provided by config root but created in recorders should create synthetic beans that are then injected into the beans where they are used", "author": "geoand", "createdAt": "2020-05-16T16:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}], "type": "inlineReview"}, {"oid": "4e6190c281059772ea95f52270e36411141392fc", "url": "https://github.com/quarkusio/quarkus/commit/4e6190c281059772ea95f52270e36411141392fc", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T16:43:08Z", "type": "forcePushed"}, {"oid": "cb7a3b807b2caf7a13815f36ddd63d3967966f37", "url": "https://github.com/quarkusio/quarkus/commit/cb7a3b807b2caf7a13815f36ddd63d3967966f37", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T16:46:58Z", "type": "forcePushed"}, {"oid": "bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "url": "https://github.com/quarkusio/quarkus/commit/bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T19:20:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429169016", "bodyText": "I wonder if it makes sense to group these methods somehow. My reasoning is that we have a ton of methods so perhaps it would be useful to users to be able to more easily locate methods if they can be added to appropriate groups.", "author": "geoand", "createdAt": "2020-05-22T10:29:32Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/SyncRedisAPI.java", "diffHunk": "@@ -0,0 +1,417 @@\n+package io.quarkus.vertx.redis;\n+\n+import java.util.List;\n+\n+import io.vertx.redis.client.Response;\n+\n+/**\n+ * A synchronous RedisAPI offering blocking Redis commands.\n+ * The commands have a default timeout of 10 seconds which can be configured\n+ * via {@code quarkus.redis.timeout} configuration knob.\n+ *\n+ * For more information about how each individual command visit\n+ * the <a href=\"https://redis.io/commands\">Redis Commands Page</a>\n+ */\n+public interface SyncRedisAPI {", "originalCommit": "bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2OTM0NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429369344", "bodyText": "This API design was heavily inspired by the mutiny based API.\nI'll be inclined to keep this dense to match the reactive counterpart.\nIn the future this class be gone as IIRC there a plans in Vert.x to provide a blocking based API - I just cannot seem to find the issue/PR were I saw this plan.\n/cc @pmlopes @cescoffier if you have any info.", "author": "machi1990", "createdAt": "2020-05-22T17:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3MzUzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429373539", "bodyText": "Hi, I don't know how you wrote this but on vertx upstream there's an handlebar template we have to generate this from the redis metadata. Perhaps you can reuse, improve it if you like", "author": "pmlopes", "createdAt": "2020-05-22T17:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NjQ3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429376474", "bodyText": "In the future this class be gone as IIRC there a plans in Vert.x to provide a blocking based API - I just cannot seem to find the issue/PR were I saw this plan.\n/cc @pmlopes @cescoffier if you have any info.\n\nFound the issue - smallrye/smallrye-mutiny-vertx-bindings#13 but it seem closed.\n\nHi, I don't know how you wrote this but on vertx upstream there's an handlebar template we have to generate this from the redis metadata. Perhaps you can reuse, improve it if you like\n\nWell, IDE did most of the work for me really.", "author": "machi1990", "createdAt": "2020-05-22T17:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTMwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429169301", "bodyText": "These can be private final, no?", "author": "geoand", "createdAt": "2020-05-22T10:30:07Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisAPIProducer.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisClientType;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+public class RedisAPIProducer {\n+    private static final char AT = '@';\n+    private static final char COLON = ':';\n+    private static final char SLASH = '/';\n+    private static final String REDIS_SCHEME = \"redis://\";\n+    private long timeout = 10;\n+\n+    Redis redisClient;\n+\n+    RedisAPI redisAPI;\n+\n+    SyncRedisAPI syncRedisAPI;\n+\n+    io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;", "originalCommit": "bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzMDQ0MA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429330440", "bodyText": "Good idea.", "author": "machi1990", "createdAt": "2020-05-22T15:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTMwMQ=="}], "type": "inlineReview"}, {"oid": "ff70985ad036e48d54730a01023fdf2332e23a5b", "url": "https://github.com/quarkusio/quarkus/commit/ff70985ad036e48d54730a01023fdf2332e23a5b", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-22T17:39:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTA1MA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429375050", "bodyText": "Redistribution has now an official iana registered connection string url format. Upstream we have the parser under the impl package but if it makes sense you could refer to it RedisURI as the api is stable and shouldn't change.", "author": "pmlopes", "createdAt": "2020-05-22T17:40:14Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisAPIProducer.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisClientType;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+class RedisAPIProducer {\n+    private static final char AT = '@';\n+    private static final char COLON = ':';\n+    private static final char SLASH = '/';\n+    private static final String REDIS_SCHEME = \"redis://\";\n+    private long timeout = 10;\n+\n+    private final Redis redisClient;\n+\n+    private final RedisAPI redisAPI;\n+\n+    private final SyncRedisAPI syncRedisAPI;\n+\n+    private final io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    private final io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;\n+\n+    public RedisAPIProducer(RedisConfig config, Vertx vertx) {\n+        RedisOptions options = new RedisOptions();\n+        options.setType(config.clientType);\n+\n+        if (RedisClientType.STANDALONE == config.clientType) {\n+            if (config.hosts.isPresent() && config.hosts.get().size() > 1) {\n+                throw new ConfigurationException(\"Multiple hosts supplied for non clustered configuration\");\n+            }\n+        }\n+\n+        if (config.hosts.isPresent()) {\n+            Set<InetSocketAddress> hosts = config.hosts.get();\n+            for (InetSocketAddress host : hosts) {\n+                options.addConnectionString(buildRedisUrl(host, config.password, config.database));\n+            }\n+        } else {\n+            InetSocketAddress defaultRedisAddress = new InetSocketAddress(\"localhost\", 6379);\n+            options.addConnectionString(buildRedisUrl(defaultRedisAddress, config.password, config.database));\n+        }\n+\n+        if (config.timeout.isPresent()) {\n+            timeout = config.timeout.get().getSeconds();\n+        }\n+\n+        redisClient = Redis.createClient(vertx, options);\n+        redisAPI = RedisAPI.api(redisClient);\n+        mutinyRedisClient = io.vertx.mutiny.redis.client.Redis.newInstance(redisClient);\n+        mutinyRedisAPI = io.vertx.mutiny.redis.client.RedisAPI.api(mutinyRedisClient);\n+        syncRedisAPI = new SyncRedisAPIImpl(mutinyRedisAPI, timeout);\n+    }\n+\n+    @Produces\n+    @Singleton\n+    Redis redis() {\n+        return redisClient;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    RedisAPI redisAPI() {\n+        return redisAPI;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    SyncRedisAPI syncRedisAPI() {\n+        return syncRedisAPI;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    io.vertx.mutiny.redis.client.Redis mutinyRedisClient() {\n+        return mutinyRedisClient;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI() {\n+        return mutinyRedisAPI;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        this.redis().close();\n+    }\n+\n+    private String buildRedisUrl(InetSocketAddress address, Optional<String> password, int database) {", "originalCommit": "ff70985ad036e48d54730a01023fdf2332e23a5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NjY5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429376697", "bodyText": "Great. Good to know. I'll look into that.", "author": "machi1990", "createdAt": "2020-05-22T17:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTY3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429375674", "bodyText": "I think if you use the connection string format I think all this class is not needed.", "author": "pmlopes", "createdAt": "2020-05-22T17:41:41Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisConfig.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.vertx.redis.client.RedisClientType;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class RedisConfig {", "originalCommit": "ff70985ad036e48d54730a01023fdf2332e23a5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3OTU4NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429379584", "bodyText": "Thanks for the review. We'll still need this class as it is the configuration root class.\nQuick question: Does ssl work with the new api? Do you have an example how I can set it up?", "author": "machi1990", "createdAt": "2020-05-22T17:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTY3NA=="}], "type": "inlineReview"}, {"oid": "53608c48aa58abefaec50fdf4c33ec84e41d4481", "url": "https://github.com/quarkusio/quarkus/commit/53608c48aa58abefaec50fdf4c33ec84e41d4481", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-22T18:43:08Z", "type": "forcePushed"}, {"oid": "2a10b8a494b7e2ff585a42191c883c81c41bedf9", "url": "https://github.com/quarkusio/quarkus/commit/2a10b8a494b7e2ff585a42191c883c81c41bedf9", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-23T07:57:51Z", "type": "forcePushed"}, {"oid": "1c396334e3dce8c9e7933fb1bc6e1760246bd88d", "url": "https://github.com/quarkusio/quarkus/commit/1c396334e3dce8c9e7933fb1bc6e1760246bd88d", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-30T09:35:19Z", "type": "forcePushed"}, {"oid": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "url": "https://github.com/quarkusio/quarkus/commit/31f3c279e6082578e12fb89583a8c8c34fd0407b", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-02T18:43:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0ODU2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441448567", "bodyText": "I don't know about the name. The SQL clients went for Reactive XXX client. MongoDB is simply mongodb-client.\n@cescoffier WDYT?", "author": "gsmet", "createdAt": "2020-06-17T10:33:38Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/FeatureBuildItem.java", "diffHunk": "@@ -114,6 +114,7 @@\n     public static final String VERTX_WEB = \"vertx-web\";\n     public static final String VERTX_GRAPHQL = \"vertx-graphql\";\n     public static final String WEBJARS_LOCATOR = \"webjars-locator\";\n+    public static final String VERTX_REDIS = \"vertx-redis\";", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ2ODMzOA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441468338", "bodyText": "After discussion with @cescoffier , let's be consistent with the MongoDB one and name it redis-client.", "author": "gsmet", "createdAt": "2020-06-17T11:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0ODU2Nw=="}], "type": "inlineReview"}, {"oid": "6f7ff316e7469c059eba9a4da23d0ead689b9a1f", "url": "https://github.com/quarkusio/quarkus/commit/6f7ff316e7469c059eba9a4da23d0ead689b9a1f", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-19T20:52:22Z", "type": "forcePushed"}, {"oid": "001ceb768e9675f74db784985b3c1158561ab23c", "url": "https://github.com/quarkusio/quarkus/commit/001ceb768e9675f74db784985b3c1158561ab23c", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-19T21:00:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzM2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443337362", "bodyText": "It should be tested with more complicated objects (list, json, pojo...)", "author": "cescoffier", "createdAt": "2020-06-22T06:17:41Z", "path": "integration-tests/redis-client/src/main/java/io/quarkus/redis/it/RedisResource.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.quarkus.redis.it;\n+\n+import java.util.Arrays;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+\n+@Path(\"/quarkus-redis\")\n+@ApplicationScoped\n+public class RedisResource {\n+    @Inject\n+    SyncRedisAPI syncRedisAPI;\n+\n+    @Inject\n+    RedisAPI reactiveRedisAPI;\n+\n+    // synchronous\n+    @GET\n+    @Path(\"/sync/{key}\")\n+    public String getSync(@PathParam(\"key\") String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    @POST\n+    @Path(\"/sync/{key}\")\n+    public void setSync(@PathParam(\"key\") String key, String value) {\n+        this.syncRedisAPI.set(Arrays.asList(key, value));\n+    }\n+\n+    // reactive\n+    @GET\n+    @Path(\"/reactive/{key}\")\n+    public Uni<String> getReactive(@PathParam(\"key\") String key) {", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODAwNg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443338006", "bodyText": "There is a lot more options to be configured:\nhttps://github.com/vert-x3/vertx-redis-client/blob/master/src/main/java/io/vertx/redis/client/RedisOptions.java", "author": "cescoffier", "createdAt": "2020-06-22T06:19:44Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisConfig.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.vertx.redis.client.RedisClientType;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class RedisConfig {", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxMTY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444311645", "bodyText": "Yes, let's add them gradually as they are requested.", "author": "machi1990", "createdAt": "2020-06-23T15:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443338315", "bodyText": "shouldn't we use the synthetic bean approach?", "author": "cescoffier", "createdAt": "2020-06-22T06:20:43Z", "path": "extensions/redis-client/deployment/src/main/java/io/quarkus/redis/client/deployment/RedisClientProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.redis.client.deployment;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.smallrye.health.deployment.spi.HealthBuildItem;\n+import io.vertx.redis.client.impl.types.BulkType;\n+\n+public class RedisClientProcessor {\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(Feature.REDIS_CLIENT);\n+    }\n+\n+    @BuildStep\n+    ExtensionSslNativeSupportBuildItem activateSslNativeSupport() {\n+        return new ExtensionSslNativeSupportBuildItem(Feature.REDIS_CLIENT.getName());\n+    }\n+\n+    @BuildStep\n+    AdditionalBeanBuildItem registerAPIsProducer() {\n+        return AdditionalBeanBuildItem.unremovableOf(\"io.quarkus.redis.client.runtime.RedisAPIProducer\");", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxMjQwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444312403", "bodyText": "Why?", "author": "machi1990", "createdAt": "2020-06-23T15:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MTg4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449471885", "bodyText": "We had some issues with beans not being injectable in gRPC for instance.\nI might admit that I have no idea if it will be the case here. @mkouba could you confirm if we need the synthetic bean approach or if the producer approach will fly here?", "author": "gsmet", "createdAt": "2020-07-03T09:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ4ODc2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449488769", "bodyText": "Synthetic beans are the way to go if there is a possibility that someone attempts to inject @Dependent/@Singleton bean produced by an uninitialized producer bean (usually before the StartupEvent is fired). From what I see the RedisAPIProducer is not initialized by a recorder so I think it's OK.", "author": "mkouba", "createdAt": "2020-07-03T09:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NDY3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443354676", "bodyText": "Make sure this is documented as it does not use the default value attribute.", "author": "cescoffier", "createdAt": "2020-06-22T07:05:02Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisAPIProducer.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Set;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisClientType;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+class RedisAPIProducer {\n+    private static final char AT = '@';\n+    private static final char COLON = ':';\n+    private static final char SLASH = '/';\n+    private static final String REDIS_SCHEME = \"redis://\";\n+    private static final String REDIS_SSL_SCHEME = \"rediss://\";\n+\n+    private long timeout = 10;\n+\n+    private final RedisConfig config;\n+\n+    private final Redis redisClient;\n+\n+    private final RedisAPI redisAPI;\n+\n+    private final SyncRedisAPI syncRedisAPI;\n+\n+    private final io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    private final io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;\n+\n+    public RedisAPIProducer(RedisConfig config, Vertx vertx) {\n+        this.config = config;\n+        RedisOptions options = new RedisOptions();\n+        options.setType(config.clientType);\n+\n+        if (RedisClientType.STANDALONE == config.clientType) {\n+            if (config.hosts.isPresent() && config.hosts.get().size() > 1) {\n+                throw new ConfigurationException(\"Multiple hosts supplied for non clustered configuration\");\n+            }\n+        }\n+\n+        if (config.hosts.isPresent()) {\n+            Set<InetSocketAddress> hosts = config.hosts.get();\n+            for (InetSocketAddress host : hosts) {\n+                String connectionString = buildConnectionString(host);\n+                options.addConnectionString(connectionString);\n+            }\n+        } else {\n+            InetSocketAddress defaultRedisAddress = new InetSocketAddress(\"localhost\", 6379);", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxNDM1MA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444314350", "bodyText": "It should be automatically documented with this default value https://github.com/quarkusio/quarkus/pull/9370/files#diff-61bc41cc0a7b78f75d4088c283c29ffbR25", "author": "machi1990", "createdAt": "2020-06-23T15:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTQwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443355401", "bodyText": "You should use mutiyResponse.await().atMost(Duration.ofSeconds(timeout);", "author": "cescoffier", "createdAt": "2020-06-22T07:06:48Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/SyncRedisAPIImpl.java", "diffHunk": "@@ -0,0 +1,1039 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+import io.vertx.redis.client.Response;\n+\n+class SyncRedisAPIImpl implements SyncRedisAPI {\n+\n+    private final RedisAPI redisAPI;\n+    private final long timeout;\n+\n+    public SyncRedisAPIImpl(RedisAPI redisAPI, long timeout) {\n+        this.redisAPI = redisAPI;\n+        this.timeout = timeout;\n+    }\n+\n+    @Override\n+    public void close() {\n+        redisAPI.close();\n+    }\n+\n+    @Override\n+    public Response append(String arg0, String arg1) {\n+        return await(redisAPI.append(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response asking() {\n+        return await(redisAPI.asking());\n+    }\n+\n+    @Override\n+    public Response auth(String arg0) {\n+        return await(redisAPI.auth(arg0));\n+    }\n+\n+    @Override\n+    public Response bgrewriteaof() {\n+        return await(redisAPI.bgrewriteaof());\n+    }\n+\n+    @Override\n+    public Response bgsave(List<String> args) {\n+        return await(redisAPI.bgsave(args));\n+    }\n+\n+    @Override\n+    public Response bitcount(List<String> args) {\n+        return await(redisAPI.bitcount(args));\n+    }\n+\n+    @Override\n+    public Response bitfield(List<String> args) {\n+        return await(redisAPI.bitfield(args));\n+    }\n+\n+    @Override\n+    public Response bitop(List<String> args) {\n+        return await(redisAPI.bitop(args));\n+    }\n+\n+    @Override\n+    public Response bitpos(List<String> args) {\n+        return await(redisAPI.bitpos(args));\n+    }\n+\n+    @Override\n+    public Response blpop(List<String> args) {\n+        return await(redisAPI.blpop(args));\n+    }\n+\n+    @Override\n+    public Response brpop(List<String> args) {\n+        return await(redisAPI.brpop(args));\n+    }\n+\n+    @Override\n+    public Response brpoplpush(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.brpoplpush(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response bzpopmax(List<String> args) {\n+        return await(redisAPI.bzpopmax(args));\n+    }\n+\n+    @Override\n+    public Response bzpopmin(List<String> args) {\n+        return await(redisAPI.bzpopmin(args));\n+    }\n+\n+    @Override\n+    public Response client(List<String> args) {\n+        return await(redisAPI.client(args));\n+    }\n+\n+    @Override\n+    public Response cluster(List<String> args) {\n+        return await(redisAPI.cluster(args));\n+    }\n+\n+    @Override\n+    public Response command() {\n+        return await(redisAPI.command());\n+    }\n+\n+    @Override\n+    public Response config(List<String> args) {\n+        return await(redisAPI.config(args));\n+    }\n+\n+    @Override\n+    public Response dbsize() {\n+        return await(redisAPI.dbsize());\n+    }\n+\n+    @Override\n+    public Response debug(List<String> args) {\n+        return await(redisAPI.debug(args));\n+    }\n+\n+    @Override\n+    public Response decr(String arg0) {\n+        return await(redisAPI.decr(arg0));\n+    }\n+\n+    @Override\n+    public Response decrby(String arg0, String arg1) {\n+        return await(redisAPI.decrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response del(List<String> args) {\n+        return await(redisAPI.del(args));\n+    }\n+\n+    @Override\n+    public Response discard() {\n+        return await(redisAPI.discard());\n+    }\n+\n+    @Override\n+    public Response dump(String arg0) {\n+        return await(redisAPI.dump(arg0));\n+    }\n+\n+    @Override\n+    public Response echo(String arg0) {\n+        return await(redisAPI.echo(arg0));\n+    }\n+\n+    @Override\n+    public Response eval(List<String> args) {\n+        return await(redisAPI.eval(args));\n+    }\n+\n+    @Override\n+    public Response evalsha(List<String> args) {\n+        return await(redisAPI.evalsha(args));\n+    }\n+\n+    @Override\n+    public Response exec() {\n+        return await(redisAPI.exec());\n+    }\n+\n+    @Override\n+    public Response exists(List<String> args) {\n+        return await(redisAPI.exists(args));\n+    }\n+\n+    @Override\n+    public Response expire(String arg0, String arg1) {\n+        return await(redisAPI.expire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response expireat(String arg0, String arg1) {\n+        return await(redisAPI.expireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response flushall(List<String> args) {\n+        return await(redisAPI.flushall(args));\n+    }\n+\n+    @Override\n+    public Response flushdb(List<String> args) {\n+        return await(redisAPI.flushdb(args));\n+    }\n+\n+    @Override\n+    public Response geoadd(List<String> args) {\n+        return await(redisAPI.geoadd(args));\n+    }\n+\n+    @Override\n+    public Response geodist(List<String> args) {\n+        return await(redisAPI.geodist(args));\n+    }\n+\n+    @Override\n+    public Response geohash(List<String> args) {\n+        return await(redisAPI.geohash(args));\n+    }\n+\n+    @Override\n+    public Response geopos(List<String> args) {\n+        return await(redisAPI.geopos(args));\n+    }\n+\n+    @Override\n+    public Response georadius(List<String> args) {\n+        return await(redisAPI.georadius(args));\n+    }\n+\n+    @Override\n+    public Response georadiusRo(List<String> args) {\n+        return await(redisAPI.georadiusRo(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymember(List<String> args) {\n+        return await(redisAPI.georadiusbymember(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymemberRo(List<String> args) {\n+        return await(redisAPI.georadiusbymemberRo(args));\n+    }\n+\n+    @Override\n+    public Response get(String arg0) {\n+        return await(redisAPI.get(arg0));\n+    }\n+\n+    @Override\n+    public Response getbit(String arg0, String arg1) {\n+        return await(redisAPI.getbit(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response getrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.getrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response getset(String arg0, String arg1) {\n+        return await(redisAPI.getset(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hdel(List<String> args) {\n+        return await(redisAPI.hdel(args));\n+    }\n+\n+    @Override\n+    public Response hexists(String arg0, String arg1) {\n+        return await(redisAPI.hexists(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hget(String arg0, String arg1) {\n+        return await(redisAPI.hget(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hgetall(String arg0) {\n+        return await(redisAPI.hgetall(arg0));\n+    }\n+\n+    @Override\n+    public Response hincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hincrbyfloat(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrbyfloat(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hkeys(String arg0) {\n+        return await(redisAPI.hkeys(arg0));\n+    }\n+\n+    @Override\n+    public Response hlen(String arg0) {\n+        return await(redisAPI.hlen(arg0));\n+    }\n+\n+    @Override\n+    public Response hmget(List<String> args) {\n+        return await(redisAPI.hmget(args));\n+    }\n+\n+    @Override\n+    public Response hmset(List<String> args) {\n+        return await(redisAPI.hmset(args));\n+    }\n+\n+    @Override\n+    public Response host(List<String> args) {\n+        return await(redisAPI.host(args));\n+    }\n+\n+    @Override\n+    public Response hscan(List<String> args) {\n+        return await(redisAPI.hscan(args));\n+    }\n+\n+    @Override\n+    public Response hset(List<String> args) {\n+        return await(redisAPI.hset(args));\n+    }\n+\n+    @Override\n+    public Response hsetnx(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hsetnx(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hstrlen(String arg0, String arg1) {\n+        return await(redisAPI.hstrlen(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hvals(String arg0) {\n+        return await(redisAPI.hvals(arg0));\n+    }\n+\n+    @Override\n+    public Response incr(String arg0) {\n+        return await(redisAPI.incr(arg0));\n+    }\n+\n+    @Override\n+    public Response incrby(String arg0, String arg1) {\n+        return await(redisAPI.incrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response incrbyfloat(String arg0, String arg1) {\n+        return await(redisAPI.incrbyfloat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response info(List<String> args) {\n+        return await(redisAPI.info(args));\n+    }\n+\n+    @Override\n+    public Response keys(String arg0) {\n+        return await(redisAPI.keys(arg0));\n+    }\n+\n+    @Override\n+    public Response lastsave() {\n+        return await(redisAPI.lastsave());\n+    }\n+\n+    @Override\n+    public Response latency(List<String> args) {\n+        return await(redisAPI.latency(args));\n+    }\n+\n+    @Override\n+    public Response lindex(String arg0, String arg1) {\n+        return await(redisAPI.lindex(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response linsert(String arg0, String arg1, String arg2, String arg3) {\n+        return await(redisAPI.linsert(arg0, arg1, arg2, arg3));\n+    }\n+\n+    @Override\n+    public Response llen(String arg0) {\n+        return await(redisAPI.llen(arg0));\n+    }\n+\n+    @Override\n+    public Response lolwut(List<String> args) {\n+        return await(redisAPI.lolwut(args));\n+    }\n+\n+    @Override\n+    public Response lpop(String arg0) {\n+        return await(redisAPI.lpop(arg0));\n+    }\n+\n+    @Override\n+    public Response lpush(List<String> args) {\n+        return await(redisAPI.lpush(args));\n+    }\n+\n+    @Override\n+    public Response lpushx(List<String> args) {\n+        return await(redisAPI.lpushx(args));\n+    }\n+\n+    @Override\n+    public Response lrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lrem(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrem(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lset(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lset(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response ltrim(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.ltrim(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response memory(List<String> args) {\n+        return await(redisAPI.memory(args));\n+    }\n+\n+    @Override\n+    public Response mget(List<String> args) {\n+        return await(redisAPI.mget(args));\n+    }\n+\n+    @Override\n+    public Response migrate(List<String> args) {\n+        return await(redisAPI.migrate(args));\n+    }\n+\n+    @Override\n+    public Response module(List<String> args) {\n+        return await(redisAPI.module(args));\n+    }\n+\n+    @Override\n+    public Response monitor() {\n+        return await(redisAPI.monitor());\n+    }\n+\n+    @Override\n+    public Response move(String arg0, String arg1) {\n+        return await(redisAPI.move(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response mset(List<String> args) {\n+        return await(redisAPI.mset(args));\n+    }\n+\n+    @Override\n+    public Response msetnx(List<String> args) {\n+        return await(redisAPI.msetnx(args));\n+    }\n+\n+    @Override\n+    public Response multi() {\n+        return await(redisAPI.multi());\n+    }\n+\n+    @Override\n+    public Response object(List<String> args) {\n+        return await(redisAPI.object(args));\n+    }\n+\n+    @Override\n+    public Response persist(String arg0) {\n+        return await(redisAPI.persist(arg0));\n+    }\n+\n+    @Override\n+    public Response pexpire(String arg0, String arg1) {\n+        return await(redisAPI.pexpire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pexpireat(String arg0, String arg1) {\n+        return await(redisAPI.pexpireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pfadd(List<String> args) {\n+        return await(redisAPI.pfadd(args));\n+    }\n+\n+    @Override\n+    public Response pfcount(List<String> args) {\n+        return await(redisAPI.pfcount(args));\n+    }\n+\n+    @Override\n+    public Response pfdebug(List<String> args) {\n+        return await(redisAPI.pfdebug(args));\n+    }\n+\n+    @Override\n+    public Response pfmerge(List<String> args) {\n+        return await(redisAPI.pfmerge(args));\n+    }\n+\n+    @Override\n+    public Response pfselftest() {\n+        return await(redisAPI.pfselftest());\n+    }\n+\n+    @Override\n+    public Response ping(List<String> args) {\n+        return await(redisAPI.ping(args));\n+    }\n+\n+    @Override\n+    public Response post(List<String> args) {\n+        return await(redisAPI.post(args));\n+    }\n+\n+    @Override\n+    public Response psetex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.psetex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response psubscribe(List<String> args) {\n+        return await(redisAPI.psubscribe(args));\n+    }\n+\n+    @Override\n+    public Response psync(String arg0, String arg1) {\n+        return await(redisAPI.psync(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pttl(String arg0) {\n+        return await(redisAPI.pttl(arg0));\n+    }\n+\n+    @Override\n+    public Response publish(String arg0, String arg1) {\n+        return await(redisAPI.publish(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pubsub(List<String> args) {\n+        return await(redisAPI.pubsub(args));\n+    }\n+\n+    @Override\n+    public Response punsubscribe(List<String> args) {\n+        return await(redisAPI.punsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response randomkey() {\n+        return await(redisAPI.randomkey());\n+    }\n+\n+    @Override\n+    public Response readonly() {\n+        return await(redisAPI.readonly());\n+    }\n+\n+    @Override\n+    public Response readwrite() {\n+        return await(redisAPI.readwrite());\n+    }\n+\n+    @Override\n+    public Response rename(String arg0, String arg1) {\n+        return await(redisAPI.rename(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response renamenx(String arg0, String arg1) {\n+        return await(redisAPI.renamenx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response replconf(List<String> args) {\n+        return await(redisAPI.replconf(args));\n+    }\n+\n+    @Override\n+    public Response replicaof(String arg0, String arg1) {\n+        return await(redisAPI.replicaof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response restore(List<String> args) {\n+        return await(redisAPI.restore(args));\n+    }\n+\n+    @Override\n+    public Response restoreAsking(List<String> args) {\n+        return await(redisAPI.restoreAsking(args));\n+    }\n+\n+    @Override\n+    public Response role() {\n+        return await(redisAPI.role());\n+    }\n+\n+    @Override\n+    public Response rpop(String arg0) {\n+        return await(redisAPI.rpop(arg0));\n+    }\n+\n+    @Override\n+    public Response rpoplpush(String arg0, String arg1) {\n+        return await(redisAPI.rpoplpush(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response rpush(List<String> args) {\n+        return await(redisAPI.rpush(args));\n+    }\n+\n+    @Override\n+    public Response rpushx(List<String> args) {\n+        return await(redisAPI.rpushx(args));\n+    }\n+\n+    @Override\n+    public Response sadd(List<String> args) {\n+        return await(redisAPI.sadd(args));\n+    }\n+\n+    @Override\n+    public Response save() {\n+        return await(redisAPI.save());\n+    }\n+\n+    @Override\n+    public Response scan(List<String> args) {\n+        return await(redisAPI.scan(args));\n+    }\n+\n+    @Override\n+    public Response scard(String arg0) {\n+        return await(redisAPI.scard(arg0));\n+    }\n+\n+    @Override\n+    public Response script(List<String> args) {\n+        return await(redisAPI.script(args));\n+    }\n+\n+    @Override\n+    public Response sdiff(List<String> args) {\n+        return await(redisAPI.sdiff(args));\n+    }\n+\n+    @Override\n+    public Response sdiffstore(List<String> args) {\n+        return await(redisAPI.sdiffstore(args));\n+    }\n+\n+    @Override\n+    public Response select(String arg0) {\n+        return await(redisAPI.select(arg0));\n+    }\n+\n+    @Override\n+    public Response set(List<String> args) {\n+        return await(redisAPI.set(args));\n+    }\n+\n+    @Override\n+    public Response setbit(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setbit(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setnx(String arg0, String arg1) {\n+        return await(redisAPI.setnx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response setrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response shutdown(List<String> args) {\n+        return await(redisAPI.shutdown(args));\n+    }\n+\n+    @Override\n+    public Response sinter(List<String> args) {\n+        return await(redisAPI.sinter(args));\n+    }\n+\n+    @Override\n+    public Response sinterstore(List<String> args) {\n+        return await(redisAPI.sinterstore(args));\n+    }\n+\n+    @Override\n+    public Response sismember(String arg0, String arg1) {\n+        return await(redisAPI.sismember(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slaveof(String arg0, String arg1) {\n+        return await(redisAPI.slaveof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slowlog(List<String> args) {\n+        return await(redisAPI.slowlog(args));\n+    }\n+\n+    @Override\n+    public Response smembers(String arg0) {\n+        return await(redisAPI.smembers(arg0));\n+    }\n+\n+    @Override\n+    public Response smove(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.smove(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sort(List<String> args) {\n+        return await(redisAPI.sort(args));\n+    }\n+\n+    @Override\n+    public Response spop(List<String> args) {\n+        return await(redisAPI.spop(args));\n+    }\n+\n+    @Override\n+    public Response srandmember(List<String> args) {\n+        return await(redisAPI.srandmember(args));\n+    }\n+\n+    @Override\n+    public Response srem(List<String> args) {\n+        return await(redisAPI.srem(args));\n+    }\n+\n+    @Override\n+    public Response sscan(List<String> args) {\n+        return await(redisAPI.sscan(args));\n+    }\n+\n+    @Override\n+    public Response strlen(String arg0) {\n+        return await(redisAPI.strlen(arg0));\n+    }\n+\n+    @Override\n+    public Response subscribe(List<String> args) {\n+        return await(redisAPI.subscribe(args));\n+    }\n+\n+    @Override\n+    public Response substr(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.substr(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sunion(List<String> args) {\n+        return await(redisAPI.sunion(args));\n+    }\n+\n+    @Override\n+    public Response sunionstore(List<String> args) {\n+        return await(redisAPI.sunionstore(args));\n+    }\n+\n+    @Override\n+    public Response swapdb(String arg0, String arg1) {\n+        return await(redisAPI.swapdb(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response sync() {\n+        return await(redisAPI.sync());\n+    }\n+\n+    @Override\n+    public Response time() {\n+        return await(redisAPI.time());\n+    }\n+\n+    @Override\n+    public Response touch(List<String> args) {\n+        return await(redisAPI.touch(args));\n+    }\n+\n+    @Override\n+    public Response ttl(String arg0) {\n+        return await(redisAPI.ttl(arg0));\n+    }\n+\n+    @Override\n+    public Response type(String arg0) {\n+        return await(redisAPI.type(arg0));\n+    }\n+\n+    @Override\n+    public Response unlink(List<String> args) {\n+        return await(redisAPI.unlink(args));\n+    }\n+\n+    @Override\n+    public Response unsubscribe(List<String> args) {\n+        return await(redisAPI.unsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response unwatch() {\n+        return await(redisAPI.unwatch());\n+    }\n+\n+    @Override\n+    public Response wait(String arg0, String arg1) {\n+        return await(redisAPI.wait(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response watch(List<String> args) {\n+        return await(redisAPI.watch(args));\n+    }\n+\n+    @Override\n+    public Response xack(List<String> args) {\n+        return await(redisAPI.xack(args));\n+    }\n+\n+    @Override\n+    public Response xadd(List<String> args) {\n+        return await(redisAPI.xadd(args));\n+    }\n+\n+    @Override\n+    public Response xclaim(List<String> args) {\n+        return await(redisAPI.xclaim(args));\n+    }\n+\n+    @Override\n+    public Response xdel(List<String> args) {\n+        return await(redisAPI.xdel(args));\n+    }\n+\n+    @Override\n+    public Response xgroup(List<String> args) {\n+        return await(redisAPI.xgroup(args));\n+    }\n+\n+    @Override\n+    public Response xinfo(List<String> args) {\n+        return await(redisAPI.xinfo(args));\n+    }\n+\n+    @Override\n+    public Response xlen(String arg0) {\n+        return await(redisAPI.xlen(arg0));\n+    }\n+\n+    @Override\n+    public Response xpending(List<String> args) {\n+        return await(redisAPI.xpending(args));\n+    }\n+\n+    @Override\n+    public Response xrange(List<String> args) {\n+        return await(redisAPI.xrange(args));\n+    }\n+\n+    @Override\n+    public Response xread(List<String> args) {\n+        return await(redisAPI.xread(args));\n+    }\n+\n+    @Override\n+    public Response xreadgroup(List<String> args) {\n+        return await(redisAPI.xreadgroup(args));\n+    }\n+\n+    @Override\n+    public Response xrevrange(List<String> args) {\n+        return await(redisAPI.xrevrange(args));\n+    }\n+\n+    @Override\n+    public Response xsetid(String arg0, String arg1) {\n+        return await(redisAPI.xsetid(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response xtrim(List<String> args) {\n+        return await(redisAPI.xtrim(args));\n+    }\n+\n+    @Override\n+    public Response zadd(List<String> args) {\n+        return await(redisAPI.zadd(args));\n+    }\n+\n+    @Override\n+    public Response zcard(String arg0) {\n+        return await(redisAPI.zcard(arg0));\n+    }\n+\n+    @Override\n+    public Response zcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zinterstore(List<String> args) {\n+        return await(redisAPI.zinterstore(args));\n+    }\n+\n+    @Override\n+    public Response zlexcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zlexcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zpopmax(List<String> args) {\n+        return await(redisAPI.zpopmax(args));\n+    }\n+\n+    @Override\n+    public Response zpopmin(List<String> args) {\n+        return await(redisAPI.zpopmin(args));\n+    }\n+\n+    @Override\n+    public Response zrange(List<String> args) {\n+        return await(redisAPI.zrange(args));\n+    }\n+\n+    @Override\n+    public Response zrangebylex(List<String> args) {\n+        return await(redisAPI.zrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrangebyscore(List<String> args) {\n+        return await(redisAPI.zrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrank(String arg0, String arg1) {\n+        return await(redisAPI.zrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zrem(List<String> args) {\n+        return await(redisAPI.zrem(args));\n+    }\n+\n+    @Override\n+    public Response zremrangebylex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebylex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyrank(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyrank(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyscore(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyscore(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zrevrange(List<String> args) {\n+        return await(redisAPI.zrevrange(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebylex(List<String> args) {\n+        return await(redisAPI.zrevrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebyscore(List<String> args) {\n+        return await(redisAPI.zrevrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrevrank(String arg0, String arg1) {\n+        return await(redisAPI.zrevrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zscan(List<String> args) {\n+        return await(redisAPI.zscan(args));\n+    }\n+\n+    @Override\n+    public Response zscore(String arg0, String arg1) {\n+        return await(redisAPI.zscore(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zunionstore(List<String> args) {\n+        return await(redisAPI.zunionstore(args));\n+    }\n+\n+    private Response await(Uni<io.vertx.mutiny.redis.client.Response> mutinyResponse) {\n+        try {\n+            return mutinyResponse.subscribeAsCompletionStage()", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxNDY5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444314692", "bodyText": "Cool.", "author": "machi1990", "createdAt": "2020-06-23T15:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTcxNw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443355717", "bodyText": "you need to reset the interrupt flag if you get an InterruptedException.\nIn case of an ExecutionException, the cause must be wrapped not the exception.", "author": "cescoffier", "createdAt": "2020-06-22T07:07:32Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/SyncRedisAPIImpl.java", "diffHunk": "@@ -0,0 +1,1039 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+import io.vertx.redis.client.Response;\n+\n+class SyncRedisAPIImpl implements SyncRedisAPI {\n+\n+    private final RedisAPI redisAPI;\n+    private final long timeout;\n+\n+    public SyncRedisAPIImpl(RedisAPI redisAPI, long timeout) {\n+        this.redisAPI = redisAPI;\n+        this.timeout = timeout;\n+    }\n+\n+    @Override\n+    public void close() {\n+        redisAPI.close();\n+    }\n+\n+    @Override\n+    public Response append(String arg0, String arg1) {\n+        return await(redisAPI.append(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response asking() {\n+        return await(redisAPI.asking());\n+    }\n+\n+    @Override\n+    public Response auth(String arg0) {\n+        return await(redisAPI.auth(arg0));\n+    }\n+\n+    @Override\n+    public Response bgrewriteaof() {\n+        return await(redisAPI.bgrewriteaof());\n+    }\n+\n+    @Override\n+    public Response bgsave(List<String> args) {\n+        return await(redisAPI.bgsave(args));\n+    }\n+\n+    @Override\n+    public Response bitcount(List<String> args) {\n+        return await(redisAPI.bitcount(args));\n+    }\n+\n+    @Override\n+    public Response bitfield(List<String> args) {\n+        return await(redisAPI.bitfield(args));\n+    }\n+\n+    @Override\n+    public Response bitop(List<String> args) {\n+        return await(redisAPI.bitop(args));\n+    }\n+\n+    @Override\n+    public Response bitpos(List<String> args) {\n+        return await(redisAPI.bitpos(args));\n+    }\n+\n+    @Override\n+    public Response blpop(List<String> args) {\n+        return await(redisAPI.blpop(args));\n+    }\n+\n+    @Override\n+    public Response brpop(List<String> args) {\n+        return await(redisAPI.brpop(args));\n+    }\n+\n+    @Override\n+    public Response brpoplpush(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.brpoplpush(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response bzpopmax(List<String> args) {\n+        return await(redisAPI.bzpopmax(args));\n+    }\n+\n+    @Override\n+    public Response bzpopmin(List<String> args) {\n+        return await(redisAPI.bzpopmin(args));\n+    }\n+\n+    @Override\n+    public Response client(List<String> args) {\n+        return await(redisAPI.client(args));\n+    }\n+\n+    @Override\n+    public Response cluster(List<String> args) {\n+        return await(redisAPI.cluster(args));\n+    }\n+\n+    @Override\n+    public Response command() {\n+        return await(redisAPI.command());\n+    }\n+\n+    @Override\n+    public Response config(List<String> args) {\n+        return await(redisAPI.config(args));\n+    }\n+\n+    @Override\n+    public Response dbsize() {\n+        return await(redisAPI.dbsize());\n+    }\n+\n+    @Override\n+    public Response debug(List<String> args) {\n+        return await(redisAPI.debug(args));\n+    }\n+\n+    @Override\n+    public Response decr(String arg0) {\n+        return await(redisAPI.decr(arg0));\n+    }\n+\n+    @Override\n+    public Response decrby(String arg0, String arg1) {\n+        return await(redisAPI.decrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response del(List<String> args) {\n+        return await(redisAPI.del(args));\n+    }\n+\n+    @Override\n+    public Response discard() {\n+        return await(redisAPI.discard());\n+    }\n+\n+    @Override\n+    public Response dump(String arg0) {\n+        return await(redisAPI.dump(arg0));\n+    }\n+\n+    @Override\n+    public Response echo(String arg0) {\n+        return await(redisAPI.echo(arg0));\n+    }\n+\n+    @Override\n+    public Response eval(List<String> args) {\n+        return await(redisAPI.eval(args));\n+    }\n+\n+    @Override\n+    public Response evalsha(List<String> args) {\n+        return await(redisAPI.evalsha(args));\n+    }\n+\n+    @Override\n+    public Response exec() {\n+        return await(redisAPI.exec());\n+    }\n+\n+    @Override\n+    public Response exists(List<String> args) {\n+        return await(redisAPI.exists(args));\n+    }\n+\n+    @Override\n+    public Response expire(String arg0, String arg1) {\n+        return await(redisAPI.expire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response expireat(String arg0, String arg1) {\n+        return await(redisAPI.expireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response flushall(List<String> args) {\n+        return await(redisAPI.flushall(args));\n+    }\n+\n+    @Override\n+    public Response flushdb(List<String> args) {\n+        return await(redisAPI.flushdb(args));\n+    }\n+\n+    @Override\n+    public Response geoadd(List<String> args) {\n+        return await(redisAPI.geoadd(args));\n+    }\n+\n+    @Override\n+    public Response geodist(List<String> args) {\n+        return await(redisAPI.geodist(args));\n+    }\n+\n+    @Override\n+    public Response geohash(List<String> args) {\n+        return await(redisAPI.geohash(args));\n+    }\n+\n+    @Override\n+    public Response geopos(List<String> args) {\n+        return await(redisAPI.geopos(args));\n+    }\n+\n+    @Override\n+    public Response georadius(List<String> args) {\n+        return await(redisAPI.georadius(args));\n+    }\n+\n+    @Override\n+    public Response georadiusRo(List<String> args) {\n+        return await(redisAPI.georadiusRo(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymember(List<String> args) {\n+        return await(redisAPI.georadiusbymember(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymemberRo(List<String> args) {\n+        return await(redisAPI.georadiusbymemberRo(args));\n+    }\n+\n+    @Override\n+    public Response get(String arg0) {\n+        return await(redisAPI.get(arg0));\n+    }\n+\n+    @Override\n+    public Response getbit(String arg0, String arg1) {\n+        return await(redisAPI.getbit(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response getrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.getrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response getset(String arg0, String arg1) {\n+        return await(redisAPI.getset(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hdel(List<String> args) {\n+        return await(redisAPI.hdel(args));\n+    }\n+\n+    @Override\n+    public Response hexists(String arg0, String arg1) {\n+        return await(redisAPI.hexists(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hget(String arg0, String arg1) {\n+        return await(redisAPI.hget(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hgetall(String arg0) {\n+        return await(redisAPI.hgetall(arg0));\n+    }\n+\n+    @Override\n+    public Response hincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hincrbyfloat(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrbyfloat(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hkeys(String arg0) {\n+        return await(redisAPI.hkeys(arg0));\n+    }\n+\n+    @Override\n+    public Response hlen(String arg0) {\n+        return await(redisAPI.hlen(arg0));\n+    }\n+\n+    @Override\n+    public Response hmget(List<String> args) {\n+        return await(redisAPI.hmget(args));\n+    }\n+\n+    @Override\n+    public Response hmset(List<String> args) {\n+        return await(redisAPI.hmset(args));\n+    }\n+\n+    @Override\n+    public Response host(List<String> args) {\n+        return await(redisAPI.host(args));\n+    }\n+\n+    @Override\n+    public Response hscan(List<String> args) {\n+        return await(redisAPI.hscan(args));\n+    }\n+\n+    @Override\n+    public Response hset(List<String> args) {\n+        return await(redisAPI.hset(args));\n+    }\n+\n+    @Override\n+    public Response hsetnx(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hsetnx(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hstrlen(String arg0, String arg1) {\n+        return await(redisAPI.hstrlen(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hvals(String arg0) {\n+        return await(redisAPI.hvals(arg0));\n+    }\n+\n+    @Override\n+    public Response incr(String arg0) {\n+        return await(redisAPI.incr(arg0));\n+    }\n+\n+    @Override\n+    public Response incrby(String arg0, String arg1) {\n+        return await(redisAPI.incrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response incrbyfloat(String arg0, String arg1) {\n+        return await(redisAPI.incrbyfloat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response info(List<String> args) {\n+        return await(redisAPI.info(args));\n+    }\n+\n+    @Override\n+    public Response keys(String arg0) {\n+        return await(redisAPI.keys(arg0));\n+    }\n+\n+    @Override\n+    public Response lastsave() {\n+        return await(redisAPI.lastsave());\n+    }\n+\n+    @Override\n+    public Response latency(List<String> args) {\n+        return await(redisAPI.latency(args));\n+    }\n+\n+    @Override\n+    public Response lindex(String arg0, String arg1) {\n+        return await(redisAPI.lindex(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response linsert(String arg0, String arg1, String arg2, String arg3) {\n+        return await(redisAPI.linsert(arg0, arg1, arg2, arg3));\n+    }\n+\n+    @Override\n+    public Response llen(String arg0) {\n+        return await(redisAPI.llen(arg0));\n+    }\n+\n+    @Override\n+    public Response lolwut(List<String> args) {\n+        return await(redisAPI.lolwut(args));\n+    }\n+\n+    @Override\n+    public Response lpop(String arg0) {\n+        return await(redisAPI.lpop(arg0));\n+    }\n+\n+    @Override\n+    public Response lpush(List<String> args) {\n+        return await(redisAPI.lpush(args));\n+    }\n+\n+    @Override\n+    public Response lpushx(List<String> args) {\n+        return await(redisAPI.lpushx(args));\n+    }\n+\n+    @Override\n+    public Response lrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lrem(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrem(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lset(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lset(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response ltrim(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.ltrim(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response memory(List<String> args) {\n+        return await(redisAPI.memory(args));\n+    }\n+\n+    @Override\n+    public Response mget(List<String> args) {\n+        return await(redisAPI.mget(args));\n+    }\n+\n+    @Override\n+    public Response migrate(List<String> args) {\n+        return await(redisAPI.migrate(args));\n+    }\n+\n+    @Override\n+    public Response module(List<String> args) {\n+        return await(redisAPI.module(args));\n+    }\n+\n+    @Override\n+    public Response monitor() {\n+        return await(redisAPI.monitor());\n+    }\n+\n+    @Override\n+    public Response move(String arg0, String arg1) {\n+        return await(redisAPI.move(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response mset(List<String> args) {\n+        return await(redisAPI.mset(args));\n+    }\n+\n+    @Override\n+    public Response msetnx(List<String> args) {\n+        return await(redisAPI.msetnx(args));\n+    }\n+\n+    @Override\n+    public Response multi() {\n+        return await(redisAPI.multi());\n+    }\n+\n+    @Override\n+    public Response object(List<String> args) {\n+        return await(redisAPI.object(args));\n+    }\n+\n+    @Override\n+    public Response persist(String arg0) {\n+        return await(redisAPI.persist(arg0));\n+    }\n+\n+    @Override\n+    public Response pexpire(String arg0, String arg1) {\n+        return await(redisAPI.pexpire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pexpireat(String arg0, String arg1) {\n+        return await(redisAPI.pexpireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pfadd(List<String> args) {\n+        return await(redisAPI.pfadd(args));\n+    }\n+\n+    @Override\n+    public Response pfcount(List<String> args) {\n+        return await(redisAPI.pfcount(args));\n+    }\n+\n+    @Override\n+    public Response pfdebug(List<String> args) {\n+        return await(redisAPI.pfdebug(args));\n+    }\n+\n+    @Override\n+    public Response pfmerge(List<String> args) {\n+        return await(redisAPI.pfmerge(args));\n+    }\n+\n+    @Override\n+    public Response pfselftest() {\n+        return await(redisAPI.pfselftest());\n+    }\n+\n+    @Override\n+    public Response ping(List<String> args) {\n+        return await(redisAPI.ping(args));\n+    }\n+\n+    @Override\n+    public Response post(List<String> args) {\n+        return await(redisAPI.post(args));\n+    }\n+\n+    @Override\n+    public Response psetex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.psetex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response psubscribe(List<String> args) {\n+        return await(redisAPI.psubscribe(args));\n+    }\n+\n+    @Override\n+    public Response psync(String arg0, String arg1) {\n+        return await(redisAPI.psync(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pttl(String arg0) {\n+        return await(redisAPI.pttl(arg0));\n+    }\n+\n+    @Override\n+    public Response publish(String arg0, String arg1) {\n+        return await(redisAPI.publish(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pubsub(List<String> args) {\n+        return await(redisAPI.pubsub(args));\n+    }\n+\n+    @Override\n+    public Response punsubscribe(List<String> args) {\n+        return await(redisAPI.punsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response randomkey() {\n+        return await(redisAPI.randomkey());\n+    }\n+\n+    @Override\n+    public Response readonly() {\n+        return await(redisAPI.readonly());\n+    }\n+\n+    @Override\n+    public Response readwrite() {\n+        return await(redisAPI.readwrite());\n+    }\n+\n+    @Override\n+    public Response rename(String arg0, String arg1) {\n+        return await(redisAPI.rename(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response renamenx(String arg0, String arg1) {\n+        return await(redisAPI.renamenx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response replconf(List<String> args) {\n+        return await(redisAPI.replconf(args));\n+    }\n+\n+    @Override\n+    public Response replicaof(String arg0, String arg1) {\n+        return await(redisAPI.replicaof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response restore(List<String> args) {\n+        return await(redisAPI.restore(args));\n+    }\n+\n+    @Override\n+    public Response restoreAsking(List<String> args) {\n+        return await(redisAPI.restoreAsking(args));\n+    }\n+\n+    @Override\n+    public Response role() {\n+        return await(redisAPI.role());\n+    }\n+\n+    @Override\n+    public Response rpop(String arg0) {\n+        return await(redisAPI.rpop(arg0));\n+    }\n+\n+    @Override\n+    public Response rpoplpush(String arg0, String arg1) {\n+        return await(redisAPI.rpoplpush(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response rpush(List<String> args) {\n+        return await(redisAPI.rpush(args));\n+    }\n+\n+    @Override\n+    public Response rpushx(List<String> args) {\n+        return await(redisAPI.rpushx(args));\n+    }\n+\n+    @Override\n+    public Response sadd(List<String> args) {\n+        return await(redisAPI.sadd(args));\n+    }\n+\n+    @Override\n+    public Response save() {\n+        return await(redisAPI.save());\n+    }\n+\n+    @Override\n+    public Response scan(List<String> args) {\n+        return await(redisAPI.scan(args));\n+    }\n+\n+    @Override\n+    public Response scard(String arg0) {\n+        return await(redisAPI.scard(arg0));\n+    }\n+\n+    @Override\n+    public Response script(List<String> args) {\n+        return await(redisAPI.script(args));\n+    }\n+\n+    @Override\n+    public Response sdiff(List<String> args) {\n+        return await(redisAPI.sdiff(args));\n+    }\n+\n+    @Override\n+    public Response sdiffstore(List<String> args) {\n+        return await(redisAPI.sdiffstore(args));\n+    }\n+\n+    @Override\n+    public Response select(String arg0) {\n+        return await(redisAPI.select(arg0));\n+    }\n+\n+    @Override\n+    public Response set(List<String> args) {\n+        return await(redisAPI.set(args));\n+    }\n+\n+    @Override\n+    public Response setbit(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setbit(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setnx(String arg0, String arg1) {\n+        return await(redisAPI.setnx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response setrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response shutdown(List<String> args) {\n+        return await(redisAPI.shutdown(args));\n+    }\n+\n+    @Override\n+    public Response sinter(List<String> args) {\n+        return await(redisAPI.sinter(args));\n+    }\n+\n+    @Override\n+    public Response sinterstore(List<String> args) {\n+        return await(redisAPI.sinterstore(args));\n+    }\n+\n+    @Override\n+    public Response sismember(String arg0, String arg1) {\n+        return await(redisAPI.sismember(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slaveof(String arg0, String arg1) {\n+        return await(redisAPI.slaveof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slowlog(List<String> args) {\n+        return await(redisAPI.slowlog(args));\n+    }\n+\n+    @Override\n+    public Response smembers(String arg0) {\n+        return await(redisAPI.smembers(arg0));\n+    }\n+\n+    @Override\n+    public Response smove(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.smove(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sort(List<String> args) {\n+        return await(redisAPI.sort(args));\n+    }\n+\n+    @Override\n+    public Response spop(List<String> args) {\n+        return await(redisAPI.spop(args));\n+    }\n+\n+    @Override\n+    public Response srandmember(List<String> args) {\n+        return await(redisAPI.srandmember(args));\n+    }\n+\n+    @Override\n+    public Response srem(List<String> args) {\n+        return await(redisAPI.srem(args));\n+    }\n+\n+    @Override\n+    public Response sscan(List<String> args) {\n+        return await(redisAPI.sscan(args));\n+    }\n+\n+    @Override\n+    public Response strlen(String arg0) {\n+        return await(redisAPI.strlen(arg0));\n+    }\n+\n+    @Override\n+    public Response subscribe(List<String> args) {\n+        return await(redisAPI.subscribe(args));\n+    }\n+\n+    @Override\n+    public Response substr(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.substr(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sunion(List<String> args) {\n+        return await(redisAPI.sunion(args));\n+    }\n+\n+    @Override\n+    public Response sunionstore(List<String> args) {\n+        return await(redisAPI.sunionstore(args));\n+    }\n+\n+    @Override\n+    public Response swapdb(String arg0, String arg1) {\n+        return await(redisAPI.swapdb(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response sync() {\n+        return await(redisAPI.sync());\n+    }\n+\n+    @Override\n+    public Response time() {\n+        return await(redisAPI.time());\n+    }\n+\n+    @Override\n+    public Response touch(List<String> args) {\n+        return await(redisAPI.touch(args));\n+    }\n+\n+    @Override\n+    public Response ttl(String arg0) {\n+        return await(redisAPI.ttl(arg0));\n+    }\n+\n+    @Override\n+    public Response type(String arg0) {\n+        return await(redisAPI.type(arg0));\n+    }\n+\n+    @Override\n+    public Response unlink(List<String> args) {\n+        return await(redisAPI.unlink(args));\n+    }\n+\n+    @Override\n+    public Response unsubscribe(List<String> args) {\n+        return await(redisAPI.unsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response unwatch() {\n+        return await(redisAPI.unwatch());\n+    }\n+\n+    @Override\n+    public Response wait(String arg0, String arg1) {\n+        return await(redisAPI.wait(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response watch(List<String> args) {\n+        return await(redisAPI.watch(args));\n+    }\n+\n+    @Override\n+    public Response xack(List<String> args) {\n+        return await(redisAPI.xack(args));\n+    }\n+\n+    @Override\n+    public Response xadd(List<String> args) {\n+        return await(redisAPI.xadd(args));\n+    }\n+\n+    @Override\n+    public Response xclaim(List<String> args) {\n+        return await(redisAPI.xclaim(args));\n+    }\n+\n+    @Override\n+    public Response xdel(List<String> args) {\n+        return await(redisAPI.xdel(args));\n+    }\n+\n+    @Override\n+    public Response xgroup(List<String> args) {\n+        return await(redisAPI.xgroup(args));\n+    }\n+\n+    @Override\n+    public Response xinfo(List<String> args) {\n+        return await(redisAPI.xinfo(args));\n+    }\n+\n+    @Override\n+    public Response xlen(String arg0) {\n+        return await(redisAPI.xlen(arg0));\n+    }\n+\n+    @Override\n+    public Response xpending(List<String> args) {\n+        return await(redisAPI.xpending(args));\n+    }\n+\n+    @Override\n+    public Response xrange(List<String> args) {\n+        return await(redisAPI.xrange(args));\n+    }\n+\n+    @Override\n+    public Response xread(List<String> args) {\n+        return await(redisAPI.xread(args));\n+    }\n+\n+    @Override\n+    public Response xreadgroup(List<String> args) {\n+        return await(redisAPI.xreadgroup(args));\n+    }\n+\n+    @Override\n+    public Response xrevrange(List<String> args) {\n+        return await(redisAPI.xrevrange(args));\n+    }\n+\n+    @Override\n+    public Response xsetid(String arg0, String arg1) {\n+        return await(redisAPI.xsetid(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response xtrim(List<String> args) {\n+        return await(redisAPI.xtrim(args));\n+    }\n+\n+    @Override\n+    public Response zadd(List<String> args) {\n+        return await(redisAPI.zadd(args));\n+    }\n+\n+    @Override\n+    public Response zcard(String arg0) {\n+        return await(redisAPI.zcard(arg0));\n+    }\n+\n+    @Override\n+    public Response zcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zinterstore(List<String> args) {\n+        return await(redisAPI.zinterstore(args));\n+    }\n+\n+    @Override\n+    public Response zlexcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zlexcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zpopmax(List<String> args) {\n+        return await(redisAPI.zpopmax(args));\n+    }\n+\n+    @Override\n+    public Response zpopmin(List<String> args) {\n+        return await(redisAPI.zpopmin(args));\n+    }\n+\n+    @Override\n+    public Response zrange(List<String> args) {\n+        return await(redisAPI.zrange(args));\n+    }\n+\n+    @Override\n+    public Response zrangebylex(List<String> args) {\n+        return await(redisAPI.zrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrangebyscore(List<String> args) {\n+        return await(redisAPI.zrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrank(String arg0, String arg1) {\n+        return await(redisAPI.zrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zrem(List<String> args) {\n+        return await(redisAPI.zrem(args));\n+    }\n+\n+    @Override\n+    public Response zremrangebylex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebylex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyrank(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyrank(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyscore(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyscore(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zrevrange(List<String> args) {\n+        return await(redisAPI.zrevrange(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebylex(List<String> args) {\n+        return await(redisAPI.zrevrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebyscore(List<String> args) {\n+        return await(redisAPI.zrevrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrevrank(String arg0, String arg1) {\n+        return await(redisAPI.zrevrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zscan(List<String> args) {\n+        return await(redisAPI.zscan(args));\n+    }\n+\n+    @Override\n+    public Response zscore(String arg0, String arg1) {\n+        return await(redisAPI.zscore(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zunionstore(List<String> args) {\n+        return await(redisAPI.zunionstore(args));\n+    }\n+\n+    private Response await(Uni<io.vertx.mutiny.redis.client.Response> mutinyResponse) {\n+        try {\n+            return mutinyResponse.subscribeAsCompletionStage()\n+                    .toCompletableFuture()\n+                    .get(timeout, SECONDS)\n+                    .getDelegate();\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            throw new RuntimeException(e);", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxODM3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444318376", "bodyText": "I guess it is not needed anymore with this #9370 (comment) suggestion.", "author": "machi1990", "createdAt": "2020-06-23T15:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTcxNw=="}], "type": "inlineReview"}, {"oid": "9650b0d0a202057bdf1713eea2ae4e937dbeeb6a", "url": "https://github.com/quarkusio/quarkus/commit/9650b0d0a202057bdf1713eea2ae4e937dbeeb6a", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-23T16:08:03Z", "type": "forcePushed"}, {"oid": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "url": "https://github.com/quarkusio/quarkus/commit/4685feef64bdf495521bff8b26e4af6282d5b6ab", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-01T15:09:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MDk0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449470941", "bodyText": "This is very minor but alphabetical order FTW :).", "author": "gsmet", "createdAt": "2020-07-03T09:07:59Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "diffHunk": "@@ -114,7 +114,7 @@\n     VERTX_WEB,\n     VERTX_GRAPHQL,\n     WEBJARS_LOCATOR,\n-    ;\n+    REDIS_CLIENT;", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MjI3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449472273", "bodyText": "I don't know how it was done for the others but if it's not API, it should probably go in the runtime. subpackage.", "author": "gsmet", "createdAt": "2020-07-03T09:10:35Z", "path": "extensions/redis-client/deployment/src/main/java/io/quarkus/redis/client/deployment/RedisClientProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.redis.client.deployment;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.smallrye.health.deployment.spi.HealthBuildItem;\n+import io.vertx.redis.client.impl.types.BulkType;\n+\n+public class RedisClientProcessor {\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(Feature.REDIS_CLIENT);\n+    }\n+\n+    @BuildStep\n+    ExtensionSslNativeSupportBuildItem activateSslNativeSupport() {\n+        return new ExtensionSslNativeSupportBuildItem(Feature.REDIS_CLIENT.getName());\n+    }\n+\n+    @BuildStep\n+    AdditionalBeanBuildItem registerAPIsProducer() {\n+        return AdditionalBeanBuildItem.unremovableOf(\"io.quarkus.redis.client.runtime.RedisAPIProducer\");\n+    }\n+\n+    @BuildStep\n+    HealthBuildItem addHealthCheck(RedisBuildTimeConfig buildTimeConfig) {\n+        return new HealthBuildItem(\"io.quarkus.redis.client.health.RedisHealthCheck\", buildTimeConfig.healthEnabled);", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MzYzMw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449473633", "bodyText": "I would use 10s here for the documentation to be clearer.", "author": "gsmet", "createdAt": "2020-07-03T09:13:01Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisConfig.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.vertx.redis.client.RedisClientType;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class RedisConfig {\n+\n+    /**\n+     * The redis password\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The redis hosts\n+     */\n+    @ConfigItem(defaultValue = \"localhost:6379\")\n+    public Optional<Set<InetSocketAddress>> hosts;\n+\n+    /**\n+     * The redis database\n+     */\n+    @ConfigItem\n+    public int database;\n+\n+    /**\n+     * The maximum delay to wait before a blocking command to redis server times out\n+     */\n+    @ConfigItem(defaultValue = \"10\")", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "495e0172b2545bc2b00ff6dd91aa8c327d95d5c6", "url": "https://github.com/quarkusio/quarkus/commit/495e0172b2545bc2b00ff6dd91aa8c327d95d5c6", "message": "feat: add a redis extension\n\nCreates a redis-client extension that provides different flavours of\nredis clients:\nImperative and Reactive client.\n\nFixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-03T14:34:24Z", "type": "forcePushed"}, {"oid": "76a6fcbf267f6e2646266420135166b13ab5aee0", "url": "https://github.com/quarkusio/quarkus/commit/76a6fcbf267f6e2646266420135166b13ab5aee0", "message": "feat: add a redis extension\n\nCreates a redis-client extension that provides different flavours of\nredis clients:\nImperative and Reactive client.\n\nFixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-04T20:15:55Z", "type": "commit"}, {"oid": "76a6fcbf267f6e2646266420135166b13ab5aee0", "url": "https://github.com/quarkusio/quarkus/commit/76a6fcbf267f6e2646266420135166b13ab5aee0", "message": "feat: add a redis extension\n\nCreates a redis-client extension that provides different flavours of\nredis clients:\nImperative and Reactive client.\n\nFixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-04T20:15:55Z", "type": "forcePushed"}]}