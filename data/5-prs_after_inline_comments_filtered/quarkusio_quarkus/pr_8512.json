{"pr_number": 8512, "pr_title": "[fixes #4481] - RP-Initiated Logout and session verification", "pr_createdAt": "2020-04-09T22:31:42Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8512", "timeline": [{"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "url": "https://github.com/quarkusio/quarkus/commit/af1c474e6be13e90cb65a2156ac4588f03c7df5d", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-09T22:37:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406699304", "bodyText": "@pedroigor should we have a check here that the token has expired ? At the moment the way to do is to check the exception message, Vertx reports JWT is expired or something like that. I'm going to work on a few Vertx PRs soon enough and perhaps we can introduce a dedicated exception too. I.e I'm not sure we should refresh in all the cases, only if the token has expired", "author": "sberyozkin", "createdAt": "2020-04-10T10:23:41Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTc4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406719782", "bodyText": "There is an assumption that the attempt to refresh should only be done if there is an existing session (e.g.: cookie exists). I'm missing this check too.\nThat said, exceptions thrown should be only related to expiration, AFAIK. That is why I'm not checking for a specific exception.\nI'm OK about being more defensive and do something along the line you suggested, but if you think my assumption is correct, maybe unnecessary to add a new exception ?", "author": "pedroigor", "createdAt": "2020-04-10T11:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc2OTcxNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406769716", "bodyText": "@pedroigor The verification can definitely fail if the token has an invalid signature, right ?", "author": "sberyozkin", "createdAt": "2020-04-10T13:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NDUzNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406774536", "bodyText": "It would be hard to have the signature invalid considering that the session cookie was previously established. Like I said, it is OK to have a specific exception for this, but I tried to keep it simple and not introduce more exceptions considering that we should get expiration errors 99% of time, I think.", "author": "pedroigor", "createdAt": "2020-04-10T14:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4ODYwMA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406788600", "bodyText": "@pedroigor But we can't afford trying to refresh a token which someone replaced in a cookie ? It is not hard to do at all for anyone spending their time hacking the cookies. We don't have a dedicated exception yet anyway, but as I said we can check the text of the message", "author": "sberyozkin", "createdAt": "2020-04-10T14:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5Mzg4OA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406793888", "bodyText": "Well, if you really want to be more explicit about the exception. Then I would say we should add proper exceptions.", "author": "pedroigor", "createdAt": "2020-04-10T14:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxOTE1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406819153", "bodyText": "The dedicated exceptions can make things cleaner but we already know Vertx will throw the exception with a specific message indicating the expiry, IMHO we can't start refreshing unless it is an expiry related cause", "author": "sberyozkin", "createdAt": "2020-04-10T15:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406703367", "bodyText": "The code around here should throw AuthenticationCompletionException to prevent the redirect loops, so that the user gets 401, otherwise a challenge will be created again and the OIDC will redirect again given that a user has just authenticated, we've had these problems before :-)", "author": "sberyozkin", "createdAt": "2020-04-10T10:37:18Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMDU4OA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406720588", "bodyText": "Not sure, I think I'm covering this scenario in the test?", "author": "pedroigor", "createdAt": "2020-04-10T11:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4OTk4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406789986", "bodyText": "@pedroigor but your test does not have a refresh failed scenario ? Try to update this code locally to assume it is a failure and see what happens", "author": "sberyozkin", "createdAt": "2020-04-10T14:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5MjI4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406792286", "bodyText": "It does ... The last checks if a redirect is performed due to the session being invalid at the OP.", "author": "pedroigor", "createdAt": "2020-04-10T14:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxOTY1MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406819650", "bodyText": "I mean a refresh grant returns an error, that what was causing a lot of headache earlier with the code grant returning an error", "author": "sberyozkin", "createdAt": "2020-04-10T15:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjYyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406826629", "bodyText": "That is what that last part does, the refresh will fail due to an invalid session (but can be anything) and the user properly redirected to the login page.\nIf the check is not enough, I'm happy to provide something else.", "author": "pedroigor", "createdAt": "2020-04-10T16:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMjc5MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406832790", "bodyText": "@pedroigor I need to think more about it, what we definitely want to avoid is that the challenge is sent to Keycloak while the user session is still valid", "author": "sberyozkin", "createdAt": "2020-04-10T16:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2NzEwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406867109", "bodyText": "That is a valid use case ... Suppose the OP is down, local session active. When refreshing we are going to invalidate the session. A similar behavior than if using token introspection with bearer tokens.\nDepending on the app requirements the behavior is expected as you must enforce that local sessions have their corresponding ones at the OP. Note that if you don't want this, you can just disable the functionality and fallback to local validation (as it stands today).", "author": "pedroigor", "createdAt": "2020-04-10T17:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MjcyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407082729", "bodyText": "Hi Pedro, @pedroigor thanks, sure that makes sense, what I'm somewhat concerned about is that redirection loop. I think if we are 100% sure that the refresh is attempted only when the ID token has expired then AuthenticationFailedException will get a user facing a KC/etc login page. This is one reason why we should check the exception message before a refresh.", "author": "sberyozkin", "createdAt": "2020-04-11T16:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNDU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406704553", "bodyText": "Can sessionCookie be null here ?", "author": "sberyozkin", "createdAt": "2020-04-10T10:41:14Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {\n+                                        throw AuthenticationFailedException.class.cast(throwable);\n+                                    }\n+                                    throw new AuthenticationFailedException(throwable);\n+                                }\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n                         }\n                     });\n         }\n \n         // start a new session by starting the code flow dance\n-        return performCodeFlow(identityProviderManager, context, resolver);\n+        return performCodeFlow(identityProviderManager, context, configContext);\n     }\n \n     public CompletionStage<ChallengeData> getChallenge(RoutingContext context, DefaultTenantConfigResolver resolver) {\n         TenantConfigContext configContext = resolver.resolve(context, false);\n+        ServerCookie sessionCookie = (ServerCookie) context.cookieMap().get(SESSION_COOKIE_NAME);\n+\n+        if (isLogout(context, configContext)) {", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMTA5NA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406721094", "bodyText": "Yes, better check that.", "author": "pedroigor", "createdAt": "2020-04-10T11:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNDU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406705210", "bodyText": "Might be worth adding a comment here it is an OIDC logout endpoint and check it is not null", "author": "sberyozkin", "createdAt": "2020-04-10T10:43:23Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {\n+                                        throw AuthenticationFailedException.class.cast(throwable);\n+                                    }\n+                                    throw new AuthenticationFailedException(throwable);\n+                                }\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n                         }\n                     });\n         }\n \n         // start a new session by starting the code flow dance\n-        return performCodeFlow(identityProviderManager, context, resolver);\n+        return performCodeFlow(identityProviderManager, context, configContext);\n     }\n \n     public CompletionStage<ChallengeData> getChallenge(RoutingContext context, DefaultTenantConfigResolver resolver) {\n         TenantConfigContext configContext = resolver.resolve(context, false);\n+        ServerCookie sessionCookie = (ServerCookie) context.cookieMap().get(SESSION_COOKIE_NAME);\n+\n+        if (isLogout(context, configContext)) {\n+            String logoutPath = OAuth2AuthProviderImpl.class.cast(configContext.auth).getConfig().getLogoutPath();", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNzg1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406707856", "bodyText": "If a given OIDC does not support the logout, what should we return then ? The user is still logged in and does not need a challenge. I propose LogoutException (this actual exception will be in quarkus-vertx-http, as AutenticationCompletionException is) ? There we can do something about it, may be redirect to the logout.redirect_uri, in a timed way, return basic HTML page: \"Logout is not supported, you will be redirected to {redirect.uri} in 3 seconds\", something like that, as I don't think 500 or 401 would be correct just because a user's attempt to logout is not supported :-)", "author": "sberyozkin", "createdAt": "2020-04-10T10:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMTM2MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406721360", "bodyText": "If the OP does not support logout we have some checks during the build so the application should fail to start.", "author": "pedroigor", "createdAt": "2020-04-10T11:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMTczMg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406731732", "bodyText": "@pedroigor Ignore most of it please :-), I see a check further down the PR :-), Though what happens if the sessionCookie is null ?", "author": "sberyozkin", "createdAt": "2020-04-10T12:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MTQ4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406741481", "bodyText": "Yeah, I've added a check for this.", "author": "pedroigor", "createdAt": "2020-04-10T12:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3MjA0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406772049", "bodyText": "@pedroigor so what happens if a logout has been requested and the session code is null ?", "author": "sberyozkin", "createdAt": "2020-04-10T14:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NDcyNw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406774727", "bodyText": "Check added, as mentioned.", "author": "pedroigor", "createdAt": "2020-04-10T14:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5MDUzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406790531", "bodyText": "@pedroigor It is just an NPE check :-) so what should happen to the logout request flow in this case ?", "author": "sberyozkin", "createdAt": "2020-04-10T14:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5MzAyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406793026", "bodyText": "You just go to the login page as per the normal flow.", "author": "pedroigor", "createdAt": "2020-04-10T14:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMTgwMA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406811800", "bodyText": "@pedroigor Got it :-)", "author": "sberyozkin", "createdAt": "2020-04-10T15:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406708867", "bodyText": "We can probably just use removeCookie here because it is then removed anyway if it is logout or not", "author": "sberyozkin", "createdAt": "2020-04-10T10:56:34Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {\n+                                        throw AuthenticationFailedException.class.cast(throwable);\n+                                    }\n+                                    throw new AuthenticationFailedException(throwable);\n+                                }\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n                         }\n                     });\n         }\n \n         // start a new session by starting the code flow dance\n-        return performCodeFlow(identityProviderManager, context, resolver);\n+        return performCodeFlow(identityProviderManager, context, configContext);\n     }\n \n     public CompletionStage<ChallengeData> getChallenge(RoutingContext context, DefaultTenantConfigResolver resolver) {\n         TenantConfigContext configContext = resolver.resolve(context, false);\n+        ServerCookie sessionCookie = (ServerCookie) context.cookieMap().get(SESSION_COOKIE_NAME);", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMTU4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406721589", "bodyText": "The problem is that the your last changes are setting the value of the cookie to an empty string. So, removing here would make hard to get the value and handle it accordingly.", "author": "pedroigor", "createdAt": "2020-04-10T11:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3MjcyOA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406772728", "bodyText": "@pedroigor Can we then update removeCookie to return the value before it was reset ?", "author": "sberyozkin", "createdAt": "2020-04-10T14:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTIyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406775226", "bodyText": "Sure, if you think is better. For me, the way it is OK too.", "author": "pedroigor", "createdAt": "2020-04-10T14:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5MTE2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406791166", "bodyText": "@pedroigor we can have 1 remove cookie call which returns the cookie value instead of 2 calls. simple to do so why not :-)", "author": "sberyozkin", "createdAt": "2020-04-10T14:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMDU3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406710576", "bodyText": "The refactoring from buildRedirectUri to buildUri itself is neat but we've just calculated absoluteUri above, URI calculation is quite expensive, so IMHO it would be more optimal to keep buildRedirectUri as is, and have buildLogoutUri as well which would also accept absoluteUri - a bit more verbose I agree :-), but would also be clearer IMHO.", "author": "sberyozkin", "createdAt": "2020-04-10T11:03:19Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -101,7 +151,7 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n         // redirect_uri\n         URI absoluteUri = URI.create(context.request().absoluteURI());\n         String redirectPath = getRedirectPath(configContext, absoluteUri);\n-        String redirectUriParam = buildRedirectUri(context, absoluteUri, redirectPath);\n+        String redirectUriParam = buildUri(context, redirectPath);", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMjU1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406722552", "bodyText": "Yeah .. I missed changing that part to use the refactored method.\nMaybe we should keep it cleaner now and improve accordingly if we have issues with performance?\nBut for this case in particular, I think we can use obtain the path directly from the context.request(), right ?", "author": "pedroigor", "createdAt": "2020-04-10T11:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMDU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NDMxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406774319", "bodyText": "But it was not really unclean - and obviously we won't be spending time measuring how absoluteUri calculation duplication affects the performance, but it is a duplication we can easily avoid", "author": "sberyozkin", "createdAt": "2020-04-10T14:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMDU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NjE3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406776175", "bodyText": "Yeah. I've updated to just use HttpServerRequest methods. Like I previously mentioned, I guess it is OK, right ?", "author": "pedroigor", "createdAt": "2020-04-10T14:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMDU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5MzExNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406793115", "bodyText": "Yeah it looks fine actually, sorry", "author": "sberyozkin", "createdAt": "2020-04-10T14:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNjUwMg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406726502", "bodyText": "It looks like this check should be after a throwable check, otherwise we will be initiating a logout flow even if the token signature has failed for example, but the user session must have a valid token (except for the possible expiry)", "author": "sberyozkin", "createdAt": "2020-04-10T11:58:58Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0ODc5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406748793", "bodyText": "Yeah, will change to only do logout if identity is available.", "author": "pedroigor", "createdAt": "2020-04-10T13:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNzM1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406727359", "bodyText": "AuthenticationCompletionException should be here", "author": "sberyozkin", "createdAt": "2020-04-10T12:01:25Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -298,5 +344,66 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n                 cookie.setPath(auth.cookiePath.get());\n             }\n         }\n+        return cookie;\n+    }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationFailedException(cause);", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc1NDM2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406754369", "bodyText": "What is the difference when using one or another? I'm expecting to send a challenge, so AuthorizationFailedException is what I need?", "author": "pedroigor", "createdAt": "2020-04-10T13:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNzM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODE5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406728195", "bodyText": "AuthenticationCompletionException", "author": "sberyozkin", "createdAt": "2020-04-10T12:04:00Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -298,5 +344,66 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n                 cookie.setPath(auth.cookiePath.get());\n             }\n         }\n+        return cookie;\n+    }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationFailedException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                CompletableFuture<SecurityIdentity> cf = new CompletableFuture<>();\n+                OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                token.principal().put(\"refresh_token\", refreshToken);\n+\n+                token.refresh(new Handler<AsyncResult<Void>>() {\n+                    @Override\n+                    public void handle(AsyncResult<Void> result) {\n+                        if (result.succeeded()) {\n+                            String rawIdToken = token.principal().getString(\"id_token\");\n+                            IdTokenCredential idToken = new IdTokenCredential(rawIdToken, context);\n+                            QuarkusSecurityIdentity identity = validateAndCreateIdentity(idToken, config,\n+                                    jwt.decode(idToken.getToken()));\n+                            // after a successful refresh, rebuild the identity and update the cookie \n+                            processSuccessfulAuthentication(context, configContext, token, identity);\n+                            cf.complete(identity);\n+                        } else {\n+                            cf.completeExceptionally(new AuthenticationFailedException(result.cause()));", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc1NDQwMw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406754403", "bodyText": "What is the difference when using one or another? I'm expecting to send a challenge, so AuthorizationFailedException is what I need?", "author": "pedroigor", "createdAt": "2020-04-10T13:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyMDg2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406820863", "bodyText": "If the user has authentiicated but the code grant fails then there will be a redirect loop, so we should avoid this here", "author": "sberyozkin", "createdAt": "2020-04-10T15:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzA4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406827085", "bodyText": "Not the case here, then ? If the refresh fails we invalidate the cookie and re-start the login flow.", "author": "pedroigor", "createdAt": "2020-04-10T16:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMTk2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406731969", "bodyText": "Should we just call it logoutEndpoint :-) ?", "author": "sberyozkin", "createdAt": "2020-04-10T12:16:23Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java", "diffHunk": "@@ -171,6 +171,14 @@ public void handle(AsyncResult<OAuth2Auth> event) {\n                 });\n \n                 auth = cf.join();\n+\n+                String endSessionEndpoint = OAuth2AuthProviderImpl.class.cast(auth).getConfig().getLogoutPath();", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0OTA0MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406749040", "bodyText": "I don't really care. This is just the name of the claim from the discovery document.", "author": "pedroigor", "createdAt": "2020-04-10T13:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMjA1NA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406732054", "bodyText": "OIDCException", "author": "sberyozkin", "createdAt": "2020-04-10T12:16:39Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java", "diffHunk": "@@ -171,6 +171,14 @@ public void handle(AsyncResult<OAuth2Auth> event) {\n                 });\n \n                 auth = cf.join();\n+\n+                String endSessionEndpoint = OAuth2AuthProviderImpl.class.cast(auth).getConfig().getLogoutPath();\n+\n+                if (endSessionEndpoint == null && oidcConfig.logout.path.isPresent()) {\n+                    throw new RuntimeException(", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjE3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406742179", "bodyText": "But if I throw a OIDCException it is going to retry the discovery, right ? I just want to fail fast.", "author": "pedroigor", "createdAt": "2020-04-10T12:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NzI4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406777287", "bodyText": "Yeah, that is fine", "author": "sberyozkin", "createdAt": "2020-04-10T14:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMjA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNTQ2OA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406735468", "bodyText": "It is not used as a URI in the code. I also propose to rename the property to something less technical such as  landingPath or postLogoutPath or similar and doc it as Relative path of the application endpoint where the user should be redirected to after the logging out from the OpenID Connect Provider or similar", "author": "sberyozkin", "createdAt": "2020-04-10T12:27:24Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+\n+        /**\n+         * The logout endpoint at the application. If provided, the application is able to initiate the logout through this\n+         * endpoint in conformance with the OpenID Connect RP-Initiated Logout specification.\n+         */\n+        @ConfigItem\n+        Optional<String> path;\n+\n+        /**\n+         * The {@code URI} to redirect the user after the logging out from the OpenID Connect Provider. This {@code URI} must be\n+         * properly registered at the OpenID Connect Provider as a valid redirect URI.\n+         */\n+        @ConfigItem\n+        Optional<String> redirectUri;", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MzI2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406743262", "bodyText": "Makes sense.", "author": "pedroigor", "createdAt": "2020-04-10T12:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNTgyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406735826", "bodyText": "Please replace The logout endpoint at the application with something like The relative path of the logout endpoint...", "author": "sberyozkin", "createdAt": "2020-04-10T12:28:32Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+\n+        /**\n+         * The logout endpoint at the application. If provided, the application is able to initiate the logout through this", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNjY5MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406736690", "bodyText": "I believe we need to support the OIDCs without the discovery (as we already do with introspectionPath and jwksPath), so adding logoutPath or logoutUri may be (doc-ed as either relative path or relative URI of the OIDC logout) and checking it if no discovery is available would make sense IMHO", "author": "sberyozkin", "createdAt": "2020-04-10T12:31:20Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNzM1NA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406737354", "bodyText": "If you agree with the logout_path proposal above, then path should likely be renamed to localPath may be, not 100% sure :-)", "author": "sberyozkin", "createdAt": "2020-04-10T12:33:24Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+\n+        /**\n+         * The logout endpoint at the application. If provided, the application is able to initiate the logout through this\n+         * endpoint in conformance with the OpenID Connect RP-Initiated Logout specification.\n+         */\n+        @ConfigItem\n+        Optional<String> path;", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0Mzg4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406743889", "bodyText": "I'm not sure. The doc change you mentioned is already stating it is a relative path at the application.", "author": "pedroigor", "createdAt": "2020-04-10T12:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3ODc3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406778779", "bodyText": "@pedroigor That is fine, lets keep it as path, what about though that property which will let uses manually configure the OIDC logout path ?", "author": "sberyozkin", "createdAt": "2020-04-10T14:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4MTI2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406781269", "bodyText": "If we have for others, sure, let's provide also an option for this one at the same level.", "author": "pedroigor", "createdAt": "2020-04-10T14:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMzc4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406813785", "bodyText": "@pedroigor Sure that would be fine", "author": "sberyozkin", "createdAt": "2020-04-10T15:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczOTUzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406739535", "bodyText": "I'd drop the word silent and would not even refer to the logout. If we have an expired ID Token then this refresh timeout will refresh all the token types for web-app applications. I can later use it for the pre-emtive refresh for the service applications too :-)", "author": "sberyozkin", "createdAt": "2020-04-10T12:39:53Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -475,6 +523,14 @@ public static Token fromAudience(String... audience) {\n         @ConfigItem\n         public Optional<String> principalClaim = Optional.empty();\n \n+        /**\n+         * The time, in seconds, that tokens should be silently refreshed so that tokens with no active session at the", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NDMyNw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406744327", "bodyText": "For service types, it would not work because you don't have a refresh token. Only the bearer.", "author": "pedroigor", "createdAt": "2020-04-10T12:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3OTMwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406779301", "bodyText": "Of course, got confused :-)", "author": "sberyozkin", "createdAt": "2020-04-10T14:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4MDE5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406780199", "bodyText": "@pedroigor I'd still remove silent - how else it can be refreshed ? :-) and drop a ref to the logout - we can still use it for the pre-emptive refresh for web-apps to refresh AT and ID tokens", "author": "sberyozkin", "createdAt": "2020-04-10T14:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczOTUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MDY0OA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406740648", "bodyText": "That should be in KeycloakRealmResourceManager ? I see, please introduce a dedicated client id, same as I did for the jwt. though it has not been merget yet :-)", "author": "sberyozkin", "createdAt": "2020-04-10T12:43:07Z", "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/CodeFlowTest.java", "diffHunk": "@@ -111,6 +118,67 @@ public void testTokenTimeoutLogout() throws IOException, InterruptedException {\n         }\n     }\n \n+    @Test\n+    public void testRPInitiatedLogout() throws IOException, InterruptedException {\n+        Keycloak keycloak = KeycloakRealmResourceManager.createKeycloakClient();", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NTA0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406745045", "bodyText": "I'm not sure if it is worth doing that as we are updating the realm itself. Realm-level settings. I think tests should be able to change the configuration at Keycloak at their will, like this one. Especially when you have some more dynamic test scenario that depends on changing config.", "author": "pedroigor", "createdAt": "2020-04-10T12:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MDY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4MjI1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406782257", "bodyText": "It is not a big deal but it just complicates the actual test a lot, simply creating all what is needed in a dedicated class makes things cleaner a lot.", "author": "sberyozkin", "createdAt": "2020-04-10T14:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MDY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5NTA4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406795083", "bodyText": "OK. Going to update.", "author": "pedroigor", "createdAt": "2020-04-10T14:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjA2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406742062", "bodyText": "IMHO it would be simpler to keep the realm updates here, see above", "author": "sberyozkin", "createdAt": "2020-04-10T12:47:18Z", "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/KeycloakRealmResourceManager.java", "diffHunk": "@@ -34,16 +34,20 @@\n         realm.getUsers().add(createUser(\"admin\", \"user\", \"admin\"));\n         realm.getUsers().add(createUser(\"jdoe\", \"user\", \"confidential\"));\n \n-        keycloak = KeycloakBuilder.builder()\n+        keycloak = createKeycloakClient();", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjA2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406742066", "bodyText": "IMHO it would be simpler to keep the realm updates here, see above", "author": "sberyozkin", "createdAt": "2020-04-10T12:47:18Z", "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/KeycloakRealmResourceManager.java", "diffHunk": "@@ -34,16 +34,20 @@\n         realm.getUsers().add(createUser(\"admin\", \"user\", \"admin\"));\n         realm.getUsers().add(createUser(\"jdoe\", \"user\", \"confidential\"));\n \n-        keycloak = KeycloakBuilder.builder()\n+        keycloak = createKeycloakClient();\n+        keycloak.realms().create(realm);\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    static Keycloak createKeycloakClient() {\n+        return KeycloakBuilder.builder()", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NDE2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406744162", "bodyText": "What would be really good is to verify idtoken (and also AT at least) has been refreshed. There is a code somewhere in this class which checks the cookie content (disables the auto-redirect and then re-enables - not sure it will be needed yet). So in this test you can record id_token before the refresh and assert it is not the same after the refresh.\nAlso, this is not part of this PR, but there is a timeout test here as well, so please add awaitility there, sorry :-)", "author": "sberyozkin", "createdAt": "2020-04-10T12:53:28Z", "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/CodeFlowTest.java", "diffHunk": "@@ -111,6 +118,67 @@ public void testTokenTimeoutLogout() throws IOException, InterruptedException {\n         }\n     }\n \n+    @Test\n+    public void testRPInitiatedLogout() throws IOException, InterruptedException {\n+        Keycloak keycloak = KeycloakRealmResourceManager.createKeycloakClient();\n+\n+        RealmResource realm = keycloak.realm(KeycloakRealmResourceManager.KEYCLOAK_REALM);\n+        RealmRepresentation representation = realm\n+                .toRepresentation();\n+\n+        Integer ssoSessionMaxLifespan = representation.getSsoSessionMaxLifespan();\n+        representation.setSsoSessionMaxLifespan(20);\n+\n+        Integer accessCodeLifespan = representation.getAccessCodeLifespan();\n+        representation.setAccessTokenLifespan(5);\n+\n+        realm.update(representation);\n+\n+        try (final WebClient webClient = createWebClient()) {\n+            HtmlPage page = webClient.getPage(\"http://localhost:8081/tenant-logout\");\n+            assertEquals(\"Log in to quarkus\", page.getTitleText());\n+            HtmlForm loginForm = page.getForms().get(0);\n+            loginForm.getInputByName(\"username\").setValueAttribute(\"alice\");\n+            loginForm.getInputByName(\"password\").setValueAttribute(\"alice\");\n+            page = loginForm.getInputByName(\"login\").click();\n+            assertTrue(page.asText().contains(\"Tenant Logout\"));\n+            assertNotNull(getSessionCookie(webClient));\n+\n+            page = webClient.getPage(\"http://localhost:8081/tenant-logout/logout\");\n+            assertTrue(page.asText().contains(\"You were logged out\"));\n+            assertNull(getSessionCookie(webClient));\n+\n+            page = webClient.getPage(\"http://localhost:8081/tenant-logout\");\n+            assertEquals(\"Log in to quarkus\", page.getTitleText());\n+            loginForm = page.getForms().get(0);\n+            loginForm.getInputByName(\"username\").setValueAttribute(\"alice\");\n+            loginForm.getInputByName(\"password\").setValueAttribute(\"alice\");\n+            page = loginForm.getInputByName(\"login\").click();\n+            assertTrue(page.asText().contains(\"Tenant Logout\"));\n+\n+            //wait now so that we reach the refresh timeout\n+            await().atMost(10, TimeUnit.SECONDS)\n+                    .pollInterval(Duration.ofSeconds(5))\n+                    .until(new Callable<Boolean>() {\n+                        @Override\n+                        public Boolean call() throws Exception {\n+                            webClient.getOptions().setRedirectEnabled(false);\n+                            WebResponse webResponse = webClient\n+                                    .loadWebResponse(new WebRequest(URI.create(\"http://localhost:8081/tenant-logout\").toURL()));\n+                            // Should not redirect to OP but silently refresh token", "originalCommit": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NTU4MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406745580", "bodyText": "I'm already using awaitility, no ?", "author": "pedroigor", "createdAt": "2020-04-10T12:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NDE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4MzI0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406783247", "bodyText": "@pedroigor Sorry, there is an existing test there testTimeout I think which uses wait(10).\nAnd verifying the id token value is not the same would be good", "author": "sberyozkin", "createdAt": "2020-04-10T14:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NDE2Mg=="}], "type": "inlineReview"}, {"oid": "775004398b9d7d0e8fde8c1c881a516d6e65cfd2", "url": "https://github.com/quarkusio/quarkus/commit/775004398b9d7d0e8fde8c1c881a516d6e65cfd2", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T13:16:09Z", "type": "forcePushed"}, {"oid": "fca62d107d55e343cda45e820b6c58ee9ff3c09d", "url": "https://github.com/quarkusio/quarkus/commit/fca62d107d55e343cda45e820b6c58ee9ff3c09d", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T13:24:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406775635", "bodyText": "What is this refreshingTokens about, why would we want to have this cache ?", "author": "sberyozkin", "createdAt": "2020-04-10T14:13:19Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -298,5 +352,74 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n                 cookie.setPath(auth.cookiePath.get());\n             }\n         }\n+        return cookie;\n+    }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                try {\n+                    if (!refreshingTokens.add(refreshToken)) {", "originalCommit": "fca62d107d55e343cda45e820b6c58ee9ff3c09d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3Njg5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406776892", "bodyText": "Suppose you have the same user coming from different concurrent threads. This code tries to fail-fast for the last thread that tries to refresh the token if it is already happening.", "author": "pedroigor", "createdAt": "2020-04-10T14:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5ODc5NA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406798794", "bodyText": "Hey, thanks, but IMHO it is not really preventive enough. It is recommended as a good practice to recycle the refresh tokens themselves as part of the RT grant (I'm def aware of such a practice :-) ), so what may happen is that a new RT is returned and we may end adding here that new token to this set while the other concurrent thread is already operating with the stale RT.\nI don't know how to resolve it right but this cache can cause the problem IMHO.", "author": "sberyozkin", "createdAt": "2020-04-10T15:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5OTM4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406799387", "bodyText": "There is one thing though that I need to check. The refresh is a blocking operation, so I need to make sure it does not run in the IO Thread. Currently, we only run blocking if the tenant is not yet resolved, so we need to advertise somehow the OidcIdentityProvider or move the runblocking logic to the authentication mechanisms.", "author": "pedroigor", "createdAt": "2020-04-10T15:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwMzIwMg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406803202", "bodyText": "I'm not following. I think you are talking about refresh token rotation ? So that you get a new one every time you refresh tokens ?\nHow would you add the new token if it was not yet sent to the browser?", "author": "pedroigor", "createdAt": "2020-04-10T15:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMzM1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406813355", "bodyText": "@pedroigor may be indeed do it there pre-emptively, in CodeAuthenticationMechansim", "author": "sberyozkin", "createdAt": "2020-04-10T15:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxNjgzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406816835", "bodyText": "I've also changed to use a bounded map so that we put a limit on how many refresh tokens we can handle simultaneously. Otherwise, we may have issues ...\nI agree, maybe we can do the runblocking stuff there ...", "author": "pedroigor", "createdAt": "2020-04-10T15:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ=="}], "type": "inlineReview"}, {"oid": "99a97ea4e9f652be5abc7ea0c07240219a7a43fd", "url": "https://github.com/quarkusio/quarkus/commit/99a97ea4e9f652be5abc7ea0c07240219a7a43fd", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T14:53:09Z", "type": "forcePushed"}, {"oid": "8c71b88232fa545ea85ff6972c8c948b7ee6ea41", "url": "https://github.com/quarkusio/quarkus/commit/8c71b88232fa545ea85ff6972c8c948b7ee6ea41", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T15:00:14Z", "type": "forcePushed"}, {"oid": "efe51530e8c60189fed4a84004eac72c8273ec26", "url": "https://github.com/quarkusio/quarkus/commit/efe51530e8c60189fed4a84004eac72c8273ec26", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T15:43:49Z", "type": "forcePushed"}, {"oid": "542ad49dc1f9d44ef36e8842f989f6a8e3866816", "url": "https://github.com/quarkusio/quarkus/commit/542ad49dc1f9d44ef36e8842f989f6a8e3866816", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T16:11:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406831127", "bodyText": "Hi Pedro @pedroigor That looks safer but I'm really not sure it is the right solution as it still does not resolve the issue that the RT can be recycled so this map may not really be reflecting the current status. IMHO we may need to give it a bit more thinking.", "author": "sberyozkin", "createdAt": "2020-04-10T16:20:13Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,35 +72,82 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, String> refreshingTokens = Collections", "originalCommit": "542ad49dc1f9d44ef36e8842f989f6a8e3866816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2OTAyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406869025", "bodyText": "I would appreciate it if you could give more details how that can happen. I did test this using refresh token rotation and multiple threads trying to refresh. That should make more clear what you are trying to saying ...\nMaybe an improvement we can make is to avoid failing fast for the last thread and block only threads that are associated with the refresh token being refreshed. We could do that by synchronizing the entry corresponding to the refresh token.", "author": "pedroigor", "createdAt": "2020-04-10T17:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4NDg2MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407084860", "bodyText": "@pedroigor I thought this map was about ensuring that multiple threads representing the same user do not refresh and with the RT recycling some faster threads can do it by the time the slower ones attempt to refresh ?\nActually, sorry for being slow :-), but can you explain again what do we want to prevent and why with this map ?\nAll that synchronization seems a bit too much given that IMHO the refresh is not really a logout request related", "author": "sberyozkin", "createdAt": "2020-04-11T16:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ0MDgwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407440805", "bodyText": "We want to prevent concurrent requests from a same subject from failing if one of them is already refreshing a token. Thus providing a more consistent behavior.\nIn addition to that, we also make refresh token requests to the OP more consistent, always using the latest RT. It should cover nicely cases when you are using refresh token rotation too (see tests).\nIt is not 100% related to logout but it is part of the solution. It helps a lot when we want the application in sync with sessions at the OP. So those local sessions are immediately invalidated when no active session exists at the OP. Without refreshing tokens, in a consistent manner, we will continue to rely on token expiration. What is something we want to improve.", "author": "pedroigor", "createdAt": "2020-04-13T11:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ0NDY1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407444657", "bodyText": "Btw, we recently had a similar issue reported in Keycloak about this problem. There we did a similar fix but only for stateful applications (using sessions). Please, consider this as a defensive barrier for potential issues and a safer approach for refreshing tokens.", "author": "pedroigor", "createdAt": "2020-04-13T11:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODA5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407538095", "bodyText": "@pedroigor Refreshing the token to extend the ID token lifetime is related to the user session, indeed, but processing the user logout request is an orthogonal operation in its own way. For example, you could've had a refresh support PR without even dealing the PR initiated logout. Logout is about the user requesting to end the session, the refresh is exactly opposite :-).\n\nWithout refreshing tokens, in a consistent manner, we will continue to rely on token expiration\n\nI'm sorry I don't follow it. We can't just refresh the tokens which have failed the signature verification but only those which have expired, I'm sorry, I know I sound as a broken record :-)\n\nWe want to prevent concurrent requests from a same subject from failing if one of them is already refreshing a token. Thus providing a more consistent behavior.\n\nSo if we have N concurrent requests with sub=1 then there  will be N requests to refresh going to OP, but not in parallel, one after another, correct ? But can many users who currently sit in front of the browser have the same sub ? Where else the concurrency with the same sub can come from ? If it is the same user pressing something multiple times then why have N refresh operations ?\nPedro, sorry, it is just important for me to understand all the subtleties involved and minimize the extra complexities if possible, thanks for the patience :-)", "author": "sberyozkin", "createdAt": "2020-04-13T15:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzOTgwNA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407539804", "bodyText": "Sure. I'm not quite following then what you are proposing here. Do you want to remove token refresh and deal with it as a separate issue?", "author": "pedroigor", "createdAt": "2020-04-13T15:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwMTk1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407601955", "bodyText": "@pedroigor\n\nDo you want to remove token refresh and deal with it as a separate issue?\n\nNo, you've already spent the time on it :-) and it is a very useful thing to have :-). My point has been that refresh should be done only when the token has expired and it is orthogonal in principle to the user logout request IMHO (i.e, I'm just asking for a few simple changes, 1. check the exception is related to the expiry before a refresh, and 2) check the logout only inside the successful authentication code branch). Only 2 updates :-) (and may be 1 or 2 more later :-) ).\nI have also asked to explain more about the whole concurrency and refresh case. It is probably all that needs to be finalized (I'm not counting some very simple doc updates etc :-))\nCheers !", "author": "sberyozkin", "createdAt": "2020-04-13T17:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMjMxMw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407622313", "bodyText": "No problem. Very important concerns.\nRegarding #1. The check for the only refresh on token expiration is OK. As we discussed in another comment.\nRegarding #2. This already happening, right ? Note that refresh only happens if the user already has a session cookie (user potentially authenticated) and if the validation fails due to token expiration (today any exception, but will fix as per #1).\nRegarding your questions about the concurrency and refresh case. See the test testRPInitiatedLogoutSuccessFullConcurrentRequests. It is basically about protecting our code from multiple concurrent requests comming (for whatever reason) and failing.", "author": "pedroigor", "createdAt": "2020-04-13T18:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzMDc3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407630772", "bodyText": "@sberyozkin But again, although not 100% related, the refresh logic is important to make sure we have a consistent logout experience, in sync with sessions at the OP. It is not only about refresh tokens, although it can later be used to support more capabilities not specific to the logout. For instance, allow applications to define a period that tokens should be updated so that the token reflects the latest changes made to an identity (roles, attributes, etc).", "author": "pedroigor", "createdAt": "2020-04-13T18:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjk3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407706973", "bodyText": "@pedroigor Hey Pedro, I'm sorry, I don't understand why we want to refresh a token (=> extend the session) when the user wants to get out out of the session with the logout request.\n\nIt is basically about protecting our code from multiple concurrent requests comming for whatever reason) and failing.\n\nOK - can you clarify please, how many refresh requests will be sent to OIDC in this case ?\nThanks", "author": "sberyozkin", "createdAt": "2020-04-13T20:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMzczMw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407713733", "bodyText": "I'm not saying we want to extend the session for logout. But that in the future we may want to support updating the tokens while sessions are still active at the OP.\nI can't predict how many requests, it depends on the application usage and load. But we should be protected.", "author": "pedroigor", "createdAt": "2020-04-13T20:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjk3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407732971", "bodyText": "@pedroigor OK, so we are moving along, this map ensures that for a given subject, when the refresh is done, quarkus-oidc will send 1 request at a time, i.e, N concurrent requests come in, and then N sequential requests will go out. So my earlier question was, can we have a single refresh request for these N concurrent requests ? I don't know, some subject specific refresh lock ?\nI think I still missing something. What my problem is is that there is a code as part of this PR whose purpose I can't clearly explain to the users, the only thing I can tell them - it is just good, it is to control the concurrent RT requests, without any further clues. So this is why I'm asking the very specific questions. When such a concurrent flow can happen that the same 'sub' is involved ? Why do we have to refresh for every such concurrent request as opposed to failing on all but the initial refresh ? All I'm looking for is for the clarity", "author": "sberyozkin", "createdAt": "2020-04-13T21:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MDA5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407760093", "bodyText": "If you just remove the code that do that and run the test I've added, you'll se what is going to happen when you get concurrent requests.\nYou can have concurrent requests for a number of reasons, even if just bloating the server in a test scenario. Regardless of the situation we should be protected and that is what the code does.\nUsers just need to worry about the refresh period and rely on us to properly manage their requests so that they don't fail, even if making them at the same time for whatever reason.\nUsers also just need to know that we keep local sessions in sync with the active sessions at the OP. So that once the session at the OP is invalidated we also invalidate the local session. That is what this code is all about.", "author": "pedroigor", "createdAt": "2020-04-13T22:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw=="}], "type": "inlineReview"}, {"oid": "ddeb46199407056372e186cde30a91121eec71d7", "url": "https://github.com/quarkusio/quarkus/commit/ddeb46199407056372e186cde30a91121eec71d7", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T19:44:16Z", "type": "forcePushed"}, {"oid": "9aad5e46b909588d90aeda102ac9d44ff692d05b", "url": "https://github.com/quarkusio/quarkus/commit/9aad5e46b909588d90aeda102ac9d44ff692d05b", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-10T19:58:27Z", "type": "forcePushed"}, {"oid": "931e789e8740df0964dcda8d1f9283299a32197e", "url": "https://github.com/quarkusio/quarkus/commit/931e789e8740df0964dcda8d1f9283299a32197e", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-11T11:36:09Z", "type": "forcePushed"}, {"oid": "bf4174280dc3515e66e7f9c35f43308a3f140c4f", "url": "https://github.com/quarkusio/quarkus/commit/bf4174280dc3515e66e7f9c35f43308a3f140c4f", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-11T12:30:07Z", "type": "forcePushed"}, {"oid": "e029283361bfb208a4e20216cc259ca5dff6e758", "url": "https://github.com/quarkusio/quarkus/commit/e029283361bfb208a4e20216cc259ca5dff6e758", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-11T12:55:09Z", "type": "forcePushed"}, {"oid": "c6a659a9b09840c531124c051f19cc442f209d50", "url": "https://github.com/quarkusio/quarkus/commit/c6a659a9b09840c531124c051f19cc442f209d50", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-11T14:31:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407086885", "bodyText": "@pedroigor That is different to what was done about the logout earlier where a challenge was attempted with a valid identity only. IMHO the refresh can only be attempted if the token has expired, which can happen on any other request, so IMHO your original flow should be restored (the logout request initiates a challenge flow only if the identity is available) and again, please just check if \"Token has expired\".equals(throwable.getMessage()) :-), please check Vertx OAuth2 JWT class for the exact message text", "author": "sberyozkin", "createdAt": "2020-04-11T17:07:43Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -61,23 +70,63 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, TokenEntry> refreshingTokens = Collections\n+            .synchronizedMap(new LinkedHashMap<String, TokenEntry>(16, 0.75f, true) {\n+                @Override\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    // we could make the max number of entries configurable\n+                    return size() > 30;\n+                }\n+            });\n+\n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            SecurityIdentity identity;\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (isLogout(context, configContext) ||", "originalCommit": "c6a659a9b09840c531124c051f19cc442f209d50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxNzI3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407217276", "bodyText": "I was thinking more about it, so yes, IMHO, the token refresh should be treated on its own, since the logout request, like any other request to the secured endpoint, should be authenticated first. Next, if the token is valid, and it is a logout, then we initiate a logout flow. If the token verification fails due to the token being expired then we try to recover and refresh ID token as per your idea - but it will work for any other secured request :-)", "author": "sberyozkin", "createdAt": "2020-04-12T15:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyMDM5OA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407220398", "bodyText": "@pedroigor Hey Pedro, the other thing I forgot. Awhile back I introduced AuthenticationRedirectException to handle the local redirect (as part of the authentication request when the user is coming back from the OIDC and the original URI is restored) as I felt using the challenge method for that (ex, throw AuthenticationFailedException and then check again in the challenge method if the redirect is needed) was not ideal (in fact the redirect to drop the query parameters falls into the same category).\nSo IMHO it would a bit simpler, if in the authentication method, once the token has been verified and isLogout is confirmed then you create there a redirect URI and throw AuthenticationRedirectException - no challenge method will even be invoked and isLogout won't have to be checked again in the challenge method - which is also good - as it is not really a challenge that we do here but redirect to OIDC to logout...", "author": "sberyozkin", "createdAt": "2020-04-12T16:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ0MDkyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407440926", "bodyText": "OK. We can use that exception to redirect.", "author": "pedroigor", "createdAt": "2020-04-13T11:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ2OTcyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407469726", "bodyText": "@sberyozkin Just noticed that using the AuthenticationRedirectException would be against one of your suggestions to avoid multiple calls to removeCookie.\nI think we should leave the code as is and have the invalidation code in a single place, as you previously suggested.", "author": "pedroigor", "createdAt": "2020-04-13T13:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzMjk2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407532961", "bodyText": "@pedroigor\n\nJust noticed that using the AuthenticationRedirectException would be against one of your suggestions to avoid multiple calls to removeCookie.\n\nWhat do you mean ? Those multiple remove cookie calls were done inside a single get challenge code, so my suggestion was a simple refactoring proposal as opposed to anything else", "author": "sberyozkin", "createdAt": "2020-04-13T15:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzNjc5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407536797", "bodyText": "I see. I thought that you would like to have the local invalidation from a single point in the code. That said, using the redirect exception is going to spread local invalidation to other parts of the code.", "author": "pedroigor", "createdAt": "2020-04-13T15:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5NjY2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407596665", "bodyText": "@pedroigor\n\nusing the redirect exception is going to spread local invalidation to other parts of the code\n\nYou mean in the same class ? Is it a blocker to having a non-challenge redirect be handled consistently and without the double logout check ?", "author": "sberyozkin", "createdAt": "2020-04-13T17:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNDE1NA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407624154", "bodyText": "Yes. For the sake of consistency, it makes more sense to me to have removed the cookie always from a single place. In this case, whenever a challenge is made.\nBut I don't mind using the redirect exception and calling removeCookie from different places.", "author": "pedroigor", "createdAt": "2020-04-13T18:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ=="}], "type": "inlineReview"}, {"oid": "018b88b02346ac87ae8a48a4e60ed10431d26334", "url": "https://github.com/quarkusio/quarkus/commit/018b88b02346ac87ae8a48a4e60ed10431d26334", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-13T19:02:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwODI5MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407708290", "bodyText": "@pedroigor Thank you :-) :-)", "author": "sberyozkin", "createdAt": "2020-04-13T20:41:45Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -61,23 +70,65 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, TokenEntry> refreshingTokens = Collections\n+            .synchronizedMap(new LinkedHashMap<String, TokenEntry>(16, 0.75f, true) {\n+                @Override\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    // we could make the max number of entries configurable\n+                    return size() > 30;\n+                }\n+            });\n+\n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                redirectToLogoutEndpoint(context, configContext, idToken);\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            Throwable cause = throwable.getCause();\n+\n+                            // we should have proper exception hierarchy to represent token expiration errors\n+                            if (cause != null && !cause.getMessage().equalsIgnoreCase(\"expired token\")) {", "originalCommit": "018b88b02346ac87ae8a48a4e60ed10431d26334", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff", "url": "https://github.com/quarkusio/quarkus/commit/625e17ed0fe29743257238edf7032c94c54c50ff", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-13T20:47:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTY2MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407735660", "bodyText": "@pedroigor I think this looks nice but may be something still needs to be tweaked. So if we have a failure due to the expiry then\n\nif it is a logout request - we just redirect to the OP logout URI - this makes sense\notherwise we just refresh, if identity is not null, all is good,  but if it is null, I think we should return AuthenticationFailedException so that a user's session is invalidated and we redirect the user to the login site, as opposed to the logout site, this is because the OP logout endpoint may not be even available, and even if it is available, I don't think the user, after his ID token has failed to refresh, should be redirected to the OP logout site - what if OP asks, would you like to logout ? while the users was doing some GET /mybook...\n\nWhat do you think ?", "author": "sberyozkin", "createdAt": "2020-04-13T21:35:49Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -61,23 +70,65 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, TokenEntry> refreshingTokens = Collections\n+            .synchronizedMap(new LinkedHashMap<String, TokenEntry>(16, 0.75f, true) {\n+                @Override\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    // we could make the max number of entries configurable\n+                    return size() > 30;\n+                }\n+            });\n+\n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                redirectToLogoutEndpoint(context, configContext, idToken);\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            Throwable cause = throwable.getCause();\n+\n+                            // we should have proper exception hierarchy to represent token expiration errors\n+                            if (cause != null && !cause.getMessage().equalsIgnoreCase(\"expired token\")) {\n+                                throw new AuthenticationFailedException(throwable);\n+                            }\n+\n+                            SecurityIdentity identity = null;\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (isLogout(context, configContext) ||\n+                                    (identity = trySilentRefresh(configContext, idToken, refreshToken, context,\n+                                            identityProviderManager)) == null) {\n+                                redirectToLogoutEndpoint(context, configContext, idToken);", "originalCommit": "625e17ed0fe29743257238edf7032c94c54c50ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc1NDQ4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407754485", "bodyText": "#1. We only redirect if the refresh fails. Otherwise, an identity is returned and the user is silently re-authenticated.\n#2. You are right, this is wrong. We should restart the authentication.", "author": "pedroigor", "createdAt": "2020-04-13T22:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407737516", "bodyText": "So yeah, what happens here to the blocking threads, they get the refresh token and proceed with their own refresh ? Or can we just let those blocking threads pick up the refreshed token/etc and continue without the refresh ?", "author": "sberyozkin", "createdAt": "2020-04-13T21:39:53Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +348,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,\n+                        new Function<String, TokenEntry>() {\n+                            @Override\n+                            public TokenEntry apply(String token) {\n+                                return new TokenEntry(refreshToken);\n+                            }\n+                        });\n+\n+                // synchronize on the entry associated with the current subject\n+                synchronized (entry) {\n+                    Uni<SecurityIdentity> cf = Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                        @Override\n+                        public void accept(UniEmitter<? super SecurityIdentity> emitter) {\n+                            OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                            // always get the last token\n+                            token.principal().put(\"refresh_token\", entry.getToken());\n+\n+                            token.refresh(new Handler<AsyncResult<Void>>() {\n+                                @Override\n+                                public void handle(AsyncResult<Void> result) {\n+                                    if (result.succeeded()) {\n+                                        authenticate(identityProviderManager,\n+                                                new IdTokenCredential(token.opaqueIdToken(), context))\n+                                                        .subscribe().with(new Consumer<SecurityIdentity>() {\n+                                                            @Override\n+                                                            public void accept(SecurityIdentity identity) {\n+                                                                // after a successful refresh, rebuild the identity and update the cookie \n+                                                                processSuccessfulAuthentication(context, configContext, token,\n+                                                                        identity);\n+                                                                // update the token so that blocking threads get the latest one\n+                                                                entry.setToken(token.opaqueRefreshToken());\n+                                                                emitter.complete(", "originalCommit": "625e17ed0fe29743257238edf7032c94c54c50ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc0OTUwNw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407749507", "bodyText": "Yes. Thing is that we would need to know if a refresh happened before to make the second point work. I think is easier to just let them refresh and get a new set of tokens.", "author": "pedroigor", "createdAt": "2020-04-13T22:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MDE1OA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407840158", "bodyText": "So can this bit perform blocking operations? If so you need to check if you are on the IO thread and dispatch to an executor.", "author": "stuartwdouglas", "createdAt": "2020-04-14T03:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMDY1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407900652", "bodyText": "Everything is within a call to authenticate  which will end up executing as blocking (by the identity provider).\nAnd here is the place I mentioned to you about the Vert.x OAuth2 always execute in the event loop thread. If you check the thread before the authenticate call you'll see it runs in the event loop thread. But if you check the thread within the block you are commenting you'll see it does run in an executor thread. However, the trySilentRefresh always executes as blocking. So we would expect that we never run in the event loop thread.", "author": "pedroigor", "createdAt": "2020-04-14T06:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk1NzI4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407957283", "bodyText": "@pedroigor OK, so we just keep recycling for every concurrent request. OK, I'm still a bit unclear about where these concurrent requests can originate from with the same sub, I'll ping you later to understand better :-) but obviously there are all sort of variations possible with 'sub' being reused.\nI'll open an issue to track the even loop issue", "author": "sberyozkin", "createdAt": "2020-04-14T08:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg=="}], "type": "inlineReview"}, {"oid": "6b5edfee40acf0c30824113446f4677b5c5a57af", "url": "https://github.com/quarkusio/quarkus/commit/6b5edfee40acf0c30824113446f4677b5c5a57af", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-13T22:23:24Z", "type": "forcePushed"}, {"oid": "7dc3131b86e6b74ab0736fcd957545397bb61a66", "url": "https://github.com/quarkusio/quarkus/commit/7dc3131b86e6b74ab0736fcd957545397bb61a66", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-13T22:27:11Z", "type": "forcePushed"}, {"oid": "1051986b26679a9f5a0d02854b06cdbcf7968f42", "url": "https://github.com/quarkusio/quarkus/commit/1051986b26679a9f5a0d02854b06cdbcf7968f42", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-13T22:28:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNTE0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407835146", "bodyText": "Why do we need this map? I don't really like the idea of making the authenticators stateful, and I really don't like the arbitrary size limit.", "author": "stuartwdouglas", "createdAt": "2020-04-14T02:52:24Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +351,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,", "originalCommit": "1051986b26679a9f5a0d02854b06cdbcf7968f42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5Njk3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407896977", "bodyText": "Indeed, it makes it stateful. You may have noticed that the idea is to prevent requests from failing when they are sent from a same subject at the same time.\nThe point here is making requests consistent and don't fail due to multiple refresh token requests from a same subject. This is especially useful when you have refresh token rotation enabled at the IdP and after a refresh token request, you get also a new refresh token.\nI understand the concerns you and @sberyozkin have about this part. In fact, my initial changes were just failing requests. But I do think this is useful and important to make things consistent.\nSo, if you also think we should remove this, I will not argue anymore and just remove it.", "author": "pedroigor", "createdAt": "2020-04-14T06:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNTE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMDcxMA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407900710", "bodyText": "The big problem with this is that it is not 'cloud native'. Requests may be going to different pods, so you can't be sure that this state is actually shared between requests.", "author": "stuartwdouglas", "createdAt": "2020-04-14T06:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNTE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkyNzEyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407927125", "bodyText": "That is a good argument. Missed that, so that in the case of pods, pod-affinity is an anti-pattern.\nI'm going to remove this part and just fail the request. Let's treat it as a corner case and have this behavior documented properly.", "author": "pedroigor", "createdAt": "2020-04-14T07:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNTE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzOTI1MA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407839250", "bodyText": "Even if this is a new token it will still be refreshed?", "author": "stuartwdouglas", "createdAt": "2020-04-14T03:07:14Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +351,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,\n+                        new Function<String, TokenEntry>() {\n+                            @Override\n+                            public TokenEntry apply(String token) {\n+                                return new TokenEntry(refreshToken);\n+                            }\n+                        });\n+\n+                // synchronize on the entry associated with the current subject\n+                synchronized (entry) {\n+                    Uni<SecurityIdentity> cf = Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                        @Override\n+                        public void accept(UniEmitter<? super SecurityIdentity> emitter) {\n+                            OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                            // always get the last token\n+                            token.principal().put(\"refresh_token\", entry.getToken());", "originalCommit": "1051986b26679a9f5a0d02854b06cdbcf7968f42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzMyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407897329", "bodyText": "Yes. I don't think we need to control whether or not a refresh already happened but just get the latest.", "author": "pedroigor", "createdAt": "2020-04-14T06:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzOTI1MA=="}], "type": "inlineReview"}, {"oid": "883895b76ad63c35f30af0ca484c3125b2ec7ad4", "url": "https://github.com/quarkusio/quarkus/commit/883895b76ad63c35f30af0ca484c3125b2ec7ad4", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-14T07:56:56Z", "type": "forcePushed"}, {"oid": "fc99ef40252c902ff133064c64f09999e13fe871", "url": "https://github.com/quarkusio/quarkus/commit/fc99ef40252c902ff133064c64f09999e13fe871", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-14T08:17:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwODUwMg==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408008502", "bodyText": "Pretty sure now this should be AuthenticationCompletionException to get 401 out if it is something anything but expiry related.", "author": "sberyozkin", "createdAt": "2020-04-14T09:48:35Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -66,23 +73,56 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                throw redirectToLogoutEndpoint(context, configContext, idToken);\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            if (throwable instanceof AuthenticationRedirectException) {\n+                                throw AuthenticationRedirectException.class.cast(throwable);\n+                            }\n+\n+                            Throwable cause = throwable.getCause();\n+\n+                            // we should have proper exception hierarchy to represent token expiration errors\n+                            if (cause != null && !cause.getMessage().equalsIgnoreCase(\"expired token\")) {\n+                                throw new AuthenticationFailedException(throwable);", "originalCommit": "fc99ef40252c902ff133064c64f09999e13fe871", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MTgwOA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408181808", "bodyText": "I think I see what you want. Avoid redirects in case of \"unknown\" failures. Will change.", "author": "pedroigor", "createdAt": "2020-04-14T14:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNTMxNA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408015314", "bodyText": "@pedroigor But what if the refresh is never even utilized ? Example the user will logout manually before the refresh is even needed ? I wonder if what Stuart said can be done somehow, switch to the blocking mode dynamically only for refresh.\n@stuartwdouglas As Pedro said, the blocking vs event loop decision is done early, but we don't even know if refresh will be needed for a current request at that stage, is it possible to switch back to the blocking mode when the request is already running in the even loop ?", "author": "sberyozkin", "createdAt": "2020-04-14T09:59:35Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/DefaultTenantConfigResolver.java", "diffHunk": "@@ -81,7 +81,14 @@ private TenantConfigContext getTenantConfigFromTenantResolver(RoutingContext con\n     }\n \n     boolean isBlocking(RoutingContext context) {\n-        return getTenantConfigFromConfigResolver(context, false) == null;\n+        TenantConfigContext resolver = getTenantConfigFromConfigResolver(context, false);\n+\n+        if (resolver != null) {\n+            // we always run blocking if refresh token is enabled even if the tenant was already resolved", "originalCommit": "fc99ef40252c902ff133064c64f09999e13fe871", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MzQwNA==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408183404", "bodyText": "I would say that it would be nice to have a way to run blocking operations from a mechanism just like we have for identity providers.\nHowever, for this particular issue, I think we can leave as is and handle it separately. Probably in conjunction with the issue I mentioned when Vert.x OAuth is operating in the event loop.", "author": "pedroigor", "createdAt": "2020-04-14T14:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNTAwNw==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408325007", "bodyText": "@pedroigor Absolutely, better handling of the blocking calls can be done later, but here it looks like the request becomes blocking even if no refresh will be done for the current call. But the refresh is healthy to have for every deployment anyway, but as soon as they set this property it becomes a performance penalty :-) so I wonder if we can avoid it somehow. Lets see what @stuartwdouglas may suggest", "author": "sberyozkin", "createdAt": "2020-04-14T17:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNzkxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408017919", "bodyText": "@pedroigor Would you like to support the case where no discovery is possible ? We simply add that extra property and check if no discovered path is available. I can do it later though, up to you", "author": "sberyozkin", "createdAt": "2020-04-14T10:03:53Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java", "diffHunk": "@@ -165,6 +165,27 @@ public void handle(AsyncResult<OAuth2Auth> event) {\n                 });\n \n                 auth = cf.join();\n+\n+                if (!ApplicationType.WEB_APP.equals(oidcConfig.applicationType)) {\n+                    if (oidcConfig.token.refreshTimeout.isPresent()) {\n+                        throw new RuntimeException(\n+                                \"The logout path can only be enabled for \" + ApplicationType.WEB_APP + \" application types\");\n+                    }\n+                    if (oidcConfig.logout.path.isPresent()) {\n+                        throw new RuntimeException(\n+                                \"The logout path can only be enabled for \" + ApplicationType.WEB_APP + \" application types\");\n+                    }\n+                }\n+\n+                String endSessionEndpoint = OAuth2AuthProviderImpl.class.cast(auth).getConfig().getLogoutPath();\n+\n+                if (oidcConfig.logout.path.isPresent()) {\n+                    if (endSessionEndpoint == null) {", "originalCommit": "fc99ef40252c902ff133064c64f09999e13fe871", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMzg1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408023851", "bodyText": "@pedroigor As mentioned earlier, IMHO it would be better if we drop silent and any reference to the logout. We just say something like \"Refresh token timeout in seconds. If enabled, the expired ID token will be refreshed if the difference between the current time and the issued at time is less than this timeout\" (but in a better worded way :-) ). And may be add \" and will invalidate the old sessions at the RP and OP sites.\" or similar as you prefer", "author": "sberyozkin", "createdAt": "2020-04-14T10:13:50Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -530,6 +580,14 @@ public static Token fromAudience(String... audience) {\n         @ConfigItem\n         public Optional<String> principalClaim = Optional.empty();\n \n+        /**\n+         * The time, in seconds, that tokens should be silently refreshed so that tokens with no active session at the", "originalCommit": "fc99ef40252c902ff133064c64f09999e13fe871", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDY5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408024695", "bodyText": "In all other cases we set Optional internally, so just pass Integer", "author": "sberyozkin", "createdAt": "2020-04-14T10:15:10Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -561,6 +619,14 @@ public void setExpirationGrace(int expirationGrace) {\n         public void setPrincipalClaim(String principalClaim) {\n             this.principalClaim = Optional.of(principalClaim);\n         }\n+\n+        public Optional<Integer> getRefreshTimeout() {\n+            return refreshTimeout;\n+        }\n+\n+        public void setRefreshTimeout(Optional<Integer> refreshTimeout) {", "originalCommit": "fc99ef40252c902ff133064c64f09999e13fe871", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e569b9f1f062ce4f635ffcbe553e191e9465bd0c", "url": "https://github.com/quarkusio/quarkus/commit/e569b9f1f062ce4f635ffcbe553e191e9465bd0c", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-14T15:23:27Z", "type": "forcePushed"}, {"oid": "78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "url": "https://github.com/quarkusio/quarkus/commit/78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-17T12:29:14Z", "type": "commit"}, {"oid": "78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "url": "https://github.com/quarkusio/quarkus/commit/78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "message": "[fixes #4481] - RP-Initiated Logout and session verification", "committedDate": "2020-04-17T12:29:14Z", "type": "forcePushed"}]}