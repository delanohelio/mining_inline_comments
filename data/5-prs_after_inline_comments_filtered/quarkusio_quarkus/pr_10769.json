{"pr_number": 10769, "pr_title": "Panache reactive based on Hibernate Reactive", "pr_createdAt": "2020-07-16T08:20:41Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10769", "timeline": [{"oid": "521c6770f3ec626ef7e579af188e34cb614c04ce", "url": "https://github.com/quarkusio/quarkus/commit/521c6770f3ec626ef7e579af188e34cb614c04ce", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics", "committedDate": "2020-07-20T14:16:51Z", "type": "forcePushed"}, {"oid": "71f49320b6f75890f760f9ee2ab72e257f65755a", "url": "https://github.com/quarkusio/quarkus/commit/71f49320b6f75890f760f9ee2ab72e257f65755a", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics", "committedDate": "2020-07-21T09:05:33Z", "type": "forcePushed"}, {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "url": "https://github.com/quarkusio/quarkus/commit/66cd30adf5f65e235831e3cb55ea57ad8f317b48", "message": "junit5-mockito: do not mock ClientProxy interfaces\n\nThey don't have generics", "committedDate": "2020-07-21T15:33:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459953963", "bodyText": "What if the settings don't match from a previously cached mock you might have created for the same klass?", "author": "Sanne", "createdAt": "2020-07-24T09:42:47Z", "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzM2MA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933360", "bodyText": "I guess it will override the mock, since they're keyed on class and not settings. That's fine.", "author": "FroMage", "createdAt": "2020-08-07T09:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0NTYxMw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466945613", "bodyText": "and settings will not change?", "author": "Sanne", "createdAt": "2020-08-07T10:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5ODM1MA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467098350", "bodyText": "Ah, you're right, OK.", "author": "FroMage", "createdAt": "2020-08-07T15:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5ODkzMg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467098932", "bodyText": "Pfff, I'll just remove this method.", "author": "FroMage", "createdAt": "2020-08-07T15:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NTExNg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459955116", "bodyText": "you have a race condition here; maybe it's not an issues as I don't expect many will invoke this method concurrecntly, but perhaps you'd still prefer to use a safer locking pattern?\nI don't think this needs to be \"high throughput\" or high performance, so just synchronize it all?", "author": "Sanne", "createdAt": "2020-07-24T09:45:20Z", "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));\n+        }\n+        IsMockEnabled = !mocks.isEmpty();", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzM5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933397", "bodyText": "OK", "author": "FroMage", "createdAt": "2020-08-07T09:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NTExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459957075", "bodyText": "What is the purpose of this check? And why should it not be persisted otherwise?", "author": "Sanne", "createdAt": "2020-07-24T09:49:42Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Nzc1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459957751", "bodyText": "Also, why is this specific variation of the persist method having this check, but the other methods won't have the same semantics?", "author": "Sanne", "createdAt": "2020-07-24T09:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzc2NA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933764", "bodyText": "The purpose is to not call persist if it's already persisted. The ORM version has the same check. What happens if I call persist on an already persisted entity, otherwise?", "author": "FroMage", "createdAt": "2020-08-07T09:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNDQ0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466934447", "bodyText": "The other variations of persist ultimately call this, so it's fine.", "author": "FroMage", "createdAt": "2020-08-07T09:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0OTIwMg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466949202", "bodyText": "What happens if I call persist on an already persisted entity, otherwise?\n\nNothing, but at least we have a chance to verify the transaction is alive, extend timeouts, and things like that.", "author": "Sanne", "createdAt": "2020-08-07T10:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5ODA2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467098063", "bodyText": "Well, the javadoc wasn't entirely clear about the semantics here.", "author": "FroMage", "createdAt": "2020-08-07T15:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459959959", "bodyText": "why name this \"getEntityManager\" when it doesn't return one? :)\nAlso: why returning an Uni, when you could just get the Session right away? opening a Session is non-blocking.", "author": "Sanne", "createdAt": "2020-07-24T09:55:50Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2MTU4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459961582", "bodyText": "I mean, ask ArC for a Mutiny.Session rather than a Uni<Mutiny.Session>", "author": "Sanne", "createdAt": "2020-07-24T09:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNzExMg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462207112", "bodyText": "+1 this would remove a lot of flatMap operations !", "author": "loicmathieu", "createdAt": "2020-07-29T10:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNzA4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466937082", "bodyText": "I don't think there's any producer for Mutiny.Session since ArC doesn't do async injection, so not sure what you're talking about.\nOK, apparently this was added after I did my PR. Fine, let's switch to that :)", "author": "FroMage", "createdAt": "2020-08-07T09:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTM4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467045382", "bodyText": "BTW, opening a Session isn't a blocking operation.", "author": "Sanne", "createdAt": "2020-08-07T13:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NTM4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459965389", "bodyText": "Should we remove this for now?", "author": "Sanne", "createdAt": "2020-07-24T10:08:28Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0MzA3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466943075", "bodyText": "Yes", "author": "FroMage", "createdAt": "2020-08-07T09:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459967556", "bodyText": "All this stuff with string manipulation is extremely dodgy .. :)", "author": "Sanne", "createdAt": "2020-07-24T10:13:52Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2ODE3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459968175", "bodyText": "I suppose you have much of the same in the non-reactive version of Panache? Could we avoid some copy paste for all this code?", "author": "Sanne", "createdAt": "2020-07-24T10:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MDA2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467040065", "bodyText": "Yes, good idea.", "author": "FroMage", "createdAt": "2020-08-07T13:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTY3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459969673", "bodyText": "Why using System.err here?", "author": "Sanne", "createdAt": "2020-07-24T10:19:06Z", "path": "extensions/panache/hibernate-reactive-panache/deployment/src/main/java/io/quarkus/hibernate/reactive/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package io.quarkus.hibernate.reactive.panache.deployment;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.persistence.Id;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.ClassType;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.ParameterizedType;\n+import org.jboss.jandex.Type;\n+import org.jboss.jandex.Type.Kind;\n+\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.deployment.ValidationPhaseBuildItem;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.bootstrap.classloading.ClassPathElement;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.util.JandexUtil;\n+import io.quarkus.hibernate.orm.deployment.AdditionalJpaModelBuildItem;\n+import io.quarkus.hibernate.orm.deployment.HibernateEnhancersRegisteredBuildItem;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntity;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepository;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepositoryBase;\n+import io.quarkus.panache.common.deployment.EntityField;\n+import io.quarkus.panache.common.deployment.EntityModel;\n+import io.quarkus.panache.common.deployment.MetamodelInfo;\n+import io.quarkus.panache.common.deployment.PanacheEntityClassesBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheFieldAccessEnhancer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizerBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheRepositoryEnhancer;\n+import io.smallrye.mutiny.Uni;\n+\n+public final class PanacheHibernateResourceProcessor {\n+\n+    static final DotName DOTNAME_PANACHE_REPOSITORY_BASE = DotName.createSimple(PanacheRepositoryBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_REPOSITORY = DotName.createSimple(PanacheRepository.class.getName());\n+    static final DotName DOTNAME_PANACHE_ENTITY_BASE = DotName.createSimple(PanacheEntityBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_ENTITY = DotName.createSimple(PanacheEntity.class.getName());\n+\n+    private static final DotName DOTNAME_REACTIVE_SESSION = DotName.createSimple(Mutiny.Session.class.getName());\n+    private static final DotName DOTNAME_UNI = DotName.createSimple(Uni.class.getName());\n+\n+    private static final DotName DOTNAME_ID = DotName.createSimple(Id.class.getName());\n+    protected static final String META_INF_PANACHE_ARCHIVE_MARKER = \"META-INF/panache-archive.marker\";\n+\n+    protected static final ParameterizedType SESSION_TYPE = ParameterizedType.create(DOTNAME_UNI,\n+            new Type[] { ClassType.create(DOTNAME_REACTIVE_SESSION, Kind.CLASS) }, null);\n+\n+    @BuildStep\n+    FeatureBuildItem featureBuildItem() {\n+        // FIXME\n+        return new FeatureBuildItem(Feature.HIBERNATE_ORM_PANACHE.getName() + \"-reactive\");\n+    }\n+\n+    @BuildStep\n+    List<AdditionalJpaModelBuildItem> produceModel() {\n+        // only useful for the index resolution: hibernate will register it to be transformed, but BuildMojo\n+        // only transforms classes from the application jar, so we do our own transforming\n+        return Collections.singletonList(\n+                new AdditionalJpaModelBuildItem(PanacheEntity.class));\n+    }\n+\n+    @BuildStep\n+    UnremovableBeanBuildItem ensureBeanLookupAvailable() {\n+        //        [types=[io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session>, java.lang.Object], \n+        //                qualifiers=[@Default, @Any], \n+        //                target=io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session> mutinySession(), \n+        //                declaringBean=io.quarkus.hibernate.reactive.runtime.ReactiveSessionProducer]\n+\n+        return new UnremovableBeanBuildItem(new Predicate<BeanInfo>() {\n+            @Override\n+            public boolean test(BeanInfo t) {\n+                boolean m1 = t.hasType(DOTNAME_UNI);\n+                if (m1) {\n+                    boolean m2 = t.getTypes().contains(SESSION_TYPE);\n+                    System.err.println(\"REMOVE \" + t + \" m1: \" + m1 + \" m2: \" + m2);", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MjU3NA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467042574", "bodyText": "Ooops.", "author": "FroMage", "createdAt": "2020-08-07T13:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MTU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459971553", "bodyText": "So Panache can't deal with composite IDs ?", "author": "Sanne", "createdAt": "2020-07-24T10:23:51Z", "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/DuplicateIdEntityTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.test.QuarkusUnitTest;\n+\n+public class DuplicateIdEntityTest {\n+\n+    @RegisterExtension\n+    static QuarkusUnitTest runner = new QuarkusUnitTest()\n+            .setExpectedException(BuildException.class)\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(DuplicateIdEntity.class));\n+\n+    @Test\n+    void shouldThrow() {\n+        fail(\"A BuildException should have been thrown due to duplicate entity ID\");", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Mzg4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467043881", "bodyText": "IIRC this detects the case where you have multiple @Id annotations but no matching @IdClass which is always a blunder.", "author": "FroMage", "createdAt": "2020-08-07T13:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MjQwNg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459972406", "bodyText": "It's not an EntityManager .. in this case since it's public API I'd definitely fix it.", "author": "Sanne", "createdAt": "2020-07-24T10:25:48Z", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/Panache.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.persistence.EntityManager;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.hibernate.reactive.panache.runtime.JpaOperations;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Utility class for Panache.\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ */\n+public class Panache {\n+\n+    /**\n+     * Returns the current {@link EntityManager}", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NDYxMg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467044612", "bodyText": "Yes, I've fixed it.", "author": "FroMage", "createdAt": "2020-08-07T13:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461591426", "bodyText": "Any  particular reason to use the collector?\nIt's possible to convert a Stream using Multi and return a Uni<Void> by using ignore().\nIt would look something like:\nreturn getEntityManager.flatMap( em -> \n    Multi.createFrom().items( entities )\n        .onItem().invoke( entity -> em.persist( entity ) )\n        .onItem().ignoreAsUni()\n);", "author": "DavideD", "createdAt": "2020-07-28T13:45:20Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "originalCommit": "32a3f43141080ba1504c0dbcfaf069954d0a69d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyOTI4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461629282", "bodyText": "Similar for delete and flush", "author": "DavideD", "createdAt": "2020-07-28T14:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NzA1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467047059", "bodyText": "Oh I didn't know about this, I've used it, thanks. I really didn't expect onItem to lead me to an operation that worked on the completion of ALL items.\nI do not see what you mean about delete and flush though, which don't use streams?", "author": "FroMage", "createdAt": "2020-08-07T13:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5OTU5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467099597", "bodyText": "Except it doesn't work:\n// this works:\n        List<Uni<Void>> uniList = entities.map(entity -> persist(session, entity)).collect(Collectors.toList());\n        return Uni.combine().all().unis(uniList).discardItems();\n\n// this does nothing:\n        return Multi.createFrom().items(entities)\n                     .map(entity -> persist(session, entity))\n                     .onItem().ignoreAsUni();\n@cescoffier is this a bug?", "author": "FroMage", "createdAt": "2020-08-07T15:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTcwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r471349709", "bodyText": "persist returns a Uni right? To you need to flatMap instead of map.", "author": "cescoffier", "createdAt": "2020-08-17T09:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTc1MA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r471361750", "bodyText": "Aha, yeah, makes a lot of sense.", "author": "FroMage", "createdAt": "2020-08-17T09:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYxNjkyNg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461616926", "bodyText": "You could use ifNull and IfNotNull here:\nfindById(entityClass, id)\n    .onItem().ifNotNull().transformToUni( entity -> s.remove( entity ).onItem().transform( ignore -> Boolean.TRUE ))\n    .onItem().ifNull().continueWith( Boolean.FALSE );", "author": "DavideD", "createdAt": "2020-07-28T14:17:09Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Long> deleteAll(Class<?> entityClass) {\n+        return getEntityManager().flatMap(em -> em.createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate()\n+                .map(i -> i.longValue()));\n+    }\n+\n+    public Uni<Boolean> deleteById(Class<?> entityClass, Object id) {\n+        // Impl note : we load the entity then delete it because it's the only implementation generic enough for any model,\n+        // and correct in all cases (composite key, graph of entities, ...). HQL cannot be directly used for these reasons.\n+        return findById(entityClass, id)\n+                .flatMap(entity -> {\n+                    if (entity == null) {\n+                        return Uni.createFrom().item(false);\n+                    }\n+                    return getEntityManager().flatMap(em -> em.remove(entity).map(v -> true));\n+                });", "originalCommit": "32a3f43141080ba1504c0dbcfaf069954d0a69d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0ODY5OA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467048698", "bodyText": "I can, but it's not clear to me that it'll be more readable :)", "author": "FroMage", "createdAt": "2020-08-07T13:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYxNjkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461627696", "bodyText": "What about this:\n\t\treturn em.persist( entity ).onItem().ignore().andContinueWithNull();", "author": "DavideD", "createdAt": "2020-07-28T14:31:10Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "originalCommit": "32a3f43141080ba1504c0dbcfaf069954d0a69d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwMzc5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462203797", "bodyText": "+1 this is what reactive MongoDB panache uses", "author": "loicmathieu", "createdAt": "2020-07-29T10:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0OTEzMA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467049130", "bodyText": "Yeah, I've found the map(v -> null) to be a lot shorter and to the point. I'd rather keep this :)", "author": "FroMage", "createdAt": "2020-08-07T13:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NzUxNA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467077514", "bodyText": "I first use map(v -> null) than Clement said that .onItem().ignore().andContinueWithNull() is better, I don't remember why (maybe it provides the item to be emitted ...)", "author": "loicmathieu", "createdAt": "2020-08-07T14:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462173928", "bodyText": "See how I did in the MongoDB ReactivePanacheQueryImpl, I do cache the Uni count.", "author": "loicmathieu", "createdAt": "2020-07-29T09:43:37Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NzM0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467067345", "bodyText": "Well, I also cache the Uni, but you don't cache its result. It could be cached or recreated every time.", "author": "FroMage", "createdAt": "2020-08-07T14:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3OTYyNA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467079624", "bodyText": "Hum, good point.\nThere is a cache method on Uni it should be use to avoid this.", "author": "loicmathieu", "createdAt": "2020-08-07T14:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTYwNA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462175604", "bodyText": "This is legacy code ;)\nThis was done like this in the first implementation of PanacheQuery, we already question this some times ago and decided to keep it I don't remember why ...\nBut default are no paging this is why there is the Hibernate related stuff right ,", "author": "loicmathieu", "createdAt": "2020-07-29T09:46:29Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462176645", "bodyText": "If hint are not supported, better remove the withHint() method or make it throw an UnsupportedOperationException.\nIf they will be supported in a near future, opennning a followup issue may be a good idead", "author": "loicmathieu", "createdAt": "2020-07-29T09:48:22Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk2NDg1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466964859", "bodyText": "Alternatively, we should consider simply not supporting hints at all in Panache. They're really there only to allow use of vendor-specific features via the JPA-standard APIs, but they're untypesafe and inconvenient.\nI would argue that it would be better if Panache offered typesafe APIs for Hibernate-specific features. As far as I understand, support for other JPA implementations is a non-goal.", "author": "gavinking", "createdAt": "2020-08-07T10:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2ODkwOA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467068908", "bodyText": "They will be, let's throw.", "author": "FroMage", "createdAt": "2020-08-07T14:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MzE2MA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467083160", "bodyText": "They will be, let's throw.\n\nSeriously? you're going to make, say, Eclipselink work in Quarkus?", "author": "gavinking", "createdAt": "2020-08-07T14:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5NzM3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467097376", "bodyText": "No, I meant hints will be supported, because I thought they would (and github didn't show me your answer at the time, so I was replying to Lo\u00efc).\nI don't mind if we replace hint support if you tell me HR will not support them.", "author": "FroMage", "createdAt": "2020-08-07T15:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NDY3MA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467544670", "bodyText": "I'd love to fully eradicate support for hints from ORM, and have a proper API instead.\nOf course we can't because of specs, but we could introduce an internal configurtion setting to at least ignore them for Hibernate Reactive (and maybe even for ORM classic when within Quarkus).\nBeyond API benefits of more explicit options, dealing with them is also highl inefficient.", "author": "Sanne", "createdAt": "2020-08-09T06:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NjcyMA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467546720", "bodyText": "I don't mind if we replace hint support if you tell me HR will not support them.\n\nYeah but I'm advocating removing them from the regular (non-reactive) API as well. Or rather, representing the specific hints that Hibernate supports in a type safe way, just like what I've done in certain specific cases in the HR API.", "author": "gavinking", "createdAt": "2020-08-09T07:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462179187", "bodyText": "In the MongoDB reactive version I do keep this code imperative for the sake of simplicity.\nI think that as long as there is no IO operations, such very quick code can stay imperative but maybe I'm wrong.", "author": "loicmathieu", "createdAt": "2020-07-29T09:52:27Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2OTI3OA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467069278", "bodyText": "Well, it also means we throw in situations where it'd be better to return a failed uni.", "author": "FroMage", "createdAt": "2020-08-07T14:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MTM0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467081341", "bodyText": "Hum, in fact I did it this way because ... you did it this way in your first implementation of Panache Rx so do as you want I'll update the MongoDB part later if needed ;)\nI agree that you don't expect reactive code to throw, but this particular case is a developement error (like a NPE) so I think you can throw", "author": "loicmathieu", "createdAt": "2020-08-07T14:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTE3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462181179", "bodyText": "In MongoDB panache reactive I have the following implementation, why is it the same not possible for Hibernate ?\n    public <T extends Entity> Uni<ReactivePanacheQuery<T>> lastPage() {\n        checkPagination();\n        return pageCount().map(pageCount -> page(page.index(pageCount - 1)));\n    }", "author": "loicmathieu", "createdAt": "2020-07-29T09:55:47Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MTk3NA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467071974", "bodyText": "OK.", "author": "FroMage", "createdAt": "2020-08-07T14:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462189182", "bodyText": "It misses firstResultOptional() and singleResultOptional() methods.", "author": "loicmathieu", "createdAt": "2020-07-29T10:09:48Z", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/PanacheQuery.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+\n+import org.hibernate.Session;\n+import org.hibernate.annotations.FilterDef;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * <p>\n+ * Interface representing an entity query, which abstracts the use of paging, getting the number of results, and\n+ * operating on {@link List} or {@link Stream}.\n+ * </p>\n+ * <p>\n+ * Instances of this interface cannot mutate the query itself or its parameters: only paging information can be\n+ * modified, and instances of this interface can be reused to obtain multiple pages of results.\n+ * </p>\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ * @param <Entity> The entity type being queried\n+ */\n+public interface PanacheQuery<Entity> {", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MjM5OA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467072398", "bodyText": "I really feel like Optional doesn't belong where we deal with Uni which have their own way to return empty results. I don't think we should add them.", "author": "FroMage", "createdAt": "2020-08-07T14:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MjcwNg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467082706", "bodyText": "Maybe ask some light from the munity expert, I'm OK if we don't provide them (I'll deprecate them in MongoDB then) as soon as we explain somewhere in the doc that we don't provide them because of Mutiny or someone may ask to add them", "author": "loicmathieu", "createdAt": "2020-08-07T14:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTU5OA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462205598", "bodyText": "Maybe encapsulate this inside a Uni.createFrom().deferred(() -> {} block to traverse the entities array asynchronously", "author": "loicmathieu", "createdAt": "2020-07-29T10:40:24Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MzA4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467073081", "bodyText": "I've changed this anyway.", "author": "FroMage", "createdAt": "2020-08-07T14:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMTA4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462211081", "bodyText": "You should use NotFoundException instead", "author": "loicmathieu", "createdAt": "2020-07-29T10:51:40Z", "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/MyOtherTestResource.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"other-entity\")\n+public class MyOtherTestResource {\n+\n+    @GET\n+    @Path(\"{id}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Uni<MyOtherEntity> get(@PathParam long id) {\n+        return MyOtherEntity.<MyOtherEntity> findById(id)\n+                .onItem().ifNull().failWith(() -> new WebApplicationException(Response.Status.NOT_FOUND));", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzI5OA==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462213298", "bodyText": "Are transaction mandatory for the test ?\nCan we block and make the assertions out of the reactive code?\nThis test is very hard to read with all the flatMap operations ...", "author": "loicmathieu", "createdAt": "2020-07-29T10:56:22Z", "path": "integration-tests/hibernate-reactive-panache/src/main/java/io/quarkus/it/panache/reactive/TestEndpoint.java", "diffHunk": "@@ -0,0 +1,1772 @@\n+package io.quarkus.it.panache.reactive;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+import javax.transaction.Transactional;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.xml.bind.annotation.XmlAttribute;\n+import javax.xml.bind.annotation.XmlElements;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import org.hibernate.engine.spi.SelfDirtinessTracker;\n+import org.hibernate.jpa.QueryHints;\n+import org.junit.jupiter.api.Assertions;\n+\n+import io.quarkus.hibernate.reactive.panache.Panache;\n+import io.quarkus.hibernate.reactive.panache.PanacheQuery;\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Various tests covering Panache functionality. All tests should work in both standard JVM and in native mode.\n+ */\n+@Path(\"test\")\n+public class TestEndpoint {\n+\n+    // fake unused injection point to force ArC to not remove this otherwise I can't mock it in the tests\n+    @Inject\n+    MockablePersonRepository mockablePersonRepository;\n+\n+    @GET\n+    @Path(\"model\")\n+    @Transactional\n+    public Uni<String> testModel() {\n+        return Panache.withTransaction(() -> Person.findAll().list()", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NDA5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467074096", "bodyText": "Yes, transaction is required for write operations. The code is indeed hard to read, but it helped writing it to spot issues in the API, so I'd rather keep it reactive.", "author": "FroMage", "createdAt": "2020-08-07T14:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462214872", "bodyText": "Are these methods used somewhere?\nBecause there is no exists operation at entity/repository level ...", "author": "loicmathieu", "createdAt": "2020-07-29T10:59:40Z", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }", "originalCommit": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NTQwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467075401", "bodyText": "Hum, how did we miss this, they're even missing in the ORM version\u2026", "author": "FroMage", "createdAt": "2020-08-07T14:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNjM5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467106393", "bodyText": "OK, so this is used by c4e84c5 by Spring data even though we don't expose it. Mystery solved. I could remove this, but I bet when sprint data reactive lands they will need this, so\u2026", "author": "FroMage", "createdAt": "2020-08-07T15:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NTk5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r475445999", "bodyText": "Ah, OK, maybe add a small comment now that we know why it exist ;)", "author": "loicmathieu", "createdAt": "2020-08-24T09:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg=="}], "type": "inlineReview"}, {"oid": "ceddafd3ade3f55aef65c58a49bac51f24d08443", "url": "https://github.com/quarkusio/quarkus/commit/ceddafd3ade3f55aef65c58a49bac51f24d08443", "message": "PanacheMock: made synchronized", "committedDate": "2020-08-07T15:11:52Z", "type": "forcePushed"}, {"oid": "912673b901fbd88dbd3693e48f32ed9bde546259", "url": "https://github.com/quarkusio/quarkus/commit/912673b901fbd88dbd3693e48f32ed9bde546259", "message": "PanacheMock: made synchronized", "committedDate": "2020-08-07T15:41:04Z", "type": "forcePushed"}, {"oid": "eb3d97df37f249b790e86b1670c2323c700ac23e", "url": "https://github.com/quarkusio/quarkus/commit/eb3d97df37f249b790e86b1670c2323c700ac23e", "message": "PanacheMock: made synchronized", "committedDate": "2020-08-13T13:57:10Z", "type": "forcePushed"}, {"oid": "86d5f706682b76591f72f4df20fd3fb727f96f5a", "url": "https://github.com/quarkusio/quarkus/commit/86d5f706682b76591f72f4df20fd3fb727f96f5a", "message": "PanacheMock: made synchronized", "committedDate": "2020-08-17T09:13:11Z", "type": "forcePushed"}, {"oid": "92cd43d1f5a6720acfdf1f03fe840f71d06790ed", "url": "https://github.com/quarkusio/quarkus/commit/92cd43d1f5a6720acfdf1f03fe840f71d06790ed", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass.", "committedDate": "2020-08-18T12:55:11Z", "type": "forcePushed"}, {"oid": "ac942666d342fc064fb9c877957de4b08a73ed2e", "url": "https://github.com/quarkusio/quarkus/commit/ac942666d342fc064fb9c877957de4b08a73ed2e", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass.", "committedDate": "2020-08-25T08:10:01Z", "type": "forcePushed"}, {"oid": "64c0ebb0435729dc77355004d7ceef7c1a67f6da", "url": "https://github.com/quarkusio/quarkus/commit/64c0ebb0435729dc77355004d7ceef7c1a67f6da", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass.", "committedDate": "2020-08-28T15:53:29Z", "type": "forcePushed"}, {"oid": "6c2c15b390751490539f8d015f3761d45c98d621", "url": "https://github.com/quarkusio/quarkus/commit/6c2c15b390751490539f8d015f3761d45c98d621", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass.", "committedDate": "2020-08-28T15:57:16Z", "type": "forcePushed"}, {"oid": "f3af0b36effdfc439ecba7b8fca91ed50c8fa116", "url": "https://github.com/quarkusio/quarkus/commit/f3af0b36effdfc439ecba7b8fca91ed50c8fa116", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes", "committedDate": "2020-08-31T10:35:21Z", "type": "forcePushed"}, {"oid": "9358e690449035e4aad0eebc24af8163da420687", "url": "https://github.com/quarkusio/quarkus/commit/9358e690449035e4aad0eebc24af8163da420687", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes", "committedDate": "2020-08-31T13:22:25Z", "type": "forcePushed"}, {"oid": "238a8b2f1a4aaaa5c2f1193dc760c90e12ac9c34", "url": "https://github.com/quarkusio/quarkus/commit/238a8b2f1a4aaaa5c2f1193dc760c90e12ac9c34", "message": "Make the Kotlin MongoDB with Panache tests pass", "committedDate": "2020-08-31T16:17:23Z", "type": "forcePushed"}, {"oid": "3ca542415b5b339ac02b6449c72078aaa1c9523a", "url": "https://github.com/quarkusio/quarkus/commit/3ca542415b5b339ac02b6449c72078aaa1c9523a", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names", "committedDate": "2020-09-01T08:13:45Z", "type": "forcePushed"}, {"oid": "a8a19fcafdeebf4f899a5413023abb35e4330ea5", "url": "https://github.com/quarkusio/quarkus/commit/a8a19fcafdeebf4f899a5413023abb35e4330ea5", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names", "committedDate": "2020-09-01T09:55:31Z", "type": "forcePushed"}, {"oid": "c805c9b1d6274646cf119275e105a5acdda63afe", "url": "https://github.com/quarkusio/quarkus/commit/c805c9b1d6274646cf119275e105a5acdda63afe", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names", "committedDate": "2020-09-02T08:22:38Z", "type": "forcePushed"}, {"oid": "1f6371d5523f93e9e1865d13b9d19e7a82a2a23b", "url": "https://github.com/quarkusio/quarkus/commit/1f6371d5523f93e9e1865d13b9d19e7a82a2a23b", "message": "Panache Reactive", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "5cec9f2fed05e73f473f789e03709d9a5b3d2ef2", "url": "https://github.com/quarkusio/quarkus/commit/5cec9f2fed05e73f473f789e03709d9a5b3d2ef2", "message": "HR: conditionally add the producers\n\nTo make sure we don't add producers that depend on something that ORM didn't add", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "6b0a48ab919dead81036ba1b6bf741b22c13da43", "url": "https://github.com/quarkusio/quarkus/commit/6b0a48ab919dead81036ba1b6bf741b22c13da43", "message": "junit5-mockito: support mocking Mutiny method default values", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "60221f52d57fd731c5ec5c636e563134509baec6", "url": "https://github.com/quarkusio/quarkus/commit/60221f52d57fd731c5ec5c636e563134509baec6", "message": "junit5-mockito: Do not mock the proxy classes but rather their superclass", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "f33134cd837a76d7ec55e82fcdd18103c14c49cd", "url": "https://github.com/quarkusio/quarkus/commit/f33134cd837a76d7ec55e82fcdd18103c14c49cd", "message": "PanacheMock: made synchronized", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "52fb6851e4b4a53385eb3b6cb6eea03cbde9b6e5", "url": "https://github.com/quarkusio/quarkus/commit/52fb6851e4b4a53385eb3b6cb6eea03cbde9b6e5", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass.", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "daafa61cc70224f7c2987583802ab96e69c29932", "url": "https://github.com/quarkusio/quarkus/commit/daafa61cc70224f7c2987583802ab96e69c29932", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "a3834ed76ffa4dc62883ee8fdd6d9b3ddfa200c1", "url": "https://github.com/quarkusio/quarkus/commit/a3834ed76ffa4dc62883ee8fdd6d9b3ddfa200c1", "message": "Make the Kotlin MongoDB with Panache tests pass", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "74d8b7161710321176695e5d2733dbe2b96403d1", "url": "https://github.com/quarkusio/quarkus/commit/74d8b7161710321176695e5d2733dbe2b96403d1", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names", "committedDate": "2020-09-15T14:52:20Z", "type": "commit"}, {"oid": "74d8b7161710321176695e5d2733dbe2b96403d1", "url": "https://github.com/quarkusio/quarkus/commit/74d8b7161710321176695e5d2733dbe2b96403d1", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names", "committedDate": "2020-09-15T14:52:20Z", "type": "forcePushed"}]}