{"pr_number": 8014, "pr_title": "Implement Vault Health Check integration", "pr_createdAt": "2020-03-20T10:56:56Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8014", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTU0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395805543", "bodyText": "it is too dangerous to include sensitive data into a toString(). it is way too easy for somebody to do a log.info(\"init result = \" + vaultInit). if we want to have a meaningful toString(), let's replace it with:\nreturn \"VaultInit{\"+keys.size()+\" keys)\"", "author": "vsevel", "createdAt": "2020-03-20T18:01:19Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultInit.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.vault.runtime.sys.seal;\n+\n+import java.util.List;\n+\n+public class VaultInit {\n+\n+    private List<String> keys;\n+    private List<String> keysBase64;\n+    private String rootToken;\n+\n+    public VaultInit(List<String> keys, List<String> keysBase64, String rootToken) {\n+        this.keys = keys;\n+        this.keysBase64 = keysBase64;\n+        this.rootToken = rootToken;\n+    }\n+\n+    public List<String> getKeys() {\n+        return keys;\n+    }\n+\n+    public List<String> getKeysBase64() {\n+        return keysBase64;\n+    }\n+\n+    public String getRootToken() {\n+        return rootToken;\n+    }\n+\n+    @Override\n+    public String toString() {", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjA1MA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395806050", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "author": "vsevel", "createdAt": "2020-03-20T18:02:15Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultInit.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.vault.runtime.sys.seal;", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjc2MA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395806760", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "author": "vsevel", "createdAt": "2020-03-20T18:03:29Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultSealStatus.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package io.quarkus.vault.runtime.sys.seal;", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzA3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395807073", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "author": "vsevel", "createdAt": "2020-03-20T18:04:02Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealth.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package io.quarkus.vault.runtime.sys.health;", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395807267", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "author": "vsevel", "createdAt": "2020-03-20T18:04:27Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMzM1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395823351", "bodyText": "I was thinking the same but, there are a lot of sys operations so I decided to split but we can put together for sure.", "author": "lordofthejars", "createdAt": "2020-03-20T18:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyOTA5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395829092", "bodyText": "not sure I got you. everything that is either a param or a return type in the system backend engine interface needs to be in a non runtime package. that's the rule I got from Guillaume when I initially pushed the extension. this applies to:\n\nVaultInit\nVaultHealth\nVaultHealthStatus\nVaultSealStatus\nalso I saw that you decided to not allow passing params to VaultHealth health(); whereas the vault api allows to pass a bunch of args: standbyok, perfstandbyok, activecode, standbycode, drsecondarycode, performancestandbycode, sealedcode\nis that on purpose?", "author": "vsevel", "createdAt": "2020-03-20T18:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMjM4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395832383", "bodyText": "Yes it is on purpose. As for me, it sounds strange that someone might want to change the status code definition and the status flags can be configured in application.properties. I was thinking more about simplicity/common cases and if someone requests it we can always extend it easily.", "author": "lordofthejars", "createdAt": "2020-03-20T18:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxNTM3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396015377", "bodyText": "As for me, it sounds strange that someone might want to change the status code definition\n\nsome time ago I had to integrate vault into k8s. the situation was different because I was implementing the liveness/readiness probes of vault itself (not a client of vault). but still it shows a situation where I had to change the status codes. basically I turned everything to 200 for liveness, otherwise vault would have been killed and restarted anytime its state would have bee something other than the ok state. which would have been counter productive because no restart would have helped. and for the readiness I did the same except for the sealedcode because when vault is sealed I did not want it to be part of the service. but I still wanted it to be reachable when it is not initialized. because if it is, all vaults are in the same situation, and making it not ready will just make it harder to access it.\nsee the probe definitions.\nyou have also to take into account that people sometime use the same endpoint for liveness and readiness, which is a very bad idea when integrating external systems into the app health checks (this could lead to unwanted app restarts, and cascading crash loop backoffs).\nare you expecting your healthchecks to be used for readiness only?", "author": "vsevel", "createdAt": "2020-03-21T18:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTU1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396019557", "bodyText": "I understand but as you said this is different, we are not integrating Vault directly into Kubernetes health check but we are providing health checks of the service so we are taking care of translating the codes of Vault into Kubernetes health checks by using the Health check spec, so I think that as a starting point is fine.\nBy default yes, if people wants to use it as liveness they can implement by themselves using the programmatic way.", "author": "lordofthejars", "createdAt": "2020-03-21T19:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxNDI3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395814273", "bodyText": "private VaultRuntimeConfig getRuntimeConfig() {\n        return getConfig(runtimeConfig, () -> loadRuntimeConfig(), \"runtime\");\n    }\n\n    private VaultBuildimeConfig getBuildtimeConfig() {\n        return getConfig(buildtimeConfig, () -> loadBuildtimeConfig(), \"buildtime\");\n    }\n\n    private <T> T getConfig(AtomicReference<T> ref, Supplier<T> supplier, String name) {\n        T config = ref.get();\n        if (config != null) {\n            return config;\n        } else {\n            config = supplier.get();\n            log.debug(\"loaded vault \" + name + \" config \" + config);\n            ref.set(config);\n            return ref.get();\n        }\n    }", "author": "vsevel", "createdAt": "2020-03-20T18:18:10Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "diffHunk": "@@ -148,16 +150,29 @@ private void fetchSecrets(List<String> paths, String prefix, Map<String, String>\n \n     private VaultManager getVaultManager() {\n \n+        VaultBuildTimeConfig buildTimeConfig = getBuildConfig();\n         VaultRuntimeConfig serverConfig = getConfig();\n \n         // init at most once\n         if (init.compareAndSet(false, true)) {\n-            VaultManager.init(serverConfig);\n+            VaultManager.init(buildTimeConfig, serverConfig);\n         }\n \n         return VaultManager.getInstance();\n     }\n \n+    private VaultBuildTimeConfig getBuildConfig() {", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxODI3OA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395818278", "bodyText": "why did you distinguished VaultHealthStatus from VaultHealth? we could have added the status code into the VaultHealthStatus. did you think that for performance reasons , in the context of healthchecks, it was important to do a head instead of a full get?", "author": "vsevel", "createdAt": "2020-03-20T18:25:54Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultSystemBackendManager.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package io.quarkus.vault.runtime;\n+\n+import io.quarkus.vault.VaultSystemBackendEngine;\n+import io.quarkus.vault.runtime.client.VaultClient;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultHealthResult;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultInitResponse;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultSealStatusResult;\n+import io.quarkus.vault.runtime.config.VaultBuildTimeConfig;\n+import io.quarkus.vault.runtime.sys.health.VaultHealth;\n+import io.quarkus.vault.runtime.sys.health.VaultHealthStatus;\n+import io.quarkus.vault.runtime.sys.seal.VaultInit;\n+import io.quarkus.vault.runtime.sys.seal.VaultSealStatus;\n+\n+public class VaultSystemBackendManager implements VaultSystemBackendEngine {\n+\n+    private VaultClient vaultClient;\n+    private VaultBuildTimeConfig buildTimeConfig;\n+\n+    public VaultSystemBackendManager(VaultBuildTimeConfig buildTimeConfig, VaultClient vaultClient) {\n+        this.vaultClient = vaultClient;\n+        this.buildTimeConfig = buildTimeConfig;\n+    }\n+\n+    @Override\n+    public VaultInit init(int secretShares, int secretThreshold) {\n+        final VaultInitResponse init = this.vaultClient.init(secretShares, secretThreshold);\n+\n+        final VaultInit vaultInit = new VaultInit(init.keys, init.keysBase64, init.rootToken);\n+        return vaultInit;\n+    }\n+\n+    @Override\n+    public VaultHealth health() {\n+\n+        boolean isStandByOk = false;\n+        if (this.buildTimeConfig.health.standbyok) {\n+            isStandByOk = true;\n+        }\n+\n+        boolean isPerfStandByOk = false;\n+        if (this.buildTimeConfig.health.perfstandbyok) {\n+            isPerfStandByOk = true;\n+        }\n+\n+        return this.health(isStandByOk, isPerfStandByOk);\n+    }\n+\n+    @Override\n+    public VaultHealthStatus healthStatus() {\n+        boolean isStandByOk = false;\n+        if (this.buildTimeConfig.health.standbyok) {\n+            isStandByOk = true;\n+        }\n+\n+        boolean isPerfStandByOk = false;\n+        if (this.buildTimeConfig.health.perfstandbyok) {\n+            isPerfStandByOk = true;\n+        }\n+\n+        return this.healthStatus(isStandByOk, isPerfStandByOk);\n+    }\n+\n+    @Override\n+    public VaultSealStatus sealStatus() {\n+        final VaultSealStatusResult vaultSealStatusResult = this.vaultClient.systemSealStatus();\n+\n+        final VaultSealStatus vaultSealStatus = new VaultSealStatus();\n+        vaultSealStatus.setClusterId(vaultSealStatusResult.clusterId);\n+        vaultSealStatus.setClusterName(vaultSealStatusResult.clusterName);\n+        vaultSealStatus.setInitialized(vaultSealStatusResult.initialized);\n+        vaultSealStatus.setMigration(vaultSealStatusResult.migration);\n+        vaultSealStatus.setN(vaultSealStatusResult.n);\n+        vaultSealStatus.setNonce(vaultSealStatusResult.nonce);\n+        vaultSealStatus.setProgress(vaultSealStatusResult.progress);\n+        vaultSealStatus.setRecoverySeal(vaultSealStatusResult.recoverySeal);\n+        vaultSealStatus.setSealed(vaultSealStatusResult.sealed);\n+        vaultSealStatus.setT(vaultSealStatusResult.t);\n+        vaultSealStatus.setType(vaultSealStatusResult.type);\n+        vaultSealStatus.setVersion(vaultSealStatusResult.version);\n+\n+        return vaultSealStatus;\n+    }\n+\n+    private VaultHealthStatus healthStatus(boolean isStandByOk, boolean isPerfStandByOk) {", "originalCommit": "e2a983e6a146694d8d2dddec1884130729929f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDI3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395824272", "bodyText": "Well two reasons, the first is that as you said head is more performant and in case of readiness checks it is important to be as performant as possible and the second is that Vault offers both options in the API. For this reason, I implemented both, so if someone wants to use programmatically is free to use it but in case of health checks use the more performant one.", "author": "lordofthejars", "createdAt": "2020-03-20T18:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxODI3OA=="}], "type": "inlineReview"}, {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506", "url": "https://github.com/quarkusio/quarkus/commit/0dcfa9cc8afd0399bdd421495634cc8153fee506", "message": "fix(#7007): Implements Vault Health Check integration.", "committedDate": "2020-03-21T19:30:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTYwNg==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396029606", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (isStandByOk) {\n          \n          \n            \n                        queryParams.put(\"standbyok\", \"true\");\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (isPerfStandByOk) {\n          \n          \n            \n                        queryParams.put(\"perfstandbyok\", \"true\");\n          \n          \n            \n                    }\n          \n          \n            \n                    queryParams.put(\"standbyok\", String.valueOf(isStandByOk));\n          \n          \n            \n                    queryParams.put(\"perfstandbyok\", String.valueOf(isPerfStandByOk));", "author": "machi1990", "createdAt": "2020-03-21T21:12:11Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "diffHunk": "@@ -312,4 +385,17 @@ private URL getUrl(String path) {\n         }\n     }\n \n+    private Map<String, String> getHealthParams(boolean isStandByOk, boolean isPerfStandByOk) {\n+        Map<String, String> queryParams = new HashMap<>();\n+        if (isStandByOk) {\n+            queryParams.put(\"standbyok\", \"true\");\n+        }\n+\n+        if (isPerfStandByOk) {\n+            queryParams.put(\"perfstandbyok\", \"true\");\n+        }", "originalCommit": "0dcfa9cc8afd0399bdd421495634cc8153fee506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTk3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396029972", "bodyText": "I have not done in this way to not create objects + parse things when it is false. Also notice that this map is iterated in another piece of code, so a readiness check is called several times + usually user will leave these with defaults (false) I thought that it will be a minor improvement (that's true) but at least an improvement.", "author": "lordofthejars", "createdAt": "2020-03-21T21:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAzMDI0MA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396030240", "bodyText": "It was a minor nitpick. We can leave the code as is.", "author": "machi1990", "createdAt": "2020-03-21T21:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTgxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396029819", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            getVaultProperty(\"health.enable\", \"false\"));\n          \n          \n            \n                            getVaultProperty(\"health.enabled\", \"false\"));", "author": "machi1990", "createdAt": "2020-03-21T21:15:08Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "diffHunk": "@@ -148,30 +151,55 @@ private void fetchSecrets(List<String> paths, String prefix, Map<String, String>\n \n     private VaultManager getVaultManager() {\n \n-        VaultRuntimeConfig serverConfig = getConfig();\n+        VaultBuildTimeConfig buildTimeConfig = getBuildtimeConfig();\n+        VaultRuntimeConfig serverConfig = getRuntimeConfig();\n \n         // init at most once\n         if (init.compareAndSet(false, true)) {\n-            VaultManager.init(serverConfig);\n+            VaultManager.init(buildTimeConfig, serverConfig);\n         }\n \n         return VaultManager.getInstance();\n     }\n \n-    private VaultRuntimeConfig getConfig() {\n-        VaultRuntimeConfig serverConfig = this.serverConfig.get();\n-        if (serverConfig != null) {\n-            return serverConfig;\n+    private VaultRuntimeConfig getRuntimeConfig() {\n+        return getConfig(this.serverConfig, () -> loadRuntimeConfig(), \"runtime\");\n+    }\n+\n+    private VaultBuildTimeConfig getBuildtimeConfig() {\n+        return getConfig(this.buildServerConfig, () -> loadBuildtimeConfig(), \"buildtime\");\n+    }\n+\n+    private <T> T getConfig(AtomicReference<T> ref, Supplier<T> supplier, String name) {\n+        T config = ref.get();\n+        if (config != null) {\n+            return config;\n         } else {\n-            serverConfig = loadConfig();\n-            log.debug(\"loaded vault server config \" + serverConfig);\n-            this.serverConfig.set(serverConfig);\n-            return this.serverConfig.get();\n+            config = supplier.get();\n+            log.debug(\"loaded vault \" + name + \" config \" + config);\n+            ref.set(config);\n+            return ref.get();\n         }\n     }\n \n     // need to recode config loading since we are at the config source level\n-    private VaultRuntimeConfig loadConfig() {\n+    private VaultBuildTimeConfig loadBuildtimeConfig() {\n+        VaultBuildTimeConfig vaultBuildTimeConfig = new VaultBuildTimeConfig();\n+        vaultBuildTimeConfig.health = new HealthConfig();\n+\n+        vaultBuildTimeConfig.health.enabled = parseBoolean(\n+                getVaultProperty(\"health.enable\", \"false\"));", "originalCommit": "0dcfa9cc8afd0399bdd421495634cc8153fee506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2ODkzMA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396068930", "bodyText": "Good catch.", "author": "lordofthejars", "createdAt": "2020-03-22T08:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MTY4MA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397071680", "bodyText": "@lordofthejars Given what you've discussed with Vincent, IMHO the java docs have to be updated to clarify the difference between health and healthStatus methods and VaultHealth and VaultHealthStatus need to be have their names exchanged as it is quite confusing IMHO.\nRight now healthStatus returns VaultHealthStatus which is filled with the real information, while health returns VaultHealth which only has all that real information available in VaultHealthStatus encapsulated  in a status code :-).\nIrrespectively of the way the lower level Vault API represents it all, it would be clearer IMHO if we had:\n// Returns Vault health status code only by using HTTP HEAD requests.\n// It is faster than a health() method which uses HTTP GET  to return a complete VaultHealth state\nVaultHealthStatus healthStatus(); \n\n// Returns a complete VaultHealth state.\nVaultHealth health(); \n\nor may be this would be better,\n// Returns Vault health status code only by using HTTP HEAD requests.\n// It is faster than a healthStatus() method which uses HTTP GET  to return a complete VaultHealthStaus state\nVaultHealthStatusCode healthStatusCode(); \n\n// Returns a complete VaultHealthStatus state.\nVaultHealthStatus healthStatus(); \n\nThanks\nCC @vsevel", "author": "sberyozkin", "createdAt": "2020-03-24T11:10:00Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);\n+\n+    /**", "originalCommit": "6c32853f4f967e10ae8400098eb54b2aa07bdb96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NTk4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397085983", "bodyText": "I'll update the JavaDoc.", "author": "lordofthejars", "createdAt": "2020-03-24T11:35:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397083063", "bodyText": "We don't have init methods exposed anywhere else in the public Vault interfaces, this is an admin operation which should not be visible to the JAX-RS service code having VaultSystemBackendEngine injected", "author": "sberyozkin", "createdAt": "2020-03-24T11:30:28Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);", "originalCommit": "6c32853f4f967e10ae8400098eb54b2aa07bdb96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NTg2OA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397085868", "bodyText": "We agreed with @vsevel to move the sys operations here.", "author": "lordofthejars", "createdAt": "2020-03-24T11:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2MTQzMw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397261433", "bodyText": "@lordofthejars OK, @vsevel Hi Vincent, do you feel it would be useful to have some users doing the Vault Initialization in scope of the current call ?", "author": "sberyozkin", "createdAt": "2020-03-24T15:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3NjE1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397276153", "bodyText": "@vsevel I'm asking because we've tried hard to have all Vault interfaces very user centric in a sense that each of those operations can do something meaningful in scope of a current HTTP request, and init does not fit. However if you do feel it is worth it then I'll be good with it, thanks", "author": "sberyozkin", "createdAt": "2020-03-24T16:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ0Nzc0MA==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397447740", "bodyText": "when I talked about moving some methods,I had specifically the sys/health in mind, but did not make it clear. I know @sberyozkin we had long discussion about this :) I think there is value in having those operations too on the SystemBackendEngine. and sometimes it confuses people to not find operations that we categorize as admin (although it is a valid criteria when priorizing what we want to work on first).\nto make it short, now that @lordofthejars has moved all of them, I would not move them back.", "author": "vsevel", "createdAt": "2020-03-24T20:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NDI3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397264271", "bodyText": "@lordofthejars So do you think that VaultHealth is more appropriate than VaultHealthStatusCode given that is only has a status code ? Wouldn;t VaultHealthStatusCode be more appropriate ?", "author": "sberyozkin", "createdAt": "2020-03-24T15:55:24Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);\n+\n+    /**\n+     * Check the health status of Vault.\n+     * Returns Vault health status code only by using HTTP HEAD requests.\n+     * It is faster than calling {@link #healthStatus() healthStatus()} method which uses HTTP GET to return a complete\n+     * VaultHealthStatus state.\n+     *\n+     * @return Vault Health Status.\n+     */\n+    VaultHealth health();", "originalCommit": "0c321504dbec989e08b6c4fc7b5f68e1714b7a53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8903455e76eea832a3a0d6af61412646592b3700", "url": "https://github.com/quarkusio/quarkus/commit/8903455e76eea832a3a0d6af61412646592b3700", "message": "fix(#7007): Implements Vault Health Check integration.", "committedDate": "2020-03-25T08:06:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTk5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398045995", "bodyText": "This is not API, it should be in the vault.runtime.health package.", "author": "gsmet", "createdAt": "2020-03-25T17:40:05Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/health/VaultHealthCheck.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package io.quarkus.vault.health;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.vault.VaultSystemBackendEngine;\n+import io.quarkus.vault.sys.VaultHealth;\n+\n+@Readiness\n+@ApplicationScoped\n+public class VaultHealthCheck implements HealthCheck {", "originalCommit": "8903455e76eea832a3a0d6af61412646592b3700", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f791b56ea6a02045aac23904bf753d50aeaac00e", "url": "https://github.com/quarkusio/quarkus/commit/f791b56ea6a02045aac23904bf753d50aeaac00e", "message": "fix(#7007): Implements Vault Health Check integration.", "committedDate": "2020-03-26T12:59:12Z", "type": "commit"}, {"oid": "f791b56ea6a02045aac23904bf753d50aeaac00e", "url": "https://github.com/quarkusio/quarkus/commit/f791b56ea6a02045aac23904bf753d50aeaac00e", "message": "fix(#7007): Implements Vault Health Check integration.", "committedDate": "2020-03-26T12:59:12Z", "type": "forcePushed"}]}