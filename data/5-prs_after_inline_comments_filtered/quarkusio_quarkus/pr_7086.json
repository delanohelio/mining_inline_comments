{"pr_number": 7086, "pr_title": "Add a composite OidcAuthenticationMechanism", "pr_createdAt": "2020-02-07T22:25:01Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7086", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzODY2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r376638667", "bodyText": "@pedroigor, @stuartwdouglas  Hi, this is a work in progress, I have one more test in the works which combines the service and web-app tenants. Happy enough with how it is working out, the only problem is resolving the configContext here deadlocks in oidc-tenancy tests :-) in the sync lock DefaultTenantConfigResolver.\nPretty sure it can be reproduced if for example BearerAuthenticationMechanism.authenticate on the master  would try to resolve early in its authenticate. Nearly there though...Thanks", "author": "sberyozkin", "createdAt": "2020-02-07T22:32:09Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcAuthenticationMechanism.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.quarkus.oidc.runtime;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import io.quarkus.security.identity.IdentityProviderManager;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.vertx.http.runtime.security.ChallengeData;\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+public class OidcAuthenticationMechanism implements HttpAuthenticationMechanism {\n+\n+    @Inject\n+    DefaultTenantConfigResolver tenantConfigResolver;\n+    private BearerAuthenticationMechanism bearerAuth = new BearerAuthenticationMechanism();\n+    private CodeAuthenticationMechanism codeAuth = new CodeAuthenticationMechanism();\n+\n+    @Override\n+    public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n+            IdentityProviderManager identityProviderManager) {\n+        TenantConfigContext configContext = tenantConfigResolver.resolve(context);", "originalCommit": "b30b3080b424e250a1e7013b5c606c4454605a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcyNjc2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r376726767", "bodyText": "I've been wondering today how I'm going to resolve this deadlock  and realized what is really needed here is a resolution without attempting to create OAuth2Auth, at this point only a check what kind of application it is is needed. DefaultTenantConfigResolver.resolve needs a boolean create parameter, same one which is used by isBlocking check internally :-)", "author": "sberyozkin", "createdAt": "2020-02-08T18:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzODY2Nw=="}], "type": "inlineReview"}, {"oid": "13598a8107fdbee2e548aa970ae2cca3cd1c6561", "url": "https://github.com/quarkusio/quarkus/commit/13598a8107fdbee2e548aa970ae2cca3cd1c6561", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-09T19:24:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTk4OA==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377031988", "bodyText": "It would be nice if we could create the mechanisms only when they are necessary. Also, I think most deployments will just rely on a single mechanism as they will not be using multi-tenancy at all.\nSo, I'm wondering if we could:\n\nDecide for a specific mechanism at build time depending on the existence of tenants\nMaybe too much, but if in a multi-tenancy deployment, create the mechanism only if necessary depending on the tenant type", "author": "pedroigor", "createdAt": "2020-02-10T12:26:02Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcAuthenticationMechanism.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.quarkus.oidc.runtime;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import io.quarkus.security.identity.IdentityProviderManager;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.vertx.http.runtime.security.ChallengeData;\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+public class OidcAuthenticationMechanism implements HttpAuthenticationMechanism {\n+\n+    @Inject\n+    DefaultTenantConfigResolver resolver;\n+    private BearerAuthenticationMechanism bearerAuth = new BearerAuthenticationMechanism();", "originalCommit": "13598a8107fdbee2e548aa970ae2cca3cd1c6561", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0NDUzMA==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377044530", "bodyText": "@pedroigor I think it would complicate things unnecessary for no obvious benefits. And with TenantConfigResolver it is not possible anyway as it offers the dynamic option.\nThis PR offers a very simple fix for #6997 - please have a look at it, right now the multi-tenancy is not properly supported for web-app anyway. As a direct consequence of this fix we will offer an option to the sophisticated users go beyond the frontend-only or backend-only services which is already being thought after in one external project, please see  #6997.\n\nI think most deployments will just rely on a single mechanism as they will not be using multi-tenancy at all\n\nThose deployments will only then have a cost of an extra single instance (Bearer or CodeAuth mechanism) - which is a really small issue compared to the enabling hybrid web-apps. Besides as I said it is typical IMHO for many modern web-apps to support the different types of clients.", "author": "sberyozkin", "createdAt": "2020-02-10T12:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0ODg3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377048875", "bodyText": "OK. So only tests are missing. Otherwise, LGTM. Thanks.", "author": "pedroigor", "createdAt": "2020-02-10T13:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1MDAzNA==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377050034", "bodyText": "@pedroigor sorry may be I've just totally missed some of your points, which would not be surprising :-). I mean, we can create the mechanisms dynamically, with the volatile storage, so for a single type applications only one will ever be created, may be few temp instances depending on how heavy the load is...", "author": "sberyozkin", "createdAt": "2020-02-10T13:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1NTI2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377055266", "bodyText": "@pedroigor By the way, you are right of course that most of the applications will not go the multi-tenancy route - but our OIDC multi-tenancy feature will be a real differentiator (thanks for wiring it so well :-) ) when people will need something more involved and it was a feature in demand by a number of users (who watched the original issue)", "author": "sberyozkin", "createdAt": "2020-02-10T13:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2NTAyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377065021", "bodyText": "@pedroigor Also, apologies for being defensive here, I'm not concerned about my PR code of course:-) but I'm very liking the idea of a flexible per-tenant specific OIDC configuration and believe it will be very good for Quarkus in the real world :-). This PR does not even introduce it (it was already there waiting for its moment :-) ), it simply fixes the web-app multi-tenancy issue :-)\n\nOK. So only tests are missing. Otherwise, LGTM. Thanks.\n\nThanks, right, working on an extra test now...", "author": "sberyozkin", "createdAt": "2020-02-10T13:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTk4OA=="}], "type": "inlineReview"}, {"oid": "4099e7dac2fc5167e83cb8f6dc50f5da8486f329", "url": "https://github.com/quarkusio/quarkus/commit/4099e7dac2fc5167e83cb8f6dc50f5da8486f329", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-10T21:26:21Z", "type": "forcePushed"}, {"oid": "3ea8c62478a4950d9faf37cf000557992ab6c814", "url": "https://github.com/quarkusio/quarkus/commit/3ea8c62478a4950d9faf37cf000557992ab6c814", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-11T12:52:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMDc3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377910777", "bodyText": "Why are you doing this lazy creation? These objects don't have any state, there is no measurable benefit to creating them lazily, but in return you add a volatile reads to every request which is more expensive.", "author": "stuartwdouglas", "createdAt": "2020-02-11T21:30:40Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcAuthenticationMechanism.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package io.quarkus.oidc.runtime;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import io.quarkus.security.identity.IdentityProviderManager;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.vertx.http.runtime.security.ChallengeData;\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+public class OidcAuthenticationMechanism implements HttpAuthenticationMechanism {\n+\n+    @Inject\n+    DefaultTenantConfigResolver resolver;\n+    private volatile BearerAuthenticationMechanism bearerAuth;", "originalCommit": "3ea8c62478a4950d9faf37cf000557992ab6c814", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0NzgyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377947829", "bodyText": "Pedro was concerned about the eager creation in the constructor, so I decided to give it a try, though was not entirely sure. I'll just revert. Please also see my response to your next comment. By the way Pedro suggested to have it done at the build time but it is not possible to do it there with the dynamic multi-tenancy :-).", "author": "sberyozkin", "createdAt": "2020-02-11T22:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMDc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1MzY3MA==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377953670", "bodyText": "If you are really concerned about the object creation all that logic could just be moved to static methods as there is no state in the objects, and they no longer have to implement an interface.", "author": "stuartwdouglas", "createdAt": "2020-02-11T23:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMDc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2ODI5MA==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r378168290", "bodyText": "@stuartwdouglas thanks, not sure I understand :-) I guess both objects can be just created as before. There is only one extra single object in the mainstream single application-type case which as you said has no state and it is not possible to avoid this extra object's class be added to the native image, so it is a very tiny cost indeed.\nBut can you explain please what you meant about moving the logic to the static methods, what difference would it make compared to the current lazy initialization done in the instance ? volatile class fields would still be read...But I guess it is not what you had in mind :-)", "author": "sberyozkin", "createdAt": "2020-02-12T10:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMDc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMTQwNg==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377911406", "bodyText": "Not that it matters, but this can actually create multiple instances here if multiple threads hit it at the same time.", "author": "stuartwdouglas", "createdAt": "2020-02-11T21:31:52Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcAuthenticationMechanism.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package io.quarkus.oidc.runtime;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import io.quarkus.security.identity.IdentityProviderManager;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.vertx.http.runtime.security.ChallengeData;\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+public class OidcAuthenticationMechanism implements HttpAuthenticationMechanism {\n+\n+    @Inject\n+    DefaultTenantConfigResolver resolver;\n+    private volatile BearerAuthenticationMechanism bearerAuth;\n+    private volatile CodeAuthenticationMechanism codeAuth;\n+\n+    @Override\n+    public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n+            IdentityProviderManager identityProviderManager) {\n+        return isWebApp(context) ? getCodeAuth().authenticate(context, identityProviderManager, resolver)\n+                : getBearerAuth().authenticate(context, identityProviderManager, resolver);\n+    }\n+\n+    @Override\n+    public CompletionStage<ChallengeData> getChallenge(RoutingContext context) {\n+        return isWebApp(context) ? getCodeAuth().getChallenge(context, resolver)\n+                : getBearerAuth().getChallenge(context, resolver);\n+    }\n+\n+    private CodeAuthenticationMechanism getCodeAuth() {\n+        if (codeAuth == null) {", "originalCommit": "3ea8c62478a4950d9faf37cf000557992ab6c814", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0NjM5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377946397", "bodyText": "Yes, this is what I was typing about above but I decided to give it a try to make sure for a single application-type no code (or bearer) flow is created given Pedro's concern.\nI'm going to return to the original code where I was just creating these 2 instances.\nWith the dynamic TenantConfigResolver one can never be 100% sure there will only be one application-type", "author": "sberyozkin", "createdAt": "2020-02-11T22:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMjc0MA==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377912740", "bodyText": "It looks like resolve is now called lots of times per request. I think it might make sense to add some code to DefaultTenantResolver that stores the result in the routing context so subsequent invocations are effectively cached.", "author": "stuartwdouglas", "createdAt": "2020-02-11T21:34:36Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -124,7 +120,9 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n     }\n \n     private CompletionStage<SecurityIdentity> performCodeFlow(IdentityProviderManager identityProviderManager,\n-            RoutingContext context) {\n+            RoutingContext context, DefaultTenantConfigResolver resolver) {\n+        TenantConfigContext configContext = resolver.resolve(context, true);", "originalCommit": "3ea8c62478a4950d9faf37cf000557992ab6c814", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0NDgyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377944821", "bodyText": "@stuartwdouglas It is only a visual impression :-). This PR only introduces one extra resolver call in OidcAuthenticationMechanism to figure which way to go. It is called a few times in CodeAuthenticationMechanism right on the master requesting a complete resolution. This PR optimizes it a bit, asking for OidcTenantConfig only when no OAuth2Auth is needed.\nAnd @pedroigor has already updated DefaultTenantConfigResolver to support caching TenantConfigContext when needed. So it should be fine", "author": "sberyozkin", "createdAt": "2020-02-11T22:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMjc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxMzU1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7086#discussion_r377913559", "bodyText": "I know this is not part of the PR, but this code should be in a PostCostruct method", "author": "stuartwdouglas", "createdAt": "2020-02-11T21:36:11Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/DefaultTenantConfigResolver.java", "diffHunk": "@@ -26,12 +26,21 @@\n     private volatile TenantConfigContext defaultTenant;\n     private volatile Function<OidcTenantConfig, TenantConfigContext> tenantConfigContextFactory;\n \n-    TenantConfigContext resolve(RoutingContext context) {\n+    /**\n+     * Resolve {@linkplain TenantConfigContext} which contains the tenant configuration and\n+     * the active OIDC connection instance which may be null.\n+     * \n+     * @param context the current request context\n+     * @param create if true then the OIDC connection must be available or established\n+     *        for the resolution to be successful\n+     * @return\n+     */\n+    TenantConfigContext resolve(RoutingContext context, boolean create) {\n         if (tenantConfigResolver.isAmbiguous()) {\n             throw new IllegalStateException(\"Multiple \" + TenantConfigResolver.class + \" beans registered\");", "originalCommit": "3ea8c62478a4950d9faf37cf000557992ab6c814", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "467df4253f8f992b8227ca132346d3f626aab369", "url": "https://github.com/quarkusio/quarkus/commit/467df4253f8f992b8227ca132346d3f626aab369", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-13T18:47:31Z", "type": "forcePushed"}, {"oid": "ee030f69afc6bb2cb1eaa061274fa01e7bc7d438", "url": "https://github.com/quarkusio/quarkus/commit/ee030f69afc6bb2cb1eaa061274fa01e7bc7d438", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-13T18:48:27Z", "type": "forcePushed"}, {"oid": "16cfb50d7b3b3dbd75beddc0fce1017d9c9e9e26", "url": "https://github.com/quarkusio/quarkus/commit/16cfb50d7b3b3dbd75beddc0fce1017d9c9e9e26", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-14T10:19:03Z", "type": "commit"}, {"oid": "16cfb50d7b3b3dbd75beddc0fce1017d9c9e9e26", "url": "https://github.com/quarkusio/quarkus/commit/16cfb50d7b3b3dbd75beddc0fce1017d9c9e9e26", "message": "Add a composite OidcAuthenticationMechanism", "committedDate": "2020-02-14T10:19:03Z", "type": "forcePushed"}]}