{"pr_number": 7049, "pr_title": "OptaPlanner extension", "pr_createdAt": "2020-02-06T21:25:11Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7049", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r376091737", "bodyText": "We talked about removing this fail-fast in the previous PR, to follow hibernate-extension's approach, so I 'll do that in a next PR if that's ok, because of the open debate below.", "author": "ge0ffrey", "createdAt": "2020-02-06T21:28:29Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");", "originalCommit": "f4a6f97d8d9292fd7c73a187c9b70eb31befc661", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NTg3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r376285877", "bodyText": "Open question, what is the behavior we want:\nA) When there is no @PlanningSolution class, fail fast (current implementation, differs from hibernate extension)\nB) When there is no @PlanningSolution class, only fail fast if there are any quarkus.optaplanner.* application.properties, otherwise do nothing\nC) When there is no @PlanningSolution class, even if there are any quarkus.optaplanner.* application.properties, always do nothing quietly\nDoes de hibernate extension do B) or C)?", "author": "ge0ffrey", "createdAt": "2020-02-07T09:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NjYxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r376286619", "bodyText": "I presume A) is a PITA when doing demo's where you grab something from code.quarkus.io and it doesn't \"just run\"?", "author": "ge0ffrey", "createdAt": "2020-02-07T09:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTA5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379311095", "bodyText": "Yeah. I would avoid A). I would do C with a warning instead of staying quiet if some configuration properties are defined.", "author": "gsmet", "createdAt": "2020-02-14T08:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw=="}], "type": "inlineReview"}, {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e", "url": "https://github.com/quarkusio/quarkus/commit/987bdf58bbe525a9891bbd1f204e1ba556923a2e", "message": "OptaPlanner extension\n\nDrop the capability for now (thanks Georgios)\n\nUse RecorderContext.proxyClass()\n\nFix type\n\nbom already includes optaplanner-core\n\nmvn optimizes imports apparently\n\nShorter description\n\nRead XML file (during the build of course!)\n\nSync test coverage of Quarkus extension tests with Spring Boot Starter ones\n\nRevert optaplanner version (no snapshot)\n\nPrefix Kogito to extension name\n\nRevert prefix Kogito to extension name\n\nUse thread context classloader instead\n\nFix unit tests + upgrade to optaplanner 7.32\n\nIntegration test for OptaPlanner extension + jackson JSON support for score\n\nConfiguration property solverConfigXml for OptaPlanner\n\nAdd termination support for application.properties + fix never-terminating integration test\n\nMove inner classes up\n\nfix jackson integration + itest: don't wait 5 seconds, terminate on reaching feasibility + add Timeout to test just in case\n\ncode style\n\nAdd illegal scan annotated classes test\n\nAdd solver properties and termination properties tests\n\nimprove test to verify exception during register extension\n\nThe setExceptionException doesn't actually do anything because there is an assertException (see quarkus issue 7000)\n\nInject SolverManager and ScoreManager\n\nInject SolverManager and ScoreManager\n\nRun optaplanner extension natively\n\nClean up dependencies\n\nFix rebase issues\n\nAdd optaplanner in stages.yml", "committedDate": "2020-02-07T16:15:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378238717", "bodyText": "Just out of curiosity, what CL will be used at runtime as a result of this?", "author": "geoand", "createdAt": "2020-02-12T13:08:43Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "originalCommit": "987bdf58bbe525a9891bbd1f204e1ba556923a2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1OTk1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378259951", "bodyText": "Most of the time, it's not used, except if a scoreDRL is active.\nIf it's null in that case, ScoreDirectorFactoryConfig does this at runtime, during SolverFactory.buildSolver():\nClassLoader actualClassLoader = (classLoader != null) ? classLoader : getClass().getClassLoader();\n\nOnce we start doing more work during the static init, after we internalize the SolverConfig in the SolverFactory (currently impossible due to deprecated methods that will dissappear in 8.0), I 'll have to come back to this, as that code might become a problem then.\nGood question indeed. :)", "author": "ge0ffrey", "createdAt": "2020-02-12T13:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2MjY0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378262641", "bodyText": "What am I sort of worried about is the dev-mode. There are certain situations where getClass().getClassLoader() might not give you what you expect.\nPerhaps also adding QuarkusDevModeTest is a good idea to make sure things work properly?", "author": "geoand", "createdAt": "2020-02-12T13:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4NTUwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379285505", "bodyText": "I 've been trying to add in QuarkusDevModeTest, but I reluctant to add a test that doesn't work in IntelliJ (it hurts productivity). In IntelliJ I get the \"Undeclared build item class io.quarkus.deployment.builditem.ApplicationClassNameBuildItem\" exception, but on the command line, I don't.", "author": "ge0ffrey", "createdAt": "2020-02-14T07:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MjA3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379292079", "bodyText": "IntelliJ can mess up the classpath when running tests inside the Quarkus repo. I don't think it's something we need to worry about", "author": "geoand", "createdAt": "2020-02-14T07:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMDA0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379310047", "bodyText": "Would it be possible to change that logic to use the TCCL if null?", "author": "gsmet", "createdAt": "2020-02-14T08:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0ODkwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379348904", "bodyText": "The dev mode test should prove that things are OK with this change.\nTo be 100% Quarkus compliant, upstream here should provide a flag to use the TCCL (of the time of execution) when the classloader is null, but I don't think we need it now", "author": "geoand", "createdAt": "2020-02-14T10:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4OTEyNw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379389127", "bodyText": "Using ThreadContextClassLoader is what it does by default if we don't set it to null.\nWhen I remove the solverConfig.setClassLoader(null); line, I get\nCaused by: java.lang.RuntimeException: Unable to serialize objects of type class io.quarkus.bootstrap.classloading.QuarkusClassLoader to bytecode as it has no default constructor\n        at io.quarkus.deployment.recording.BytecodeRecorderImpl$53.createValue(BytecodeRecorderImpl.java:1273)", "author": "ge0ffrey", "createdAt": "2020-02-14T11:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0NDA0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378244043", "bodyText": "Maybe add a capacity, it looks like 5 is the max this can ever get, right?", "author": "geoand", "createdAt": "2020-02-12T13:19:22Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();", "originalCommit": "987bdf58bbe525a9891bbd1f204e1ba556923a2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5NTYwOA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378695608", "bodyText": "Fixed with new commit on this fork.", "author": "ge0ffrey", "createdAt": "2020-02-13T07:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0NDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MDQ3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378250472", "bodyText": "IIRC, this isn't picked up automatically because it's part of the module and therefore if the user doesn't have Jackson you don't register the bean.\nPerhaps this warrants a comment on this class as to how things have been done and why because I am sure we will forget about it in the future", "author": "geoand", "createdAt": "2020-02-12T13:31:20Z", "path": "extensions/optaplanner/runtime/src/main/java/io/quarkus/optaplanner/OptaPlannerObjectMapperCustomizer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package io.quarkus.optaplanner;\n+\n+import javax.inject.Singleton;\n+\n+import org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.quarkus.jackson.ObjectMapperCustomizer;\n+\n+@Singleton\n+public class OptaPlannerObjectMapperCustomizer implements ObjectMapperCustomizer {", "originalCommit": "987bdf58bbe525a9891bbd1f204e1ba556923a2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNDY5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378314699", "bodyText": "Adding this javadoc\n/**\n * Only registered if the Jackson capability is active.\n * OptaPlanner doesn't use Jackson, but it does have optional Jackson support for {@link Score}, etc.\n */", "author": "ge0ffrey", "createdAt": "2020-02-12T15:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MDQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5NTU1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378695552", "bodyText": "Fixed with new commit on this fork.", "author": "ge0ffrey", "createdAt": "2020-02-13T07:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MDQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTkyNw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379311927", "bodyText": "What annoys me a bit here is that if you use Jackson for your REST services and OptaPlanner without Jackson persistence, you end up with this exception. Or did I misunderstand?", "author": "gsmet", "createdAt": "2020-02-14T08:53:02Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>(5);\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848, fixed in optaplanner 7.33.0.Final\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        AnnotationTarget solutionTarget = annotationInstances.iterator().next().target();\n+        if (solutionTarget.kind() != AnnotationTarget.Kind.CLASS) {\n+            throw new IllegalStateException(\"A target (\" + solutionTarget\n+                    + \") with a @\" + PlanningSolution.class.getSimpleName() + \" must be a class.\");\n+        }\n+\n+        return recorderContext.classProxy(solutionTarget.asClass().name().toString());\n+    }\n+\n+    private List<Class<?>> findEntityClassList(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_ENTITY);\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningEntity.class.getSimpleName() + \" annotation.\");\n+        }\n+        List<AnnotationTarget> targetList = annotationInstances.stream()\n+                .map(AnnotationInstance::target)\n+                .collect(Collectors.toList());\n+        if (targetList.stream().anyMatch(target -> target.kind() != AnnotationTarget.Kind.CLASS)) {\n+            throw new IllegalStateException(\"All targets (\" + targetList\n+                    + \") with a @\" + PlanningEntity.class.getSimpleName() + \" must be a class.\");\n+        }\n+        return targetList.stream()\n+                .map(target -> recorderContext.classProxy(target.asClass().name().toString()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Class<? extends ConstraintProvider> findConstraintProviderClass(RecorderContext recorderContext,\n+            IndexView indexView) {\n+        Collection<ClassInfo> classInfos = indexView.getAllKnownImplementors(\n+                DotName.createSimple(ConstraintProvider.class.getName()));\n+        if (classInfos.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        if (classInfos.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        String constraintProviderClassName = classInfos.iterator().next().name().toString();\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            // Don't use recorderContext.classProxy(constraintProviderClassName)\n+            // because ReflectiveClassBuildItem cannot cope with a class proxy\n+            return (Class<? extends ConstraintProvider>) classLoader.loadClass(constraintProviderClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(\"The constraintProviderClass (\" + constraintProviderClassName\n+                    + \") cannot be created during deployment.\", e);\n+        }\n+    }\n+\n+    private void applyTerminationProperties(SolverConfig solverConfig) {\n+        TerminationConfig terminationConfig = solverConfig.getTerminationConfig();\n+        if (terminationConfig == null) {\n+            terminationConfig = new TerminationConfig();\n+            solverConfig.setTerminationConfig(terminationConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.termination.spentLimit.ifPresent(terminationConfig::setSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.unimprovedSpentLimit.ifPresent(terminationConfig::setUnimprovedSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.bestScoreLimit.ifPresent(terminationConfig::setBestScoreLimit);\n+    }\n+\n+    private String convertAnnotationInstancesToString(Collection<AnnotationInstance> annotationInstances) {\n+        return \"[\" + annotationInstances.stream().map(instance -> instance.target().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n+        return \"[\" + classInfos.stream().map(instance -> instance.name().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    @BuildStep\n+    public RuntimeInitializedClassBuildItem nativeImageDroolsTricks() {\n+        return new RuntimeInitializedClassBuildItem(ClassFieldAccessorFactory.class.getName());\n+    }\n+\n+    // TODO health check\n+\n+    @BuildStep\n+    void registerOptaPlannerJacksonModule(BuildProducer<AdditionalBeanBuildItem> additionalBeans,\n+            Capabilities capabilities) {\n+        if (!capabilities.isCapabilityPresent(Capabilities.JACKSON)) {\n+            return;\n+        }\n+        try {\n+            Class.forName(\"org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule\", false,\n+                    Thread.currentThread().getContextClassLoader());\n+        } catch (Exception e) {\n+            // Fail fast during build to avoid a certain runtime failure\n+            throw new IllegalStateException(\n+                    \"When using both Jackson and OptaPlanner,\"\n+                            + \" add a dependency on org.optaplanner:optaplanner-persistence-jackson too.\",", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0MzM3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379343373", "bodyText": "Yea - the idea is that it would stick out like a soar thumb, fail-fast basically. While if you forgot to add quarkus-optaplanner-jackson, there is no fail fast: it's just hard to notice that score instances aren't being jacksoned correctly.\nAnyway, not worth the hassle - I am creating quarkus-optaplanner-jackson to align with the quarkus ecosystem spirit :)", "author": "ge0ffrey", "createdAt": "2020-02-14T10:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3MTU4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379371586", "bodyText": "Done", "author": "ge0ffrey", "createdAt": "2020-02-14T11:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjI0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312246", "bodyText": "Call it OptaPlannerBuildTimeConfig and get rid of the comment.", "author": "gsmet", "createdAt": "2020-02-14T08:53:44Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+// Not named OptaPlannerConfig because classes ending with just \"Config\" collide with OptaPlanner's API\n+@ConfigRoot(name = \"optaplanner\")\n+public class OptaPlannerQuarkusConfig {", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4NzE2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379387167", "bodyText": "Done, good point.", "author": "ge0ffrey", "createdAt": "2020-02-14T11:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312609", "bodyText": "That looks like a runtime property to me.", "author": "gsmet", "createdAt": "2020-02-14T08:54:31Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverManagerConfig}.\n+ */\n+@ConfigGroup\n+public class SolverManagerQuarkusConfig {\n+\n+    /**\n+     * The number of solvers that run in parallel. This directly influences CPU consumption.\n+     * Defaults to {@value SolverManagerConfig#PARALLEL_SOLVER_COUNT_AUTO}.\n+     * Other options include a number or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> parallelSolverCount;", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4MDIyMw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379380223", "bodyText": "It only affects SolverManager during build time - those get injected, but we don't need to read this property at runtime.", "author": "ge0ffrey", "createdAt": "2020-02-14T11:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4NzY2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379387666", "bodyText": "Discussed with Georgios. He agrees, these are build time properties (they get translated into optaplanner configuration during the build time, they aren't used at runtime). Renamed class to end with BuildTimeConfig instead of QuarkusConfig to signal that.", "author": "ge0ffrey", "createdAt": "2020-02-14T11:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxODQ3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380218479", "bodyText": "Well, they might be build time for your code but I think it's typically values that you will want to change at runtime because it might depend on the hardware on which you deploy it.\nI don't have a problem merging that as is for now but I think it's probably something we should think about for a later version (but it might be totally impractical, I don't know OptaPlanner at all).", "author": "gsmet", "createdAt": "2020-02-17T14:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODMyNA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380268324", "bodyText": "Agreed - or users wanting to override them with -D system properties?", "author": "ge0ffrey", "createdAt": "2020-02-17T16:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjY1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312654", "bodyText": "That looks like a runtime property to me.", "author": "gsmet", "createdAt": "2020-02-14T08:54:37Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.EnvironmentMode;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverConfig}.\n+ */\n+@ConfigGroup\n+public class SolverQuarkusConfig {\n+\n+    /**\n+     * Enable runtime assertions to detect common bugs in your implementation during development.\n+     * Defaults to {@link EnvironmentMode#REPRODUCIBLE}.\n+     */\n+    @ConfigItem\n+    Optional<EnvironmentMode> environmentMode;\n+    /**\n+     * Enable multithreaded solving for a single problem, which increases CPU consumption.\n+     * Defaults to {@value SolverConfig#MOVE_THREAD_COUNT_NONE}.\n+     * Other options include {@value SolverConfig#MOVE_THREAD_COUNT_AUTO}, a number\n+     * or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> moveThreadCount;", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4ODQ2NA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379388464", "bodyText": "It's a build time property, see other comment.", "author": "ge0ffrey", "createdAt": "2020-02-14T11:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjgxOA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312818", "bodyText": "That looks like a runtime property to me.", "author": "gsmet", "createdAt": "2020-02-14T08:55:05Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/TerminationQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link TerminationConfig}.\n+ */\n+@ConfigGroup\n+public class TerminationQuarkusConfig {", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4ODU0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379388549", "bodyText": "It's a build time property, see other comment. Adjusted class name to reflect that.", "author": "ge0ffrey", "createdAt": "2020-02-14T11:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNTA2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379315063", "bodyText": "Please no license header.", "author": "gsmet", "createdAt": "2020-02-14T09:00:15Z", "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/domain/ITestdataPlanningSolution.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNTE1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379315152", "bodyText": "Same here, well, remove all of them :).", "author": "gsmet", "createdAt": "2020-02-14T09:00:27Z", "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/solver/ITestdataPlanningConstraintProvider.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "originalCommit": "12d131b2ab6f9ead0462a8d9a555754444b21286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NTUyMg==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379345522", "bodyText": "Fixed", "author": "ge0ffrey", "createdAt": "2020-02-14T10:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNTE1Mg=="}], "type": "inlineReview"}, {"oid": "1c8edb3203827a7b6bbbd08263b9795f4c352adf", "url": "https://github.com/quarkusio/quarkus/commit/1c8edb3203827a7b6bbbd08263b9795f4c352adf", "message": "Comment out guide until it's released", "committedDate": "2020-02-14T10:04:22Z", "type": "forcePushed"}, {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8", "url": "https://github.com/quarkusio/quarkus/commit/a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8", "message": "OptaPlanner extension", "committedDate": "2020-02-17T10:32:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMDQ4OA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380220488", "bodyText": "The name of the property should be the one used by the user. This is not the case here.\nAlso maybe a ConfigException would be better.", "author": "gsmet", "createdAt": "2020-02-17T14:43:23Z", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.HotDeploymentWatchedFileBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerBuildTimeConfig optaPlannerBuildTimeConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    HotDeploymentWatchedFileBuildItem configFile() {\n+        String solverConfigXML;\n+        if (optaPlannerBuildTimeConfig.solverConfigXml.isPresent()) {\n+            solverConfigXML = optaPlannerBuildTimeConfig.solverConfigXml.get();\n+        } else {\n+            solverConfigXML = OptaPlannerBuildTimeConfig.DEFAULT_SOLVER_CONFIG_URL;\n+        }\n+        return new HotDeploymentWatchedFileBuildItem(solverConfigXML);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerBuildTimeConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerBuildTimeConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML", "originalCommit": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMTg1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380221854", "bodyText": "I'm curious how this works without a LiveReloadBuildItem? I think we should probably have one to restart all the app in case of a change, similar to what we do elsewhere.", "author": "gsmet", "createdAt": "2020-02-17T14:45:56Z", "path": "extensions/optaplanner/deployment/src/test/java/io/quarkus/optaplanner/rest/OptaPlannerProcessorHotReloadTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.optaplanner.rest;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.optaplanner.constraints.TestdataPlanningConstraintProvider;\n+import io.quarkus.optaplanner.domain.TestdataPlanningEntity;\n+import io.quarkus.optaplanner.domain.TestdataPlanningSolution;\n+import io.quarkus.test.QuarkusDevModeTest;\n+import io.restassured.RestAssured;\n+\n+public class OptaPlannerProcessorHotReloadTest {\n+\n+    // This fails in IntelliJ with \"Undeclared build item class\", but not in maven. That's normal in Quarkus for now.\n+    @RegisterExtension\n+    static final QuarkusDevModeTest test = new QuarkusDevModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(TestdataPlanningEntity.class,\n+                            TestdataPlanningSolution.class, TestdataPlanningConstraintProvider.class,\n+                            SolverConfigTestResource.class)\n+                    .addAsResource(\"solverConfig.xml\"));\n+\n+    @Test\n+    public void solverConfigHotReload() {\n+        String resp = RestAssured.get(\"/solver-config/seconds-spent-limit\").asString();\n+        Assertions.assertEquals(\"secondsSpentLimit=2\", resp);\n+        test.modifyResourceFile(\"solverConfig.xml\", s -> s.replace(\"<secondsSpentLimit>2</secondsSpentLimit>\",\n+                \"<secondsSpentLimit>9</secondsSpentLimit>\"));\n+        resp = RestAssured.get(\"/solver-config/seconds-spent-limit\").asString();\n+        Assertions.assertEquals(\"secondsSpentLimit=9\", resp);", "originalCommit": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1NzU3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380557576", "bodyText": "A HotDeploymentWatchedFileBuildItem has been added to the PR that enables the config file for reload.", "author": "geoand", "createdAt": "2020-02-18T09:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMTg1NA=="}], "type": "inlineReview"}, {"oid": "48f23daee712a8f9a21b4794e357386053016174", "url": "https://github.com/quarkusio/quarkus/commit/48f23daee712a8f9a21b4794e357386053016174", "message": "OptaPlanner extension", "committedDate": "2020-02-18T18:41:01Z", "type": "forcePushed"}, {"oid": "c3c0e693d0f2215fc222ffaf220f3e54f7b43666", "url": "https://github.com/quarkusio/quarkus/commit/c3c0e693d0f2215fc222ffaf220f3e54f7b43666", "message": "OptaPlanner extension", "committedDate": "2020-02-18T19:01:55Z", "type": "forcePushed"}, {"oid": "bc14ce6e0ec25a99c403f31ebbe188b406bf72a5", "url": "https://github.com/quarkusio/quarkus/commit/bc14ce6e0ec25a99c403f31ebbe188b406bf72a5", "message": "OptaPlanner extension", "committedDate": "2020-02-19T10:24:51Z", "type": "commit"}, {"oid": "bc14ce6e0ec25a99c403f31ebbe188b406bf72a5", "url": "https://github.com/quarkusio/quarkus/commit/bc14ce6e0ec25a99c403f31ebbe188b406bf72a5", "message": "OptaPlanner extension", "committedDate": "2020-02-19T10:24:51Z", "type": "forcePushed"}]}