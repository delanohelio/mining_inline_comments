{"pr_number": 2922, "pr_title": "Make the TransitLayerMapper multi-threaded to decrease startup time.", "pr_createdAt": "2020-01-10T19:18:41Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5Mjc5Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r366792796", "bodyText": "This modify its input - sideeffects.", "author": "t2gran", "createdAt": "2020-01-15T10:12:52Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -139,70 +145,119 @@ private TransitLayer map() {\n             LOG.info(\"This TransitLayerMapper got a realtime timetable snapshot. The TransitLayer will reflect realtime updates to scheduled service.\");\n         }\n         Set<ServiceDate> allServiceDates = serviceIdsForServiceDate.keySet();\n-        Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n-        for (ServiceDate serviceDate : allServiceDates) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-            TIntSet serviceCodesRunning = new TIntHashSet();\n-\n-            for (FeedScopedId serviceId : serviceIdsForServiceDate.get(serviceDate)) {\n-                serviceCodesRunning.add(graph.serviceCodes.get(serviceId));\n-            }\n+        ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new ConcurrentHashMap<>();\n \n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                // Get an updated or scheduled timetable depending on the date. This might have the\n-                // trips pre-filtered for the specified date, that needs to be investigated. But in\n-                // any case we might end up with a scheduled timetable, which can include\n-                // non-running trips. So filter the trips according to which service IDs are running\n-                // on the given day.\n-                Timetable timetable = oldTripPattern.scheduledTimetable;\n-                if (timetableSnapshot != null) {\n-                    timetable = timetableSnapshot.resolve(oldTripPattern, serviceDate);\n-                }\n-                List<TripSchedule> newTripSchedules = new ArrayList<>();\n-                // The TripTimes are not sorted by departure time in the source timetable because\n-                // OTP1 performs a simple/ linear search. Raptor results depend on trips being\n-                // sorted. We reuse the same timetables many times on different days, so cache the\n-                // sorted versions to avoid repeated compute-intensive sorting. Anecdotally this\n-                // reduces mapping time by more than half, but it is still rather slow. NL Mapping\n-                // takes 32 seconds sorting every timetable, 9 seconds with cached sorting, and 6\n-                // seconds with no timetable sorting at all.\n-                List<TripTimes> sortedTripTimes = sortedTripTimesForTimetable.computeIfAbsent(\n-                    timetable,\n-                    TransitLayerMapper::getSortedTripTimes\n-                );\n-                for (TripTimes tripTimes : sortedTripTimes) {\n-                    if (!serviceCodesRunning.contains(tripTimes.serviceCode)) {\n-                        continue;\n-                    }\n-                    if (tripTimes.getRealTimeState() == RealTimeState.CANCELED) {\n-                        continue;\n-                    }\n-                    TripSchedule tripSchedule = tripScheduleForTripTimes.computeIfAbsent(\n-                        tripTimes,\n-                        // The following are two alternative implementations of TripSchedule\n-                        tt -> new TripScheduleWrapperImpl(tt, oldTripPattern)\n-                        // tt -> tt.toTripSchedulImpl(oldTripPattern)\n+        // CONCURRENT !!! The following stream is running in multiple threads. For a dataset like\n+        // the Norwegian NeTEx hole of Norway, running this in parallel on a Mac book PRO, JAN 2020,\n+        // this saves 20 seconds - from 36s down to 15s.\n+        allServiceDates\n+                .parallelStream()\n+                .forEach(serviceDate -> {\n+                    // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n+                    // the return Map.\n+                    LocalDate date = ServiceCalendarMapper.localDateFromServiceDate(\n+                            serviceDate);\n+\n+                    List<TripPatternForDate> res = mapTripPatternForDay(\n+                            serviceIdsForServiceDate,\n+                            allTripPatterns,\n+                            newTripPatternForOld,\n+                            tripScheduleForTripTimes,\n+                            sortedTripTimesForTimetable,\n+                            serviceDate,\n+                            date\n                     );\n-                    newTripSchedules.add(tripSchedule);\n-                } \n-                TripPattern newTripPattern = newTripPatternForOld.get(oldTripPattern);\n-                TripPatternForDate tripPatternForDate = new TripPatternForDate(\n-                        newTripPattern,\n-                        newTripSchedules,\n-                        localDate\n+                    if(!res.isEmpty()) {\n+                        synchronized (tripPatternsForDates) {\n+                            tripPatternsForDates.put(date, res);\n+                        }\n+                    }\n+                });\n+        return tripPatternsForDates;\n+    }\n+\n+    /**\n+     * Create a list of trip patterns for a given {@code serviceDate}.\n+     * <p>\n+     * THREAD SAFE - This method is called from multiple threads and MUST be thread safe.\n+     *", "originalCommit": "73068f9245c5b79b1ca63c6397bf23bb3dce453e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "message": "Make the TransitLayerMapper multithreaded to decrease startup time", "committedDate": "2020-02-06T09:35:17Z", "type": "commit"}, {"oid": "d316e88e3246fac699cd64092fa6c58338844150", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d316e88e3246fac699cd64092fa6c58338844150", "message": "Improve logging for Graph indexing, to be able to see, when it start and ends. This is a major part of the startup time.", "committedDate": "2020-02-06T09:44:28Z", "type": "commit"}, {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9dfaedb5e58d7682842e8fe645ab30618209cb7", "message": "Added javadoc", "committedDate": "2020-02-06T09:55:27Z", "type": "commit"}, {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9dfaedb5e58d7682842e8fe645ab30618209cb7", "message": "Added javadoc", "committedDate": "2020-02-06T09:55:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMjA0OQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377932049", "bodyText": "Mak a comment here so it is REALY easy to see this this is running in multiple threads.", "author": "t2gran", "createdAt": "2020-02-11T22:15:19Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -90,29 +95,39 @@ private TransitLayer map() {\n             newTripPatternForOld\n         );\n \n-        for (ServiceDate serviceDate : graph.index.getServiceCodesRunningForDate().keySet()) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-\n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                TripPatternForDate tripPatternForDate = tripPatternForDateMapper.map(oldTripPattern.scheduledTimetable, serviceDate);\n-                if (tripPatternForDate != null) {\n-                    values.add(tripPatternForDate);\n+        Set<ServiceDate> allServiceDates = graph.index.getServiceCodesRunningForDate().keySet();\n+\n+        allServiceDates", "originalCommit": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzgwMQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377933801", "bodyText": "This class needs JavaDoc documentation that it is Thread safe - why it is so.", "author": "t2gran", "createdAt": "2020-02-11T22:19:14Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -28,14 +29,20 @@\n \n   private static final Logger LOG = LoggerFactory.getLogger(TripPatternForDateMapper.class);\n \n-  private final Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n+  private final ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable =\n+      new ConcurrentHashMap<>();", "originalCommit": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjQ4Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377936486", "bodyText": "Using the Collection.unmodifiableMap(...) would be good idea here, then it becomes clear that these are READ_ONLY.", "author": "t2gran", "createdAt": "2020-02-11T22:25:17Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -44,6 +51,13 @@\n     this.newTripPatternForOld = newTripPatternForOld;\n   }", "originalCommit": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ce162fb04225dcfd144e610b46c79562249becec", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ce162fb04225dcfd144e610b46c79562249becec", "message": "Added javadoc and comments", "committedDate": "2020-02-12T11:52:00Z", "type": "commit"}, {"oid": "9f385bb4b66946e8db7fcdf60cb64df19deb366c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9f385bb4b66946e8db7fcdf60cb64df19deb366c", "message": "Merge branch 'dev-2.x' into otp2_TransitLayerMapper_optimize", "committedDate": "2020-02-12T11:52:30Z", "type": "commit"}, {"oid": "584245f686b23423c013cfd797a9e9880ab72290", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/584245f686b23423c013cfd797a9e9880ab72290", "message": "Merge branch 'dev-2.x' into otp2_TransitLayerMapper_optimize", "committedDate": "2020-02-12T13:53:28Z", "type": "commit"}, {"oid": "165fb5414bcb5c172fa781fdb6678f3d15a9ee13", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/165fb5414bcb5c172fa781fdb6678f3d15a9ee13", "message": "Review - Minor cosmetic changes, removed 'synchronized' block by converting to a 'ConcurrentHashMap' instead.", "committedDate": "2020-02-12T14:20:36Z", "type": "commit"}]}