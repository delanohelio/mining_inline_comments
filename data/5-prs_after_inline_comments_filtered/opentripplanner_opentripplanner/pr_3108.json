{"pr_number": 3108, "pr_title": "Optimize SimpleStreetSplitter: two-stage search, remove sorting", "pr_createdAt": "2020-06-19T00:42:03Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3108", "timeline": [{"oid": "98697ea4eaf79f36f38b525ab3ba6d3250966da1", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/98697ea4eaf79f36f38b525ab3ba6d3250966da1", "message": "Optimize SimpleStreetSplitter: two-stage search, remove sorting", "committedDate": "2020-06-18T15:06:52Z", "type": "commit"}, {"oid": "18a0c79c9bc9261218d560bfeaec6def0868fe1a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/18a0c79c9bc9261218d560bfeaec6def0868fe1a", "message": "Code cleanup of the SimpleStreetSplitter.", "committedDate": "2020-08-04T08:24:57Z", "type": "commit"}, {"oid": "ec904d2f8c49213cccec99a250f22b06f7c1a786", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ec904d2f8c49213cccec99a250f22b06f7c1a786", "message": "Merge branch 'dev-2.x' into optimize-linker", "committedDate": "2020-08-04T08:28:03Z", "type": "commit"}, {"oid": "f55739ca4048f72e526b3e2f2164753a66c1932a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f55739ca4048f72e526b3e2f2164753a66c1932a", "message": "Merge branch 'dev-2.x' into optimize-linker", "committedDate": "2020-08-05T09:03:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI1ODc0MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3108#discussion_r466258740", "bodyText": "What is the purpose of e.getToVertex().getIncoming().contains(e) ? I think we should add a \"business method\" to edge witch make this easier to understand, and call that in the filter(...) method above:\nboolean Edge.isConnectedToGraph() {\n    return getToVertex().getIncoming().contains(this);\n}\n\nIt might not be needed, if so we can delete it.", "author": "t2gran", "createdAt": "2020-08-06T09:10:58Z", "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "diffHunk": "@@ -227,124 +245,86 @@ public boolean link(Vertex vertex, TraverseMode traverseMode, RoutingRequest opt\n \n         final double DUPLICATE_WAY_EPSILON_DEGREES = SphericalDistanceLibrary.metersToDegrees(DUPLICATE_WAY_EPSILON_METERS);\n \n-        final TraverseModeSet traverseModeSet;\n+        final TraverseModeSet traverseModeSet = new TraverseModeSet(traverseMode);\n         if (traverseMode == TraverseMode.BICYCLE) {\n-            traverseModeSet = new TraverseModeSet(traverseMode, TraverseMode.WALK);\n-        } else {\n-            traverseModeSet = new TraverseModeSet(traverseMode);\n-        }\n-        // We sort the list of candidate edges by distance to the stop\n-        // This should remove any issues with things coming out of the spatial index in different orders\n-        // Then we link to everything that is within DUPLICATE_WAY_EPSILON_METERS of of the best distance\n-        // so that we capture back edges and duplicate ways.\n-        List<StreetEdge> candidateEdges = idx.query(env).stream()\n-            .filter(streetEdge -> streetEdge instanceof  StreetEdge)\n-            .map(edge -> (StreetEdge) edge)\n-            // note: not filtering by radius here as distance calculation is expensive\n-            // we do that below.\n-            .filter(edge -> edge.canTraverse(traverseModeSet) &&\n-                // only link to edges still in the graph.\n-                edge.getToVertex().getIncoming().contains(edge))\n-            .collect(Collectors.toList());\n-\n-        // Make a map of distances to all edges.\n-        final TObjectDoubleMap<Edge> distances = new TObjectDoubleHashMap<>();\n-        for (StreetEdge e : candidateEdges) {\n-            distances.put(e, distance(vertex, e, xscale));\n-        }\n-\n-        // Sort the list.\n-        Collections.sort(candidateEdges, (o1, o2) -> {\n-            double diff = distances.get(o1) - distances.get(o2);\n-            // A Comparator must return an integer but our distances are doubles.\n-            if (diff < 0)\n-                return -1;\n-            if (diff > 0)\n-                return 1;\n-            return 0;\n-        });\n-\n-        // find the closest candidate edges\n-        if (candidateEdges.isEmpty() || distances.get(candidateEdges.get(0)) > radiusDeg) {\n-            // We only link to stops if we are searching for origin/destination and for that we need transitStopIndex.\n-            if (destructiveSplitting || transitStopIndex == null) {\n-                return false;\n-            }\n-            LOG.debug(\"No street edge was found for {}\", vertex);\n-            // We search for closest stops (since this is only used in origin/destination linking if no edges were found)\n-            // in the same way the closest edges are found.\n-            List<TransitStopVertex> candidateStops = new ArrayList<>();\n-            transitStopIndex.query(env).forEach(candidateStop -> candidateStops.add((TransitStopVertex) candidateStop));\n-\n-            final TObjectDoubleMap<Vertex> stopDistances = new TObjectDoubleHashMap<>();\n-\n-            for (TransitStopVertex t : candidateStops) {\n-                stopDistances.put(t, distance(vertex, t, xscale));\n-            }\n-\n-            Collections.sort(candidateStops, (o1, o2) -> {\n-                    double diff = stopDistances.get(o1) - stopDistances.get(o2);\n-                    if (diff < 0) {\n-                        return -1;\n-                    }\n-                    if (diff > 0) {\n-                        return 1;\n+            traverseModeSet.setWalk(true);\n+        }\n+        // Scope block to avoid confusing edge-related local variables with stop-related variables below.\n+        {\n+            // Perform several transformations at once on the edges returned by the index.\n+            // Only consider street edges traversable by the given mode and still present in the graph.\n+            // Calculate a distance to each of those edges, and keep only the ones within the search radius.\n+            List<DistanceTo<StreetEdge>> candidateEdges = idx.query(env).stream()\n+                    .filter(StreetEdge.class::isInstance)\n+                    .map(StreetEdge.class::cast)\n+                    .filter(e -> e.canTraverse(traverseModeSet) && e.getToVertex().getIncoming().contains(e))\n+                    .map(e -> new DistanceTo<>(e, distance(vertex, e, xscale)))\n+                    .filter(ead -> ead.distanceDegreesLat < radiusDeg)\n+                    .collect(Collectors.toList());", "originalCommit": "f55739ca4048f72e526b3e2f2164753a66c1932a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2ODc4NQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3108#discussion_r473968785", "bodyText": "When the SimpleStreetSplitter is in destructiveSplitting mode (during graph construction rather than handling routing requests), it removes edges that have been split and can then re-split the resulting segments, so parts of them are also removed. New edge fragments are added to the spatial index; the edges that were split are removed (disconnected) from the graph but not removed from the spatial index, so for the rest of the linking and splitting operation we must check whether any edge coming out of the index has not been \"soft deleted\".\nI think all of this is compensating for the fact that STRTrees are optimized at construction and read-only, so you can't remove things from them once they're built. That's no longer relevant since we've been using our own hash grid spatial index instead of the STRTree for a while. I think we can turn this check into an assertion, then change the method that removes the edges so it also removes them from the index.", "author": "abyrd", "createdAt": "2020-08-20T13:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI1ODc0MA=="}], "type": "inlineReview"}, {"oid": "f8cf79e11f369efe358aa3bb95d3f8b622b32557", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f8cf79e11f369efe358aa3bb95d3f8b622b32557", "message": "lambda syntax in HashGridSpatialIndex, comment on efficiency", "committedDate": "2020-08-20T14:13:48Z", "type": "commit"}, {"oid": "c6403315c727ea08ad63c4dba5a7b33e7b12db92", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/c6403315c727ea08ad63c4dba5a7b33e7b12db92", "message": "factor out edgeReachableFromGraph check", "committedDate": "2020-08-20T14:18:37Z", "type": "commit"}, {"oid": "0db9188ddd824531efa380d08ec48316bde4acd6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0db9188ddd824531efa380d08ec48316bde4acd6", "message": "fix double-increment, ensure unique stop IDs and labels", "committedDate": "2020-08-20T14:44:26Z", "type": "commit"}, {"oid": "d36d8194bf32dcb5fc372dda16c8abccca783994", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d36d8194bf32dcb5fc372dda16c8abccca783994", "message": "compare link edges in order of increasing length", "committedDate": "2020-08-20T15:19:40Z", "type": "commit"}, {"oid": "a60bdd900d06a2e12677d29cdec116cf33d259f6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a60bdd900d06a2e12677d29cdec116cf33d259f6", "message": "Merge branch 'dev-2.x' into optimize-linker", "committedDate": "2020-08-20T15:25:49Z", "type": "commit"}, {"oid": "b1e499424f43c0bf73b3cc39dcd9399d0245a1b0", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b1e499424f43c0bf73b3cc39dcd9399d0245a1b0", "message": "Merge branch 'dev-2.x' into optimize-linker", "committedDate": "2020-08-25T08:21:26Z", "type": "commit"}]}