{"pr_number": 3173, "pr_title": "Add support for graph building with flex locations and trips", "pr_createdAt": "2020-09-03T08:28:02Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3OTkyNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482979924", "bodyText": "Revert change", "author": "hannesj", "createdAt": "2020-09-03T13:31:57Z", "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "diffHunk": "@@ -84,25 +90,34 @@ public NearbyStopFinder(Graph graph, double radiusMeters, boolean useStreets) {\n      * This is intentional: we don't want to return the next stop down the line for trip patterns that pass through the\n      * origin vertex.\n      */\n-    public Set<StopAtDistance> findNearbyStopsConsideringPatterns (Vertex vertex) {\n+    public Set<StopAtDistance> findNearbyStopsConsideringPatterns(Vertex vertex, boolean reverseDirection) {\n \n         /* Track the closest stop on each pattern passing nearby. */\n         MinMap<TripPattern, StopAtDistance> closestStopForPattern = new MinMap<TripPattern, StopAtDistance>();\n \n+        /* Track the closest stop on each flex trip nearby. */\n+        MinMap<FlexTrip, StopAtDistance> closestStopForFlexTrip = new MinMap<>();\n+\n+        /* Make a transfer from the origin stop to each destination stop that was the closest stop on any pattern. */\n+        Set<StopAtDistance> uniqueStops = Sets.newHashSet();", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NzI0Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482987246", "bodyText": "Add comment about \"Simplification so that we only return one vertex from each stop location. Add all vertices tp the map, which is filtered below\"", "author": "hannesj", "createdAt": "2020-09-03T13:42:44Z", "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "diffHunk": "@@ -165,8 +183,24 @@ public NearbyStopFinder(Graph graph, double radiusMeters, boolean useStreets) {\n                 if (targetVertex instanceof TransitStopVertex && state.isFinal()) {\n                     stopsFound.add(StopAtDistance.stopAtDistanceForState(state, ((TransitStopVertex) targetVertex).getStop()));\n                 }\n+                if (OTPFeature.FlexRouting.isOn()\n+                    && targetVertex instanceof StreetVertex\n+                    && ((StreetVertex) targetVertex).flexStopLocations != null) {\n+                   for (FlexStopLocation flexStopLocation : ((StreetVertex) targetVertex).flexStopLocations) {", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NzkyMQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482987921", "bodyText": "Select the vertex from all vertices that are reachable by taking the minimum walking distance", "author": "hannesj", "createdAt": "2020-09-03T13:43:40Z", "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "diffHunk": "@@ -165,8 +183,24 @@ public NearbyStopFinder(Graph graph, double radiusMeters, boolean useStreets) {\n                 if (targetVertex instanceof TransitStopVertex && state.isFinal()) {\n                     stopsFound.add(StopAtDistance.stopAtDistanceForState(state, ((TransitStopVertex) targetVertex).getStop()));\n                 }\n+                if (OTPFeature.FlexRouting.isOn()\n+                    && targetVertex instanceof StreetVertex\n+                    && ((StreetVertex) targetVertex).flexStopLocations != null) {\n+                   for (FlexStopLocation flexStopLocation : ((StreetVertex) targetVertex).flexStopLocations) {\n+                        locationsMap.put(flexStopLocation, state);\n+                    }\n+                }\n             }\n         }\n+\n+        for (var locationStates : locationsMap.asMap().entrySet()) {\n+            FlexStopLocation flexStopLocation = locationStates.getKey();\n+            Collection<State> states = locationStates.getValue();\n+            State min = Collections.min(states, (s1, s2) -> (int) (s1.walkDistance - s2.walkDistance));", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5OTYyMw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482999623", "bodyText": "Stop to stop transfers are already populated by the findNearbyStopsConsideringPatterns(ts0, false)", "author": "hannesj", "createdAt": "2020-09-03T13:59:14Z", "path": "src/main/java/org/opentripplanner/graph_builder/module/DirectTransferGenerator.java", "diffHunk": "@@ -88,6 +89,19 @@ public void buildGraph(\n                 );\n                 n += 1;\n             }\n+            if (OTPFeature.FlexRouting.isOn()) {\n+                for (StopAtDistance sd : nearbyStopFinder.findNearbyStopsConsideringPatterns(ts0,  true)) {\n+                    /* Skip the origin stop, loop transfers are not needed. */\n+                    if (sd.stop == ts0.getStop())\n+                        continue;\n+                    if (sd.stop instanceof Stop)", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMTM1Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483001357", "bodyText": "add to separate class", "author": "hannesj", "createdAt": "2020-09-03T14:01:26Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/UnscheduledTrip.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class UnscheduledTrip extends FlexTrip {\n+\n+  private final StopLocation[] stops;\n+  private final int[] minDepartureTimes;\n+  private final int[] maxDepartureTimes;\n+  private final int[] minArrivalTimes;\n+  private final int[] maxArrivalTimes;\n+\n+  private final int[] pickupTypes;\n+  private final int[] dropOffTypes;", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMTk0Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483001946", "bodyText": "add to separate class", "author": "hannesj", "createdAt": "2020-09-03T14:02:17Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+public class ScheduledDeviatedTrip extends FlexTrip {\n+  static final int MISSING_VALUE = -999;\n+\n+  private final StopLocation[] stops;\n+  private final int[] departureTimes;\n+  private final int[] arrivalTimes;\n+\n+  private final int[] pickupTypes;\n+  private final int[] dropOffTypes;", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMTc5OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483011798", "bodyText": "Add Javadoc", "author": "hannesj", "createdAt": "2020-09-03T14:15:48Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/UnscheduledTrip.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class UnscheduledTrip extends FlexTrip {", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMTkxOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483011919", "bodyText": "Add Javadoc", "author": "hannesj", "createdAt": "2020-09-03T14:15:58Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+public class ScheduledDeviatedTrip extends FlexTrip {", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxOTM2MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483019360", "bodyText": "Add isConnectedToWalkingEdge, isConnectedToDriveableEdge and isEligibleForPickupDropoff in StreetEdge", "author": "hannesj", "createdAt": "2020-09-03T14:26:00Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.locationtech.jts.geom.Point;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.graph_builder.DataImportIssueStore;\n+import org.opentripplanner.graph_builder.services.GraphBuilderModule;\n+import org.opentripplanner.model.FlexStopLocation;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.core.TraverseModeSet;\n+import org.opentripplanner.routing.edgetype.StreetEdge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.impl.StreetVertexIndex;\n+import org.opentripplanner.routing.vertextype.StreetVertex;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+public class FlexLocationsToStreetEdgesMapper implements GraphBuilderModule {\n+\n+  @Override\n+  public void buildGraph(\n+      Graph graph, HashMap<Class<?>, Object> extra, DataImportIssueStore issueStore\n+  ) {\n+    if (graph.locationsById.isEmpty()) {\n+      return;\n+    }\n+\n+    StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n+    TraverseModeSet carTraverseModeSet = new TraverseModeSet(TraverseMode.CAR);\n+    TraverseModeSet walkTraverseModeSet = new TraverseModeSet(TraverseMode.WALK);\n+\n+    for (FlexStopLocation flexStopLocation : graph.locationsById.values()) {\n+      for (Vertex vertx : streetIndex.getVerticesForEnvelope(flexStopLocation\n+          .getGeometry()\n+          .getEnvelopeInternal())\n+      ) {\n+        if (!(vertx instanceof StreetVertex)) { continue; }\n+        if (vertx.getOutgoing().stream().noneMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(carTraverseModeSet))  ||", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMDM3OQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483020379", "bodyText": "getVerticesForEnvelope can return Vertices which are not inside the search area", "author": "hannesj", "createdAt": "2020-09-03T14:27:17Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.locationtech.jts.geom.Point;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.graph_builder.DataImportIssueStore;\n+import org.opentripplanner.graph_builder.services.GraphBuilderModule;\n+import org.opentripplanner.model.FlexStopLocation;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.core.TraverseModeSet;\n+import org.opentripplanner.routing.edgetype.StreetEdge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.impl.StreetVertexIndex;\n+import org.opentripplanner.routing.vertextype.StreetVertex;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+public class FlexLocationsToStreetEdgesMapper implements GraphBuilderModule {\n+\n+  @Override\n+  public void buildGraph(\n+      Graph graph, HashMap<Class<?>, Object> extra, DataImportIssueStore issueStore\n+  ) {\n+    if (graph.locationsById.isEmpty()) {\n+      return;\n+    }\n+\n+    StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n+    TraverseModeSet carTraverseModeSet = new TraverseModeSet(TraverseMode.CAR);\n+    TraverseModeSet walkTraverseModeSet = new TraverseModeSet(TraverseMode.WALK);\n+\n+    for (FlexStopLocation flexStopLocation : graph.locationsById.values()) {\n+      for (Vertex vertx : streetIndex.getVerticesForEnvelope(flexStopLocation\n+          .getGeometry()\n+          .getEnvelopeInternal())\n+      ) {\n+        if (!(vertx instanceof StreetVertex)) { continue; }\n+        if (vertx.getOutgoing().stream().noneMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(carTraverseModeSet))  ||\n+            vertx.getOutgoing().stream().noneMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(walkTraverseModeSet))\n+        ) {\n+          continue;\n+        }\n+\n+        Point p = GeometryUtils.getGeometryFactory().createPoint(vertx.getCoordinate());\n+        if (flexStopLocation.getGeometry().disjoint(p)) {", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTAwOA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483021008", "bodyText": "Document filters and link to trip types", "author": "hannesj", "createdAt": "2020-09-03T14:28:06Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.ScheduledDeviatedTrip;\n+import org.opentripplanner.ext.flex.trip.UnscheduledTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.TripStopTimes;\n+import org.opentripplanner.model.impl.OtpTransitServiceBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import static org.onebusaway.gtfs.model.StopTime.MISSING_VALUE;\n+\n+public class FlexTripsMapper {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripsMapper.class);\n+\n+  static public void createFlexTrips(OtpTransitServiceBuilder builder) {\n+    TripStopTimes stopTimesByTrip = builder.getStopTimesSortedByTrip();\n+\n+    final int tripSize = stopTimesByTrip.size();\n+    int tripCount = 0;\n+\n+    for (org.opentripplanner.model.Trip trip : stopTimesByTrip.keys()) {\n+      if (++tripCount % 100000 == 0) {\n+        LOG.debug(\"Mapped StopTimes for flex trips {}/{}\", tripCount, tripSize);\n+      }\n+\n+      /* Fetch the stop times for this trip. Copy the list since it's immutable. */\n+      List<StopTime> stopTimes = new ArrayList<>(stopTimesByTrip.get(trip));\n+\n+      if (isUnscheduledTrip(stopTimes)) {\n+        if (stopTimes.size() == 2) {\n+          // TODO: Drop this restriction after time handling and ride times are defined\n+          builder.getFlexTripsById().add(new UnscheduledTrip(trip, stopTimes));\n+        }\n+      } else if (isScheduledFlexTrip(stopTimes)) {\n+        builder.getFlexTripsById().add(new ScheduledDeviatedTrip(trip, stopTimes));\n+      } else if (hasContinuousStops(stopTimes)) {\n+        // builder.getFlexTripsById().add(new ContinuousPickupDropOffTrip(trip, stopTimes));\n+      }\n+    }\n+  }\n+\n+  private static boolean isUnscheduledTrip(List<StopTime> stopTimes) {", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTk2Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483021967", "bodyText": "Potentially move as static methods on classes", "author": "hannesj", "createdAt": "2020-09-03T14:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTczMA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483021730", "bodyText": "use new type of progress tracker", "author": "hannesj", "createdAt": "2020-09-03T14:29:06Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.ScheduledDeviatedTrip;\n+import org.opentripplanner.ext.flex.trip.UnscheduledTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.TripStopTimes;\n+import org.opentripplanner.model.impl.OtpTransitServiceBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import static org.onebusaway.gtfs.model.StopTime.MISSING_VALUE;\n+\n+public class FlexTripsMapper {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripsMapper.class);\n+\n+  static public void createFlexTrips(OtpTransitServiceBuilder builder) {\n+    TripStopTimes stopTimesByTrip = builder.getStopTimesSortedByTrip();\n+\n+    final int tripSize = stopTimesByTrip.size();\n+    int tripCount = 0;\n+\n+    for (org.opentripplanner.model.Trip trip : stopTimesByTrip.keys()) {\n+      if (++tripCount % 100000 == 0) {", "originalCommit": "7058cae7e98588242bb641040b8290f04287b8f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3230f4e1fa8604da5c89cf09c0db5bfa79b51a3a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/3230f4e1fa8604da5c89cf09c0db5bfa79b51a3a", "message": "Add support for graph building with flex locations and trips", "committedDate": "2020-09-08T06:57:02Z", "type": "commit"}, {"oid": "40bf6002f791257df6069f62e415439f64f52a4d", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/40bf6002f791257df6069f62e415439f64f52a4d", "message": "Review fixes", "committedDate": "2020-09-08T07:41:27Z", "type": "commit"}, {"oid": "ee9d48803374e464d81148e75c9cecd7214a9e46", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ee9d48803374e464d81148e75c9cecd7214a9e46", "message": "Extract stoptimes to separate classes", "committedDate": "2020-09-08T07:46:06Z", "type": "commit"}, {"oid": "dc5e5cbc24f7f863df384498f9e10788699ea559", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dc5e5cbc24f7f863df384498f9e10788699ea559", "message": "Add Javadoc", "committedDate": "2020-09-08T08:14:15Z", "type": "commit"}, {"oid": "dc5e5cbc24f7f863df384498f9e10788699ea559", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dc5e5cbc24f7f863df384498f9e10788699ea559", "message": "Add Javadoc", "committedDate": "2020-09-08T08:14:15Z", "type": "forcePushed"}, {"oid": "3ffd0b90aee7b39471f38728539429c7c936d0ea", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/3ffd0b90aee7b39471f38728539429c7c936d0ea", "message": "Fix brackets and comments", "committedDate": "2020-09-08T09:40:11Z", "type": "commit"}, {"oid": "13bc6b1efacc60225d2db72316d05bb405358057", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/13bc6b1efacc60225d2db72316d05bb405358057", "message": "typo", "committedDate": "2020-09-08T09:42:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MDk2NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r484790964", "bodyText": "We could add a method, boolean canTranverse(TraverseMode traverseMode) in StreetEdge", "author": "hannesj", "createdAt": "2020-09-08T09:45:45Z", "path": "src/main/java/org/opentripplanner/routing/vertextype/StreetVertex.java", "diffHunk": "@@ -65,4 +71,18 @@ public I18NString getIntersectionName(Locale locale) {\n         }\n         return calculatedName;\n     }\n+\n+    public boolean isConnectedToWalkingEdge() {\n+        return this.getOutgoing().stream().anyMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(WALK_TRAVERSE_MODE_SET));", "originalCommit": "3ffd0b90aee7b39471f38728539429c7c936d0ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e5f09d0baa08b0df442bc76d733e97ee5316bf1", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4e5f09d0baa08b0df442bc76d733e97ee5316bf1", "message": "Use getPermission on StreetEdge", "committedDate": "2020-09-08T09:53:11Z", "type": "commit"}, {"oid": "be0745b96326f2ab41e5d9809b19fb256028e993", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/be0745b96326f2ab41e5d9809b19fb256028e993", "message": "Merge branch 'dev-2.x' into flex-upstream-graph-build", "committedDate": "2020-09-08T10:10:23Z", "type": "commit"}]}