{"pr_number": 1735, "pr_title": "[REST Auth] API tokens & openhab:users console command", "pr_createdAt": "2020-10-19T18:10:12Z", "pr_url": "https://github.com/openhab/openhab-core/pull/1735", "timeline": [{"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af", "url": "https://github.com/openhab/openhab-core/commit/8c3c0a5bf0059aabbb01eff285911c46dca211af", "message": "Generate a unique salt for each token\n\nReusing the password salt is bad practice, and changing the\npassword changes the salt as well which makes all tokens\ninvalid.\n\nPut the salt in the same field as the hash (concatenated\nwith a separator) to avoid modifying the JSON DB schema.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-19T20:52:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTMxNg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508289316", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n          \n          \n            \n                            throw new AuthenticationException(\"User not found in registry\");", "author": "wborn", "createdAt": "2020-10-20T08:00:19Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "originalCommit": "8c3c0a5bf0059aabbb01eff285911c46dca211af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0MDE4MQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508640181", "bodyText": "Thanks, I rebased and addressed it in the process.", "author": "ghys", "createdAt": "2020-10-20T15:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTQ1MA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508289450", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n          \n          \n            \n                        throw new AuthenticationException(\"User not found in registry\");", "author": "wborn", "createdAt": "2020-10-20T08:00:30Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n+            }\n+            return new UserSecurityContext(user, \"ApiToken\");\n+        } else {\n+            Authentication auth = jwtHelper.verifyAndParseJwtAccessToken(token);\n+            return new JwtSecurityContext(auth);\n+        }\n+    }\n+\n+    private SecurityContext authenticateUsernamePassword(String username, String password)\n+            throws AuthenticationException {\n+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n+        Authentication auth = userRegistry.authenticate(credentials);\n+        User user = userRegistry.get(auth.getUsername());\n+        if (user == null) {\n+            throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "originalCommit": "8c3c0a5bf0059aabbb01eff285911c46dca211af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b459cbc0cb5cf5586c796fe882b427eadc03d0d5", "url": "https://github.com/openhab/openhab-core/commit/b459cbc0cb5cf5586c796fe882b427eadc03d0d5", "message": "[REST Auth] API tokens & openhab:users console command\n\nThis adds API tokens as a new credential type. Their format is:\n`oh.<name>.<random chars>`\n\nThe \"oh.\" prefix is used to tell them apart from a JWT access token,\nbecause they're both used as a Bearer authorization scheme, but there\nis no semantic value attached to any of the other parts.\n\nThey are stored hashed in the user's profile, and can be listed, added\nor removed managed with the new `openhab:users` console command.\n\nCurrently the scopes are still not checked, but ultimately they could\nbe, for instance a scope of e.g. `user admin.items` would mean that the\nAPI token can be used to perform user operations like retrieving info\nor sending a command, _and_ managing the items, but nothing else -\neven if the user has more permissions because of their role (which\nwill of course still be checked).\n\nTokens are normally passed in the Authorization header with the Bearer\nscheme, or the X-OPENHAB-TOKEN header, like access tokens.\nAs a special exception, API tokens can also be used with the Basic\nauthorization scheme, **even if the allowBasicAuth** option is not\nenabled in the \"API Security\" service, because there's no additional\nsecurity risk in allowing that. In that case, the token should be\npassed as the username and the password MUST be empty.\n\nIn short, this means that all these curl commands will work:\n- `curl -H 'Authorization: Bearer <token>' http://localhost:8080/rest/inbox`\n- `curl -H 'X-OPENHAB-TOKEN: <token>' http://localhost:8080/rest/inbox`\n- `curl -u '<token>[:]' http://localhost:8080/rest/inbox`\n- `curl http://<token>@localhost:8080/rest/inbox`\n\n2 REST API operations were adding to the AuthResource, to allow\nauthenticated users to list their tokens or remove (revoke) one.\nSelf-service for creating a token or changing the password is more\nsensitive so these should be handled with a servlet and pages devoid\nof any JavaScript instead of REST API calls, therefore for now they'll\nhave to be done with the console.\n\nThis also fixes regressions introduced with #1713 - the operations\nannotated with @RolesAllowed({ Role.USER }) only were not authorized\nfor administrators anymore.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-20T15:06:55Z", "type": "commit"}, {"oid": "9d099c7694f8c5ea46551a4c36c9a12a2e9429b1", "url": "https://github.com/openhab/openhab-core/commit/9d099c7694f8c5ea46551a4c36c9a12a2e9429b1", "message": "Generate a unique salt for each token\n\nReusing the password salt is bad practice, and changing the\npassword changes the salt as well which makes all tokens\ninvalid.\n\nPut the salt in the same field as the hash (concatenated\nwith a separator) to avoid modifying the JSON DB schema.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-20T15:06:56Z", "type": "commit"}, {"oid": "fe67008e945d1a696a32105ac3bbbb212ab7c33b", "url": "https://github.com/openhab/openhab-core/commit/fe67008e945d1a696a32105ac3bbbb212ab7c33b", "message": "Fix API token authentication, make scope available to security context\n\nThe X-OPENHAB-TOKEN header now has priority over the Authorization\nheader to credentials, if both are set.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-20T15:48:05Z", "type": "commit"}, {"oid": "fe67008e945d1a696a32105ac3bbbb212ab7c33b", "url": "https://github.com/openhab/openhab-core/commit/fe67008e945d1a696a32105ac3bbbb212ab7c33b", "message": "Fix API token authentication, make scope available to security context\n\nThe X-OPENHAB-TOKEN header now has priority over the Authorization\nheader to credentials, if both are set.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-20T15:48:05Z", "type": "forcePushed"}, {"oid": "07de0ce0460ccb872e7b09af09575a2c67c39691", "url": "https://github.com/openhab/openhab-core/commit/07de0ce0460ccb872e7b09af09575a2c67c39691", "message": "Add self-service pages to change password & create new API token\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-20T18:10:33Z", "type": "commit"}, {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "url": "https://github.com/openhab/openhab-core/commit/6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "message": "Fix SAT error\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-20T18:38:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODQ4Mw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509738483", "bodyText": "Usually List.of(..) can be used instead of  Arrays.asList(new String[] {}) in Java 11.", "author": "wborn", "createdAt": "2020-10-21T22:00:46Z", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5NjMyNg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510196326", "bodyText": "I see there's inconsistencies in the other CommandExtensions:\n\n  \n    \n      openhab-core/bundles/org.openhab.core.voice/src/main/java/org/openhab/core/voice/internal/VoiceConsoleCommandExtension.java\n    \n    \n        Lines 65 to 68\n      in\n      5d75bce\n    \n    \n    \n    \n\n        \n          \n           public List<String> getUsages() { \n        \n\n        \n          \n               return List.of(buildCommandUsage(SUBCMD_SAY + \" <text>\", \"speaks a text\"), \n        \n\n        \n          \n                       buildCommandUsage(SUBCMD_INTERPRET + \" <command>\", \"interprets a human language command\"), \n        \n\n        \n          \n                       buildCommandUsage(SUBCMD_VOICES, \"lists available voices of the TTS services\")); \n        \n    \n  \n\n\n\n  \n    \n      openhab-core/bundles/org.openhab.core.audio/src/main/java/org/openhab/core/audio/internal/AudioConsoleCommandExtension.java\n    \n    \n        Lines 66 to 69\n      in\n      5d75bce\n    \n    \n    \n    \n\n        \n          \n           public List<String> getUsages() { \n        \n\n        \n          \n               return Arrays.asList(new String[] { \n        \n\n        \n          \n                       buildCommandUsage(SUBCMD_PLAY + \" [<sink>] <filename>\", \n        \n\n        \n          \n                               \"plays a sound file from the sounds folder through the optionally specified audio sink(s)\"), \n        \n    \n  \n\n\nI happened to take the code from the AudioConsoleCommandExtension :) But I will change it to List.of nonetheless.", "author": "ghys", "createdAt": "2020-10-22T14:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczOTkzNQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509739935", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (managedUser.getApiTokens().size() > 0) {\n          \n          \n            \n                                    if (!managedUser.getApiTokens().isEmpty()) {", "author": "wborn", "createdAt": "2020-10-21T22:02:37Z", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MDc1Ng==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509740756", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        managedUser.getApiTokens().forEach(t -> {\n          \n          \n            \n                                            console.println(\"user=\" + user.toString() + \", \" + t.toString());\n          \n          \n            \n                                        });\n          \n          \n            \n                                        managedUser.getApiTokens().forEach(t -> console.println(\"user=\" + user.toString() + \", \" + t.toString()));", "author": "wborn", "createdAt": "2020-10-21T22:03:55Z", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTI4Ng==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509741286", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected Instant lastAuthenticationFailure;\n          \n          \n            \n                protected @Nullable Instant lastAuthenticationFailure;", "author": "wborn", "createdAt": "2020-10-21T22:04:43Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTUxNw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509741517", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n          \n          \n            \n                protected Map<String, Instant> csrfTokens = new HashMap<>();", "author": "wborn", "createdAt": "2020-10-21T22:05:04Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NTc2Mg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509745762", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "author": "wborn", "createdAt": "2020-10-21T22:12:22Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NjE3NQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509746175", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "author": "wborn", "createdAt": "2020-10-21T22:12:48Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzAwNw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509747007", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "author": "wborn", "createdAt": "2020-10-21T22:13:56Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509747482", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "author": "wborn", "createdAt": "2020-10-21T22:14:26Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MTY4Mw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509791683", "bodyText": "This is against what was decided before. Otherwise using @NonNullByDefault({}) would also be possible for mandatory config fields or the config itself of set in the thing handler\u2019s initialize(). The decision was to only use the @NonNullByDefault({})-annotation for injected ressources of the OSGi-framework.", "author": "J-N-K", "createdAt": "2020-10-21T23:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk2NTY5OA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509965698", "bodyText": "The agreed upon guidelines don't mention anything about how to deal with annotating classes that implement methods from unannotated classes.\nThese issues also did not occur previously because we did not annotate classes with @NonNullByDefault({}) if they were overriding methods from unannotated classes.\nIf there were EEAs for this dependency, these parameters would probably be analyzed to be @NonNull so in that case it makes more sense to use @NonNullByDefault({}) which would prevent these unnecessary null checks.\nAnother case not mentioned in the guidelines is how to deal with generics. The @NonNullByDefault({}) defined on classes is not used by the analysis for generic types. So in that case the only way to make them non-null is by annotating the generic types with @NonNull, see for example the AbstractRegistry.", "author": "wborn", "createdAt": "2020-10-22T08:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509756574", "bodyText": "I think it would be helpful to print it. The UI also informs users of this.", "author": "wborn", "createdAt": "2020-10-21T22:25:19Z", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5Mjk1OA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510092958", "bodyText": "Is it even true the tokens cannot be retrieved?\nI see there is a command to list them:\nopenhab:users listApiTokens - lists the API keys for all users", "author": "wborn", "createdAt": "2020-10-22T11:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5MzAzNA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510193034", "bodyText": "I think it would be helpful to print it. The UI also informs users of this.\n\nI don't know, in the end I figured it's best to leave the command ouputs as no-frills as possible, in case the output is redirected to a file/piped to another command. The admin who masters these commands is supposed to know that it's the only opportunity to save the token.\n\nI see there is a command to list them\n\nYou only see the metadata like below, but not the actual token (and you can't even retrieve it from the JSON DB since it's not stored in plain text):\nopenhab> openhab:users listApiTokens\nuser=ysc (administrator), name=service1, createdTime=Mon Oct 19 20:17:40 CEST 2020, scope=admin\nuser=ysc (administrator), name=service2, createdTime=Mon Oct 19 20:17:46 CEST 2020, scope=admin\nuser=ysc (administrator), name=service3, createdTime=Mon Oct 19 20:17:50 CEST 2020, scope=admin", "author": "ghys", "createdAt": "2020-10-22T14:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDg1OQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510270859", "bodyText": "Great! \ud83d\udc4d I didn't have time to compile and execute the command myself or figure out if it was hashed or plain text when I made the comment. Otherwise the next comment would have been to hash it. \ud83d\ude09", "author": "wborn", "createdAt": "2020-10-22T15:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NTQ2OQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510485469", "bodyText": "I don't know, in the end I figured it's best to leave the command ouputs as no-frills as possible, in case the output is redirected to a file/piped to another command. The admin who masters these commands is supposed to know that it's the only opportunity to save the token.\n\nThen the question has been answered and we should remove the comment. :-)", "author": "wborn", "createdAt": "2020-10-22T22:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNzQ5Nw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510537497", "bodyText": "I still wanted to hear opinions about this ;) Done now.", "author": "ghys", "createdAt": "2020-10-23T00:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MDYzNQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509770635", "bodyText": "You might want to use a try-with-resources statement here to be sure the stream is always closed.", "author": "wborn", "createdAt": "2020-10-21T22:39:50Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509772332", "bodyText": "You could add a helpful message here what file could not be opened.\nDo these kind of authentication related exceptions also show in the browser or only in logging?", "author": "wborn", "createdAt": "2020-10-21T22:43:29Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NzI0Ng==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510257246", "bodyText": "This is only when the page cannot be loaded from the bundle resources, I don't think it will ever happen. I didn't know how to handle this exception, any suggestion is welcome.\nIn general authentication failures are logged but not shown in detail to the user on the webpage (it only says \"Please try again\") because you don't want to divulge too much (i.e. does the account exist, and only the password is wrong, etc.).", "author": "ghys", "createdAt": "2020-10-22T15:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4MjkwOA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510482908", "bodyText": "You'll run into this whenever one day the file is deleted/renamed or moved to another directory.\nSo I would add a message to the exception that it cannot open \"pages/authorize.html\".\nOr if there is something wrong with the storage or permissions.", "author": "wborn", "createdAt": "2020-10-22T22:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3ODYzNg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509778636", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n          \n          \n            \n                        logger.error(\"Error during change password page registration: {}\", e.getMessage());", "author": "wborn", "createdAt": "2020-10-21T22:51:41Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDQ0MA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780440", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"username\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"username\")) {", "author": "wborn", "createdAt": "2020-10-21T22:53:59Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDcxMg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780712", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"password\")) {", "author": "wborn", "createdAt": "2020-10-21T22:54:22Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDkzMQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780931", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"new_password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"new_password\")) {", "author": "wborn", "createdAt": "2020-10-21T22:54:36Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"new_password\"))) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTUwNw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509781507", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    responseBody = responseBody.replace(\"{formClass}\", (hideForm) ? \"hide\" : \"show\");\n          \n          \n            \n                    responseBody = responseBody.replace(\"{formClass}\", hideForm ? \"hide\" : \"show\");", "author": "wborn", "createdAt": "2020-10-21T22:55:28Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"new_password\"))) {\n+                    throw new AuthenticationException(\"no new password\");\n+                }\n+                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                    throw new AuthenticationException(\"CSRF check failed\");\n+                }\n+\n+                removeCsrfToken(params.get(\"csrf_token\")[0]);\n+\n+                String username = params.get(\"username\")[0];\n+                String password = params.get(\"password\")[0];\n+                String newPassword = params.get(\"new_password\")[0];\n+\n+                if (!params.containsKey(\"password_repeat\") || !newPassword.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n+                }\n+\n+                User user = login(username, password);\n+\n+                if (user instanceof ManagedUser) {\n+                    userRegistry.changePassword(user, newPassword);\n+                } else {\n+                    throw new AuthenticationException(\"User is not managed\");\n+                }\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getResultPageBody(params, \"Password changed.\")); // TODO: i18n\n+                resp.getWriter().close();\n+            } catch (AuthenticationException e) {\n+                processFailedLogin(resp, params, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n+        String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n+        String buttonLabel = \"Change Password\"; // TODO: i18n\n+        responseBody = responseBody.replace(\"{message}\", message);\n+        responseBody = responseBody.replace(\"{formAction}\", \"/changePassword\");\n+        responseBody = responseBody.replace(\"{formClass}\", (hideForm) ? \"hide\" : \"show\");", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjAwNg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"username\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"username\")) {", "author": "wborn", "createdAt": "2020-10-21T22:56:55Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjA2Ng==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782066", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"password\")) {", "author": "wborn", "createdAt": "2020-10-21T22:57:05Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjEzMA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"token_name\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"token_name\")) {", "author": "wborn", "createdAt": "2020-10-21T22:57:15Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"token_name\"))) {", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTIxNA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785214", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "author": "wborn", "createdAt": "2020-10-21T23:05:54Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTI0Mg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785242", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "author": "wborn", "createdAt": "2020-10-21T23:06:00Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTMwMA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785300", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "author": "wborn", "createdAt": "2020-10-21T23:06:11Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTMyNg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785326", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "author": "wborn", "createdAt": "2020-10-21T23:06:15Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTM3MA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785370", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "author": "wborn", "createdAt": "2020-10-21T23:06:20Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                .filter(apiToken -> apiToken.getName().equals(name)).findAny();\n+        if (userApiToken.isEmpty()) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"No API token found with that name\");", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njc2Mg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        User user = this.get(usernamePasswordCreds.getUsername());\n          \n          \n            \n                        User user = get(usernamePasswordCreds.getUsername());", "author": "wborn", "createdAt": "2020-10-21T23:10:44Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjgzOA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "author": "wborn", "createdAt": "2020-10-21T23:10:57Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njg3Nw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786877", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "author": "wborn", "createdAt": "2020-10-21T23:11:05Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjkyMQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786921", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "author": "wborn", "createdAt": "2020-10-21T23:11:14Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njk3OA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786978", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "author": "wborn", "createdAt": "2020-10-21T23:11:24Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzAyNg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509787026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "author": "wborn", "createdAt": "2020-10-21T23:11:32Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public String addUserApiToken(User user, String name, String scope) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+        if (!name.matches(\"[a-zA-Z0-9]*\")) {\n+            throw new IllegalArgumentException(\"API token name format invalid, alphanumeric characters only\");\n         }\n \n-        Authentication authentication = new Authentication(managedUser.getName());\n-        return authentication;\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String tokenSalt = generateSalt(KEY_LENGTH / 8).get();\n+        byte[] rnd = new byte[64];\n+        RAND.nextBytes(rnd);\n+        String token = APITOKEN_PREFIX + \".\" + name + \".\"\n+                + Base64.getEncoder().encodeToString(rnd).replaceAll(\"(\\\\+|/|=)\", \"\");\n+        String tokenHash = hash(token, tokenSalt, APITOKEN_ITERATIONS).get();\n+\n+        UserApiToken userApiToken = new UserApiToken(name, tokenHash + \":\" + tokenSalt, scope);\n+\n+        managedUser.getApiTokens().add(userApiToken);\n+        this.update(user);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzExMg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509787112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "author": "wborn", "createdAt": "2020-10-21T23:11:45Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public String addUserApiToken(User user, String name, String scope) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+        if (!name.matches(\"[a-zA-Z0-9]*\")) {\n+            throw new IllegalArgumentException(\"API token name format invalid, alphanumeric characters only\");\n         }\n \n-        Authentication authentication = new Authentication(managedUser.getName());\n-        return authentication;\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String tokenSalt = generateSalt(KEY_LENGTH / 8).get();\n+        byte[] rnd = new byte[64];\n+        RAND.nextBytes(rnd);\n+        String token = APITOKEN_PREFIX + \".\" + name + \".\"\n+                + Base64.getEncoder().encodeToString(rnd).replaceAll(\"(\\\\+|/|=)\", \"\");\n+        String tokenHash = hash(token, tokenSalt, APITOKEN_ITERATIONS).get();\n+\n+        UserApiToken userApiToken = new UserApiToken(name, tokenHash + \":\" + tokenSalt, scope);\n+\n+        managedUser.getApiTokens().add(userApiToken);\n+        this.update(user);\n+\n+        return token;\n+    }\n+\n+    @Override\n+    public void removeUserApiToken(User user, UserApiToken userApiToken) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getApiTokens().remove(userApiToken);\n+        this.update(user);", "originalCommit": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ea523afb6804cd8674fd1a31805ab4939698db3a", "url": "https://github.com/openhab/openhab-core/commit/ea523afb6804cd8674fd1a31805ab4939698db3a", "message": "Address review comments\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-22T15:26:11Z", "type": "commit"}, {"oid": "62c4e6f4278093449966c9b5d13d733d4a30824e", "url": "https://github.com/openhab/openhab-core/commit/62c4e6f4278093449966c9b5d13d733d4a30824e", "message": "Missing closing paren\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-22T15:34:33Z", "type": "commit"}, {"oid": "f051da17a1892a50746392ce911944bfaab3ac27", "url": "https://github.com/openhab/openhab-core/commit/f051da17a1892a50746392ce911944bfaab3ac27", "message": "Fix error message when token name doesn't match pattern\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-22T15:36:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NDEwMQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510484101", "bodyText": "These checks can be removed now.", "author": "wborn", "createdAt": "2020-10-22T22:03:18Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -57,43 +56,41 @@ public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpSer\n         try {\n             httpService.registerServlet(\"/changePassword\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n-            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+            logger.error(\"Error during change password page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message, false));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n-            }\n+        try {\n+            String message = \"\";\n+\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n         if (req != null && resp != null) {", "originalCommit": "ea523afb6804cd8674fd1a31805ab4939698db3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjE2NQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486165", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (!(\"code\".equals(responseType))) {\n          \n          \n            \n                        if (!\"code\".equals(responseType)) {", "author": "wborn", "createdAt": "2020-10-22T22:08:37Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjM4Ng==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n          \n          \n            \n                            String codeChallenge = params.containsKey(\"code_challenge\") ? params.get(\"code_challenge\")[0] : null;", "author": "wborn", "createdAt": "2020-10-22T22:09:10Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjQ5Mg==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486492", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n          \n          \n            \n                            String codeChallengeMethod = params.containsKey(\"code_challenge_method\")", "author": "wborn", "createdAt": "2020-10-22T22:09:25Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjY1NA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486654", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n          \n          \n            \n                    String repeatPasswordFieldType = isSignupMode() ? \"password\" : \"hidden\";", "author": "wborn", "createdAt": "2020-10-22T22:09:53Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjgwNw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486807", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n\n          \n          \n            \n                    String buttonLabel = isSignupMode() ? \"Create Account\" : \"Sign In\"; // TODO: i18n", "author": "wborn", "createdAt": "2020-10-22T22:10:15Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n         String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Njk0Nw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486947", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!params.containsKey((\"redirect_uri\"))) {\n          \n          \n            \n                    if (!params.containsKey(\"redirect_uri\")) {", "author": "wborn", "createdAt": "2020-10-22T22:10:33Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n         String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n\n         responseBody = responseBody.replace(\"{message}\", message);\n+        responseBody = responseBody.replace(\"{formAction}\", \"/auth\");\n+        responseBody = responseBody.replace(\"{formClass}\", \"show\");\n         responseBody = responseBody.replace(\"{repeatPasswordFieldType}\", repeatPasswordFieldType);\n+        responseBody = responseBody.replace(\"{newPasswordFieldType}\", \"hidden\");\n+        responseBody = responseBody.replace(\"{tokenNameFieldType}\", \"hidden\");\n+        responseBody = responseBody.replace(\"{tokenScopeFieldType}\", \"hidden\");\n         responseBody = responseBody.replace(\"{buttonLabel}\", buttonLabel);\n+        responseBody = responseBody.replace(\"{resultClass}\", \"\");\n         return responseBody;\n     }\n \n-    private String getFormFields(Map<String, String[]> params) {\n+    @Override\n+    protected String getFormFields(Map<String, String[]> params) {\n         String hiddenFormFields = \"\";\n \n         if (!params.containsKey((\"redirect_uri\"))) {", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Nzg3MA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510487870", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]), scope);\n          \n          \n            \n                        return auth;\n          \n          \n            \n                        return new Authentication(username, roles.toArray(new String[roles.size()]), scope);", "author": "wborn", "createdAt": "2020-10-22T22:13:05Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/JwtHelper.java", "diffHunk": "@@ -150,7 +149,8 @@ public Authentication verifyAndParseJwtAccessToken(String jwt) throws Authentica\n             JwtClaims jwtClaims = jwtConsumer.processToClaims(jwt);\n             String username = jwtClaims.getSubject();\n             List<String> roles = jwtClaims.getStringListClaimValue(\"role\");\n-            Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]));\n+            String scope = jwtClaims.getStringClaimValue(\"scope\");\n+            Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]), scope);\n             return auth;", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4ODU4OA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510488588", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param the new password hash\n          \n          \n            \n                 * @param passwordHash the new password hash", "author": "wborn", "createdAt": "2020-10-22T22:14:56Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/ManagedUser.java", "diffHunk": "@@ -59,6 +59,24 @@ public String getPasswordHash() {\n         return passwordHash;\n     }\n \n+    /**\n+     * Alters the password salt.\n+     *\n+     * @param passwordSalt the new password salt\n+     */\n+    public void setPasswordSalt(String passwordSalt) {\n+        this.passwordSalt = passwordSalt;\n+    }\n+\n+    /**\n+     * Alters the password hash.\n+     *\n+     * @param the new password hash", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4ODk4NQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510488985", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param password the new password\n          \n          \n            \n                 * @param newPassword the new password", "author": "wborn", "createdAt": "2020-10-22T22:15:54Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/UserRegistry.java", "diffHunk": "@@ -38,4 +38,55 @@\n      * @return the new registered {@link User} instance\n      */\n     public User register(String username, String password, Set<String> roles);\n+\n+    /**\n+     * Change the password for an {@link User} in this registry. The implementation receives the new password and is\n+     * responsible for their secure storage (for instance by hashing the password).\n+     *\n+     * @param username the username of the existing user\n+     * @param password the new password", "originalCommit": "f051da17a1892a50746392ce911944bfaab3ac27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b", "url": "https://github.com/openhab/openhab-core/commit/0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b", "message": "Address more review comments\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-23T00:51:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511106888", "bodyText": "That's probably because I am not very careful :) \ud83d\ude44", "author": "ghys", "createdAt": "2020-10-23T19:28:48Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "originalCommit": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTExNDcyOQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511114729", "bodyText": "(and, admittedly, not too big on unit tests...)", "author": "ghys", "createdAt": "2020-10-23T19:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyNDc5OQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511124799", "bodyText": "Yes that explains!", "author": "wborn", "createdAt": "2020-10-23T19:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyOTQ5Mw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511129493", "bodyText": "I also noticed the test coverage is lacking on such critical code. But I'm OK with that if you promise to make up for that in a follow up PR. \ud83d\ude09", "author": "wborn", "createdAt": "2020-10-23T20:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzMyNQ==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511167325", "bodyText": "No time like the present, I added some test coverage to the UserRegistryImpl :)", "author": "ghys", "createdAt": "2020-10-23T21:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMzc4Mw==", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511333783", "bodyText": "That's even better. \ud83d\udc4d I sometimes run out of time myself too to add them while very enthusiastically implementing lots of new functionalities. \ud83d\ude04", "author": "wborn", "createdAt": "2020-10-24T07:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}], "type": "inlineReview"}, {"oid": "d5bf4a4eb4954709e9d373500e1d1631c8b0a142", "url": "https://github.com/openhab/openhab-core/commit/d5bf4a4eb4954709e9d373500e1d1631c8b0a142", "message": "Fix removeUserSession in UserRegistryImpl\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-23T19:30:24Z", "type": "commit"}, {"oid": "e486af4c668f1015b47170bebad0a6018b1a17d2", "url": "https://github.com/openhab/openhab-core/commit/e486af4c668f1015b47170bebad0a6018b1a17d2", "message": "Add UserRegistryImplTest\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-23T21:36:11Z", "type": "commit"}, {"oid": "ef5f4a75bec594e654861d7596b7a56164074038", "url": "https://github.com/openhab/openhab-core/commit/ef5f4a75bec594e654861d7596b7a56164074038", "message": "Fix null annotations warnings in TokenResource\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-10-25T09:51:33Z", "type": "commit"}]}