{"pr_number": 1389, "pr_title": "Implementation of a JWT-based OAuth2 flow for the admin API", "pr_createdAt": "2020-03-10T23:37:09Z", "pr_url": "https://github.com/openhab/openhab-core/pull/1389", "timeline": [{"oid": "b872042c000b2c7274833d4219b6c2148fbd82ee", "url": "https://github.com/openhab/openhab-core/commit/b872042c000b2c7274833d4219b6c2148fbd82ee", "message": "Initial implementation of a JWT-based OAuth2 flow for the admin API\n\nImplements #1388.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-10T23:36:29Z", "type": "commit"}, {"oid": "cc396fc58232be8f24bad866c554232446f8f563", "url": "https://github.com/openhab/openhab-core/commit/cc396fc58232be8f24bad866c554232446f8f563", "message": "Improve token issuing & session management\n\n- Allow the use of a support cookie to mitigate leaking\nof refresh tokens stored in the browser with XSS\nattacks. The flow is still OAuth2 but the client can\nmake the server set an http-only cookie with the\nsession ID, which will be checked when the refresh\ntoken is used to get another access token.\nThis cookie can also be used for certain servlets\n(/proxy, /icon...) without an access_token to get\nthe user session, if the risks of CSRF are acceptable.\n\n- Prevent leaking exceptions to the client when the token\nis invalid\n\n- Improve logging\n\n- Detect api_key query parameters from the swagger UI\n\n- Improvements to the authorize page: confirm the password\nwhen creating the first account, sanitize some user input,\nimprove messages\n\n- Add logout (session removal) endpoint\n\n- Add checks yo improve conformity to RFC 6749\n\n- Adjust some RoleAllowed annotations\n\n- Reduce JWS key size from RS512 to RS256\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-13T09:58:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE1MTAwNA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r392151004", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new RuntimeException(e);\n          \n          \n            \n                                throw new UncheckedIOException(e);", "author": "Hilbrand", "createdAt": "2020-03-13T10:40:20Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.apache.commons.httpclient.HttpStatus;\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class AuthorizePageServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n+\n+    private HashSet<String> csrfTokens = new HashSet<>();\n+\n+    private HttpService httpService;\n+    private UserRegistry userRegistry;\n+    private AuthenticationProvider authProvider;\n+\n+    private String pageTemplate;\n+\n+    @Activate\n+    public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        try {\n+            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+            if (resource != null) {\n+                try {\n+                    pageTemplate = IOUtils.toString(resource.openStream());\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);", "originalCommit": "cc396fc58232be8f24bad866c554232446f8f563", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c1c129c586397672c03eeadb1b23887601c83c9d", "url": "https://github.com/openhab/openhab-core/commit/c1c129c586397672c03eeadb1b23887601c83c9d", "message": "Try fixing features\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-13T11:26:47Z", "type": "commit"}, {"oid": "0e51f98dba3b908ccde1b054e7ecc87bc1dbfc87", "url": "https://github.com/openhab/openhab-core/commit/0e51f98dba3b908ccde1b054e7ecc87bc1dbfc87", "message": "Add Javadoc, minor & cosmetic fixes\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-13T13:16:09Z", "type": "commit"}, {"oid": "aa87b921b83e0ace9ba42923d24f9f7e7bbc4c79", "url": "https://github.com/openhab/openhab-core/commit/aa87b921b83e0ace9ba42923d24f9f7e7bbc4c79", "message": "Fix SAT error (and 1 warning)\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-13T13:38:55Z", "type": "commit"}, {"oid": "8ee6905075371aba10644f10bf8e30c17d206fd8", "url": "https://github.com/openhab/openhab-core/commit/8ee6905075371aba10644f10bf8e30c17d206fd8", "message": "Add support for PKCE (RFC 7636)\n\nSupport X-OPENHAB-TOKEN headers as alternative header\nfor the token if the X-OPENHAB-AUTH-HEADER is set\n(whatever its value). This is helpful when the\nAuthorization header is already used by a reverse\nproxy or openHAB Cloud/myopenhab.org. It can then\nset a X-OPENHAB-AUTH-HEADER cookie which must be\nvisible to the JavaScript (i.e. no HttpOnly) which\nshould then pass the token in the alternative header.\n\nAdd authenticated session list endpoint\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-14T13:57:59Z", "type": "commit"}, {"oid": "5851c2120be9719c8c302b664c37dba16b188acd", "url": "https://github.com/openhab/openhab-core/commit/5851c2120be9719c8c302b664c37dba16b188acd", "message": "Add Karaf integration for the UserRegistry login module\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-18T18:55:59Z", "type": "commit"}, {"oid": "5851c2120be9719c8c302b664c37dba16b188acd", "url": "https://github.com/openhab/openhab-core/commit/5851c2120be9719c8c302b664c37dba16b188acd", "message": "Add Karaf integration for the UserRegistry login module\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-18T18:55:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NzM1NA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395897354", "bodyText": "As this class is a component, why don't you simply declare this as a service dependency?", "author": "kaikreuzer", "createdAt": "2020-03-20T21:26:29Z", "path": "bundles/org.openhab.core.auth.jaas/src/main/java/org/openhab/core/auth/jaas/internal/ManagedUserLoginModule.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.auth.jaas.internal;\n+\n+import java.util.Map;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.login.LoginException;\n+import javax.security.auth.spi.LoginModule;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.ServiceReference;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This {@link LoginModule} delegates the authentication to a {@link UserRegistry}\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@Component(service = LoginModule.class, property = { \"jaas.realmName=openhab\" })\n+public class ManagedUserLoginModule implements LoginModule {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ManagedUserLoginModule.class);\n+\n+    private UserRegistry userRegistry;\n+\n+    @Nullable\n+    private Subject subject;\n+\n+    @Nullable\n+    private User user;\n+\n+    @Override\n+    public void initialize(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState,\n+            Map<String, ?> options) {\n+        this.subject = subject;\n+    }\n+\n+    @Override\n+    public boolean login() throws LoginException {\n+        try {\n+            // try to get the UserRegistry instance\n+            BundleContext bundleContext = FrameworkUtil.getBundle(UserRegistry.class).getBundleContext();\n+            ServiceReference<UserRegistry> serviceReference = bundleContext.getServiceReference(UserRegistry.class);", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk4ODExMg==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395988112", "bodyText": "Actually it's instantiated by the JAAS framework for each login (I learned that during development) so I now wonder whether there's a good reason for it to keep being a component at all - I'll check and remove the annotation in that case.", "author": "ghys", "createdAt": "2020-03-21T12:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwMTIyMQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395901221", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-03-20T21:37:50Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.apache.commons.httpclient.HttpStatus;\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving the authorization page part of the OAuth2 authorization code flow.\n+ *\n+ * The page can register the first administrator account when there are no users yet in the {@link UserRegistry}, and\n+ * authenticates the user otherwise. It also presents the scope that is about to be granted to the client, so the user\n+ * can review what kind of access is being authorized. If successful, it redirects the client back to the URI which was\n+ * specified and creates an authorization code stored for later in the user's profile.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class AuthorizePageServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n+\n+    private HashSet<String> csrfTokens = new HashSet<>();\n+\n+    private HttpService httpService;\n+    private UserRegistry userRegistry;\n+    private AuthenticationProvider authProvider;\n+\n+    private String pageTemplate;\n+\n+    @Activate\n+    public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        try {\n+            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+            if (resource != null) {\n+                try {\n+                    pageTemplate = IOUtils.toString(resource.openStream());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+                httpService.registerServlet(\"/auth\", this, null, null);\n+            }\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+\n+                // Basic sanity check\n+                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                    throw new IllegalArgumentException(\"invalid_request\");\n+                }\n+\n+                // TODO: i18n\n+                if (isSignupMode()) {\n+                    message = \"Create a first administrator account to continue.\";\n+                } else {\n+                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n+                }\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey(\"csrf_token\") || !csrfTokens.contains(params.get(\"csrf_token\")[0])) {\n+                    throw new AuthenticationException(\"CSRF check failed\");\n+                }\n+                if (!params.containsKey((\"redirect_uri\"))) {\n+                    throw new IllegalArgumentException(\"invalid_request\");\n+                }\n+                if (!params.containsKey((\"response_type\"))) {\n+                    throw new IllegalArgumentException(\"unsupported_response_type\");\n+                }\n+                if (!params.containsKey((\"client_id\"))) {\n+                    throw new IllegalArgumentException(\"unauthorized_client\");\n+                }\n+                if (!params.containsKey((\"scope\"))) {\n+                    throw new IllegalArgumentException(\"invalid_scope\");\n+                }\n+                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+                String responseType = params.get(\"response_type\")[0];\n+                String clientId = params.get(\"redirect_uri\")[0];\n+                String scope = params.get(\"scope\")[0];\n+\n+                if (!(\"code\".equals(responseType))) {\n+                    throw new AuthenticationException(\"unsupported_response_type\");\n+                }\n+\n+                if (!clientId.equals(baseRedirectUri)) {\n+                    throw new IllegalArgumentException(\"unauthorized_client\");\n+                }\n+\n+                String username = params.get(\"username\")[0];\n+                String password = params.get(\"password\")[0];\n+\n+                User user;\n+                if (isSignupMode()) {\n+                    // Create a first administrator account with the supplied credentials\n+\n+                    // first verify the password confirmation and bail out if necessary\n+                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                        resp.setContentType(\"text/html;charset=UTF-8\");\n+                        // TODO: i18n\n+                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n+                        resp.getWriter().close();\n+                        return;\n+                    }\n+\n+                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                    logger.info(\"First user account created: {}\", username);\n+                } else {\n+                    // Authenticate the user with the supplied credentials\n+                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n+                    Authentication auth = authProvider.authenticate(credentials);\n+                    logger.debug(\"Login successful: {}\", auth.getUsername());\n+                    user = userRegistry.get(auth.getUsername());\n+                }\n+\n+                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+                if (user instanceof ManagedUser) {\n+                    String state = (params.containsKey(\"state\")) ? params.get(\"state\")[0] : null;\n+                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n+                            : null;\n+                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                            ? params.get(\"code_challenge_method\")[0]\n+                            : null;\n+                    ManagedUser managedUser = (ManagedUser) user;\n+                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                            codeChallenge, codeChallengeMethod);\n+                    managedUser.setPendingToken(pendingToken);\n+                    userRegistry.update(managedUser);\n+                }\n+\n+                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                resp.setStatus(HttpStatus.SC_MOVED_TEMPORARILY);\n+", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwMTkxOA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395901918", "bodyText": "Would we maybe want to have a failure counter, so that we can artificially delay further attempts to avoid brute force attacks?", "author": "kaikreuzer", "createdAt": "2020-03-20T21:39:55Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.apache.commons.httpclient.HttpStatus;\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving the authorization page part of the OAuth2 authorization code flow.\n+ *\n+ * The page can register the first administrator account when there are no users yet in the {@link UserRegistry}, and\n+ * authenticates the user otherwise. It also presents the scope that is about to be granted to the client, so the user\n+ * can review what kind of access is being authorized. If successful, it redirects the client back to the URI which was\n+ * specified and creates an authorization code stored for later in the user's profile.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class AuthorizePageServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n+\n+    private HashSet<String> csrfTokens = new HashSet<>();\n+\n+    private HttpService httpService;\n+    private UserRegistry userRegistry;\n+    private AuthenticationProvider authProvider;\n+\n+    private String pageTemplate;\n+\n+    @Activate\n+    public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        try {\n+            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+            if (resource != null) {\n+                try {\n+                    pageTemplate = IOUtils.toString(resource.openStream());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+                httpService.registerServlet(\"/auth\", this, null, null);\n+            }\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+\n+                // Basic sanity check\n+                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                    throw new IllegalArgumentException(\"invalid_request\");\n+                }\n+\n+                // TODO: i18n\n+                if (isSignupMode()) {\n+                    message = \"Create a first administrator account to continue.\";\n+                } else {\n+                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n+                }\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey(\"csrf_token\") || !csrfTokens.contains(params.get(\"csrf_token\")[0])) {\n+                    throw new AuthenticationException(\"CSRF check failed\");\n+                }\n+                if (!params.containsKey((\"redirect_uri\"))) {\n+                    throw new IllegalArgumentException(\"invalid_request\");\n+                }\n+                if (!params.containsKey((\"response_type\"))) {\n+                    throw new IllegalArgumentException(\"unsupported_response_type\");\n+                }\n+                if (!params.containsKey((\"client_id\"))) {\n+                    throw new IllegalArgumentException(\"unauthorized_client\");\n+                }\n+                if (!params.containsKey((\"scope\"))) {\n+                    throw new IllegalArgumentException(\"invalid_scope\");\n+                }\n+                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+                String responseType = params.get(\"response_type\")[0];\n+                String clientId = params.get(\"redirect_uri\")[0];\n+                String scope = params.get(\"scope\")[0];\n+\n+                if (!(\"code\".equals(responseType))) {\n+                    throw new AuthenticationException(\"unsupported_response_type\");\n+                }\n+\n+                if (!clientId.equals(baseRedirectUri)) {\n+                    throw new IllegalArgumentException(\"unauthorized_client\");\n+                }\n+\n+                String username = params.get(\"username\")[0];\n+                String password = params.get(\"password\")[0];\n+\n+                User user;\n+                if (isSignupMode()) {\n+                    // Create a first administrator account with the supplied credentials\n+\n+                    // first verify the password confirmation and bail out if necessary\n+                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                        resp.setContentType(\"text/html;charset=UTF-8\");\n+                        // TODO: i18n\n+                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n+                        resp.getWriter().close();\n+                        return;\n+                    }\n+\n+                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                    logger.info(\"First user account created: {}\", username);\n+                } else {\n+                    // Authenticate the user with the supplied credentials\n+                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n+                    Authentication auth = authProvider.authenticate(credentials);\n+                    logger.debug(\"Login successful: {}\", auth.getUsername());\n+                    user = userRegistry.get(auth.getUsername());\n+                }\n+\n+                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+                if (user instanceof ManagedUser) {\n+                    String state = (params.containsKey(\"state\")) ? params.get(\"state\")[0] : null;\n+                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n+                            : null;\n+                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                            ? params.get(\"code_challenge_method\")[0]\n+                            : null;\n+                    ManagedUser managedUser = (ManagedUser) user;\n+                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                            codeChallenge, codeChallengeMethod);\n+                    managedUser.setPendingToken(pendingToken);\n+                    userRegistry.update(managedUser);\n+                }\n+\n+                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                resp.setStatus(HttpStatus.SC_MOVED_TEMPORARILY);\n+\n+            } catch (AuthenticationException e) {\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                logger.warn(\"Authentication failed: {}\", e.getMessage());\n+                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk4ODEzOQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395988139", "bodyText": "Good idea.", "author": "ghys", "createdAt": "2020-03-21T12:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwMTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwMzE3Mw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395903173", "bodyText": "Shouldn't the tokens automatically be removed from the set after a while (or once they were used)? It seems you keep them indefinitely right now.", "author": "kaikreuzer", "createdAt": "2020-03-20T21:43:45Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.apache.commons.httpclient.HttpStatus;\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving the authorization page part of the OAuth2 authorization code flow.\n+ *\n+ * The page can register the first administrator account when there are no users yet in the {@link UserRegistry}, and\n+ * authenticates the user otherwise. It also presents the scope that is about to be granted to the client, so the user\n+ * can review what kind of access is being authorized. If successful, it redirects the client back to the URI which was\n+ * specified and creates an authorization code stored for later in the user's profile.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class AuthorizePageServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n+\n+    private HashSet<String> csrfTokens = new HashSet<>();", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk4ODE2MA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395988160", "bodyText": "Thought about that too and then forgot, thanks ;)", "author": "ghys", "createdAt": "2020-03-21T12:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwMzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNTQ5OA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395905498", "bodyText": "This is a bit hacky as swagger should actually have an \"apiToken\" (which isn't yet implemented) instead of treating the passed api_key as an access token. Bot ok for me for the time being.", "author": "kaikreuzer", "createdAt": "2020-03-20T21:50:52Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.Priority;\n+import javax.security.sasl.AuthenticationException;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.Priorities;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.container.ContainerRequestFilter;\n+import javax.ws.rs.container.PreMatching;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.ext.Provider;\n+\n+import org.openhab.core.auth.Authentication;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * This filter is responsible for parsing a token provided with a request, and hydrating a {@link SecurityContext} from\n+ * the claims contained in the token.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@PreMatching\n+@Priority(Priorities.AUTHENTICATION)\n+@Provider\n+@Component(immediate = true, service = AuthFilter.class)\n+public class AuthFilter implements ContainerRequestFilter {\n+    private static final String COOKIE_AUTH_HEADER = \"X-OPENHAB-AUTH-HEADER\";\n+    private static final String ALT_AUTH_HEADER = \"X-OPENHAB-TOKEN\";\n+\n+    @Reference\n+    private JwtHelper jwtHelper;\n+\n+    @Override\n+    public void filter(ContainerRequestContext requestContext) throws IOException {\n+        try {\n+            String authHeader = requestContext.getHeaderString(HttpHeaders.AUTHORIZATION);\n+\n+            if (authHeader != null) {\n+                String[] authParts = authHeader.split(\" \");\n+                if (authParts.length == 2) {\n+                    if (\"Bearer\".equals(authParts[0])) {\n+                        Authentication auth = jwtHelper.verifyAndParseJwtAccessToken(authParts[1]);\n+                        requestContext.setSecurityContext(new JwtSecurityContext(auth));\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            if (requestContext.getCookies().containsKey(COOKIE_AUTH_HEADER)) {\n+                String altTokenHeader = requestContext.getHeaderString(ALT_AUTH_HEADER);\n+                if (altTokenHeader != null) {\n+                    Authentication auth = jwtHelper.verifyAndParseJwtAccessToken(altTokenHeader);\n+                    requestContext.setSecurityContext(new JwtSecurityContext(auth));\n+                    return;\n+                }\n+            }\n+\n+            // support the api_key query parameter of the Swagger UI\n+            if (requestContext.getUriInfo().getRequestUri().toString().contains(\"api_key=\")) {", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk4ODUyOQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395988529", "bodyText": "The API tokens will probably simply be access tokens (or very similar) only with a long lifetime, so there is no change in behavior whether they're access tokens or API tokens. But maybe a better idea could be to try to patch the Swagger UI - if possible - to make it put the access token in a HTTP header instead of handling this specific case. (That's what I did in another project)", "author": "ghys", "createdAt": "2020-03-21T12:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNjI5OQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395906299", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Creating new JWT signature key\");\n          \n          \n            \n                        return generateNewKey();\n          \n          \n            \n                        RsaJsonWebKey key = generateNewKey();\n          \n          \n            \n                        logger.info(\"Created JWT signature key.\");\n          \n          \n            \n                        return key;", "author": "kaikreuzer", "createdAt": "2020-03-20T21:53:13Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/JwtHelper.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.security.sasl.AuthenticationException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.jose4j.jwa.AlgorithmConstraints.ConstraintType;\n+import org.jose4j.jwk.JsonWebKey;\n+import org.jose4j.jwk.JsonWebKey.OutputControlLevel;\n+import org.jose4j.jwk.RsaJsonWebKey;\n+import org.jose4j.jwk.RsaJwkGenerator;\n+import org.jose4j.jws.AlgorithmIdentifiers;\n+import org.jose4j.jws.JsonWebSignature;\n+import org.jose4j.jwt.JwtClaims;\n+import org.jose4j.jwt.consumer.JwtConsumer;\n+import org.jose4j.jwt.consumer.JwtConsumerBuilder;\n+import org.jose4j.lang.JoseException;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.config.core.ConfigConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class helps with JWT tokens' building, signing, verifying and parsing.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = JwtHelper.class)\n+public class JwtHelper {\n+    private final Logger logger = LoggerFactory.getLogger(JwtHelper.class);\n+\n+    private static final String KEY_FILE_PATH = ConfigConstants.getUserDataFolder() + File.separator + \"secrets\"\n+            + File.separator + \"rsa_json_web_key.json\";\n+\n+    private static final String ISSUER_NAME = \"openhab\";\n+    private static final String AUDIENCE = \"openhab\";\n+\n+    private RsaJsonWebKey jwtWebKey;\n+\n+    public JwtHelper() {\n+        try {\n+            jwtWebKey = loadOrGenerateKey();\n+        } catch (Exception e) {\n+            logger.error(\"Error while initializing the JWT helper\", e);\n+            throw new RuntimeException(e.getMessage());\n+        }\n+    }\n+\n+    private RsaJsonWebKey generateNewKey() throws JoseException, FileNotFoundException, IOException {\n+        RsaJsonWebKey newKey = RsaJwkGenerator.generateJwk(2048);\n+\n+        File file = new File(KEY_FILE_PATH);\n+        file.getParentFile().mkdirs();\n+\n+        String keyJson = newKey.toJson(OutputControlLevel.INCLUDE_PRIVATE);\n+\n+        IOUtils.write(keyJson, new FileOutputStream(file));\n+        return newKey;\n+    }\n+\n+    private RsaJsonWebKey loadOrGenerateKey() throws FileNotFoundException, JoseException, IOException {\n+        try {\n+            List<String> lines = IOUtils.readLines(new FileInputStream(KEY_FILE_PATH));\n+            return (RsaJsonWebKey) JsonWebKey.Factory.newJwk(lines.get(0));\n+        } catch (IOException | JoseException e) {\n+            logger.info(\"Creating new JWT signature key\");\n+            return generateNewKey();", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNzM3Ng==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395907376", "bodyText": "Please add a new line at the end of every new class.", "author": "kaikreuzer", "createdAt": "2020-03-20T21:56:34Z", "path": "bundles/org.openhab.core.auth.jaas/src/main/java/org/openhab/core/auth/jaas/internal/ManagedUserLoginConfiguration.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.auth.jaas.internal;\n+\n+import java.util.HashMap;\n+\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;\n+import javax.security.auth.login.Configuration;\n+\n+/**\n+ * Describes a JAAS configuration with the {@link ManagedUserLoginModule} as a sufficient login module.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+public class ManagedUserLoginConfiguration extends Configuration {\n+\n+    @Override\n+    public AppConfigurationEntry[] getAppConfigurationEntry(String name) {\n+        return new AppConfigurationEntry[] { new AppConfigurationEntry(ManagedUserLoginModule.class.getCanonicalName(),\n+                LoginModuleControlFlag.SUFFICIENT, new HashMap<String, Object>()) };\n+    }\n+\n+}", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExODM1Mw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396118353", "bodyText": "Sorry - not sure what's wrong here?", "author": "ghys", "createdAt": "2020-03-22T17:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNzM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0NDE0Nw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396144147", "bodyText": "the SAT tooling checks for a new carriage return at the end of the last line of every file and will show you a warning, if it isn't present. See also https://unix.stackexchange.com/questions/18743/whats-the-point-in-adding-a-new-line-to-the-end-of-a-file.", "author": "kaikreuzer", "createdAt": "2020-03-22T21:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNzM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE2MjA3Ng==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396162076", "bodyText": "I get that, but as far as I can see here there's one :) Do you have SAT complaining?", "author": "ghys", "createdAt": "2020-03-22T23:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNzM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc2OTgzMA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396769830", "bodyText": "Err, well - then better forget my comment \ud83d\ude07 .", "author": "kaikreuzer", "createdAt": "2020-03-23T21:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNzM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNzkzNg==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395907936", "bodyText": "Why don't you set this through the constructor as well, just like the other two services?", "author": "kaikreuzer", "createdAt": "2020-03-20T21:58:20Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwODEyNg==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395908126", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.warn(\"Couldn't find an user with the provided authentication code pending\");\n          \n          \n            \n                                    logger.warn(\"Couldn't find a user with the provided authentication code pending\");", "author": "kaikreuzer", "createdAt": "2020-03-20T21:58:48Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending\n+                    Optional<User> user = userRegistry.getAll().stream()\n+                            .filter(u -> ((ManagedUser) u).getPendingToken() != null\n+                                    && ((ManagedUser) u).getPendingToken().getAuthorizationCode().equals(code))\n+                            .findAny();\n+\n+                    if (!user.isPresent()) {\n+                        logger.warn(\"Couldn't find an user with the provided authentication code pending\");", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwODk3Mg==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395908972", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.warn(\"client_id doesn't match pending token information\");\n          \n          \n            \n                                    logger.warn(\"client_id '{}' doesn't match pending token information '{}'\", clientId, pendingToken.getClientId());", "author": "kaikreuzer", "createdAt": "2020-03-20T22:01:39Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending\n+                    Optional<User> user = userRegistry.getAll().stream()\n+                            .filter(u -> ((ManagedUser) u).getPendingToken() != null\n+                                    && ((ManagedUser) u).getPendingToken().getAuthorizationCode().equals(code))\n+                            .findAny();\n+\n+                    if (!user.isPresent()) {\n+                        logger.warn(\"Couldn't find an user with the provided authentication code pending\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    ManagedUser managedUser = (ManagedUser) user.get();\n+                    PendingToken pendingToken = managedUser.getPendingToken();\n+                    if (pendingToken == null) {\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getClientId().equals(clientId)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTIwMw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395909203", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.warn(\"client_id doesn't match pending token information\");\n          \n          \n            \n                                    logger.warn(\"redirect_url '{}' doesn't match pending token information '{}'\", redirectUri, pendingToken.getRedirectUri());", "author": "kaikreuzer", "createdAt": "2020-03-20T22:02:28Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending\n+                    Optional<User> user = userRegistry.getAll().stream()\n+                            .filter(u -> ((ManagedUser) u).getPendingToken() != null\n+                                    && ((ManagedUser) u).getPendingToken().getAuthorizationCode().equals(code))\n+                            .findAny();\n+\n+                    if (!user.isPresent()) {\n+                        logger.warn(\"Couldn't find an user with the provided authentication code pending\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    ManagedUser managedUser = (ManagedUser) user.get();\n+                    PendingToken pendingToken = managedUser.getPendingToken();\n+                    if (pendingToken == null) {\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getClientId().equals(clientId)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getRedirectUri().equals(redirectUri)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTQ2MA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395909460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            logger.warn(\"PKCE transformation algorithm not found\");\n          \n          \n            \n                                            logger.warn(\"PKCE transformation algorithm '{}' not found\", codeChallengeMethod);", "author": "kaikreuzer", "createdAt": "2020-03-20T22:03:15Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending\n+                    Optional<User> user = userRegistry.getAll().stream()\n+                            .filter(u -> ((ManagedUser) u).getPendingToken() != null\n+                                    && ((ManagedUser) u).getPendingToken().getAuthorizationCode().equals(code))\n+                            .findAny();\n+\n+                    if (!user.isPresent()) {\n+                        logger.warn(\"Couldn't find an user with the provided authentication code pending\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    ManagedUser managedUser = (ManagedUser) user.get();\n+                    PendingToken pendingToken = managedUser.getPendingToken();\n+                    if (pendingToken == null) {\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getClientId().equals(clientId)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getRedirectUri().equals(redirectUri)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    // create a new session ID and refresh token\n+                    String sessionId = UUID.randomUUID().toString();\n+                    String newRefreshToken = UUID.randomUUID().toString().replace(\"-\", \"\");\n+                    String scope = pendingToken.getScope();\n+\n+                    // if there is PKCE information in the pending token, check that first\n+                    String codeChallengeMethod = pendingToken.getCodeChallengeMethod();\n+                    if (codeChallengeMethod != null) {\n+                        String codeChallenge = pendingToken.getCodeChallenge();\n+                        if (codeChallenge == null || codeVerifier == null) {\n+                            logger.warn(\"the PKCE code challenge or code verifier information is missing\");\n+                            throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                        }\n+                        switch (codeChallengeMethod) {\n+                            case \"plain\":\n+                                if (!codeVerifier.equals(codeChallenge)) {\n+                                    logger.warn(\"PKCE verification failed\");\n+                                    throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                                }\n+                                break;\n+                            case \"S256\":\n+                                MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n+                                String computedCodeChallenge = Base64Url\n+                                        .encode(sha256Digest.digest(codeVerifier.getBytes()));\n+                                if (!computedCodeChallenge.equals(codeChallenge)) {\n+                                    logger.warn(\"PKCE verification failed\");\n+                                    throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                                }\n+                                break;\n+                            default:\n+                                logger.warn(\"PKCE transformation algorithm not found\");", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTYyOA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395909628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // if the client has requested a http-only cookie for the session, set it\n          \n          \n            \n                                // if the client has requested an http-only cookie for the session, set it", "author": "kaikreuzer", "createdAt": "2020-03-20T22:03:49Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending\n+                    Optional<User> user = userRegistry.getAll().stream()\n+                            .filter(u -> ((ManagedUser) u).getPendingToken() != null\n+                                    && ((ManagedUser) u).getPendingToken().getAuthorizationCode().equals(code))\n+                            .findAny();\n+\n+                    if (!user.isPresent()) {\n+                        logger.warn(\"Couldn't find an user with the provided authentication code pending\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    ManagedUser managedUser = (ManagedUser) user.get();\n+                    PendingToken pendingToken = managedUser.getPendingToken();\n+                    if (pendingToken == null) {\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getClientId().equals(clientId)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getRedirectUri().equals(redirectUri)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    // create a new session ID and refresh token\n+                    String sessionId = UUID.randomUUID().toString();\n+                    String newRefreshToken = UUID.randomUUID().toString().replace(\"-\", \"\");\n+                    String scope = pendingToken.getScope();\n+\n+                    // if there is PKCE information in the pending token, check that first\n+                    String codeChallengeMethod = pendingToken.getCodeChallengeMethod();\n+                    if (codeChallengeMethod != null) {\n+                        String codeChallenge = pendingToken.getCodeChallenge();\n+                        if (codeChallenge == null || codeVerifier == null) {\n+                            logger.warn(\"the PKCE code challenge or code verifier information is missing\");\n+                            throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                        }\n+                        switch (codeChallengeMethod) {\n+                            case \"plain\":\n+                                if (!codeVerifier.equals(codeChallenge)) {\n+                                    logger.warn(\"PKCE verification failed\");\n+                                    throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                                }\n+                                break;\n+                            case \"S256\":\n+                                MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n+                                String computedCodeChallenge = Base64Url\n+                                        .encode(sha256Digest.digest(codeVerifier.getBytes()));\n+                                if (!computedCodeChallenge.equals(codeChallenge)) {\n+                                    logger.warn(\"PKCE verification failed\");\n+                                    throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                                }\n+                                break;\n+                            default:\n+                                logger.warn(\"PKCE transformation algorithm not found\");\n+                                throw new TokenEndpointException(ErrorType.INVALID_REQUEST);\n+                        }\n+                    }\n+\n+                    // create an access token\n+                    String accessToken = jwtHelper.getJwtAccessToken(managedUser, clientId, scope);\n+\n+                    UserSession newSession = new UserSession(sessionId, newRefreshToken, clientId, redirectUri, scope);\n+\n+                    ResponseBuilder response = Response\n+                            .ok(new TokenResponseDTO(accessToken, \"bearer\", 3600, newRefreshToken, scope, managedUser));\n+\n+                    // if the client has requested a http-only cookie for the session, set it", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMDM2Ng==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395910366", "bodyText": "Hell, these are many lines of code for this case of the switch statement - it would be much nicer to move this codeblock to a separate method.", "author": "kaikreuzer", "createdAt": "2020-03-20T22:06:28Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMDQ4Mw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395910483", "bodyText": "move codeblock to a separate method as well", "author": "kaikreuzer", "createdAt": "2020-03-20T22:07:00Z", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.auth.internal;\n+\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.jose4j.base64url.Base64Url;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.PendingToken;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UserSession;\n+import org.openhab.core.io.rest.RESTResource;\n+import org.openhab.core.io.rest.Stream2JSONInputStream;\n+import org.openhab.core.io.rest.auth.internal.TokenEndpointException.ErrorType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * This class is used to issue JWT tokens to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Path(TokenResource.PATH_AUTH)\n+@Api(value = TokenResource.PATH_AUTH)\n+@Component(service = { RESTResource.class, TokenResource.class })\n+public class TokenResource implements RESTResource {\n+    private final Logger logger = LoggerFactory.getLogger(TokenResource.class);\n+\n+    /** The URI path to this resource */\n+    public static final String PATH_AUTH = \"auth\";\n+\n+    /** The name of the HTTP-only cookie holding the session ID */\n+    public static final String SESSIONID_COOKIE_NAME = \"X-OPENHAB-SESSIONID\";\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Reference\n+    private AuthenticationProvider authenticationProvider;\n+\n+    private UserRegistry userRegistry;\n+\n+    private JwtHelper jwtHelper;\n+\n+    @Activate\n+    public TokenResource(final @Reference UserRegistry userRegistry, final @Reference JwtHelper jwtHelper) {\n+        this.userRegistry = userRegistry;\n+        this.jwtHelper = jwtHelper;\n+    }\n+\n+    @POST\n+    @Path(\"/token\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    @Consumes({ MediaType.APPLICATION_FORM_URLENCODED })\n+    @ApiOperation(value = \"Get access and refresh tokens.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Response getToken(@FormParam(\"grant_type\") String grantType, @FormParam(\"code\") String code,\n+            @FormParam(\"redirect_uri\") String redirectUri, @FormParam(\"client_id\") String clientId,\n+            @FormParam(\"refresh_token\") String refreshToken, @FormParam(\"code_verifier\") String codeVerifier,\n+            @QueryParam(\"useCookie\") boolean useCookie, @CookieParam(SESSIONID_COOKIE_NAME) Cookie sessionCookie) {\n+        try {\n+            switch (grantType) {\n+                case \"authorization_code\":\n+                    // find an user with the authorization code pending\n+                    Optional<User> user = userRegistry.getAll().stream()\n+                            .filter(u -> ((ManagedUser) u).getPendingToken() != null\n+                                    && ((ManagedUser) u).getPendingToken().getAuthorizationCode().equals(code))\n+                            .findAny();\n+\n+                    if (!user.isPresent()) {\n+                        logger.warn(\"Couldn't find an user with the provided authentication code pending\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    ManagedUser managedUser = (ManagedUser) user.get();\n+                    PendingToken pendingToken = managedUser.getPendingToken();\n+                    if (pendingToken == null) {\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getClientId().equals(clientId)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+                    if (!pendingToken.getRedirectUri().equals(redirectUri)) {\n+                        logger.warn(\"client_id doesn't match pending token information\");\n+                        throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                    }\n+\n+                    // create a new session ID and refresh token\n+                    String sessionId = UUID.randomUUID().toString();\n+                    String newRefreshToken = UUID.randomUUID().toString().replace(\"-\", \"\");\n+                    String scope = pendingToken.getScope();\n+\n+                    // if there is PKCE information in the pending token, check that first\n+                    String codeChallengeMethod = pendingToken.getCodeChallengeMethod();\n+                    if (codeChallengeMethod != null) {\n+                        String codeChallenge = pendingToken.getCodeChallenge();\n+                        if (codeChallenge == null || codeVerifier == null) {\n+                            logger.warn(\"the PKCE code challenge or code verifier information is missing\");\n+                            throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                        }\n+                        switch (codeChallengeMethod) {\n+                            case \"plain\":\n+                                if (!codeVerifier.equals(codeChallenge)) {\n+                                    logger.warn(\"PKCE verification failed\");\n+                                    throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                                }\n+                                break;\n+                            case \"S256\":\n+                                MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n+                                String computedCodeChallenge = Base64Url\n+                                        .encode(sha256Digest.digest(codeVerifier.getBytes()));\n+                                if (!computedCodeChallenge.equals(codeChallenge)) {\n+                                    logger.warn(\"PKCE verification failed\");\n+                                    throw new TokenEndpointException(ErrorType.INVALID_GRANT);\n+                                }\n+                                break;\n+                            default:\n+                                logger.warn(\"PKCE transformation algorithm not found\");\n+                                throw new TokenEndpointException(ErrorType.INVALID_REQUEST);\n+                        }\n+                    }\n+\n+                    // create an access token\n+                    String accessToken = jwtHelper.getJwtAccessToken(managedUser, clientId, scope);\n+\n+                    UserSession newSession = new UserSession(sessionId, newRefreshToken, clientId, redirectUri, scope);\n+\n+                    ResponseBuilder response = Response\n+                            .ok(new TokenResponseDTO(accessToken, \"bearer\", 3600, newRefreshToken, scope, managedUser));\n+\n+                    // if the client has requested a http-only cookie for the session, set it\n+                    if (useCookie) {\n+                        try {\n+                            // this feature is only available for root redirect URIs: the targeted client is the main\n+                            // UI; even though the cookie will be set for the entire domain (i.e. no path) so that\n+                            // other servlets can make use of it\n+                            URI domainUri = new URI(redirectUri);\n+                            if (!(\"\".equals(domainUri.getPath()) || \"/\".equals(domainUri.getPath()))) {\n+                                throw new IllegalArgumentException(\n+                                        \"Will not honor the request to set a session cookie for this client, because it's only allowed for root redirect URIs\");\n+                            }\n+                            NewCookie newCookie = new NewCookie(SESSIONID_COOKIE_NAME, sessionId, \"/\",\n+                                    domainUri.getHost(), null, 2147483647, false, true);\n+                            response.cookie(newCookie);\n+\n+                            // also mark the session as supported by a cookie\n+                            newSession.setSessionCookie(true);\n+                        } catch (Exception e) {\n+                            logger.warn(\"Error while setting a session cookie: {}\", e.getMessage());\n+                            throw new TokenEndpointException(ErrorType.UNAUTHORIZED_CLIENT);\n+                        }\n+                    }\n+\n+                    // add the new session to the user profile and clear the pending token information\n+                    managedUser.getSessions().add(newSession);\n+                    managedUser.setPendingToken(null);\n+                    userRegistry.update(managedUser);\n+\n+                    return response.build();\n+\n+                case \"refresh_token\":\n+                    if (refreshToken == null) {", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMTg2MQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395911861", "bodyText": "could that maybe be debug only?", "author": "kaikreuzer", "createdAt": "2020-03-20T22:11:57Z", "path": "bundles/org.openhab.core.karaf/src/main/java/org/openhab/core/karaf/internal/jaas/ManagedUserRealm.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.karaf.internal.jaas;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.inject.Singleton;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;\n+import javax.security.auth.spi.LoginModule;\n+\n+import org.apache.karaf.jaas.boot.ProxyLoginModule;\n+import org.apache.karaf.jaas.config.JaasRealm;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A JAAS realm description for the {@link UserRegistry} based login module.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@Singleton\n+@Component(service = JaasRealm.class)\n+@Service\n+public class ManagedUserRealm implements JaasRealm {\n+\n+    public static final String REALM_NAME = \"openhab\";\n+    public static final String MODULE_CLASS = \"org.openhab.core.auth.jaas.internal.ManagedUserLoginModule\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ManagedUserRealm.class);\n+\n+    BundleContext bundleContext;\n+\n+    @Activate\n+    public ManagedUserRealm(BundleContext bundleContext, @Reference LoginModule loginModule) {\n+        this.bundleContext = bundleContext;\n+        logger.info(\"Using login module {} for the openhab realm\", loginModule.getClass().getCanonicalName());", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMTk1OA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395911958", "bodyText": "can this be removed?", "author": "kaikreuzer", "createdAt": "2020-03-20T22:12:16Z", "path": "bundles/org.openhab.core.karaf/src/main/java/org/openhab/core/karaf/internal/jaas/ManagedUserRealm.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.karaf.internal.jaas;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.inject.Singleton;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;\n+import javax.security.auth.spi.LoginModule;\n+\n+import org.apache.karaf.jaas.boot.ProxyLoginModule;\n+import org.apache.karaf.jaas.config.JaasRealm;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A JAAS realm description for the {@link UserRegistry} based login module.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@Singleton\n+@Component(service = JaasRealm.class)\n+@Service\n+public class ManagedUserRealm implements JaasRealm {\n+\n+    public static final String REALM_NAME = \"openhab\";\n+    public static final String MODULE_CLASS = \"org.openhab.core.auth.jaas.internal.ManagedUserLoginModule\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ManagedUserRealm.class);\n+\n+    BundleContext bundleContext;\n+\n+    @Activate\n+    public ManagedUserRealm(BundleContext bundleContext, @Reference LoginModule loginModule) {\n+        this.bundleContext = bundleContext;\n+        logger.info(\"Using login module {} for the openhab realm\", loginModule.getClass().getCanonicalName());\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return REALM_NAME;\n+    }\n+\n+    @Override\n+    public int getRank() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public AppConfigurationEntry[] getEntries() {\n+        Map<String, Object> options = new HashMap<>();\n+        options.put(ProxyLoginModule.PROPERTY_MODULE, MODULE_CLASS);\n+        // options.put(ProxyLoginModule.PROPERTY_BUNDLE, bundleContext.getBundle().getBundleId());", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk4ODc2OA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395988768", "bodyText": "I wasn't sure if it was needed, but it seems to do fine without it. And it's not correct anyway because the login module is in the org.openhab.core.auth.jaas bundle, not this one. I'll remove it.", "author": "ghys", "createdAt": "2020-03-21T12:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMzc1MA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395913750", "bodyText": "this does not seem to be used anywhere", "author": "kaikreuzer", "createdAt": "2020-03-20T22:18:25Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.auth;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserProvider;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.openhab.core.common.registry.AbstractRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implementation of a {@link UserRegistry} for {@link ManagedUser} entities.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UserRegistry.class, immediate = true)\n+public class UserRegistryImpl extends AbstractRegistry<User, String, UserProvider> implements UserRegistry {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UserRegistryImpl.class);\n+\n+    private static final int ITERATIONS = 65536;\n+    private static final int KEY_LENGTH = 512;\n+    private static final String ALGORITHM = \"PBKDF2WithHmacSHA512\";\n+\n+    private int rank = 0;", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMzkwOQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395913909", "bodyText": "Is this code doing anything or can it be removed?", "author": "kaikreuzer", "createdAt": "2020-03-20T22:18:54Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.auth;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserProvider;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.openhab.core.common.registry.AbstractRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implementation of a {@link UserRegistry} for {@link ManagedUser} entities.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UserRegistry.class, immediate = true)\n+public class UserRegistryImpl extends AbstractRegistry<User, String, UserProvider> implements UserRegistry {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UserRegistryImpl.class);\n+\n+    private static final int ITERATIONS = 65536;\n+    private static final int KEY_LENGTH = 512;\n+    private static final String ALGORITHM = \"PBKDF2WithHmacSHA512\";\n+\n+    private int rank = 0;\n+\n+    private static final SecureRandom RAND = new SecureRandom();\n+\n+    @Activate\n+    public UserRegistryImpl(BundleContext context, Map<String, Object> properties) {\n+        super(UserProvider.class);\n+        super.activate(context);\n+\n+        Object serviceRanking = properties.get(Constants.SERVICE_RANKING);\n+        if (serviceRanking instanceof Integer) {\n+            rank = (Integer) serviceRanking;\n+        } else {\n+            rank = 1; // takes precedence over other providers usually ranked 0\n+        }", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNDE1Mg==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395914152", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-03-20T22:19:43Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.auth;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserProvider;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.openhab.core.common.registry.AbstractRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implementation of a {@link UserRegistry} for {@link ManagedUser} entities.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UserRegistry.class, immediate = true)\n+public class UserRegistryImpl extends AbstractRegistry<User, String, UserProvider> implements UserRegistry {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UserRegistryImpl.class);\n+\n+    private static final int ITERATIONS = 65536;\n+    private static final int KEY_LENGTH = 512;\n+    private static final String ALGORITHM = \"PBKDF2WithHmacSHA512\";\n+\n+    private int rank = 0;\n+\n+    private static final SecureRandom RAND = new SecureRandom();\n+\n+    @Activate\n+    public UserRegistryImpl(BundleContext context, Map<String, Object> properties) {\n+        super(UserProvider.class);\n+        super.activate(context);\n+\n+        Object serviceRanking = properties.get(Constants.SERVICE_RANKING);\n+        if (serviceRanking instanceof Integer) {\n+            rank = (Integer) serviceRanking;\n+        } else {\n+            rank = 1; // takes precedence over other providers usually ranked 0\n+        }\n+    }\n+\n+    @Override\n+    @Deactivate\n+    protected void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n+    protected void setManagedProvider(ManagedUserProvider managedProvider) {\n+        super.setManagedProvider(managedProvider);\n+        super.addProvider(managedProvider);\n+    }\n+\n+    protected void unsetManagedProvider(ManagedUserProvider managedProvider) {\n+        super.unsetManagedProvider(managedProvider);\n+        super.removeProvider(managedProvider);\n+    }\n+\n+    @Override\n+    public User register(String username, String password, Set<String> roles) {\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hashPassword(password, passwordSalt).get();\n+        ManagedUser user = new ManagedUser(username, passwordSalt, passwordHash);\n+        user.setRoles(new HashSet<>(roles));\n+        super.add(user);\n+        return user;\n+    }\n+\n+    private Optional<String> generateSalt(final int length) {\n+", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNDMyNA==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395914324", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-03-20T22:20:18Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.auth;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserProvider;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.openhab.core.common.registry.AbstractRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implementation of a {@link UserRegistry} for {@link ManagedUser} entities.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UserRegistry.class, immediate = true)\n+public class UserRegistryImpl extends AbstractRegistry<User, String, UserProvider> implements UserRegistry {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UserRegistryImpl.class);\n+\n+    private static final int ITERATIONS = 65536;\n+    private static final int KEY_LENGTH = 512;\n+    private static final String ALGORITHM = \"PBKDF2WithHmacSHA512\";\n+\n+    private int rank = 0;\n+\n+    private static final SecureRandom RAND = new SecureRandom();\n+\n+    @Activate\n+    public UserRegistryImpl(BundleContext context, Map<String, Object> properties) {\n+        super(UserProvider.class);\n+        super.activate(context);\n+\n+        Object serviceRanking = properties.get(Constants.SERVICE_RANKING);\n+        if (serviceRanking instanceof Integer) {\n+            rank = (Integer) serviceRanking;\n+        } else {\n+            rank = 1; // takes precedence over other providers usually ranked 0\n+        }\n+    }\n+\n+    @Override\n+    @Deactivate\n+    protected void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n+    protected void setManagedProvider(ManagedUserProvider managedProvider) {\n+        super.setManagedProvider(managedProvider);\n+        super.addProvider(managedProvider);\n+    }\n+\n+    protected void unsetManagedProvider(ManagedUserProvider managedProvider) {\n+        super.unsetManagedProvider(managedProvider);\n+        super.removeProvider(managedProvider);\n+    }\n+\n+    @Override\n+    public User register(String username, String password, Set<String> roles) {\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hashPassword(password, passwordSalt).get();\n+        ManagedUser user = new ManagedUser(username, passwordSalt, passwordHash);\n+        user.setRoles(new HashSet<>(roles));\n+        super.add(user);\n+        return user;\n+    }\n+\n+    private Optional<String> generateSalt(final int length) {\n+\n+        if (length < 1) {\n+            logger.error(\"error in generateSalt: length must be > 0\");\n+            return Optional.empty();\n+        }\n+\n+        byte[] salt = new byte[length];\n+        RAND.nextBytes(salt);\n+\n+        return Optional.of(Base64.getEncoder().encodeToString(salt));\n+    }\n+\n+    private Optional<String> hashPassword(String password, String salt) {\n+", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNDM3OQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395914379", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-03-20T22:20:29Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.auth;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserProvider;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.openhab.core.common.registry.AbstractRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implementation of a {@link UserRegistry} for {@link ManagedUser} entities.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UserRegistry.class, immediate = true)\n+public class UserRegistryImpl extends AbstractRegistry<User, String, UserProvider> implements UserRegistry {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UserRegistryImpl.class);\n+\n+    private static final int ITERATIONS = 65536;\n+    private static final int KEY_LENGTH = 512;\n+    private static final String ALGORITHM = \"PBKDF2WithHmacSHA512\";\n+\n+    private int rank = 0;\n+\n+    private static final SecureRandom RAND = new SecureRandom();\n+\n+    @Activate\n+    public UserRegistryImpl(BundleContext context, Map<String, Object> properties) {\n+        super(UserProvider.class);\n+        super.activate(context);\n+\n+        Object serviceRanking = properties.get(Constants.SERVICE_RANKING);\n+        if (serviceRanking instanceof Integer) {\n+            rank = (Integer) serviceRanking;\n+        } else {\n+            rank = 1; // takes precedence over other providers usually ranked 0\n+        }\n+    }\n+\n+    @Override\n+    @Deactivate\n+    protected void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n+    protected void setManagedProvider(ManagedUserProvider managedProvider) {\n+        super.setManagedProvider(managedProvider);\n+        super.addProvider(managedProvider);\n+    }\n+\n+    protected void unsetManagedProvider(ManagedUserProvider managedProvider) {\n+        super.unsetManagedProvider(managedProvider);\n+        super.removeProvider(managedProvider);\n+    }\n+\n+    @Override\n+    public User register(String username, String password, Set<String> roles) {\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hashPassword(password, passwordSalt).get();\n+        ManagedUser user = new ManagedUser(username, passwordSalt, passwordHash);\n+        user.setRoles(new HashSet<>(roles));\n+        super.add(user);\n+        return user;\n+    }\n+\n+    private Optional<String> generateSalt(final int length) {\n+\n+        if (length < 1) {\n+            logger.error(\"error in generateSalt: length must be > 0\");\n+            return Optional.empty();\n+        }\n+\n+        byte[] salt = new byte[length];\n+        RAND.nextBytes(salt);\n+\n+        return Optional.of(Base64.getEncoder().encodeToString(salt));\n+    }\n+\n+    private Optional<String> hashPassword(String password, String salt) {\n+\n+        char[] chars = password.toCharArray();\n+        byte[] bytes = salt.getBytes();\n+\n+        PBEKeySpec spec = new PBEKeySpec(chars, bytes, ITERATIONS, KEY_LENGTH);\n+\n+        Arrays.fill(chars, Character.MIN_VALUE);\n+\n+        try {\n+            SecretKeyFactory fac = SecretKeyFactory.getInstance(ALGORITHM);\n+            byte[] securePassword = fac.generateSecret(spec).getEncoded();\n+            return Optional.of(Base64.getEncoder().encodeToString(securePassword));\n+", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNDQxMQ==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r395914411", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-03-20T22:20:37Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.auth;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.Credentials;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserProvider;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.openhab.core.common.registry.AbstractRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implementation of a {@link UserRegistry} for {@link ManagedUser} entities.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UserRegistry.class, immediate = true)\n+public class UserRegistryImpl extends AbstractRegistry<User, String, UserProvider> implements UserRegistry {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UserRegistryImpl.class);\n+\n+    private static final int ITERATIONS = 65536;\n+    private static final int KEY_LENGTH = 512;\n+    private static final String ALGORITHM = \"PBKDF2WithHmacSHA512\";\n+\n+    private int rank = 0;\n+\n+    private static final SecureRandom RAND = new SecureRandom();\n+\n+    @Activate\n+    public UserRegistryImpl(BundleContext context, Map<String, Object> properties) {\n+        super(UserProvider.class);\n+        super.activate(context);\n+\n+        Object serviceRanking = properties.get(Constants.SERVICE_RANKING);\n+        if (serviceRanking instanceof Integer) {\n+            rank = (Integer) serviceRanking;\n+        } else {\n+            rank = 1; // takes precedence over other providers usually ranked 0\n+        }\n+    }\n+\n+    @Override\n+    @Deactivate\n+    protected void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n+    protected void setManagedProvider(ManagedUserProvider managedProvider) {\n+        super.setManagedProvider(managedProvider);\n+        super.addProvider(managedProvider);\n+    }\n+\n+    protected void unsetManagedProvider(ManagedUserProvider managedProvider) {\n+        super.unsetManagedProvider(managedProvider);\n+        super.removeProvider(managedProvider);\n+    }\n+\n+    @Override\n+    public User register(String username, String password, Set<String> roles) {\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hashPassword(password, passwordSalt).get();\n+        ManagedUser user = new ManagedUser(username, passwordSalt, passwordHash);\n+        user.setRoles(new HashSet<>(roles));\n+        super.add(user);\n+        return user;\n+    }\n+\n+    private Optional<String> generateSalt(final int length) {\n+\n+        if (length < 1) {\n+            logger.error(\"error in generateSalt: length must be > 0\");\n+            return Optional.empty();\n+        }\n+\n+        byte[] salt = new byte[length];\n+        RAND.nextBytes(salt);\n+\n+        return Optional.of(Base64.getEncoder().encodeToString(salt));\n+    }\n+\n+    private Optional<String> hashPassword(String password, String salt) {\n+\n+        char[] chars = password.toCharArray();\n+        byte[] bytes = salt.getBytes();\n+\n+        PBEKeySpec spec = new PBEKeySpec(chars, bytes, ITERATIONS, KEY_LENGTH);\n+\n+        Arrays.fill(chars, Character.MIN_VALUE);\n+\n+        try {\n+            SecretKeyFactory fac = SecretKeyFactory.getInstance(ALGORITHM);\n+            byte[] securePassword = fac.generateSecret(spec).getEncoded();\n+            return Optional.of(Base64.getEncoder().encodeToString(securePassword));\n+\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            logger.error(\"Exception encountered in hashPassword\", e);\n+            return Optional.empty();\n+", "originalCommit": "5851c2120be9719c8c302b664c37dba16b188acd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f9fc64be606fb09d53ab081270c109dfe8065fed", "url": "https://github.com/openhab/openhab-core/commit/f9fc64be606fb09d53ab081270c109dfe8065fed", "message": "Address review comments\n\nFix token lifetime mismatch (minutes/hours).\nAdd cooldown period after unsuccessful login.\nPurge CSRF tokens.\nJavadoc & logging improvements.\nRemove unnecessary code.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-22T17:15:15Z", "type": "commit"}, {"oid": "b4d106b6d66d1fe591c9d027ed7a07521210a57c", "url": "https://github.com/openhab/openhab-core/commit/b4d106b6d66d1fe591c9d027ed7a07521210a57c", "message": "Remove useless code\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-03-22T17:31:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0MzUxNg==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396143516", "bodyText": "Hm, theoretically, you would need to keep track of this per user - otherwise, other users would not be able to login if a certain user forgot his password and did too many tries.\nFor our openHAB situation, it could be ok to block log in in general, though as we are not talking about many different user accounts.", "author": "kaikreuzer", "createdAt": "2020-03-22T21:33:49Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -68,11 +70,14 @@\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashSet<String> csrfTokens = new HashSet<>();\n+    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n \n     private HttpService httpService;\n     private UserRegistry userRegistry;\n     private AuthenticationProvider authProvider;\n+    @Nullable\n+    private Instant lastAuthenticationFailure;", "originalCommit": "b4d106b6d66d1fe591c9d027ed7a07521210a57c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE2MTY1Ng==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396161656", "bodyText": "That's what I thought too, to keep things simple. As a \"last resort\" restarting the bundle (or openHAB) does reset the timer too.", "author": "ghys", "createdAt": "2020-03-22T23:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0MzUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0Mzc2Nw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396143767", "bodyText": "Will you evaluate this somehow in the UI? How will the user know that he is merely temporarily blocked for a few seconds? Maybe we could simply add that info (\"Login possible again after x seconds\" or something like that).", "author": "kaikreuzer", "createdAt": "2020-03-22T21:36:26Z", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -191,17 +199,25 @@ protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletRes\n                     user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n                     logger.info(\"First user account created: {}\", username);\n                 } else {\n+                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n+                    // consecutive failures in seconds\n+                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n+                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n+                        throw new AuthenticationException(\"Too many consecutive login attempts\");", "originalCommit": "b4d106b6d66d1fe591c9d027ed7a07521210a57c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE2MTg0Ng==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396161846", "bodyText": "It only says \"Please try again\" to the user but the real reason is logged as a warning so you would see \"Authentication failed: Too many consecutive login attempts\" in the logs. Isn't is enough?", "author": "ghys", "createdAt": "2020-03-22T23:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0Mzc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTA0Nw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396771047", "bodyText": "A \"Please try again\" does not tell the user much. But as I assume that a normal user won't misspell his password more than 3 times in a row, he won't really hit the delay at all - and for brute force attackers, I don't care what message they see ;-)", "author": "kaikreuzer", "createdAt": "2020-03-23T21:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0Mzc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0NDg1Nw==", "url": "https://github.com/openhab/openhab-core/pull/1389#discussion_r396844857", "bodyText": "Yes, in some schools of thought it's considered a good practice to remain rather opaque on what the actual issue is when the login fails - i.e. not tell that the user account actually exists but the password is wrong, or if the account is locked for some reason. It doesn't scale well when you have thousands of accounts but I believe we're not in that situation with openHAB so it's fine to look at the logs to figure out why a otherwise legitimate login didn't succeed ;)", "author": "ghys", "createdAt": "2020-03-24T00:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0Mzc2Nw=="}], "type": "inlineReview"}]}