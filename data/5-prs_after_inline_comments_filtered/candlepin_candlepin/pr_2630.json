{"pr_number": 2630, "pr_title": "[F] ENT-1846: Port ActivationKeyDTO to openapi spec", "pr_createdAt": "2020-03-02T13:35:46Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2630", "timeline": [{"oid": "331755dee24dad8a0224f8b669971f43b25615ee", "url": "https://github.com/candlepin/candlepin/commit/331755dee24dad8a0224f8b669971f43b25615ee", "message": "ENT-1846: Port ActivationKeyDTO to openapi spec\n\n- Replace use of current ReleaseVersionWrapSerializer and\n  ReleaseVersionWrapDeserializer on ActivationKeyDTO\n  with a new ReleaseVerDTO and ReleaseVersionWrapDeserializer.\n- Replace use of current ProductWrapSerializer and\n  ProductWrapDeserializer on ActivationKeyDTO with a new\n  ActivationKeyProductDTO.\n- Replace use of current OwnerDTO which was serialized with the\n  assistance of Hateoas annotations when being nested, with a\n  cut-down version called NestedOwnerDTO, to be used by all\n  DTOs that have reference a nested OwnerDTO, eliminating the\n  need of hateoas filters.\n- Add non-null and non-empty field restrictions\n  (required, minLength) to ActivationKeyDTO and\n  existing ContentOverrideDTO and StatusDTO specs\n  for validation.\n- Introduce DTOValidator utility class to be used on Resource\n  endpoints for performing validation that previously happened\n  on DTO setters/constructors.", "committedDate": "2020-03-02T14:42:50Z", "type": "forcePushed"}, {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "url": "https://github.com/candlepin/candlepin/commit/7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "message": "ENT-1846: Port ActivationKeyDTO to openapi spec\n\n- Replace use of current ReleaseVersionWrapSerializer and\n  ReleaseVersionWrapDeserializer on ActivationKeyDTO\n  with a new ReleaseVerDTO and ReleaseVersionWrapDeserializer.\n- Replace use of current ProductWrapSerializer and\n  ProductWrapDeserializer on ActivationKeyDTO with a new\n  ActivationKeyProductDTO.\n- Replace use of current OwnerDTO which was serialized with the\n  assistance of Hateoas annotations when being nested, with a\n  cut-down version called NestedOwnerDTO, to be used by all\n  DTOs that have reference a nested OwnerDTO, eliminating the\n  need of hateoas filters.\n- Add non-null and non-empty field restrictions\n  (required, minLength) to ActivationKeyDTO and\n  existing ContentOverrideDTO and StatusDTO specs\n  for validation.\n- Introduce DTOValidator utility class to be used on Resource\n  endpoints for performing validation that previously happened\n  on DTO setters/constructors.", "committedDate": "2020-03-03T09:02:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMzU3Mw==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387033573", "bodyText": "We should be passing these through and letting the model translator deal with this if we're going to have a translator for it.", "author": "Ceiu", "createdAt": "2020-03-03T13:55:33Z", "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -101,27 +124,37 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n         }\n         dest.setAddOns(addOns);\n \n-        // Process nested DTO objects if we have a model translator to use to the translation...\n-        if (modelTranslator != null) {\n-            dest.setOwner(modelTranslator.translate(source.getOwner(), OwnerDTO.class));\n+        Owner owner = source.getOwner();\n+        if (source.getOwner() != null) {\n+            NestedOwnerDTO ownerDTO = new NestedOwnerDTO()", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3NTk0OQ==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387075949", "bodyText": "Ah, I forgot to use the translator here because initially wrote this as if we might not need it.", "author": "nikosmoum", "createdAt": "2020-03-03T14:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMzU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODQ0Ng==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558446", "bodyText": "Done", "author": "nikosmoum", "createdAt": "2020-03-04T09:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMzU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzNDc3OQ==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387034779", "bodyText": "This can fit on the previous line", "author": "Ceiu", "createdAt": "2020-03-03T13:57:26Z", "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -83,16 +98,24 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n                     productIds.add(prod.getId());\n                 }\n             }\n-\n-            dest.setProductIds(productIds);\n+            Set<ActivationKeyProductDTO> productIdObjects = productIds.stream().map(productId ->  {\n+                ActivationKeyProductDTO newProduct =\n+                    new ActivationKeyProductDTO();", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODM5Nw==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558397", "bodyText": "Done", "author": "nikosmoum", "createdAt": "2020-03-04T09:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzNDc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MDE2Mg==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387040162", "bodyText": "Indentation", "author": "Ceiu", "createdAt": "2020-03-03T14:06:07Z", "path": "server/src/main/java/org/candlepin/jackson/ReleaseVersionWrapDeserializer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.jackson;\n+\n+import org.candlepin.common.exceptions.CandlepinJsonProcessingException;\n+import org.candlepin.dto.api.v1.ReleaseVerDTO;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * Handles the deserialization of the \"releaseVer\" field by wrapping it in a {@link ReleaseVerDTO} object,\n+ * by handling both of the following formats: <pre> {@code \"releaseVer\":\"value\" } </pre> and\n+ * <pre> {@code \"releaseVer\":{\"releaseVer \":\"value\"} } </pre>.\n+ */\n+public class ReleaseVersionWrapDeserializer extends JsonDeserializer<ReleaseVerDTO> {\n+\n+    private static Logger log = LoggerFactory.getLogger(ReleaseVersionWrapDeserializer.class);\n+\n+    private static String fieldName = \"releaseVer\";\n+\n+    @Override\n+    public ReleaseVerDTO deserialize(JsonParser parser, DeserializationContext context)\n+        throws IOException {\n+\n+        TreeNode node = parser.readValueAsTree();\n+\n+        if (node.isValueNode()) {\n+            log.debug(\"Processing {} as a value node.\", fieldName);\n+\n+            return parseValueNode(node);\n+        }\n+        else if (node.isObject()) {\n+            log.debug(\"Processing {} as a containing object node.\", fieldName);\n+\n+            TreeNode valueNode = node.path(fieldName);\n+            if (valueNode.isMissingNode()) {\n+                throw new CandlepinJsonProcessingException(\n+                        \"The field \" + fieldName + \" is missing from: \" + node.asToken(),", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODQ5Mw==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558493", "bodyText": "Done", "author": "nikosmoum", "createdAt": "2020-03-04T09:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjAyNw==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387046027", "bodyText": "I'm mostly alright with the microoptimization here around the avoidance of the implicit array creation, however, I feel these should be structured with code minimization in mind -- especially since we're offloading the work to a worker method to begin with.\nAnyway, since we have a private method which validates a collection, and the single-param version does nothing more than unpack the collection from its supplier, it feels like the cleanest way to do all of this is to declare the single-param version as the base, and then have the various variadic overloads call it with each supplier. For example:\n    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n        Collection<?> collection = getter.get();\n        if (collection == null || collection.stream().anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\"collection contains null elements\");\n        }\n    }\n\n    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n        Supplier<? extends Collection<?>> getter2) {\n\n        this.validateCollectionElementsNonNull(getter1);\n        this.validateCollectionElementsNonNull(getter2);\n    }\n\n    // and so on", "author": "Ceiu", "createdAt": "2020-03-03T14:15:13Z", "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3NjQ5NA==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387076494", "bodyText": "Good idea", "author": "nikosmoum", "createdAt": "2020-03-03T14:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODUzNw==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558537", "bodyText": "Done", "author": "nikosmoum", "createdAt": "2020-03-04T09:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjkyNQ==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387046925", "bodyText": "Same deal here: use this version as the base, and have the extended versions just call into it with each arg.", "author": "Ceiu", "createdAt": "2020-03-03T14:16:31Z", "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        Collection<?> collection3 = getter3.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2) ||\n+            isCollectionInvalid(collection3)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    private boolean isCollectionInvalid(Collection<?> collection) {\n+        return collection != null && collection.stream().anyMatch(Objects::isNull);\n+    }\n+\n+\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Maps of elements, and\n+     * validates that none of the elements (keys and values) contained in them are null. When at least one\n+     * key or value of any of the Maps is null, an exception is thrown.\n+     *\n+     * If the map returned by the getter itself is null, no exception is thrown (null map is considered\n+     * valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateMapElementsNotNull(dto::getAttributes, dto::getProductAttributes);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Maps of items\n+     * @throws IllegalArgumentException when any of the maps returned from the specified getters contains at\n+     * least one null key or value\n+     */\n+    @SafeVarargs\n+    public final void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3,\n+        Supplier<? extends Map<?, ?>>... getters) {\n+\n+        validateMapElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Map<?, ?>> getter : getters) {\n+            Map<?, ?> map = getter.get();\n+            if (isMapInvalid(map)) {\n+                throw new IllegalArgumentException(\"map contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateMapElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three maps that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 maps at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter) {", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODU4MQ==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558581", "bodyText": "Done", "author": "nikosmoum", "createdAt": "2020-03-04T09:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2NTU5NQ==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387065595", "bodyText": "Map has methods map.containsKey(null) and map.containsValue(null). We could use those.", "author": "Januson", "createdAt": "2020-03-03T14:43:40Z", "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        Collection<?> collection3 = getter3.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2) ||\n+            isCollectionInvalid(collection3)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    private boolean isCollectionInvalid(Collection<?> collection) {\n+        return collection != null && collection.stream().anyMatch(Objects::isNull);\n+    }\n+\n+\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Maps of elements, and\n+     * validates that none of the elements (keys and values) contained in them are null. When at least one\n+     * key or value of any of the Maps is null, an exception is thrown.\n+     *\n+     * If the map returned by the getter itself is null, no exception is thrown (null map is considered\n+     * valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateMapElementsNotNull(dto::getAttributes, dto::getProductAttributes);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Maps of items\n+     * @throws IllegalArgumentException when any of the maps returned from the specified getters contains at\n+     * least one null key or value\n+     */\n+    @SafeVarargs\n+    public final void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3,\n+        Supplier<? extends Map<?, ?>>... getters) {\n+\n+        validateMapElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Map<?, ?>> getter : getters) {\n+            Map<?, ?> map = getter.get();\n+            if (isMapInvalid(map)) {\n+                throw new IllegalArgumentException(\"map contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateMapElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three maps that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 maps at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter) {\n+        Map<?, ?> map = getter.get();\n+        if (isMapInvalid(map)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2) {\n+        Map<?, ?> map1 = getter1.get();\n+        Map<?, ?> map2 = getter2.get();\n+        if (isMapInvalid(map1) ||\n+            isMapInvalid(map2)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3) {\n+        Map<?, ?> map1 = getter1.get();\n+        Map<?, ?> map2 = getter2.get();\n+        Map<?, ?> map3 = getter3.get();\n+        if (isMapInvalid(map1) ||\n+            isMapInvalid(map2) ||\n+            isMapInvalid(map3)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    private boolean isMapInvalid(Map<?, ?> map) {\n+        return map != null &&\n+            (map.values().stream().anyMatch(Objects::isNull) ||", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0OTIxMA==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387549210", "bodyText": "Apparently, some implementations of Map such as ConcurrentHashMap will throw an NPE if you pass null to containsValue, so I'll keep this as is", "author": "nikosmoum", "createdAt": "2020-03-04T09:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2NTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MTU2Mw==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387071563", "bodyText": "We could use Validation.buildDefaultValidatorFactory() instead of extending the whole DB fixture.", "author": "Januson", "createdAt": "2020-03-03T14:51:28Z", "path": "server/src/test/java/org/candlepin/resource/validation/DTOValidatorTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import org.candlepin.test.DatabaseTestFixture;\n+\n+import com.google.inject.Inject;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+/**\n+ * Test suite for the DTOValidator class\n+ */\n+public class DTOValidatorTest extends DatabaseTestFixture {\n+\n+    @Inject DTOValidator validator;", "originalCommit": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1OTA1NQ==", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387559055", "bodyText": "Done. I had to add the javax.el library, but it saves us ~8 seconds of execution", "author": "nikosmoum", "createdAt": "2020-03-04T09:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MTU2Mw=="}], "type": "inlineReview"}, {"oid": "23f347749fdfb763c1a2d7709fca03e8836cdf42", "url": "https://github.com/candlepin/candlepin/commit/23f347749fdfb763c1a2d7709fca03e8836cdf42", "message": "ENT-1846: Port ActivationKeyDTO to openapi spec\n\n- Replace use of current ReleaseVersionWrapSerializer and\n  ReleaseVersionWrapDeserializer on ActivationKeyDTO\n  with a new ReleaseVerDTO and ReleaseVersionWrapDeserializer.\n- Replace use of current ProductWrapSerializer and\n  ProductWrapDeserializer on ActivationKeyDTO with a new\n  ActivationKeyProductDTO.\n- Replace use of current OwnerDTO which was serialized with the\n  assistance of Hateoas annotations when being nested, with a\n  cut-down version called NestedOwnerDTO, to be used by all\n  DTOs that have reference a nested OwnerDTO, eliminating the\n  need of hateoas filters.\n- Add non-null and non-empty field restrictions\n  (required, minLength) to ActivationKeyDTO and\n  existing ContentOverrideDTO and StatusDTO specs\n  for validation.\n- Introduce DTOValidator utility class to be used on Resource\n  endpoints for performing validation that previously happened\n  on DTO setters/constructors.", "committedDate": "2020-03-04T10:42:28Z", "type": "forcePushed"}, {"oid": "3841b7550dc5cf38dc1c846ba3dc79ecc2429f5d", "url": "https://github.com/candlepin/candlepin/commit/3841b7550dc5cf38dc1c846ba3dc79ecc2429f5d", "message": "ENT-1846: Port ActivationKeyDTO to openapi spec\n\n- Replace use of current ReleaseVersionWrapSerializer and\n  ReleaseVersionWrapDeserializer on ActivationKeyDTO\n  with a new ReleaseVerDTO and ReleaseVersionWrapDeserializer.\n- Replace use of current ProductWrapSerializer and\n  ProductWrapDeserializer on ActivationKeyDTO with a new\n  ActivationKeyProductDTO.\n- Replace use of current OwnerDTO which was serialized with the\n  assistance of Hateoas annotations when being nested, with a\n  cut-down version called NestedOwnerDTO, to be used by all\n  DTOs that have reference a nested OwnerDTO, eliminating the\n  need of hateoas filters.\n- Add non-null and non-empty field restrictions\n  (required, minLength) to ActivationKeyDTO and\n  existing ContentOverrideDTO and StatusDTO specs\n  for validation.\n- Introduce DTOValidator utility class to be used on Resource\n  endpoints for performing validation that previously happened\n  on DTO setters/constructors.", "committedDate": "2020-03-04T10:44:54Z", "type": "commit"}, {"oid": "3841b7550dc5cf38dc1c846ba3dc79ecc2429f5d", "url": "https://github.com/candlepin/candlepin/commit/3841b7550dc5cf38dc1c846ba3dc79ecc2429f5d", "message": "ENT-1846: Port ActivationKeyDTO to openapi spec\n\n- Replace use of current ReleaseVersionWrapSerializer and\n  ReleaseVersionWrapDeserializer on ActivationKeyDTO\n  with a new ReleaseVerDTO and ReleaseVersionWrapDeserializer.\n- Replace use of current ProductWrapSerializer and\n  ProductWrapDeserializer on ActivationKeyDTO with a new\n  ActivationKeyProductDTO.\n- Replace use of current OwnerDTO which was serialized with the\n  assistance of Hateoas annotations when being nested, with a\n  cut-down version called NestedOwnerDTO, to be used by all\n  DTOs that have reference a nested OwnerDTO, eliminating the\n  need of hateoas filters.\n- Add non-null and non-empty field restrictions\n  (required, minLength) to ActivationKeyDTO and\n  existing ContentOverrideDTO and StatusDTO specs\n  for validation.\n- Introduce DTOValidator utility class to be used on Resource\n  endpoints for performing validation that previously happened\n  on DTO setters/constructors.", "committedDate": "2020-03-04T10:44:54Z", "type": "forcePushed"}]}