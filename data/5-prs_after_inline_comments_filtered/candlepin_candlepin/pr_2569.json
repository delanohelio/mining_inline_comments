{"pr_number": 2569, "pr_title": "[F] ENT-1911 Add method to get provided products from ProductInfo", "pr_createdAt": "2020-01-16T11:47:44Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2569", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzODg0MQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r367438841", "bodyText": "Would it make sense to do the validation before clearing the existing list?", "author": "barnabycourt", "createdAt": "2020-01-16T14:13:53Z", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductDTO.java", "diffHunk": "@@ -846,6 +847,92 @@ private boolean isNullOrIncomplete(BrandingDTO branding) {\n             branding.getType() == null || branding.getType().isEmpty();\n     }\n \n+    /**\n+     * Retrieves a view of the provided products for the product represented by this DTO.\n+     * If the provided products have not yet been defined, this method returns null.\n+     *\n+     * Note that the collection returned by this method is a view of the collection backing this\n+     * set of provided products. Elements cannot be added to the collection, but elements may be removed.\n+     * Changes made to the collection will be reflected by this product DTO instance.\n+     *\n+     * @return\n+     *  The provided products associated with this key, or null if they have not yet been defined\n+     */\n+    @JsonIgnore\n+    @Override\n+    public Set<ProductDTO> getProvidedProducts() {\n+        return this.providedProducts != null ? new SetView<>(this.providedProducts) : null;\n+    }\n+\n+    /**\n+     * Adds the collection of provided products to this Product DTO.\n+     *\n+     * @param providedProducts\n+     *  A set of provided products to attach to this DTO, or null to clear the existing ones\n+     *\n+     * @return\n+     *  A reference to this DTO\n+     */\n+    @JsonIgnore\n+    public ProductDTO setProvidedProducts(Set<ProductDTO> providedProducts) {\n+        if (providedProducts != null) {\n+            if (this.providedProducts == null) {\n+                this.providedProducts = new HashSet<>();\n+            }\n+            else {\n+                this.providedProducts.clear();\n+            }\n+\n+            for (ProductDTO dto : providedProducts) {", "originalCommit": "52ea98419facd5c9fc042e184899838138fd247e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MjQ0NQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r367792445", "bodyText": "At DTO level it wouldn't make much difference as we want a fresh DTO to be returned every time with all its properties. There is still a possibility others can throw exception resulting in failure of whole operation as there are no try-catch guarding setter method invocation anywhere. Also there are multiple such methods in execution chain and failure of even one method can lead to failure of operation, which is expected.", "author": "wolfdale", "createdAt": "2020-01-17T06:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzODg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMzg4Ng==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r367923886", "bodyText": "I'm a bit confused by this. Why are we calling the populate method recursively here, which will overwrite all the data on the marketing ProductData (this) we're populating already? If it is in order to turn the Product into a ProductData, new ProductData(Product product) is what we should be using instead.", "author": "nikosmoum", "createdAt": "2020-01-17T13:01:13Z", "path": "server/src/main/java/org/candlepin/model/dto/ProductData.java", "diffHunk": "@@ -1118,6 +1189,12 @@ public ProductData populate(Product source) {\n         this.setDependentProductIds(source.getDependentProductIds());\n         this.setBranding(source.getBranding());\n \n+        if (source.getProvidedProducts() != null) {\n+            this.setProvidedProducts(source.getProvidedProducts().stream()\n+                .map(prod -> this.populate(prod))", "originalCommit": "52ea98419facd5c9fc042e184899838138fd247e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3ODUzNg==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r367978536", "bodyText": "Are we still using ProductData? If we can avoid it, we should.", "author": "Ceiu", "createdAt": "2020-01-17T14:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMzg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDY3MQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r367980671", "bodyText": "Subscription, and in extent, the adapters code is definitely using it. (the IT adapters too I think)", "author": "nikosmoum", "createdAt": "2020-01-17T15:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMzg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTkwMg==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368021902", "bodyText": "Gross. We really need to spend some time to revisit the refactor tasks around it and finally get rid of all the PoC and v1 DTO layers. Especially with the spec-first stuff driving what is effectively a v3 layer.", "author": "Ceiu", "createdAt": "2020-01-17T16:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMzg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1NDk0OA==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368454948", "bodyText": "@nikosmoum there are few more places where DTO methods need to be \"n-tier\" aware, all are now taken care of and fixed.\n@Ceiu Are we planning for ProductData to be removed?", "author": "wolfdale", "createdAt": "2020-01-20T09:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMzg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU3MjA2OA==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368572068", "bodyText": "Yes. ProductData was one of the first attempts to start standardizing a DTO layer around the time that Subscription was being removed from the model. It's been almost entirely replaced by ProductDTO and the general DTO layer for manifests. However, since Subscription is still used heavily in manifests, we haven't gotten around to a proper refactor.", "author": "Ceiu", "createdAt": "2020-01-20T14:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMzg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDE5MQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r367930191", "bodyText": "I know you've added the ignore annotations here, but the truth is that since the manifest API should not change (provided products should still stay in the manifest PoolDTO), there is no need to add this field on this DTO at all.\nI know you've added it because the ProductInfo interface dictates it, but this is another case of asking: why does this DTO need that interface??? @Ceiu since I see you added that, what was the reason? Our manifest API is clearly different than our model, our REST API, and our adapters API, so do we need that interface here?", "author": "nikosmoum", "createdAt": "2020-01-17T13:17:44Z", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductDTO.java", "diffHunk": "@@ -846,6 +847,92 @@ private boolean isNullOrIncomplete(BrandingDTO branding) {\n             branding.getType() == null || branding.getType().isEmpty();\n     }\n \n+    /**\n+     * Retrieves a view of the provided products for the product represented by this DTO.\n+     * If the provided products have not yet been defined, this method returns null.\n+     *\n+     * Note that the collection returned by this method is a view of the collection backing this\n+     * set of provided products. Elements cannot be added to the collection, but elements may be removed.\n+     * Changes made to the collection will be reflected by this product DTO instance.\n+     *\n+     * @return\n+     *  The provided products associated with this key, or null if they have not yet been defined\n+     */\n+    @JsonIgnore", "originalCommit": "52ea98419facd5c9fc042e184899838138fd247e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMjg4Ng==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368022886", "bodyText": "Something that seems to be getting lost or misunderstood is what role the various models play in conjunction with each other, and a bit of Candlepin's development history.\nFirst, the model we care about primarily is our data model (the entities). That drives how we store data and how we work with data at the logic level. The DTOs and various DTO-like things (adapter *Info interfaces) are views into that model or data. We try to keep them as a subset of the data layer, but that isn't always possible due to preexisting conditions, usages, or just some legacy behavior we cannot remove or update for some reason. In any event, the data model is what drives most of the design of everything around it, not the views.\nIn the case of the adapter interfaces, they are a stopgap implementation to get adapter consumers (IT) to stop using our internal model objects and start using their own, for both maintenance and performance reasons. However, as soon as the adapter's model changed, we had to address the fallout of how the adapters were designed and intended to be used vs how they ended up actually being used; coupled with the fact we now had code that was reliant on multiple versions of the model (data, manifest view and adapter view). So, we were left with a few options, one of which was rewrite every bit of code that surrounded the adapters (i.e. most of the manifest processing, chunks of refresh, etc.), which, as I'm sure you can imagine, was deemed unviable given the sheer volume of such work. After several discussions we landed on the interface + existing DTO reuse we have today. @kahowell might remember and have more to add here if he cares enough.\nNow, should the adapters have their own DTO implementations that we use? Maybe. Given how we seem to want to use the adapters, probably not, though. However, both answers to this question come with plenty of baggage and need to be properly understood before a decision is made. Perhaps the DTO layers should all be interfaces and we can implement them in whatever means we choose?\nSo then... getting back to the original question of why do we need the JsonIgnore annotation. Short answer is: we don't. Having extra fields is a waste of data and processing time, but it's not strictly required that we avoid it if the change is a net addition that doesn't violate any security concerns. In this specific case, I'd be curious to understand why we don't want the product model\nWe have other potential concerns here, such as the one @nikosmoum is seemingly alluding to here and one I brought up in the design discussion yesterday in that we should be avoiding having a view dictate the model implementation. That kind of applies here, but perhaps should be better framed as we should be working to separate the shared implementation of the two interfaces if the overlap is no longer maintainable.", "author": "Ceiu", "createdAt": "2020-01-17T16:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMzUwOA==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368023508", "bodyText": "I can go more in-depth on some of this stuff if necessary, but it's getting hard to keep up with given how messy the history and design behind all of this is; and the research involved just in writing this part took a good 90 minutes of my morning.", "author": "Ceiu", "createdAt": "2020-01-17T16:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1NDk4Mg==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368454982", "bodyText": "From what I understand by looking at manifest ProductDTO which is closely tied with ProductInfo interface at multiple places involving refresh flow and manifest processing.\nAre we planing to refactor this by any chance ? @Ceiu @nikosmoum\nRemoving JsonIgnore as it is not strictly needed.", "author": "wolfdale", "createdAt": "2020-01-20T09:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5ODI2MQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368498261", "bodyText": "@Ceiu Thanks for the detailed background. I suppose removing the jsonignore annotation is fine here, since net additions aren't a direct problem. Maybe it would be good to document it in the comment for future reference. Adding new fields to our APIs just because we can, but without actually using them is not something I'm a fan of (We should be more intentional with our API changes, but this is I guess a longer discussion that relates our overall API/versioning strategy).\n\nbut perhaps should be better framed as we should be working to separate the shared implementation of the two interfaces if the overlap is no longer maintainable.\n\nYes, ideally, just like a view shouldn't dictate our model, a view (adapters API) should not dictate another view (manifest API) in my opinion.", "author": "nikosmoum", "createdAt": "2020-01-20T11:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4NDkyNw==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r368584927", "bodyText": "Something that's being glossed over in all of this is that manifests use two models simultaneously. If we spend the time to separate that out, or otherwise standardize the manifest DTO layer such that it lines up with the adapter layer (which is kind of what happens when ProductDTO inherits ProductInfo), then this mostly goes away on its own.\nThere are a couple ways of doing that:\n\nWrite a translator and copy the data between the models (again)\nDecouple the manifest code from the refresh path which would drop the need for the adapter models in manifest.\nDecouple refresh from the adapter models\n\nAnd so on and so forth. Lots of options to do it, but none of them are easy or efficient; and despite many pleas on my behalf, we haven't found/had time to dedicate to giving manifest the rewrite/refactor it deserves.", "author": "Ceiu", "createdAt": "2020-01-20T14:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDE5MQ=="}], "type": "inlineReview"}, {"oid": "da58028e52847faf63fc2924831549c52861fb36", "url": "https://github.com/candlepin/candlepin/commit/da58028e52847faf63fc2924831549c52861fb36", "message": "ENT-1911: added method to get provided product from productInfo interface.", "committedDate": "2020-01-20T09:44:34Z", "type": "forcePushed"}, {"oid": "21e230b48ece041f79d99531e327f5938986aba7", "url": "https://github.com/candlepin/candlepin/commit/21e230b48ece041f79d99531e327f5938986aba7", "message": "ENT-1911: added method to get provided product from productInfo interface.", "committedDate": "2020-01-20T12:07:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyNTIxNA==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369025214", "bodyText": "Isn't the use of the Util.collectionsAreEqual unnecessary here and on all other DTOs (manifest ProductDTO, ProductData)? @Ceiu am I right in thinking we only need to use this method in hibernate entity classes, because hibernate collections don't implement .equals properly?", "author": "nikosmoum", "createdAt": "2020-01-21T14:17:15Z", "path": "server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java", "diffHunk": "@@ -1035,6 +1035,8 @@ public boolean equals(Object obj) {\n \n             // Check product content\n             equals = equals && Util.collectionsAreEqual(this.getProductContent(), that.getProductContent());\n+            equals = equals &&\n+                Util.collectionsAreEqual(this.getProvidedProducts(), that.getProvidedProducts());", "originalCommit": "21e230b48ece041f79d99531e327f5938986aba7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MDc3Mg==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369580772", "bodyText": "Removed it.", "author": "wolfdale", "createdAt": "2020-01-22T14:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyNTIxNA=="}], "type": "inlineReview"}, {"oid": "21f8e975856fe832e28831b07bae3a35cb6f43cf", "url": "https://github.com/candlepin/candlepin/commit/21f8e975856fe832e28831b07bae3a35cb6f43cf", "message": "ENT-1911: added method to get provided product from productInfo interface.", "committedDate": "2020-01-22T14:01:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NzE3Mw==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369587173", "bodyText": "Similarly to the equals method, where we don't need to check equality in a custom way, we also don't need to calculate hashcode in a custom way. You can just add this.getProvidedProducts() in the HashCodeBuilder below.", "author": "nikosmoum", "createdAt": "2020-01-22T14:22:31Z", "path": "server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java", "diffHunk": "@@ -1055,6 +1056,15 @@ public int hashCode() {\n             }\n         }\n \n+        int ppHashCode = 0;\n+        Collection<ProductDTO> providedProducts = this.getProvidedProducts();\n+\n+        if (providedProducts != null) {\n+            for (ProductDTO dto : providedProducts) {\n+                ppHashCode = 31 * ppHashCode + (dto != null ? dto.hashCode() : 0);\n+            }\n+        }\n+", "originalCommit": "21f8e975856fe832e28831b07bae3a35cb6f43cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMjQ3OQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369612479", "bodyText": "removed it.", "author": "wolfdale", "createdAt": "2020-01-22T15:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NzkwMg==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369587902", "bodyText": "Same here, no need to calculate hashcode above and set it here. This line is enough: .append(this.getProvidedProducts()).", "author": "nikosmoum", "createdAt": "2020-01-22T14:23:40Z", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductDTO.java", "diffHunk": "@@ -908,7 +1011,9 @@ public int hashCode() {\n             .append(this.getAttributes())\n             .append(this.getDependentProductIds())\n             .append(this.getBranding())\n-            .append(pcHashCode);\n+            .append(this.getProvidedProducts())\n+            .append(pcHashCode)\n+            .append(ppHashCode);", "originalCommit": "21f8e975856fe832e28831b07bae3a35cb6f43cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMjUwMw==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369612503", "bodyText": "removed it.", "author": "wolfdale", "createdAt": "2020-01-22T15:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4ODM4OA==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369588388", "bodyText": "Same here, no need for calculating hashcode and setting it. Just append.(this.getProvidedProducts())", "author": "nikosmoum", "createdAt": "2020-01-22T14:24:27Z", "path": "server/src/main/java/org/candlepin/model/dto/ProductData.java", "diffHunk": "@@ -1001,7 +1072,8 @@ public int hashCode() {\n             .append(this.content)\n             .append(this.dependentProductIds)\n             .append(this.branding)\n-            .append(this.locked);\n+            .append(this.locked)\n+            .append(ppHashCode);", "originalCommit": "21f8e975856fe832e28831b07bae3a35cb6f43cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMjU0MQ==", "url": "https://github.com/candlepin/candlepin/pull/2569#discussion_r369612541", "bodyText": "removed it.", "author": "wolfdale", "createdAt": "2020-01-22T15:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4ODM4OA=="}], "type": "inlineReview"}, {"oid": "effa8bb1c651aac2a0cbf82fbadee43fdd0e1561", "url": "https://github.com/candlepin/candlepin/commit/effa8bb1c651aac2a0cbf82fbadee43fdd0e1561", "message": "ENT-1911: added method to get provided product from productInfo interface.", "committedDate": "2020-01-22T14:58:14Z", "type": "commit"}, {"oid": "effa8bb1c651aac2a0cbf82fbadee43fdd0e1561", "url": "https://github.com/candlepin/candlepin/commit/effa8bb1c651aac2a0cbf82fbadee43fdd0e1561", "message": "ENT-1911: added method to get provided product from productInfo interface.", "committedDate": "2020-01-22T14:58:14Z", "type": "forcePushed"}]}