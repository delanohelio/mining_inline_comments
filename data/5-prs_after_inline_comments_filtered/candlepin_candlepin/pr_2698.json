{"pr_number": 2698, "pr_title": "[F] Removed unnecessary code and added missing refresh tests (ENT-2207)", "pr_createdAt": "2020-05-12T19:50:30Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2698", "timeline": [{"oid": "84f4e1a06bbcc398ffb8f372ca382f02066e0ffe", "url": "https://github.com/candlepin/candlepin/commit/84f4e1a06bbcc398ffb8f372ca382f02066e0ffe", "message": "Removed unnecessary code and added missing refresh tests\n\n- Added versioning tests for the full RefreshWorker execute code\n  path\n- Removed ContentManager.importContent, as it is entirely\n  obsoleted by the RefreshWorker framework\n- Deprecated the ProductManager and ContentManager classes as a\n  whole\n- Added missing transactional annotation to RefreshWorker.execute\n- Updated the spec tests for the consumer resource functionality", "committedDate": "2020-05-12T09:05:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NTMxNQ==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r424255315", "bodyText": "Should we be deprecating this class (and ProductManager) as a whole? It is just the import* methods used by refresh that are deprecated really, but these classes provide CRUD methods for custom Content & Products (unrelated to Refresh), so I'd not say they should be deprecated", "author": "nikosmoum", "createdAt": "2020-05-13T08:16:12Z", "path": "server/src/main/java/org/candlepin/controller/ContentManager.java", "diffHunk": "@@ -60,7 +55,13 @@\n  * <p></p>\n  * The methods provided by this class are the prefered methods to use for CRUD operations on\n  * content, to ensure content versioning and linking is handled properly.\n+ *\n+ * @deprecated\n+ *  This class's primary purpose has been replaced by the RefreshWorker and its various components.\n+ *  New code should avoid using this class and its methods if at all possible, instead opting to\n+ *  use the RefreshWorker.", "originalCommit": "ca971519bfc4af0e4e6c9a272e1e8698b09d3e3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMjU0NA==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r424432544", "bodyText": "There are a few more improvements overall to do (such as adding deletion functionality), but aside from that, the CRUD operations on products and content is basically \"change an entity and then update everything above it\", most of which is just duplicating what the RefreshWorker does.\nAt the end of the card I created for this, I noted that if we opt to keep them around, they should be nothing more than wrappers around the RefreshWorker setup and execution.", "author": "Ceiu", "createdAt": "2020-05-13T13:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NTMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ1NjYzNA==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r424456634", "bodyText": "I've removed the deprecation annotation from ContentManager and moved ProductManager's onto importProducts, but this is something that needs to be cleaned up eventually. It's almost entirely dead code at this point.", "author": "Ceiu", "createdAt": "2020-05-13T13:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1OTEwNg==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r424359106", "bodyText": "Same question as ContentManager", "author": "nikosmoum", "createdAt": "2020-05-13T11:17:00Z", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -62,7 +62,13 @@\n  * <p></p>\n  * The methods provided by this class are the prefered methods to use for CRUD operations on\n  * products, to ensure product versioning and linking is handled properly.\n+ *\n+ * @deprecated\n+ *  This class's primary purpose has been replaced by the RefreshWorker and its various components.\n+ *  New code should avoid using this class and its methods if at all possible, instead opting to\n+ *  use the RefreshWorker.\n  */\n+@Deprecated", "originalCommit": "ca971519bfc4af0e4e6c9a272e1e8698b09d3e3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MDUwNQ==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r424360505", "bodyText": "This file also has commented out calls of these methods throughout many tests like the following, which should be removed:\n// this.mockProductImport(owner, product);\n// this.mockContentImport(owner, new Content[] {});", "author": "nikosmoum", "createdAt": "2020-05-13T11:19:58Z", "path": "server/src/test/java/org/candlepin/controller/PoolManagerTest.java", "diffHunk": "@@ -579,76 +579,6 @@ public RefreshResult answer(InvocationOnMock iom) throws Throwable {\n         .when(this.refreshWorker).execute(eq(owner));\n     }\n \n-    // private void mockProductImport(Owner owner, final Map<String, Product> products) {", "originalCommit": "ca971519bfc4af0e4e6c9a272e1e8698b09d3e3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ1NDY3NQ==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r424454675", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-05-13T13:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MDUwNQ=="}], "type": "inlineReview"}, {"oid": "84f4e1a06bbcc398ffb8f372ca382f02066e0ffe", "url": "https://github.com/candlepin/candlepin/commit/84f4e1a06bbcc398ffb8f372ca382f02066e0ffe", "message": "Removed unnecessary code and added missing refresh tests\n\n- Added versioning tests for the full RefreshWorker execute code\n  path\n- Removed ContentManager.importContent, as it is entirely\n  obsoleted by the RefreshWorker framework\n- Deprecated the ProductManager and ContentManager classes as a\n  whole\n- Added missing transactional annotation to RefreshWorker.execute\n- Updated the spec tests for the consumer resource functionality", "committedDate": "2020-05-12T09:05:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MDA2Mw==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r425070063", "bodyText": "This is not directly related to your changes, but rather the previous changes in this method.\nIf the initial call of productAdapter.getProductsByIds(owner.getKey(), Arrays.asList(sku)) returns the marketing product we want, I assume that when Teamnado are going to implement our current ProductInfo interface which has the new getProvidedProducts() method on it, then that means we already have the whole product hierarchy fetched (well, for now a single mkt product on level 0 and some eng products on level 1). Why do we need to call the adapter a second time for all the children of sku?", "author": "nikosmoum", "createdAt": "2020-05-14T11:37:20Z", "path": "server/src/main/java/org/candlepin/controller/Entitler.java", "diffHunk": "@@ -376,47 +382,67 @@ private DeveloperProducts getDeveloperPoolProducts(Owner owner, String sku) {\n      *         from the adapter.\n      */\n     private DeveloperProducts getDevProductMap(Owner owner, String sku) {\n-\n         Collection<? extends ProductInfo> productsByIds = this.productAdapter\n             .getProductsByIds(owner.getKey(), Arrays.asList(sku));\n \n-        Collection<String> devProductIds = new ArrayList<>();\n-        if (productsByIds.iterator().hasNext()) {\n+        Map<String, Product> devProductMap = new HashMap<>();\n+\n+        if (productsByIds != null && !productsByIds.isEmpty()) {\n+            // We're apparently only interested in the first product returned for the given sku\n             ProductInfo devProduct = productsByIds.iterator().next();\n-            devProductIds.add(devProduct.getId());\n \n-            Collection<? extends ProductInfo> provided = devProduct.getProvidedProducts();\n+            // Collect the dev product IDs from the potential tree of products we received\n+            List<String> devProductIds = new ArrayList<>();\n+            this.collectDevProductIds(devProductIds, devProduct);\n \n-            if (provided != null) {\n-                provided.forEach(product -> {\n-                    if (product != null) {\n-                        devProductIds.add(product.getId());\n-                    }\n-                });\n-            }\n-        }\n+            // Do a refresh so we're all up to date here\n+            log.debug(\"Importing products for dev pool resolution...\");\n \n-        log.debug(\"Importing products for dev pool resolution...\");\n-        ImportedEntityCompiler compiler = new ImportedEntityCompiler();\n+            RefreshWorker refresher = this.refreshWorkerProvider.get();\n+            refresher.addProducts(this.productAdapter.getProductsByIds(owner.getKey(), devProductIds));", "originalCommit": "84f4e1a06bbcc398ffb8f372ca382f02066e0ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTExMA==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r425115110", "bodyText": "That's a very valid point.\nToday this path is still necessary to get the overall code working, since our default product service adapter hasn't been ported to the new model yet. But it would be a lot nicer to not need to do a fetch->collect->fetch step.", "author": "Ceiu", "createdAt": "2020-05-14T12:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MDA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NTc1OQ==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r425075759", "bodyText": "You mentioned yesterday that because of how the RefreshWorker works, we're adding all the org's products to the devProductMap. Can we not do some filtering here, and only add the refreshed products that are part of sku (and its hierarchy below it)?", "author": "nikosmoum", "createdAt": "2020-05-14T11:48:29Z", "path": "server/src/main/java/org/candlepin/controller/Entitler.java", "diffHunk": "@@ -376,47 +382,67 @@ private DeveloperProducts getDeveloperPoolProducts(Owner owner, String sku) {\n      *         from the adapter.\n      */\n     private DeveloperProducts getDevProductMap(Owner owner, String sku) {\n-\n         Collection<? extends ProductInfo> productsByIds = this.productAdapter\n             .getProductsByIds(owner.getKey(), Arrays.asList(sku));\n \n-        Collection<String> devProductIds = new ArrayList<>();\n-        if (productsByIds.iterator().hasNext()) {\n+        Map<String, Product> devProductMap = new HashMap<>();\n+\n+        if (productsByIds != null && !productsByIds.isEmpty()) {\n+            // We're apparently only interested in the first product returned for the given sku\n             ProductInfo devProduct = productsByIds.iterator().next();\n-            devProductIds.add(devProduct.getId());\n \n-            Collection<? extends ProductInfo> provided = devProduct.getProvidedProducts();\n+            // Collect the dev product IDs from the potential tree of products we received\n+            List<String> devProductIds = new ArrayList<>();\n+            this.collectDevProductIds(devProductIds, devProduct);\n \n-            if (provided != null) {\n-                provided.forEach(product -> {\n-                    if (product != null) {\n-                        devProductIds.add(product.getId());\n-                    }\n-                });\n-            }\n-        }\n+            // Do a refresh so we're all up to date here\n+            log.debug(\"Importing products for dev pool resolution...\");\n \n-        log.debug(\"Importing products for dev pool resolution...\");\n-        ImportedEntityCompiler compiler = new ImportedEntityCompiler();\n+            RefreshWorker refresher = this.refreshWorkerProvider.get();\n+            refresher.addProducts(this.productAdapter.getProductsByIds(owner.getKey(), devProductIds));\n+            RefreshResult refreshResult = refresher.execute(owner);\n \n-        compiler.addProducts(this.productAdapter.getProductsByIds(owner.getKey(), devProductIds));\n+            // Step through the items we refreshed and add the resulting products to our map\n+            for (String pid : refresher.getProducts().keySet()) {\n+                Product product = refreshResult.getProduct(pid);\n+                if (product != null) {\n+                    devProductMap.put(product.getId(), product);", "originalCommit": "84f4e1a06bbcc398ffb8f372ca382f02066e0ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExODkzNw==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r425118937", "bodyText": "I don't fully understand the question.\nThis block is what is doing that filtering. Previously we were relying on the poorly named .getImportedProducts to grab everything, but with the new system, we need to be a little more selective to get the correct result.\nPart of the issue here is how DeveloperProduct works, and still expects to be working with a flat map. I feel there are going to be many places like this where we have to make a decision to either update a larger area of code to be more n-tier aware, or have patches like this which allow those places to continue working as they do.", "author": "Ceiu", "createdAt": "2020-05-14T13:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NTc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1ODY0OA==", "url": "https://github.com/candlepin/candlepin/pull/2698#discussion_r425158648", "bodyText": "Nevermind, I misread the code!", "author": "nikosmoum", "createdAt": "2020-05-14T13:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NTc1OQ=="}], "type": "inlineReview"}]}