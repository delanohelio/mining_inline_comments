{"pr_number": 2685, "pr_title": "[F] Product + Content Refresh Refactor (ENT-2207)", "pr_createdAt": "2020-04-23T03:54:21Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2685", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r419365463", "bodyText": "Not something for this PR/task, but we should add a card in the epic to add a documentation page on candlepinproject.org on how the algorithm works", "author": "nikosmoum", "createdAt": "2020-05-04T11:18:52Z", "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher;\n+\n+import org.candlepin.controller.refresher.builders.ContentNodeBuilder;\n+import org.candlepin.controller.refresher.builders.NodeFactory;\n+import org.candlepin.controller.refresher.builders.ProductNodeBuilder;\n+import org.candlepin.controller.refresher.mappers.ContentMapper;\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.mappers.PoolMapper;\n+import org.candlepin.controller.refresher.mappers.ProductMapper;\n+import org.candlepin.controller.refresher.visitors.ContentNodeVisitor;\n+import org.candlepin.controller.refresher.visitors.NodeProcessor;\n+import org.candlepin.controller.refresher.visitors.ProductNodeVisitor;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.ContentCurator;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerContentCurator;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.service.model.ProductContentInfo;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.service.model.SubscriptionInfo;\n+\n+import com.google.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+\n+/**\n+ * The RefreshWorker gathers upstream objects to refresh, and then performs the actual work to\n+ * update their local representations.", "originalCommit": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MDc3MA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420140770", "bodyText": "The overall algorithm for merging doesn't change, just how we're doing the work. I'm not entirely opposed to documenting how/why this works, but from an outsider's perspective, nothing (should have) changed here.", "author": "Ceiu", "createdAt": "2020-05-05T14:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1OTExMg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420159112", "bodyText": "I'm thinking more as a resource for developers than outsiders", "author": "nikosmoum", "createdAt": "2020-05-05T14:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3ODg0Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r419978843", "bodyText": "This mentions one of the two effects of this method (that it returns the node), but we should also mention the other, maybe even more important effect: that the node is added to the NodeMapper (which is the whole point of NodeFactory, to build up a NodeMapper data structure so that we can then process it)", "author": "nikosmoum", "createdAt": "2020-05-05T09:30:55Z", "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.AbstractHibernateObject;\n+import org.candlepin.model.Owner;\n+import org.candlepin.service.model.ServiceAdapterModel;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+\n+/**\n+ * The NodeFactory is responsible for orchestrating the complete creation and mapping of a node and\n+ * any children nodes it may create.\n+ * <p></p>\n+ * The tasks that make up the creation and mapping of a node may be performed by other objects, but\n+ * those objects must be provided before a node creation request is made.\n+ */\n+public class NodeFactory {\n+\n+    private NodeMapper mapper;\n+    private Map<Class, NodeBuilder> builders;\n+\n+    /**\n+     * Creates a new NodeFactory without any mappers or builders\n+     */\n+    public NodeFactory() {\n+        this.builders = new HashMap<>();\n+    }\n+\n+    /**\n+     * Adds a builder to this factory. The builder will be used to create nodes for the class\n+     * returned by the builder's <tt>getEntityClass</tt> method.\n+     *\n+     * @param builder\n+     *  the builder to add to this factory\n+     *\n+     * @throws IllegalArgumentException\n+     *  if the provided builder is null\n+     *\n+     * @return\n+     *  a reference to this node factory\n+     */\n+    public NodeFactory addBuilder(NodeBuilder builder) {\n+        if (builder == null) {\n+            throw new IllegalArgumentException(\"builder is null\");\n+        }\n+\n+        this.builders.put(builder.getEntityClass(), builder);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the mapper to use for mapping nodes created by this factory.\n+     *\n+     * @param mapper\n+     *  the mapper to use for mapping nodes\n+     *\n+     * @throws IllegalArgumentException\n+     *  if the provided mapper is null\n+     *\n+     * @return\n+     *  a reference to this node factory\n+     */\n+    public NodeFactory setNodeMapper(NodeMapper mapper) {\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"mapper is null\");\n+        }\n+\n+        this.mapper = mapper;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns an entity node for the given entity class and ID, creating it as necessary.", "originalCommit": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MTE5NQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420141195", "bodyText": "Added an extra bit to the end of that sentence. Now reads \"creating and mapping it as necessary\". Will show up in the next commit.", "author": "Ceiu", "createdAt": "2020-05-05T14:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3ODg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420065010", "bodyText": "The ProductManager did flush when saving the core products, then again when saving the owner-products. Here it seems we're deferring flushing for when? Shouldn't we flush before CandlepinPoolManager starts processing the pools? (same question applies for ContentNodeVisitor.complete)", "author": "nikosmoum", "createdAt": "2020-05-05T12:19:45Z", "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ProductNodeVisitor.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.visitors;\n+\n+import org.candlepin.controller.ProductManager;\n+import org.candlepin.controller.refresher.RefreshResult;\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.Branding;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerProduct;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.BrandingInfo;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.service.model.ProductContentInfo;\n+import org.candlepin.service.model.ProductInfo;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+\n+/**\n+ * A NodeVisitor implementation that supports product entity nodes\n+ */\n+public class ProductNodeVisitor implements NodeVisitor<Product, ProductInfo> {\n+    private final ProductCurator productCurator;\n+    private final OwnerProductCurator ownerProductCurator;\n+\n+    private Set<OwnerProduct> ownerProductEntities;\n+    private Map<Owner, Map<String, String>> ownerProductUuidMap;\n+\n+    /**\n+     * Creates a new ProductNodeVisitor that uses the provided curators for performing database\n+     * operations.\n+     *\n+     * @param productCurator\n+     *  the ProductCurator to use for product database operations\n+     *\n+     * @param ownerProductCurator\n+     *  the OwnerProductCurator to use for owner-product database operations\n+     *\n+     * @throws IllegalArgumentException\n+     *  if any of the provided curators are null\n+     */\n+    public ProductNodeVisitor(ProductCurator productCurator, OwnerProductCurator ownerProductCurator) {\n+        if (productCurator == null) {\n+            throw new IllegalArgumentException(\"productCurator is null\");\n+        }\n+\n+        if (ownerProductCurator == null) {\n+            throw new IllegalArgumentException(\"ownerProductCurator is null\");\n+        }\n+\n+        this.productCurator = productCurator;\n+        this.ownerProductCurator = ownerProductCurator;\n+\n+        this.ownerProductEntities = new HashSet<>();\n+        this.ownerProductUuidMap = new HashMap<>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Class<Product> getEntityClass() {\n+        return Product.class;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void processNode(NodeProcessor processor, NodeMapper mapper,\n+        EntityNode<Product, ProductInfo> node) {\n+\n+        boolean childrenUpdated = false;\n+        boolean nodeChanged = false;\n+\n+        if (node.visited()) {\n+            return;\n+        }\n+\n+        // Process children nodes first (depth-first), so we can update references and avoid\n+        // rework; also check if we need to make reference updates on this entity.\n+        for (EntityNode child : (Set<EntityNode>) node.getChildrenNodes()) {\n+            processor.processNode(child);\n+            childrenUpdated |= child.changed();\n+        }\n+\n+        Product existingEntity = node.getExistingEntity();\n+        ProductInfo importedEntity = node.getImportedEntity();\n+\n+        if (existingEntity != null) {\n+            if (importedEntity != null) {\n+                nodeChanged = ProductManager.isChangedBy(existingEntity, importedEntity);\n+            }\n+\n+            if (nodeChanged || childrenUpdated) {\n+                Product updatedEntity = this.createEntity(mapper, node);\n+                node.setUpdatedEntity(updatedEntity);\n+\n+                // Store the mapping to be updated later\n+                Map<String, String> productUuidMap = this.ownerProductUuidMap.get(node.getOwner());\n+                if (productUuidMap == null) {\n+                    productUuidMap = new HashMap<>();\n+                    this.ownerProductUuidMap.put(node.getOwner(), productUuidMap);\n+                }\n+                productUuidMap.put(existingEntity.getUuid(), updatedEntity.getUuid());\n+\n+                node.markChanged();\n+            }\n+        }\n+        else {\n+            // Node is new\n+            Product updatedEntity = this.createEntity(mapper, node);\n+            node.setUpdatedEntity(updatedEntity);\n+\n+            // Create a new owner-product mapping for this entity. This will get persisted\n+            // later during completion\n+            this.ownerProductEntities.add(new OwnerProduct(node.getOwner(), updatedEntity));\n+\n+            node.markChanged();\n+        }\n+\n+        node.markVisited();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void complete() {\n+        this.ownerProductCurator.saveAll(this.ownerProductEntities, false, true);", "originalCommit": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MDE4Mg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420140182", "bodyText": "Oversight on my part a bit. We need to flush before we start doing direct SQL queries for the owner remapping or bad things will happen; but we shouldn't need to flush between each in a given visitor. Just a single flush should be good.\nAs an interesting side note: evict without flush on the saveAll and updateAll methods does nothing. Debating leaving it as-is to show intent, but also reverting it to false, false since it doesn't do anything for us.", "author": "Ceiu", "createdAt": "2020-05-05T14:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1ODQxNw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420158417", "bodyText": "yes, evict to false would be more clear", "author": "nikosmoum", "createdAt": "2020-05-05T14:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2MTAyNA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420161024", "bodyText": "Done.", "author": "Ceiu", "createdAt": "2020-05-05T14:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwMzc1MQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420703751", "bodyText": "All the commented out code in this class should be removed, since it looks like it has already been replaced by the mockRefresh call", "author": "nikosmoum", "createdAt": "2020-05-06T10:56:43Z", "path": "server/src/test/java/org/candlepin/controller/PoolManagerTest.java", "diffHunk": "@@ -545,75 +556,98 @@ private void mockProducts(Owner owner, Product... products) {\n         this.mockProducts(owner, productMap);\n     }\n \n-    private void mockProductImport(Owner owner, final Map<String, Product> products) {\n-        when(mockProductManager.importProducts(eq(owner), any(Map.class), any(Map.class)))\n-            .thenAnswer(new Answer<ImportResult<Product>>() {\n-                @Override\n-                public ImportResult<Product> answer(InvocationOnMock invocation) throws Throwable {\n-                    Object[] args = invocation.getArguments();\n-                    Map<String, ProductData> productData = (Map<String, ProductData>) args[1];\n-                    ImportResult<Product> importResult = new ImportResult<>();\n-                    Map<String, Product> output = importResult.getCreatedEntities();\n-\n-                    if (productData != null) {\n-                        for (String pid : productData.keySet()) {\n-                            Product product = products.get(pid);\n+    private void mockRefresh(Owner owner, Collection<Product> products, Collection<Content> contents) {\n+        doAnswer(new Answer<RefreshResult>() {\n+            @Override\n+            public RefreshResult answer(InvocationOnMock iom) throws Throwable {\n+                RefreshResult output = new RefreshResult();\n \n-                            if (product != null) {\n-                                output.put(product.getId(), product);\n-                            }\n-                        }\n+                if (products != null) {\n+                    for (Product product : products) {\n+                        output.addCreatedProduct(product);\n                     }\n-\n-                    return importResult;\n                 }\n-            });\n-    }\n-\n-    private void mockProductImport(Owner owner, Product... products) {\n-        Map<String, Product> productMap = new HashMap<>();\n \n-        for (Product product : products) {\n-            productMap.put(product.getId(), product);\n-        }\n-\n-        this.mockProductImport(owner, productMap);\n-    }\n-\n-    private void mockContentImport(Owner owner, final Map<String, Content> contents) {\n-        when(mockContentManager.importContent(eq(owner), any(Map.class), any(Set.class)))\n-            .thenAnswer(new Answer<ImportResult<Content>>() {\n-                @Override\n-                public ImportResult<Content> answer(InvocationOnMock invocation) throws Throwable {\n-                    Object[] args = invocation.getArguments();\n-                    Map<String, ContentData> contentData = (Map<String, ContentData>) args[1];\n-                    ImportResult<Content> importResult = new ImportResult<>();\n-                    Map<String, Content> output = importResult.getCreatedEntities();\n-\n-                    if (contentData != null) {\n-                        for (String pid : contentData.keySet()) {\n-                            Content content = contents.get(pid);\n-\n-                            if (content != null) {\n-                                output.put(content.getId(), content);\n-                            }\n-                        }\n+                if (contents != null) {\n+                    for (Content content : contents) {\n+                        output.addCreatedContent(content);\n                     }\n-\n-                    return importResult;\n                 }\n-            });\n-    }\n \n-    private void mockContentImport(Owner owner, Content... contents) {\n-        Map<String, Content> contentMap = new HashMap<>();\n-\n-        for (Content content : contents) {\n-            contentMap.put(content.getId(), content);\n-        }\n-\n-        this.mockContentImport(owner, contentMap);\n-    }\n+                return output;\n+            }})\n+        .when(this.refreshWorker).execute(eq(owner));\n+    }\n+\n+    // private void mockProductImport(Owner owner, final Map<String, Product> products) {", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMDgzOQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420930839", "bodyText": "Yeah. Once I finish with the refresh testing, I'm going to go back and remove the commented out code which is no longer required, and fix up the bits that are.", "author": "Ceiu", "createdAt": "2020-05-06T16:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwMzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjA1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420706053", "bodyText": "irrelevant comment for the test", "author": "nikosmoum", "createdAt": "2020-05-06T11:01:19Z", "path": "server/src/test/java/org/candlepin/controller/refresher/builders/ContentNodeBuilderTest.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.ContentMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ContentNodeBuilder class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ContentNodeBuilderTest {\n+\n+    private NodeFactory mockNodeFactory;\n+    private ContentMapper contentMapper;\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.mockNodeFactory = mock(NodeFactory.class);\n+        this.contentMapper = new ContentMapper();\n+    }\n+\n+    private ContentNodeBuilder buildNodeBuilder() {\n+        return new ContentNodeBuilder(this.contentMapper);\n+    }\n+\n+    private Set<Content> createCandidateEntitiesSet(String id) {\n+        Set<Content> candidates = new HashSet<>();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            Content candidate = TestUtil.createContent(id, TestUtil.randomString());\n+            candidates.add(candidate);\n+        }\n+\n+        return candidates;\n+    }\n+\n+    private void addDummyCandidateEntitiesToMap(Map<String, Set<Content>> candidateEntitiesMap) {\n+        for (int i = 0; i < 5; ++i) {\n+            String id = TestUtil.randomString();\n+            candidateEntitiesMap.put(id, this.createCandidateEntitiesSet(id));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ContentNodeBuilder builder = this.buildNodeBuilder();\n+\n+        Class output = builder.getEntityClass();\n+\n+        assertNotNull(output);\n+        assertEquals(Content.class, output);\n+    }\n+\n+\n+    /**\n+     * Builds a new entity node owned by the given owner, using the specified entity ID. The\n+     * provided node factory should be used when performing construction of children nodes to ensure\n+     * proper mapping and avoiding code duplication.\n+     *\n+     * @param factory\n+     *  the node factory to use for performing construction of children nodes\n+     *\n+     * @param owner\n+     *  the organization that will own the entity represented by the new entity node\n+     *\n+     * @param id\n+     *  the ID of the entity represented by the new entity node\n+     *\n+     * @throws IllegalStateException\n+     *  if an entity node representing the given ID cannot be created\n+     *\n+     * @return\n+     *  a new EntityNode instance representing the entity with the provided ID\n+     */\n+    // EntityNode<E, I> buildNode(NodeFactory factory, Owner owner, String id);\n+", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMTk1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420931953", "bodyText": "Oh, whoops. Something I copied in so I didn't have to keep switching tabs. Removed.", "author": "Ceiu", "createdAt": "2020-05-06T16:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwODAzNw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420708037", "bodyText": "out of place comment", "author": "nikosmoum", "createdAt": "2020-05-06T11:05:23Z", "path": "server/src/test/java/org/candlepin/controller/refresher/builders/ProductNodeBuilderTest.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.ProductMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.AbstractHibernateObject;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.Product;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.service.model.ServiceAdapterModel;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ProductNodeBuilder class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ProductNodeBuilderTest {\n+\n+    private NodeFactory mockNodeFactory;\n+    private ProductMapper productMapper;\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.mockNodeFactory = mock(NodeFactory.class);\n+        this.productMapper = new ProductMapper();\n+    }\n+\n+    private ProductNodeBuilder buildNodeBuilder() {\n+        return new ProductNodeBuilder(this.productMapper);\n+    }\n+\n+    private Set<Product> createCandidateEntitiesSet(String id) {\n+        Set<Product> candidates = new HashSet<>();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            Product candidate = TestUtil.createProduct(id, TestUtil.randomString());\n+            candidates.add(candidate);\n+        }\n+\n+        return candidates;\n+    }\n+\n+    private void addDummyCandidateEntitiesToMap(Map<String, Set<Product>> candidateEntitiesMap) {\n+        for (int i = 0; i < 5; ++i) {\n+            String id = TestUtil.randomString();\n+            candidateEntitiesMap.put(id, this.createCandidateEntitiesSet(id));\n+        }\n+    }\n+\n+    private EntityNode mockEntityNode(Owner owner, Class cls, String id,\n+        AbstractHibernateObject existingEntity, ServiceAdapterModel importedEntity) {\n+\n+        EntityNode node = mock(EntityNode.class);\n+\n+        doReturn(owner).when(node).getOwner();\n+        doReturn(cls).when(node).getEntityClass();\n+        doReturn(id).when(node).getEntityId();\n+\n+        doReturn(existingEntity).when(node).getExistingEntity();\n+        doReturn(importedEntity).when(node).getImportedEntity();\n+\n+        doReturn(node).when(this.mockNodeFactory).buildNode(eq(owner), eq(cls), eq(id));\n+\n+        return node;\n+    }\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ProductNodeBuilder builder = this.buildNodeBuilder();\n+\n+        Class output = builder.getEntityClass();\n+\n+        assertNotNull(output);\n+        assertEquals(Product.class, output);\n+    }\n+\n+\n+    /**\n+     * Builds a new entity node owned by the given owner, using the specified entity ID. The\n+     * provided node factory should be used when performing construction of children nodes to ensure\n+     * proper mapping and avoiding code duplication.\n+     *\n+     * @param factory\n+     *  the node factory to use for performing construction of children nodes\n+     *\n+     * @param owner\n+     *  the organization that will own the entity represented by the new entity node\n+     *\n+     * @param id\n+     *  the ID of the entity represented by the new entity node\n+     *\n+     * @throws IllegalStateException\n+     *  if an entity node representing the given ID cannot be created\n+     *\n+     * @return\n+     *  a new EntityNode instance representing the entity with the provided ID\n+     */\n+    // EntityNode<E, I> buildNode(NodeFactory factory, Owner owner, String id);\n+", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDE0MQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421380141", "bodyText": "\ud83d\udc4d Recursing on the NodeProcessor directly is much clearer than going through the visitors", "author": "nikosmoum", "createdAt": "2020-05-07T09:49:02Z", "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/NodeProcessor.java", "diffHunk": "@@ -110,38 +111,26 @@ public void processNodes() {\n         }\n     }\n \n-    /**\n-     * Processes the specified node. If a node mapper has not yet been set, or a visitor has not\n-     * been provided for the node, or one or more of its children, this method throws an exception.\n-     * If the provided node is null, this method will silently return.\n-     *\n-     * @param node\n-     *  the entity node to process\n-     *\n-     * @throws IllegalStateException\n-     *  if a node mapper has not been set, or a visitor has not been provided for the class of\n-     *  node provided, or one or more of its children.\n-     */\n-    public void processNode(EntityNode node) {\n-        if (this.mapper == null) {\n-            throw new IllegalStateException(\"node mapper has not been set\");\n-        }\n-\n-        this.processNodeImpl(node);\n-    }\n-\n     /**\n      * Internal implementation that avoids repeating unnecessary input and state validation\n      */\n     private void processNodeImpl(EntityNode node) {\n         if (node != null) {\n-            NodeVisitor visitor = this.visitors.get(node.getEntityClass());\n+            // Process children nodes first (depth-first), so we can update references and avoid\n+            // rework\n+            for (EntityNode childNode : (Collection<EntityNode>) node.getChildrenNodes()) {\n+                this.processNodeImpl(childNode);", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4Njk2MQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421386961", "bodyText": "It doesn't look like this one line is needed (the validator isn't used thereafter)", "author": "nikosmoum", "createdAt": "2020-05-07T10:00:26Z", "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitorTest.java", "diffHunk": "@@ -332,8 +277,10 @@ public void testProcessNodeForUnchangedEntity(String key, Object base, Object up\n         Owner owner = TestUtil.createOwner();\n         String id = TestUtil.randomString(\"test_id\");\n \n-        Content existing = this.createPopulatedEntity(id, key, base);\n-        ContentInfo imported = this.createPopulatedEntity(id, key, base);\n+        Content existing = this.createPopulatedExistingEntity(id, key, base);\n+        ContentInfo imported = this.createPopulatedImportedEntity(id, key, base);\n+\n+        MergeValidator<ContentInfo> validator = this.validators.get(key);", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTUyNw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421535527", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-05-07T14:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTAxMg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421389012", "bodyText": "\ud83d\udc4d", "author": "nikosmoum", "createdAt": "2020-05-07T10:04:03Z", "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitorTest.java", "diffHunk": "@@ -60,79 +55,9 @@\n @MockitoSettings(strictness = Strictness.LENIENT)\n public class ContentNodeVisitorTest {\n \n-    @FunctionalInterface\n-    private static interface Mutator {\n-\n-        void mutate(Content content, Object value);\n-\n-    }\n-\n-    @FunctionalInterface\n-    private static interface Validator {\n-        default void validate(ContentInfo existing, ContentInfo imported, ContentInfo merged) {\n-            if (this.access(merged) != null) {\n-                if (imported != null && this.access(imported) != null) {\n-                    assertEquals(this.access(imported), this.access(merged));\n-                }\n-                else {\n-                    assertNotNull(existing);\n-                    assertEquals(this.access(existing), this.access(merged));\n-                }\n-            }\n-            else {\n-                if (imported != null) {\n-                    assertNull(this.access(imported));\n-                }\n-\n-                if (existing != null) {\n-                    assertNull(this.access(existing));\n-                }\n-            }\n-        }\n-\n-        Object access(ContentInfo content);\n-    }\n-\n-    @FunctionalInterface\n-    private static interface CollectionValidator extends Validator {\n-        @Override\n-        default void validate(ContentInfo existing, ContentInfo imported, ContentInfo merged) {\n-            if (this.access(merged) != null) {\n-                Collection<Object> actual = this.access(merged);\n-                Collection<Object> expected = null;\n-\n-                if (imported != null && this.access(imported) != null) {\n-                    expected = this.access(imported);\n-                }\n-                else {\n-                    assertNotNull(existing);\n-                    expected = this.access(existing);\n-                }\n-\n-                assertNotNull(expected);\n-                assertEquals(expected.size(), actual.size());\n-\n-                for (Object item : expected) {\n-                    assertThat(actual, hasItem(item));\n-                }\n-            }\n-            else {\n-                if (imported != null) {\n-                    assertNull(this.access(imported));\n-                }\n-\n-                if (existing != null) {\n-                    assertNull(this.access(existing));\n-                }\n-            }\n-        }\n-\n-        @Override\n-        Collection access(ContentInfo content);\n-    }\n-\n-    private Map<String, Mutator> mutators;\n-    private Map<String, Validator> validators;\n+    private Map<String, Mutator<Content>> contentMutators;\n+    private Map<String, Mutator<ContentInfo>> cinfoMutators;", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTY0MA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421389640", "bodyText": "Same here, validator not used after retrieving here", "author": "nikosmoum", "createdAt": "2020-05-07T10:05:07Z", "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ProductNodeVisitorTest.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.visitors;\n+\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.controller.refresher.nodes.ProductNode;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerProduct;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.AdditionalAnswers.returnsFirstArg;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ProductNodeVisitor class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ProductNodeVisitorTest {\n+\n+    private Map<String, Mutator<Product>> productMutators;\n+    private Map<String, Mutator<ProductInfo>> pinfoMutators;\n+    private Map<String, MergeValidator<ProductInfo>> validators;\n+\n+    private ProductCurator mockProductCurator;\n+    private OwnerProductCurator mockOwnerProductCurator;\n+    private NodeProcessor mockNodeProcessor;\n+    private NodeMapper mockNodeMapper;\n+\n+    @BeforeEach\n+    public void init() {\n+        this.productMutators = new HashMap<>();\n+        this.productMutators.put(\"name\", (c, v) -> c.setName((String) v));\n+        this.productMutators.put(\"multiplier\", (c, v) -> c.setMultiplier((Long) v));\n+        this.productMutators.put(\"dependent_product_ids\", (c, v) -> c.setDependentProductIds((Collection) v));\n+        this.productMutators.put(\"attributes\", (c, v) -> c.setAttributes((Map) v));\n+        this.productMutators.put(\"product_content\", (c, v) -> c.setProductContent((Collection) v));\n+        this.productMutators.put(\"branding\", (c, v) -> c.setBranding((Collection) v));\n+        this.productMutators.put(\"provided_products\", (c, v) -> c.setProvidedProducts((Collection) v));\n+\n+        this.pinfoMutators = new HashMap<>();\n+        this.pinfoMutators.put(\"name\", (c, v) -> doReturn(v).when(c).getName());\n+        this.pinfoMutators.put(\"multiplier\", (c, v) -> doReturn(v).when(c).getMultiplier());\n+        this.pinfoMutators.put(\"dependent_product_ids\",\n+            (c, v) -> doReturn(v).when(c).getDependentProductIds());\n+        this.pinfoMutators.put(\"attributes\", (c, v) -> doReturn(v).when(c).getAttributes());\n+        this.pinfoMutators.put(\"product_content\", (c, v) -> doReturn(v).when(c).getProductContent());\n+        this.pinfoMutators.put(\"branding\", (c, v) -> doReturn(v).when(c).getBranding());\n+        this.pinfoMutators.put(\"provided_products\", (c, v) -> doReturn(v).when(c).getProvidedProducts());\n+\n+        this.validators = new HashMap<>();\n+        this.validators.put(\"name\", c -> c.getName());\n+        this.validators.put(\"multiplier\", c -> c.getMultiplier());\n+        this.validators.put(\"dependent_product_ids\", (CollectionMergeValidator<ProductInfo>)\n+            c -> c.getDependentProductIds());\n+        this.validators.put(\"attributes\", (MapMergeValidator<ProductInfo>) c -> c.getAttributes());\n+\n+\n+        this.mockProductCurator = mock(ProductCurator.class);\n+        this.mockOwnerProductCurator = mock(OwnerProductCurator.class);\n+        this.mockNodeProcessor = mock(NodeProcessor.class);\n+        this.mockNodeMapper = mock(NodeMapper.class);\n+\n+        doAnswer(returnsFirstArg())\n+            .when(this.mockProductCurator)\n+            .saveOrUpdate(Mockito.any(Product.class));\n+\n+        doAnswer(returnsFirstArg())\n+            .when(this.mockOwnerProductCurator)\n+            .saveOrUpdate(Mockito.any(OwnerProduct.class));\n+    }\n+\n+    public static List<Arguments> productDataProvider() {\n+        Map<String, String> baseAttribs = new HashMap<>();\n+        baseAttribs.put(\"A\", \"1\");\n+        baseAttribs.put(\"B\", \"2\");\n+        baseAttribs.put(\"C\", \"3\");\n+\n+        Map<String, String> updatedAttribs = new HashMap<>();\n+        baseAttribs.put(\"C\", \"3\");\n+        baseAttribs.put(\"D\", \"4\");\n+        baseAttribs.put(\"E\", \"5\");\n+\n+        return Arrays.asList(\n+            Arguments.of(\"name\", \"base_name\", \"updated_name\"),\n+            Arguments.of(\"multiplier\", 12345L, 67890L),\n+            Arguments.of(\"dependent_product_ids\", Arrays.asList(\"1\", \"2\", \"3\"), Arrays.asList(\"A\", \"B\", \"C\")),\n+            Arguments.of(\"attributes\", baseAttribs, updatedAttribs));\n+    }\n+\n+    private ProductNodeVisitor buildProductNodeVisitor() {\n+        return new ProductNodeVisitor(this.mockProductCurator, this.mockOwnerProductCurator);\n+    }\n+\n+    private Product createPopulatedExistingEntity(String id, String key, Object value) {\n+        Product entity = new Product();\n+        entity.setId(id);\n+\n+        Mutator mutator = this.productMutators.get(key);\n+        if (mutator == null) {\n+            throw new IllegalStateException(\"No mutator for key: \" + key);\n+        }\n+\n+        mutator.mutate(entity, value);\n+\n+        return entity;\n+    }\n+\n+    private ProductInfo createPopulatedImportedEntity(String id, String key, Object value) {\n+        ProductInfo entity = mock(ProductInfo.class);\n+        doReturn(id).when(entity).getId();\n+\n+        // Impl note:\n+        // This is necessary, since the default behavior for mocked methods that return primitive\n+        // containers is to return a wrapped default primitive value, *NOT* null as one might\n+        // expect.\n+        doReturn(null).when(entity).getMultiplier();\n+\n+        Mutator mutator = this.pinfoMutators.get(key);\n+        if (mutator == null) {\n+            throw new IllegalStateException(\"No mutator for key: \" + key);\n+        }\n+\n+        mutator.mutate(entity, value);\n+\n+        return entity;\n+    }\n+\n+    private void validateMergedEntity(Product existing, ProductInfo imported, Product merged) {\n+        // Assert that we actually have a merged entity\n+        assertNotNull(merged);\n+\n+        // Ensure the ID is set properly\n+        assertNotNull(merged.getId());\n+\n+        if (existing != null) {\n+            assertNotNull(existing.getId());\n+            assertEquals(existing.getId(), merged.getId());\n+        }\n+\n+        if (imported != null) {\n+            assertNotNull(imported.getId());\n+            assertEquals(imported.getId(), merged.getId());\n+        }\n+\n+        // Check that the product is locked properly\n+        if (existing != null) {\n+            assertEquals(existing.isLocked(), merged.isLocked());\n+        }\n+        else {\n+            assertNotNull(imported);\n+            assertTrue(merged.isLocked());\n+        }\n+\n+        // Check other attributes\n+        for (MergeValidator validator : this.validators.values()) {\n+            validator.validate(existing, imported, merged);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        assertEquals(Product.class, visitor.getEntityClass());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForSkippedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+\n+        EntityNode<Product, ProductInfo> node = new ProductNode(owner, id)\n+            .setExistingEntity(existing);\n+\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        // Ensure initial node state\n+        assertFalse(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+\n+        // Visit/process the node\n+        visitor.processNode(this.mockNodeProcessor, this.mockNodeMapper, node);\n+        visitor.complete();\n+\n+        // Validate \"processed\" state\n+        assertTrue(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForUnmodifiedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+        ProductInfo imported = this.createPopulatedImportedEntity(id, key, null);\n+\n+        EntityNode<Product, ProductInfo> node = new ProductNode(owner, id)\n+            .setExistingEntity(existing)\n+            .setImportedEntity(imported);\n+\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        // Ensure initial node state\n+        assertFalse(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+\n+        // Visit/process the node\n+        visitor.processNode(this.mockNodeProcessor, this.mockNodeMapper, node);\n+        visitor.complete();\n+\n+        // Validate \"processed\" state\n+        assertTrue(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForUnchangedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+        ProductInfo imported = this.createPopulatedImportedEntity(id, key, base);\n+\n+        MergeValidator<ProductInfo> validator = this.validators.get(key);", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTYzNg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421535636", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-05-07T14:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTY0MA=="}], "type": "inlineReview"}, {"oid": "3006213a170f9e614fb0554698a88f5354ec2750", "url": "https://github.com/candlepin/candlepin/commit/3006213a170f9e614fb0554698a88f5354ec2750", "message": "(SQUASH ME) Added tests for the RefreshResult and RefreshWorker classes", "committedDate": "2020-05-11T20:52:10Z", "type": "forcePushed"}, {"oid": "0fdb8357fbbbc3a83de7b57d691808b9cc682078", "url": "https://github.com/candlepin/candlepin/commit/0fdb8357fbbbc3a83de7b57d691808b9cc682078", "message": "Added the RefreshWorker framework and refactored the refresh process\n\n- Added the RefreshWorker and the org.candlepin.controller.refresher.*\n  package containing the new framework for performing refresh\n- Updated the CandlepinPoolManager to use the new refresh framework\n- Added the upstream_subscription_injector tool for setting up a\n  Candlepin instance for repeatable upstream testing\n- Fixed the test data setup in the tests for OwnerProductResource\n- Fixed a NPE bug in Subscription when calling isStacked without\n  a product\n- Added additional validation to the hosted-test subscription\n  adapter to ensure subscriptions cannot be created without a\n  product\n- Improved several API methods in the hosted test spec resources\n- Fixed refresh spec tests broken by changes to the hosted test APIs", "committedDate": "2020-05-11T20:56:28Z", "type": "commit"}, {"oid": "0fdb8357fbbbc3a83de7b57d691808b9cc682078", "url": "https://github.com/candlepin/candlepin/commit/0fdb8357fbbbc3a83de7b57d691808b9cc682078", "message": "Added the RefreshWorker framework and refactored the refresh process\n\n- Added the RefreshWorker and the org.candlepin.controller.refresher.*\n  package containing the new framework for performing refresh\n- Updated the CandlepinPoolManager to use the new refresh framework\n- Added the upstream_subscription_injector tool for setting up a\n  Candlepin instance for repeatable upstream testing\n- Fixed the test data setup in the tests for OwnerProductResource\n- Fixed a NPE bug in Subscription when calling isStacked without\n  a product\n- Added additional validation to the hosted-test subscription\n  adapter to ensure subscriptions cannot be created without a\n  product\n- Improved several API methods in the hosted test spec resources\n- Fixed refresh spec tests broken by changes to the hosted test APIs", "committedDate": "2020-05-11T20:56:28Z", "type": "forcePushed"}]}