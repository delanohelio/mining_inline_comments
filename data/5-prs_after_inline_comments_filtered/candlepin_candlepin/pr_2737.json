{"pr_number": 2737, "pr_title": "[F] RefreshWorker now prunes \"unused\" entities during refresh (ENT-2352)", "pr_createdAt": "2020-06-26T21:34:01Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2737", "timeline": [{"oid": "6f56156c211b3e94649207096448143b9da82f96", "url": "https://github.com/candlepin/candlepin/commit/6f56156c211b3e94649207096448143b9da82f96", "message": "WIP: RefreshWorker now prunes \"unused\" entities during refresh\n\nDONE:\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences to use\n  partitioned data sets, to avoid running over the parameter limit\n  when processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool (may revert this)\n\nTODO:\n- Rewrite/Fix a bunch of tests\n- Fix OwnerProductCurator to be in line with the changes made to\n  OwnerContentCurator\n- Update RefreshResult to better collect, store, and provide\n  its entities. This should be done with an EntityState enum,\n  and by storing a Pair<EntityState, Entity> rather than the\n  raw entity in individual maps. This will prevent an entity\n  from existing twice in the EntityStore and will make fetching\n  entire maps much easier with some fancy use of streams,\n  filters, and collectors.\n- Remove the new code from EnvironmentContentCurator if it's not\n  used in the final implementation\n- Add details for other work that's been done that I haven't yet\n  captured in this commit message.\n- Potentially remove the flat entity maps in favor of just building\n  the nodes directly. This may not work given the order of\n  operations, but it seems like having n+1 flatmaps is not very\n  memory efficient, nor required.\n- Figure out why pool mapping works when it shouldn't", "committedDate": "2020-07-01T19:04:26Z", "type": "forcePushed"}, {"oid": "a49c85e324c1ae063966d59bf400e71f87076c95", "url": "https://github.com/candlepin/candlepin/commit/a49c85e324c1ae063966d59bf400e71f87076c95", "message": "WIP: RefreshWorker now prunes \"unused\" entities during refresh\n\nDONE:\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n\nTODO:\n- Rewrite/Fix a bunch of tests\n- Update RefreshResult to better collect, store, and provide\n  its entities. This should be done with an EntityState enum,\n  and by storing a Pair<EntityState, Entity> rather than the\n  raw entity in individual maps. This will prevent an entity\n  from existing twice in the EntityStore and will make fetching\n  entire maps much easier with some fancy use of streams,\n  filters, and collectors.\n- Remove the new code from EnvironmentContentCurator if it's not\n  used in the final implementation\n- Add details for other work that's been done that I haven't yet\n  captured in this commit message.\n- Potentially remove the flat entity maps in favor of just building\n  the nodes directly. This may not work given the order of\n  operations, but it seems like having n+1 flatmaps is not very\n  memory efficient, nor required.", "committedDate": "2020-06-17T20:04:07Z", "type": "forcePushed"}, {"oid": "97c7cf6930ae930b5f7ff63d8d3bed78db2db74b", "url": "https://github.com/candlepin/candlepin/commit/97c7cf6930ae930b5f7ff63d8d3bed78db2db74b", "message": "WIP: RefreshWorker now prunes \"unused\" entities during refresh\n\nDONE:\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n\nTODO:\n- Rewrite/Fix a bunch of tests\n- Update RefreshResult to better collect, store, and provide\n  its entities. This should be done with an EntityState enum,\n  and by storing a Pair<EntityState, Entity> rather than the\n  raw entity in individual maps. This will prevent an entity\n  from existing twice in the EntityStore and will make fetching\n  entire maps much easier with some fancy use of streams,\n  filters, and collectors.\n- Remove the new code from EnvironmentContentCurator if it's not\n  used in the final implementation\n- Add details for other work that's been done that I haven't yet\n  captured in this commit message.\n- Potentially remove the flat entity maps in favor of just building\n  the nodes directly. This may not work given the order of\n  operations, but it seems like having n+1 flatmaps is not very\n  memory efficient, nor required.", "committedDate": "2020-08-03T21:03:59Z", "type": "forcePushed"}, {"oid": "5b672a3688fc2d82001168c2486c7eae61bdf49e", "url": "https://github.com/candlepin/candlepin/commit/5b672a3688fc2d82001168c2486c7eae61bdf49e", "message": "WIP: RefreshWorker now prunes \"unused\" entities during refresh\n\nDONE:\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n\nTODO:\n- Add remaining tests for new functionality\n- Update RefreshResult to better collect, store, and provide\n  its entities. This should be done with an EntityState enum,\n  and by storing a Pair<EntityState, Entity> rather than the\n  raw entity in individual maps. This will prevent an entity\n  from existing twice in the EntityStore and will make fetching\n  entire maps much easier with some fancy use of streams,\n  filters, and collectors.\n- Remove the new code from EnvironmentContentCurator if it's not\n  used in the final implementation", "committedDate": "2020-08-04T19:21:04Z", "type": "forcePushed"}, {"oid": "8890bafa288fb5832a7dcd7f6376231040c6c4f1", "url": "https://github.com/candlepin/candlepin/commit/8890bafa288fb5832a7dcd7f6376231040c6c4f1", "message": "RefreshWorker now prunes \"unused\" entities during refresh\n\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n- RefreshResult no longer uses a hardcoded collection of maps\n  to store resultant refresh information", "committedDate": "2020-08-05T18:12:29Z", "type": "forcePushed"}, {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff", "url": "https://github.com/candlepin/candlepin/commit/edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff", "message": "RefreshWorker now prunes \"unused\" entities during refresh\n\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n- RefreshResult no longer uses a hardcoded collection of maps\n  to store resultant refresh information", "committedDate": "2020-08-05T19:53:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA2NDc5Nw==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472064797", "bodyText": "Log argument is missing.", "author": "Januson", "createdAt": "2020-08-18T10:04:46Z", "path": "server/src/main/java/org/candlepin/async/tasks/OrphanCleanupJob.java", "diffHunk": "@@ -88,23 +91,29 @@ private int deleteOrphanedContent() {\n             ++count;\n         }\n \n-        this.productCurator.flush();\n+        this.contentCurator.flush();\n         log.debug(\"{} orphaned product entities deleted\", count);\n \n         return count;\n     }\n \n     private int deleteOrphanedProducts() {\n-        int count = 0;\n-        CandlepinQuery<Product> productQuery = this.ownerProductCurator.getOrphanedProducts()\n-            .setLockMode(LockModeType.PESSIMISTIC_WRITE);\n+        List<String> orphanedProductUuids = this.ownerProductCurator.getOrphanedProductUuids();\n \n-        for (Product product : productQuery) {\n-            this.productCurator.delete(product);\n-            ++count;\n+        Set<Pair<String, String>> activePoolProducts = this.productCurator\n+            .getProductsWithPools(orphanedProductUuids);\n+\n+        if (activePoolProducts != null && !activePoolProducts.isEmpty()) {\n+            log.warn(\"Found {} pools referencing orphaned products:\");", "originalCommit": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE4NDUyNQ==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472184525", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-08-18T13:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA2NDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDc3OA==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472070778", "bodyText": "Could we do something about our use of raw types? It's starting to feel a bit excessive. We could at least use the wildcards.", "author": "Januson", "createdAt": "2020-08-18T10:15:30Z", "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -67,23 +71,45 @@ public NodeFactory addBuilder(NodeBuilder builder) {\n     }\n \n     /**\n-     * Sets the mapper to use for mapping nodes created by this factory.\n+     * Adds a mapper to this factory. The mapper will be used to provide entities during node\n+     * construction for the class returned by the mapper's <tt>getEntityClass</tt> method.\n      *\n      * @param mapper\n-     *  the mapper to use for mapping nodes\n+     *  the mapper to add to this factory\n      *\n      * @throws IllegalArgumentException\n      *  if the provided mapper is null\n      *\n      * @return\n      *  a reference to this node factory\n      */\n-    public NodeFactory setNodeMapper(NodeMapper mapper) {\n+    public NodeFactory addMapper(EntityMapper mapper) {", "originalCommit": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3OTgxOA==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472279818", "bodyText": "I've added wildcards where appropriate, but this doesn't really buy us much outside of one weird compiler error that required a random cast to the same type.", "author": "Ceiu", "createdAt": "2020-08-18T15:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzY1Ng==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472073656", "bodyText": "We could you Map.computeIfAbsent here.", "author": "Januson", "createdAt": "2020-08-18T10:20:58Z", "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitor.java", "diffHunk": "@@ -87,32 +89,38 @@ public ContentNodeVisitor(ContentCurator contentCurator, OwnerContentCurator own\n     public void processNode(NodeProcessor processor, NodeMapper mapper,\n         EntityNode<Content, ContentInfo> node) {\n \n-        if (node.visited()) {\n-            return;\n-        }\n-\n         // Content nodes should not have any children\n         if (!node.isLeafNode()) {\n             throw new IllegalStateException(\"Content node has one or more children nodes\");\n         }\n \n+        // If this node already has a state, we don't need to reprocess it (probably)\n+        if (node.getNodeState() != null) {\n+            return;\n+        }\n+\n         Content existingEntity = node.getExistingEntity();\n         ContentInfo importedEntity = node.getImportedEntity();\n \n+        // Default the node state to UNCHANGED and let our cases below overwrite this\n+        node.setNodeState(NodeState.UNCHANGED);\n+\n         if (existingEntity != null) {\n-            if (importedEntity != null && ContentManager.isChangedBy(existingEntity, importedEntity)) {\n-                Content mergedEntity = this.createEntity(mapper, node);\n-                node.setMergedEntity(mergedEntity);\n-\n-                // Store the mapping to be updated later\n-                Map<String, String> contentUuidMap = this.ownerContentUuidMap.get(node.getOwner());\n-                if (contentUuidMap == null) {\n-                    contentUuidMap = new HashMap<>();\n-                    this.ownerContentUuidMap.put(node.getOwner(), contentUuidMap);\n+            if (importedEntity != null) {\n+                if (ContentManager.isChangedBy(existingEntity, importedEntity)) {\n+                    Content mergedEntity = this.createEntity(mapper, node);\n+                    node.setMergedEntity(mergedEntity);\n+\n+                    // Store the mapping to be updated later\n+                    Map<String, String> contentUuidMap = this.ownerContentUuidMap.get(node.getOwner());\n+                    if (contentUuidMap == null) {", "originalCommit": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE4NTE4NQ==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472185185", "bodyText": "Ahh, nice. Turns out it's ever-so-slightly faster, too. Fixed here and in a few other places.", "author": "Ceiu", "createdAt": "2020-08-18T13:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzY1Ng=="}], "type": "inlineReview"}, {"oid": "7fd89c353faebd302ca0cfc470efcdaa1675790d", "url": "https://github.com/candlepin/candlepin/commit/7fd89c353faebd302ca0cfc470efcdaa1675790d", "message": "RefreshWorker now prunes \"unused\" entities during refresh\n\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n- RefreshResult no longer uses a hardcoded collection of maps\n  to store resultant refresh information", "committedDate": "2020-08-18T15:20:47Z", "type": "forcePushed"}, {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b", "url": "https://github.com/candlepin/candlepin/commit/11773f6f21a55a56972f9d2fa2b39e74c15c251b", "message": "RefreshWorker now prunes \"unused\" entities during refresh\n\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n- RefreshResult no longer uses a hardcoded collection of maps\n  to store resultant refresh information", "committedDate": "2020-08-18T16:53:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r473094236", "bodyText": "If we want the buildNodes() method to be the primary interface that users of this class should build the nodes with, then we should change this method from public to protected or private, (unless there's a reason to keep this public?) to make the API clearer.", "author": "nikosmoum", "createdAt": "2020-08-19T14:56:45Z", "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -101,38 +127,66 @@ public NodeFactory setNodeMapper(NodeMapper mapper) {\n      *  the entity ID of the node to create\n      *\n      * @throws IllegalStateException\n-     *  if the mapper has not been set, or a builder has not been provided for the given entity\n-     *  class, or the builder failed to create a node for the entity\n+     *  if the node mapper has not been set, or a mapper or builder has not been provided for the\n+     *  given entity class, or the builder failed to create a node for the entity\n      *\n      * @return\n      *  the entity node for the given entity class and ID\n      */\n     public <E extends AbstractHibernateObject, I extends ServiceAdapterModel> EntityNode<E, I>\n         buildNode(Owner owner, Class<E> cls, String id) {", "originalCommit": "11773f6f21a55a56972f9d2fa2b39e74c15c251b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwMTY0NQ==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474701645", "bodyText": "This method is intended to be used by the builders which create children (ProductNodeBuilder, PoolNodeBuilder in the future) so the correct builder can be called and the caching is performed in a single place.", "author": "Ceiu", "createdAt": "2020-08-21T13:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNTUxOA==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474705518", "bodyText": "Oops you're right, I just noticed that PoolNodeBuilder does use it.", "author": "nikosmoum", "createdAt": "2020-08-21T13:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcxODE1Mg==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474718152", "bodyText": "I've bumped it to protected anyway, since it seems like we won't be using it outside of that package, and it probably doesn't have a ton of use externally.", "author": "Ceiu", "createdAt": "2020-08-21T14:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTQyNw==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474015427", "bodyText": "This should probably not say that the method is used for adding a \"created\" entity, since the method actually accepts a state argument", "author": "nikosmoum", "createdAt": "2020-08-20T14:13:57Z", "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshResult.java", "diffHunk": "@@ -32,501 +34,284 @@\n  */\n public class RefreshResult {\n \n-    // TODO: Flesh out the collection types here a bit more, in accordance with the table below\n-    //\n-    // Existing     Imported    Merged entity       Result\n-    // not-null     not-null    not-null            updated entity\n-    // not-null     not-null    null                unchanged entity (imported but unchanged)\n-    // not-null     null        not-null            children updated\n-    // not-null     null        null                unchanged entity (not imported, no changes to children)\n-    // null         not-null    not-null            created entity\n-    // null         not-null    null                ERROR STATE - creation failed\n-    // null         null        null                ERROR STATE - uninitialized node\n-    //\n-    // Following this, we have 3 states to report, and 2 pseudo-states:\n-    // - resultant states: created (5), updated (1, 3), unchanged (2, 4)\n-    // - pseudo-states: imported (1, 2, 5) and skipped (3, 4)\n-    //\n-    // At the time of writing, we can kind of discern the pseudo-states by getting the collections\n-    // back out of the refresh worker, so maybe this is a non-issue.\n-\n-    private Map<String, Pool> createdPools;\n-    private Map<String, Pool> updatedPools;\n-    private Map<String, Pool> skippedPools;\n-\n-    private Map<String, Product> createdProducts;\n-    private Map<String, Product> updatedProducts;\n-    private Map<String, Product> skippedProducts;\n-\n-    private Map<String, Content> createdContent;\n-    private Map<String, Content> updatedContent;\n-    private Map<String, Content> skippedContent;\n-\n-\n     /**\n-     * Creates a new RefreshResult instance with no data\n+     * The known states an entity can be in post-refresh\n      */\n-    public RefreshResult() {\n-        this.createdPools = new HashMap<>();\n-        this.updatedPools = new HashMap<>();\n-        this.skippedPools = new HashMap<>();\n-\n-        this.createdProducts = new HashMap<>();\n-        this.updatedProducts = new HashMap<>();\n-        this.skippedProducts = new HashMap<>();\n-\n-        this.createdContent = new HashMap<>();\n-        this.updatedContent = new HashMap<>();\n-        this.skippedContent = new HashMap<>();\n+    public static enum EntityState {\n+        CREATED,\n+        UPDATED,\n+        UNCHANGED,\n+        DELETED\n     }\n \n     /**\n-     * Adds the specified pool as a \"created\" pool, where a created pool is defined as a pool which\n-     * did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as a created pool\n+     * Stores refreshed entities of a given type\n      *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     * @param <T>\n+     *  the class of entity managed by this entity store\n      */\n-    public boolean addCreatedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+    public static class EntityStore<T extends AbstractHibernateObject> {\n+\n+        /**\n+         * Container class for storing entity and entity state\n+         */\n+        private static class EntityData<T extends AbstractHibernateObject> {\n+            private final String entityId;\n+            private final T entity;\n+            private final EntityState state;\n+\n+            public EntityData(String entityId, T entity, EntityState state) {\n+                this.entityId = entityId;\n+                this.entity = entity;\n+                this.state = state;\n+            }\n+\n+            public String getEntityId() {\n+                return this.entityId;\n+            }\n+\n+            public T getEntity() {\n+                return this.entity;\n+            }\n+\n+            public EntityState getEntityState() {\n+                return this.state;\n+            }\n         }\n \n-        return (this.createdPools.put(pool.getId(), pool) != pool);\n-    }\n+        private Map<String, EntityData<T>> entities;\n \n-    /**\n-     * Adds the specified pool as an \"updated\" pool, where an updated pool is defined as a pool\n-     * which was already defined locally, and was changed or updated during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as an updated pool\n-     *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addUpdatedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+        public EntityStore() {\n+            this.entities = new HashMap<>();\n         }\n \n-        return (this.updatedPools.put(pool.getId(), pool) != pool);\n-    }\n+        public void addEntity(T entity, EntityState state) {\n+            if (entity == null) {\n+                throw new IllegalArgumentException(\"entity is null\");\n+            }\n \n-    /**\n-     * Adds the specified pool as a \"skipped\" pool, where a skipped pool is defined as a pool which\n-     * was already defined locally, but remained unchanged during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as a skipped pool\n-     *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+            if (state == null) {\n+                throw new IllegalArgumentException(\"state is null\");\n+            }\n+\n+            EntityData<T> data = new EntityData<>((String) entity.getId(), entity, state);\n+            this.entities.put(data.getEntityId(), data);\n         }\n \n-        return (this.skippedPools.put(pool.getId(), pool) != pool);\n-    }\n+        public T getEntity(String id, Collection<EntityState> states) {\n+            EntityData<T> data = this.entities.get(id);\n \n-    /**\n-     * Adds the specified product as a \"created\" product, where a created product is defined as a\n-     * product which did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param product\n-     *  the product to add as a created product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addCreatedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n-        }\n+            if (data != null) {\n+                return states == null || states.isEmpty() || states.contains(data.getEntityState()) ?\n+                    data.getEntity() :\n+                    null;\n+            }\n \n-        return (this.createdProducts.put(product.getId(), product) != product);\n-    }\n+            return null;\n+        }\n \n-    /**\n-     * Adds the specified product as an \"updated\" product, where an updated product is defined as a\n-     * product which was already defined locally, and was changed or updated during the refresh\n-     * operation.\n-     *\n-     * @param product\n-     *  the product to add as an updated product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addUpdatedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n+        public EntityState getEntityState(String id) {\n+            EntityData<T> data = this.entities.get(id);\n+            return data != null ? data.getEntityState() : null;\n         }\n \n-        return (this.updatedProducts.put(product.getId(), product) != product);\n-    }\n+        public Map<String, T> getEntities(Collection<EntityState> states) {\n+            Stream<EntityData<T>> stream = this.entities.values()\n+                .stream();\n \n-    /**\n-     * Adds the specified product as a \"skipped\" product, where a skipped product is defined as a\n-     * product which was already defined locally, but remained unchanged during the refresh\n-     * operation.\n-     *\n-     * @param product\n-     *  the product to add as a skipped product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n-        }\n+            if (states != null && !states.isEmpty()) {\n+                stream = stream.filter(edata -> states.contains(edata.getEntityState()));\n+            }\n \n-        return (this.skippedProducts.put(product.getId(), product) != product);\n+            return stream.collect(Collectors.toMap(EntityData::getEntityId, EntityData::getEntity));\n+        }\n     }\n \n+    private Map<Class, EntityStore> entityStoreMap;\n+\n     /**\n-     * Adds the specified content as a \"created\" content, where a created content is defined as\n-     * content which did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param content\n-     *  the content to add as a created content\n-     *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     * Creates a new RefreshResult instance with no data\n      */\n-    public boolean addCreatedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n-        }\n-\n-        return (this.createdContent.put(content.getId(), content) != content);\n+    public RefreshResult() {\n+        this.entityStoreMap = new HashMap<>();\n     }\n \n     /**\n-     * Adds the specified content as an \"updated\" content, where an updated content is defined as\n-     * content which was already defined locally, and was changed or updated during the refresh\n-     * operation.\n+     * Fetches the entity store for the given class, optionally creating it as necessary.\n      *\n-     * @param content\n-     *  the content to add as an updated content\n+     * @param cls\n+     *  the class of the entity store to fetch\n      *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n+     * @param create\n+     *  whether or not to create the entity store if it doesn't already exist\n      *\n      * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     *  the entity store for the given class, or null if an appropriate entity store does not exist\n+     *  and the create flag is false.\n      */\n-    public boolean addUpdatedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n+    private <T extends AbstractHibernateObject> EntityStore<T> getEntityStore(Class<T> cls, boolean create) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"cls is null\");\n         }\n \n-        return (this.updatedContent.put(content.getId(), content) != content);\n-    }\n-\n-    /**\n-     * Adds the specified content as a \"skipped\" content, where a skipped content is defined as\n-     * content which was already defined locally, but remained unchanged during the refresh\n-     * operation.\n-     *\n-     * @param content\n-     *  the content to add as a skipped content\n-     *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n+        EntityStore<T> entityStore = (EntityStore<T>) this.entityStoreMap.get(cls);\n+        if (entityStore == null && create) {\n+            entityStore = new EntityStore<T>();\n+            this.entityStoreMap.put(cls, entityStore);\n         }\n \n-        return (this.skippedContent.put(content.getId(), content) != content);\n+        return entityStore;\n     }\n \n-    // TODO: Return copy-on-write versions of the maps from the getters, rather than returning\n-    // our internal maps directly.\n-\n     /**\n-     * Fetches the pools created during refresh as a mapping of pool IDs to pool instances. If no\n-     * pools were created during the refresh operation, this method returns an empty map.\n+     * Adds the specified entity as a \"created\" entity, where a created entity is defined as a\n+     * entity which did not have a local definition and was created during the refresh operation.", "originalCommit": "11773f6f21a55a56972f9d2fa2b39e74c15c251b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5ODM1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474698353", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-08-21T13:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDA4OQ==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474040089", "bodyText": "UNPROCESSED doesn't seem to be a state, and isn't referenced anywhere else afaik", "author": "nikosmoum", "createdAt": "2020-08-20T14:46:59Z", "path": "server/src/main/java/org/candlepin/controller/refresher/nodes/EntityNode.java", "diffHunk": "@@ -125,33 +160,33 @@\n     boolean isLeafNode();\n \n     /**\n-     * Checks if this node has been \"visited\", indicating that a visitor has processed the node and\n-     * marked it as visited.\n+     * Checks if this node represents a new or updated database entity.\n      *\n      * @return\n-     *  true if this node has been marked as visited; false otherwise\n-     */\n-    boolean visited();\n-\n-    /**\n-     * Marks this node as visited. If the node has already been marked visited, this method silently\n-     * returns.\n+     *  true if this node represents a new or updated database entity; false otherwise\n      */\n-    void markVisited();\n+    boolean changed();\n \n     /**\n-     * Checks if this node represents a new or updated database entity.\n+     * Fetches the operation to be performed on this node\n      *\n      * @return\n-     *  true if this node represents a new or updated database entity; false otherwise\n+     *  a NodeState representing the pseudo-state of this node\n      */\n-    boolean changed();\n+    NodeState getNodeState();\n \n     /**\n-     * Marks this node as changed. If the node has already been marked changed, this method silently\n-     * returns.\n+     * Sets the pseudo-state of this node. If the provided state is null or UNPROCESSED, any", "originalCommit": "11773f6f21a55a56972f9d2fa2b39e74c15c251b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5OTQ5MA==", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474699490", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-08-21T13:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDA4OQ=="}], "type": "inlineReview"}, {"oid": "a2d3b7ea04c8253201327bdde6ebdce40058bc9c", "url": "https://github.com/candlepin/candlepin/commit/a2d3b7ea04c8253201327bdde6ebdce40058bc9c", "message": "RefreshWorker now prunes \"unused\" entities during refresh\n\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n- RefreshResult no longer uses a hardcoded collection of maps\n  to store resultant refresh information", "committedDate": "2020-08-21T14:01:50Z", "type": "commit"}, {"oid": "a2d3b7ea04c8253201327bdde6ebdce40058bc9c", "url": "https://github.com/candlepin/candlepin/commit/a2d3b7ea04c8253201327bdde6ebdce40058bc9c", "message": "RefreshWorker now prunes \"unused\" entities during refresh\n\n- Added the PoolNodeBuilder, PoolNodeVisitor, and general handling\n  of pool nodes. Pool entities are still not processed by the\n  refresh worker, but the framework is now present.\n- NodeVisitor now has a pruneNode operation\n- NodeProcessor now performs two passes through the trees: once to\n  prune nodes/entities, and once to process/merge remaining entities\n- ContentNodeVisitor and ProductNodeVisitor now will remove\n  \"locked\" entities which exist locally but are not present upstream\n  during a refresh (suggesting they are no longer used by the org)\n- NodeProcessor.processNodes now returns a RefreshResult instance\n  directly instead of requiring an explicit call to compileResults\n- NodeFactory is now responsible for building all nodes, rather\n  than requiring explicit, individual calls to NodeFactory.buildNode\n- Updated OwnerContentCurator.removeOwnerContentReferences to no\n  longer use the unsafe bulkSQLDelete, and instead performs properly\n  partitioned JPQL deletes\n- Updated OwnerContentCurator.updateOwnerContentReferences and\n  OwnerProductCurator.removeContentReferences to use partitioned\n  data sets, to avoid running over the parameter limit when\n  processing certain sets of data\n- Added the AbstractHibernateCurator.partitionMap utility method\n- Removed EntityNode.visited() and any backing state management for\n  it, as storing the visited state on the nodes does not work very\n  well for performing multiple passes through the tree(s)\n- Removed other EntityNode utility methods for determining the\n  type of entity operation performed during refresh, as they were\n  not very accurate, and were also unused\n- Added EntityNode.NodeState for better definining the resultant\n  state of the entity represented by the node. This field may also\n  double as an impromptu \"visited\" flag in certain circumstances\n- OwnerProductCurator.removeOwnerContentReferences no longer\n  prevents removing references when a product is used by a given\n  pool\n- Refresh now checks if any pools are left in a state where they\n  reference a product which is not owned by the pool's owning\n  organization\n- The OrphanCleanupJob no longer attempts to remove orphaned\n  products if they are still referenced by one or more pools,\n  and will instead issue a warning for each invalid pool-product\n  reference\n- Removed the AbstractHibernateCurator.bulkDeleteTransactional\n  method, as it was redundant (bulkDelete is transactional)\n  and only used in one place\n- RefreshResult no longer uses a hardcoded collection of maps\n  to store resultant refresh information", "committedDate": "2020-08-21T14:01:50Z", "type": "forcePushed"}]}