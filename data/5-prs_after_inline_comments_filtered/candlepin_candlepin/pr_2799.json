{"pr_number": 2799, "pr_title": "ENT-2806: Only add content from active pools on the SCA certificate", "pr_createdAt": "2020-09-08T08:14:55Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2799", "timeline": [{"oid": "9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "url": "https://github.com/candlepin/candlepin/commit/9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-09-11T08:32:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTAxOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489209018", "bodyText": "This logic is repeated across multiple methods. We should refactor this into reusable pieces.", "author": "Januson", "createdAt": "2020-09-16T07:04:00Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2006,217 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch provided product UUIDS\n+     *\n+     * @return\n+     *  A mapping of pool IDs to provided product UUIDs\n+     */\n+    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n+\n+        if (poolIds != null && !poolIds.isEmpty()) {\n+            StringBuilder builder =\n+                new StringBuilder(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE\");\n+            javax.persistence.Query query = null;\n+\n+            int blockSize = getInBlockSize();\n+            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+\n+            if (blockCount > 1) {\n+                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+\n+                for (int i = 0; i < blockCount; ++i) {\n+                    if (i != 0) {\n+                        builder.append(\" OR\");\n+                    }\n+\n+                    builder.append(\" p.id IN (:block\").append(i).append(')');\n+                }\n+\n+                query = this.getEntityManager().createQuery(builder.toString());\n+                int i = -1;\n+\n+                for (List<String> block : blocks) {\n+                    query.setParameter(\"block\" + ++i, block);\n+                }\n+            }\n+            else {\n+                builder.append(\" p.id IN (:pids)\");\n+                query = this.getEntityManager().createQuery(builder.toString())\n+                    .setParameter(\"pids\", poolIds);\n+            }\n+\n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n+                }\n+\n+                providedProducts.add((String) cols[1]);\n+            }", "originalCommit": "9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2OTI1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489369253", "bodyText": "Refactored the logic.", "author": "wolfdale", "createdAt": "2020-09-16T11:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTc0Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489209742", "bodyText": "This could be Map.computeIfAbsent.", "author": "Januson", "createdAt": "2020-09-16T07:05:32Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2006,217 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch provided product UUIDS\n+     *\n+     * @return\n+     *  A mapping of pool IDs to provided product UUIDs\n+     */\n+    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n+\n+        if (poolIds != null && !poolIds.isEmpty()) {\n+            StringBuilder builder =\n+                new StringBuilder(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE\");\n+            javax.persistence.Query query = null;\n+\n+            int blockSize = getInBlockSize();\n+            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+\n+            if (blockCount > 1) {\n+                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+\n+                for (int i = 0; i < blockCount; ++i) {\n+                    if (i != 0) {\n+                        builder.append(\" OR\");\n+                    }\n+\n+                    builder.append(\" p.id IN (:block\").append(i).append(')');\n+                }\n+\n+                query = this.getEntityManager().createQuery(builder.toString());\n+                int i = -1;\n+\n+                for (List<String> block : blocks) {\n+                    query.setParameter(\"block\" + ++i, block);\n+                }\n+            }\n+            else {\n+                builder.append(\" p.id IN (:pids)\");\n+                query = this.getEntityManager().createQuery(builder.toString())\n+                    .setParameter(\"pids\", poolIds);\n+            }\n+\n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {", "originalCommit": "9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2OTMyMg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489369322", "bodyText": "Done.", "author": "wolfdale", "createdAt": "2020-09-16T11:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTc0Mg=="}], "type": "inlineReview"}, {"oid": "2ad2d679526ff4f19b014b407338456dda763da3", "url": "https://github.com/candlepin/candlepin/commit/2ad2d679526ff4f19b014b407338456dda763da3", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-09-16T11:37:25Z", "type": "forcePushed"}, {"oid": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "url": "https://github.com/candlepin/candlepin/commit/5c6cee6723e8913a082089e5dc9cb7276cdb90de", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-09-16T11:44:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwODgwMw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494308803", "bodyText": "Nack on this.\nThis completely changes the typing on our output, which is very bad. Consistency is more important than code reuse.", "author": "Ceiu", "createdAt": "2020-09-24T13:17:56Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -1684,26 +1685,40 @@ public Boolean providesDerived(Pool pool, String derivedProvidedProductId) {\n             }\n         }\n \n-        return this.getProvidedProductIdsByPoolIds(poolIds);\n+        return this.getProvidedProductByPoolIds(poolIds, true);\n     }\n \n     /**\n-     * Fetches a mapping of pool IDs to sets of product IDs representing the provided products of\n+     * Fetches a mapping of pool IDs to sets of product IDs or UUIDs representing the provided products of\n      * the given pool. The returned map will only contain mappings for pools specified in the given\n      * collection of pool IDs.\n      *\n      * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product IDs\n+     *  A collection of pool IDs for which to fetch provided product IDs or UUIDs\n+     *\n+     * @param fetchMode", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjEwNw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976107", "bodyText": "Removed this piece of code from here.", "author": "wolfdale", "createdAt": "2020-10-01T04:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwODgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMjY4NQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494312685", "bodyText": "Incorrect use of computeIfAbsent. The method will generate a new value if not present and return whatever ends up in the field in either case. This saves us an interaction with the map by making the fetch, generation, and storage operations all atomic and packaged in a single call. You can then use method chaining and the knowledge that you'll never get a null value out of the map to eliminate the need for explicit declaration. It should look like this:\nprovidedProductMap.computeIfAbsent((String) cols[0], key -> new HashSet<>())\n    .add((String) cols[1]);", "author": "Ceiu", "createdAt": "2020-09-24T13:23:32Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -1735,14 +1750,10 @@ public Boolean providesDerived(Pool pool, String derivedProvidedProductId) {\n             }\n \n             for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n-\n-                if (providedProducts == null) {\n-                    providedProducts = new HashSet<>();\n-                    providedProductMap.put((String) cols[0], providedProducts);\n-                }\n-\n-                providedProducts.add((String) cols[1]);\n+                providedProductMap.computeIfAbsent((String) cols[0],", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjE1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976153", "bodyText": "Removed this piece of code from here.", "author": "wolfdale", "createdAt": "2020-10-01T04:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMjY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzIxOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494313218", "bodyText": "Again, nack on these changes -- we don't want to completely swing a method's operation and output on a single boolean input. Rewrite the method and make changes as necessary.", "author": "Ceiu", "createdAt": "2020-09-24T13:24:17Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -1772,26 +1783,39 @@ public Boolean providesDerived(Pool pool, String derivedProvidedProductId) {\n             }\n         }\n \n-        return this.getDerivedProvidedProductIdsByPoolIds(poolIds);\n+        return this.getDerivedProvidedProductByPoolIds(poolIds, true);\n     }\n \n     /**\n-     * Fetches a mapping of pool IDs to sets of product IDs representing the provided products of\n+     * Fetches a mapping of pool IDs to sets of product IDs or UUIDs representing the provided products of\n      * the given pool. The returned map will only contain mappings for pools specified in the given\n      * collection of pool IDs.\n      *\n      * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product IDs\n+     *  A collection of pool IDs for which to fetch provided product IDs or UUIDs\n+     *\n+     * @param fetchMode\n+     *  Boolean field.\n+     *  True  -> Returns mapping of Pool IDs & provided product IDs\n+     *  False -> Returns mapping of Pool IDs & provided product UUIDs\n      *\n      * @return\n-     *  A mapping of pool IDs to provided product IDs\n+     *  A mapping of pool IDs to provided product IDs or UUIDs\n      */\n-    public Map<String, Set<String>> getDerivedProvidedProductIdsByPoolIds(Collection<String> poolIds) {\n+    public Map<String, Set<String>> getDerivedProvidedProductByPoolIds(Collection<String> poolIds,", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjE4NA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976184", "bodyText": "Removed this piece of code from here.", "author": "wolfdale", "createdAt": "2020-10-01T04:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzkzOQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494313939", "bodyText": "This should be named \"getActivePoolIdsByOwnerId\", as it is fetching multiple pool IDs, not a single pool.", "author": "Ceiu", "createdAt": "2020-09-24T13:25:14Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTg2Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975862", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDI2OQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494314269", "bodyText": "This should be \"ids\" rather than \"uuids\"", "author": "Ceiu", "createdAt": "2020-09-24T13:25:38Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n+            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n+\n+        List<String> uuids = this.getEntityManager()", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTg4Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975882", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNTMwNA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494315304", "bodyText": "Try not to put line breaks for continuations in the middle of a statement or clause. There's enough space for the :owner_id part of the first WHERE clause, or the WHERE portion should move down to the line with it.", "author": "Ceiu", "createdAt": "2020-09-24T13:26:57Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTgyOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975828", "bodyText": "Noted", "author": "wolfdale", "createdAt": "2020-10-01T04:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTMxNA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494319314", "bodyText": "Let's try to find a better way to write this. This method looks heavily derived from the bulkSQL[update|delete] methods from AbstractHibernateCurator which should be flagged as deprecated if they're not already. Building raw SQL can be dangerous, and runs into potential problems with parameter limits (as this implementation does here).", "author": "Ceiu", "createdAt": "2020-09-24T13:32:16Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n+            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n+\n+        List<String> uuids = this.getEntityManager()\n+            .createQuery(jpql, String.class)\n+            .setParameter(\"owner_id\", ownerId)\n+            .setParameter(\"endDate\", currentDate)\n+            .setParameter(\"startDate\", currentDate)\n+            .getResultList();\n+\n+        return uuids != null ? uuids : Collections.<String>emptyList();\n+    }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch product & derived product UUIDs.\n+     *\n+     * @return\n+     *  A mapping of pool IDs to product & derived product UUIDs\n+     */\n+    public Map<String, Set<String>> getProductAndDerivedProductUuidsByPoolIds(Collection<String> poolIds) {", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTgxOQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975819", "bodyText": "Noted. Changed the logic here.", "author": "wolfdale", "createdAt": "2020-10-01T04:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMDMwNQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494320305", "bodyText": "This is a functional duplication of listAllByUuid", "author": "Ceiu", "createdAt": "2020-09-24T13:33:40Z", "path": "server/src/main/java/org/candlepin/model/ProductCurator.java", "diffHunk": "@@ -505,4 +505,25 @@ public boolean productHasSubscriptions(Owner owner, Product product) {\n \n         return this.cpQueryFactory.<Product>buildQuery();\n     }\n+\n+    /**\n+     * Fetches products by product UUIDs.\n+     *\n+     * @param productUuids\n+     *  The Collection of product UUIDs\n+     *\n+     * @return\n+     *  Query collection of Products\n+     */\n+    public CandlepinQuery<Product> getProductsByProductUuids(Collection<String> productUuids) {", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTY3Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975673", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMDMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMjI2Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494322263", "bodyText": "CandlepinQuery is deprecated, we shouldn't introduce new code that uses it.", "author": "Ceiu", "createdAt": "2020-09-24T13:36:13Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -509,7 +518,35 @@ private String createDN(Consumer consumer, Owner owner) {\n     private byte[] createContentAccessDataPayload(Owner owner, Environment environment) throws IOException {\n         // fake a product dto as a container for the org content\n         Set<Product> containerSet = new HashSet<>();\n-        CandlepinQuery<Product> ownerProduct = ownerProductCurator.getProductsByOwner(owner);\n+        Set<String> productUuids = new HashSet<>();\n+\n+        Collection<String> activePoolIds = poolCurator.getActivePoolByOwnerId(owner.getId());\n+        Map<String, Set<String>> products =\n+            poolCurator.getProductAndDerivedProductUuidsByPoolIds(activePoolIds);\n+\n+        Map<String, Set<String>> providedProducts =\n+            poolCurator.getProvidedProductByPoolIds(activePoolIds, false);\n+\n+        Map<String, Set<String>> derivedProvidedProducts =\n+            poolCurator.getDerivedProvidedProductByPoolIds(activePoolIds, false);\n+\n+        for (String poolId : activePoolIds) {\n+            if (providedProducts.get(poolId) != null) {\n+                productUuids.addAll(providedProducts.get(poolId));\n+            }\n+\n+            if (derivedProvidedProducts.get(poolId) != null) {\n+                productUuids.addAll(derivedProvidedProducts.get(poolId));\n+            }\n+\n+            if (products.get(poolId) != null) {\n+                productUuids.addAll(products.get(poolId));\n+            }\n+        }\n+\n+        CandlepinQuery<Product> productsToConsider =", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTY1NA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975654", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzU0Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494323542", "bodyText": "This is an expensive way to fetch the product information for active pools. If the goal here is to fetch products for active pools, we should do exactly that: fetch active pools and then pull the products from them in code (functionally identical to what we're doing here), or write a new curator method that fetches only products from active entitlements of a given organization.", "author": "Ceiu", "createdAt": "2020-09-24T13:38:02Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -509,7 +518,35 @@ private String createDN(Consumer consumer, Owner owner) {\n     private byte[] createContentAccessDataPayload(Owner owner, Environment environment) throws IOException {\n         // fake a product dto as a container for the org content\n         Set<Product> containerSet = new HashSet<>();\n-        CandlepinQuery<Product> ownerProduct = ownerProductCurator.getProductsByOwner(owner);\n+        Set<String> productUuids = new HashSet<>();\n+\n+        Collection<String> activePoolIds = poolCurator.getActivePoolByOwnerId(owner.getId());", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjY5NQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976695", "bodyText": "Changed the logic to pull products & it's content directly in the code from active pools.\nNot sure if we can use active entitlement to pull product's contents here, since active pool can exists without any active entitlement.", "author": "wolfdale", "createdAt": "2020-10-01T04:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzU0Mg=="}], "type": "inlineReview"}, {"oid": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "url": "https://github.com/candlepin/candlepin/commit/a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:07:41Z", "type": "forcePushed"}, {"oid": "30360c541a1ee227cb77b529d71f1bb26c5f2aa1", "url": "https://github.com/candlepin/candlepin/commit/30360c541a1ee227cb77b529d71f1bb26c5f2aa1", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:15:27Z", "type": "forcePushed"}, {"oid": "aaa786f5451251159a706baf05e5501d11ab5314", "url": "https://github.com/candlepin/candlepin/commit/aaa786f5451251159a706baf05e5501d11ab5314", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:20:12Z", "type": "forcePushed"}, {"oid": "7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "url": "https://github.com/candlepin/candlepin/commit/7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:29:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ4NDA1NA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r502484054", "bodyText": "setMaxResults called twice with different values here (blockCount looks to be extraneous)", "author": "Ceiu", "createdAt": "2020-10-09T14:50:54Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2008,115 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n+     *\n+     * @param ownerId\n+     *  Owner Id\n+     *\n+     * @return\n+     *  A Set of product content associated with active pool.\n+     */\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n+        Date currentDate = new Date();\n+\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {\n+                List<Pool> pools = this.getEntityManager()\n+                    .createQuery(query)\n+                    .setMaxResults(blockCount)\n+                    .setFirstResult(offset)\n+                    .setMaxResults(blockSize)", "originalCommit": "7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1Mzg4MQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r514053881", "bodyText": "Not needed anymore.", "author": "wolfdale", "createdAt": "2020-10-29T07:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ4NDA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r502503929", "bodyText": "The blocking here probably isn't critical in our general case, but it also doesn't hurt anything.\nHowever, the code goes out of its way to have special handling for the 1 block case, when that's unnecessary -- even with only a single block, setting the max results and first result in the query won't change the performance of the query enough to justify having separate branches for each case.\nAdditionally, the block count bit is largely unnecessary. Once you have the element count, block size, and keep track of the offset, the counting of blocks becomes extraneous -- just check that your offset is lower than your element count. Even without the element count, you can achieve the same level of performance by just querying until you get a batch that has zero elements.\nThat said, fetching the element count is basically the same query here except without returning the pool information -- the DB work is effectively the same. Moreover, the collection processing below runs into not one, but two n+1 problems of doing a ton of extra queries to fetch the product and content collections. I would bet this is overall slower than just fetching all of the \"active\" pool IDs, then using those to get the related product UUIDs, and then using that to get the content objects. You'd get the whole thing done in three queries, rather than the 2n^p+b+1 queries we have here.", "author": "Ceiu", "createdAt": "2020-10-09T15:20:16Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2008,115 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n+     *\n+     * @param ownerId\n+     *  Owner Id\n+     *\n+     * @return\n+     *  A Set of product content associated with active pool.\n+     */\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n+        Date currentDate = new Date();\n+\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {", "originalCommit": "7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyMjkxMg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r503222912", "bodyText": "Yes it is slower, firing extra queries under the hood to fetch product & contents, this is what I was afraid of hence I chose to execute queries to get Product UUIDs.\n\nIf the goal here is to fetch products for active pools, we should do exactly that: fetch active pools and then pull the products from them in code.\n\nFrom your previous comment I thought you meant to get the products (and content) of active pool right from the code.\nMaybe we can go back to previous approach of having direct queries to fetch all associated products UUIDs of active pools and then fetch the product's content. What are your thoughts on that ? Also do we care if fetch these UUIDs in batch or not ?", "author": "wolfdale", "createdAt": "2020-10-12T11:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0MzcxOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r507743718", "bodyText": "Sorry, Github isn't showing me the old code, so I'm going from memory here...\nAnyway, IIRC, the old code did pool iteration as a one-off in the method itself, so my assumption was that it would be augmented to simply pull the objects off it there and we'd drop the custom SQL builder code derived from a deprecated method that had a very dangerous oversight in it. My overall stance is that if we're going to add a method to do this operation at the curator level, it's something that should be generalized and as efficient as reasonably possible since it will be available to the rest of the code base at that point, and we might attempt to use it elsewhere in the future.\nOnce we are working at the curator level, the three queries I mentioned above can be used to fetch the information quicker than object iteration, and with minimal fetching of DB data. One of them will require raw SQL, but we should avoid constructing SQL statements via string concatenation without careful consideration of all the problems that introduces.\nRegarding the batching question, there are two cases we want to do requests in batches:\n\nif the number of input parameters would exceed the limits of either an IN operator or the overall query parameter limit (this is the most common scenario)\noptimizing lookups when fetching lazy collections off of certain entities (rare thus far in Candlepin)\n\nI believe in this case, once we move the operation to the curator level, we will need to batch each query due to the nature of the operation (N pools, M products, O content). The easiest way to do this is with the partition method provided by AbstractHibernateCurator, or you can use the partitioning functionality directly. There are other ways to batch, but I would recommend them only in specific cases where your data store(s) or operations don't lend themselves nicely to the partitioning functionality.\nHope that helps, and my apologies for seemingly going back and forth here.", "author": "Ceiu", "createdAt": "2020-10-19T13:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1NDI1NQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r514054255", "bodyText": "Changes made to cut back the complex batching logic & to simplify the SQL queries with JPA criteria queries. I broke the steps into multiple parts of pulling the active PoolIDs, then product & derived product UUIDs, provided product UUIDs and finally derived provided product UUIDs. In between these queries we process for product content so that we can avoid holding everything in-memory.", "author": "wolfdale", "createdAt": "2020-10-29T07:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ=="}], "type": "inlineReview"}, {"oid": "17c419cdaf4f8f456aaaf16732eecde57a792f2a", "url": "https://github.com/candlepin/candlepin/commit/17c419cdaf4f8f456aaaf16732eecde57a792f2a", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-28T11:28:38Z", "type": "forcePushed"}, {"oid": "eced13855f2bc10749ee6a07daf50cdc546a229f", "url": "https://github.com/candlepin/candlepin/commit/eced13855f2bc10749ee6a07daf50cdc546a229f", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-29T07:32:36Z", "type": "forcePushed"}, {"oid": "d91cbb7efbc18b2001112d2fdb6688f174c833e2", "url": "https://github.com/candlepin/candlepin/commit/d91cbb7efbc18b2001112d2fdb6688f174c833e2", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-29T08:20:23Z", "type": "forcePushed"}, {"oid": "d743b82aadc7cff2a4c27694d2023e144cb28f45", "url": "https://github.com/candlepin/candlepin/commit/d743b82aadc7cff2a4c27694d2023e144cb28f45", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-30T08:46:44Z", "type": "forcePushed"}, {"oid": "757f391be364206a7650b3b12d6748fd9daa8456", "url": "https://github.com/candlepin/candlepin/commit/757f391be364206a7650b3b12d6748fd9daa8456", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-30T08:53:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNzg2Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515307862", "bodyText": "I realize looking at this now there's a bug with how this query is partitioned. We need to use the minimum value between the in block limit or one fourth of the query parameter limit, since we'll be passing the block in four times. As it is now, if we happen to have a block of pools right at the in-block limit, we'll run clear over the overall parameter limit and crash out all the same.", "author": "Ceiu", "createdAt": "2020-10-30T18:44:21Z", "path": "server/src/main/java/org/candlepin/model/OwnerContentCurator.java", "diffHunk": "@@ -548,4 +554,60 @@ public void removeOwnerContentReferences(Owner owner, Collection<String> content\n         }\n     }\n \n+    /**\n+     * Fetches all the product content for active pools by owner Id.\n+     *\n+     * @param ownerId\n+     *  Id of an owner\n+     *\n+     * @return\n+     *  Set of product content.\n+     */\n+    public Set<ProductContent> getProductContentsOfActivePoolByOwner(String ownerId) {\n+        EntityManager entityManager = this.getEntityManager();\n+        Date now = new Date();\n+\n+        // Get all the active pools\n+\n+        String jpql = \"SELECT p.id FROM Pool p \" +\n+            \"WHERE p.owner.id = :owner_id AND p.startDate <= :start_date AND p.endDate >= :end_date\";\n+\n+        List<String> poolIds = entityManager.createQuery(jpql, String.class)\n+            .setParameter(\"owner_id\", ownerId)\n+            .setParameter(\"start_date\", now)\n+            .setParameter(\"end_date\", now)\n+            .getResultList();\n+\n+        // Use the pool IDs to select all related product UUIDs\n+        // Note: we have to start partitioning now to safely handle any number of active pools\n+\n+        String sql = \"SELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n+            \"UNION \" +\n+            \"SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n+            \"UNION \" +\n+            \"SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (:pool_ids) \" +\n+            \"UNION \" +\n+            \"SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (:pool_ids) \";\n+\n+        Query prodQuery = entityManager.createNativeQuery(sql);\n+        Set<String> prodIds = new HashSet<>();\n+\n+        for (List<String> block : this.partition(poolIds)) {", "originalCommit": "757f391be364206a7650b3b12d6748fd9daa8456", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNDQ1OQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515834459", "bodyText": "This is superb fix. I was not aware of this.\nint blockSize = Math.min(this.getInBlockSize(), this.getQueryParameterLimit() / 4);", "author": "wolfdale", "createdAt": "2020-11-02T09:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDczMA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515324730", "bodyText": "Ah ha. I remember this discussion now.\nSo we need to include all \"active\" content for a given org, but we need to flag it as enabled properly, resolving any conflicts to enabled.\nThat complicates things a bit, but is something we can still solve efficiently.\nSince ProductContent is a join object, we don't want to fetch it directly if we can help it -- especially since the object we actually care about is the Content instance, which we have to fetch even if we try to use the ProductContent mutators of Product directly. Using ProductContent like this results in another N+1 issue, where examining the content field results in another query. Running the spec test for this method, for instance, results in the following queries:\nselect pool0_.id as col_0_0_ from cp_pool pool0_ where pool0_.owner_id=? and pool0_.startDate<=? and pool0_.endDate>=?\n\nSELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (?, ?) UNION SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (?, ?) \n\nselect productcon0_.id as id1_12_, productcon0_.created as created2_12_, productcon0_.updated as updated3_12_, productcon0_.content_uuid as content_5_12_, productcon0_.enabled as enabled4_12_, productcon0_.product_uuid as product_6_12_ from cp2_product_content productcon0_ where productcon0_.product_uuid in (? , ? , ?)\n\nselect content0_.uuid as uuid1_1_0_, content0_.created as created2_1_0_, content0_.updated as updated3_1_0_, content0_.arches as arches4_1_0_, content0_.contentUrl as contentU5_1_0_, content0_.entity_version as entity_v6_1_0_, content0_.gpgUrl as gpgUrl7_1_0_, content0_.content_id as content_8_1_0_, content0_.label as label9_1_0_, content0_.locked as locked10_1_0_, content0_.metadataExpire as metadat11_1_0_, content0_.name as name12_1_0_, content0_.releaseVer as release13_1_0_, content0_.requiredTags as require14_1_0_, content0_.type as type15_1_0_, content0_.vendor as vendor16_1_0_ from cp2_content content0_ where content0_.uuid=?\n\nselect content0_.uuid as uuid1_1_0_, content0_.created as created2_1_0_, content0_.updated as updated3_1_0_, content0_.arches as arches4_1_0_, content0_.contentUrl as contentU5_1_0_, content0_.entity_version as entity_v6_1_0_, content0_.gpgUrl as gpgUrl7_1_0_, content0_.content_id as content_8_1_0_, content0_.label as label9_1_0_, content0_.locked as locked10_1_0_, content0_.metadataExpire as metadat11_1_0_, content0_.name as name12_1_0_, content0_.releaseVer as release13_1_0_, content0_.requiredTags as require14_1_0_, content0_.type as type15_1_0_, content0_.vendor as vendor16_1_0_ from cp2_content content0_ where content0_.uuid=?\n\nNote the two content queries at the end -- that's invoked once for each ProductContent fetched by the getProductContentsOfActivePoolsByOwner* method when getContent is invoked. Side note: that method name is a bit wordy -- getActiveProductContentByOwner would suffice, and even that's a tad long due to specifying the return type in the method name.\nSo, that means we need to solve this in the curator method.\nMy first thought was to use a DISTINCT with ORDER BY on the enabled field in ascending order, and then collect the content objects in order. This would put all the enabled content at the end, and would overwrite any disabled entries with an enabled one:\njpql = \"SELECT DISTINCT pc.content, pc.enabled FROM ProductContent pc WHERE pc.product.uuid IN (:product_uuids) ORDER BY pc.enabled ASC\";\n\nThis would work perfectly if it wasn't for one small hiccup: since we're partitioning, we have to assume we'll be running this query at least twice; and if we're running it twice, our order is no longer guaranteed between queries, and we run the risk of clobbering our \"enabled\" entries from the end of previous query with \"disabled\" entries in the next. We can work around this with some logic similar to what is outlined in the method this comment hangs on, but at that point, the ordering does literally nothing for us -- so we can omit it entirely.\n    // OwnerContentCurator.java\n    public Map<Content, Boolean> getActiveContentByOwner(String ownerId) {\n        EntityManager entityManager = this.getEntityManager();\n        Date now = new Date();\n\n        // Get all the active pools\n\n        String jpql = \"SELECT p.id FROM Pool p \" +\n            \"WHERE p.owner.id = :owner_id AND p.startDate <= :start_date AND p.endDate >= :end_date\";\n\n        List<String> poolIds = entityManager.createQuery(jpql, String.class)\n            .setParameter(\"owner_id\", ownerId)\n            .setParameter(\"start_date\", now)\n            .setParameter(\"end_date\", now)\n            .getResultList();\n\n        // Use the pool IDs to select all related product UUIDs\n        // Note: we have to start partitioning now to safely handle any number of active pools\n\n        String sql = \"SELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n            \"UNION \" +\n            \"SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n            \"UNION \" +\n            \"SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (:pool_ids) \" +\n            \"UNION \" +\n            \"SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (:pool_ids) \";\n\n        Query prodQuery = entityManager.createNativeQuery(sql);\n        Set<String> prodIds = new HashSet<>();\n\n        int blockSize = Math.min(this.getInBlockSize(), this.getQueryParameterLimit() / 4);\n\n        for (List<String> block : Iterables.partition(poolIds, blockSize)) {\n            prodIds.addAll(prodQuery.setParameter(\"pool_ids\", block).getResultList());\n        }\n\n        // Use the product UUIDs to select all related enabled content\n        jpql = \"SELECT DISTINCT pc.content, pc.enabled FROM ProductContent pc \" +\n            \"WHERE pc.product.uuid IN (:product_uuids)\";\n\n        Query contentQuery = entityManager.createQuery(jpql);\n\n        HashMap<Content, Boolean> activeContent = new HashMap<>();\n\n        for (List<String> block : this.partition(prodIds)) {\n            contentQuery.setParameter(\"product_uuids\", block)\n                .getResultList()\n                .forEach(col -> {\n                    Content content = (Content) ((Object[]) col)[0];\n                    Boolean enabled = (Boolean) ((Object[]) col)[1];\n\n                    activeContent.merge(content, enabled, (v1, v2) ->\n                        v1 != null && v1.booleanValue() ? v1 : v2);\n                });\n        }\n\n        return activeContent;\n    }\n\n    ...\n\n    // ContentAccessManager.java\n    this.ownerContentCurator.getActiveContentByOwner(owner.getId())\n        .forEach((content, enabled) -> container.addContent(content, enabled));\n\n\nThis avoids the N+1 problem entirely, as we can verify by checking the output during the same spec test:\nselect pool0_.id as col_0_0_ from cp_pool pool0_ where pool0_.owner_id=? and pool0_.startDate<=? and pool0_.endDate>=?\n\nSELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (?, ?) UNION SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (?, ?) \n\nselect distinct productcon0_.content_uuid as col_0_0_, productcon0_.enabled as col_1_0_, content1_.uuid as uuid1_1_, content1_.created as created2_1_, content1_.updated as updated3_1_, content1_.arches as arches4_1_, content1_.contentUrl as contentU5_1_, content1_.entity_version as entity_v6_1_, content1_.gpgUrl as gpgUrl7_1_, content1_.content_id as content_8_1_, content1_.label as label9_1_, content1_.locked as locked10_1_, content1_.metadataExpire as metadat11_1_, content1_.name as name12_1_, content1_.releaseVer as release13_1_, content1_.requiredTags as require14_1_, content1_.type as type15_1_, content1_.vendor as vendor16_1_ from cp2_product_content productcon0_ inner join cp2_content content1_ on productcon0_.content_uuid=content1_.uuid where productcon0_.product_uuid in (? , ? , ?)\n\nNote that this also keeps the logic for this problem in one place.", "author": "Ceiu", "createdAt": "2020-10-30T19:21:07Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -559,6 +543,32 @@ else if (pc.isEnabled() && !contentEnabledMap.get(pc.getContent().getUuid())) {\n             emptyConsumer, emptyPool, null);\n     }\n \n+    /**\n+     * To process product content and added it to container product.\n+     *\n+     * @param container\n+     *  Product container\n+     *\n+     * @param ownerId\n+     *  Id of an owner\n+     *\n+     */\n+    private void processOwnerContent(Product container, String ownerId) {", "originalCommit": "757f391be364206a7650b3b12d6748fd9daa8456", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNDU3Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515834572", "bodyText": "This look very good and efficient. This certainty avoids the N+1 problem.\nthank for help me out with this.", "author": "wolfdale", "createdAt": "2020-11-02T09:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDczMA=="}], "type": "inlineReview"}, {"oid": "43e9e0a2f4d8f01630fbf6b28567a6738bc311a8", "url": "https://github.com/candlepin/candlepin/commit/43e9e0a2f4d8f01630fbf6b28567a6738bc311a8", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T09:19:18Z", "type": "forcePushed"}, {"oid": "0ddf504bee894971cacdf1eedfdbdbc4cdd97951", "url": "https://github.com/candlepin/candlepin/commit/0ddf504bee894971cacdf1eedfdbdbc4cdd97951", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T10:37:31Z", "type": "forcePushed"}, {"oid": "d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "url": "https://github.com/candlepin/candlepin/commit/d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T11:24:45Z", "type": "commit"}, {"oid": "d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "url": "https://github.com/candlepin/candlepin/commit/d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T11:24:45Z", "type": "forcePushed"}]}