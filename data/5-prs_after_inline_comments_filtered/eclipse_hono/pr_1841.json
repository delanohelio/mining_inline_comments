{"pr_number": 1841, "pr_title": "[#1272] Implement new Command & Control handling", "pr_createdAt": "2020-03-17T07:39:58Z", "pr_url": "https://github.com/eclipse/hono/pull/1841", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNDMxMA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393504310", "bodyText": "why don't we simply pass the client factories into the create method?", "author": "sophokles73", "createdAt": "2020-03-17T08:13:15Z", "path": "client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public interface CommandTargetMapper {\n+\n+    /**\n+     * Creates a new {@link CommandTargetMapper} using the default implementation.\n+     *\n+     * @param tracer The tracer instance.\n+     * @return The CommandTargetMapper instance.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    static CommandTargetMapper create(final Tracer tracer) {\n+        return new CommandTargetMapperImpl(tracer);\n+    }\n+\n+    /**\n+     * Initializes the CommandTargetMapper with the given components.\n+     *\n+     * @param registrationClientFactory The factory to create a registration client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    void initialize(RegistrationClientFactory registrationClientFactory,", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNDk2Nw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393504967", "bodyText": "2019, 2020?", "author": "sophokles73", "createdAt": "2020-03-17T08:14:32Z", "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjI0Ng==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393506246", "bodyText": "how about using the adapter's container name used in the connection for the purpose of the adapter instance ID?", "author": "sophokles73", "createdAt": "2020-03-17T08:17:06Z", "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3NzE3Ng==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393677176", "bodyText": "You mean the name set here? \n  \n    \n      hono/core/src/main/java/org/eclipse/hono/connection/impl/ConnectionFactoryImpl.java\n    \n    \n        Lines 205 to 206\n      in\n      b2096cc\n    \n    \n    \n    \n\n        \n          \n           downstreamConnection \n        \n\n        \n          \n                   .setContainer(String.format(\"%s-%s\", config.getName(), UUID.randomUUID())) \n        \n    \n  \n\n\nLike it is currently implemented, this id changes with each reconnect.", "author": "calohmn", "createdAt": "2020-03-17T13:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NjI2Nw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393686267", "bodyText": "but that could easily be changed, couldn't it?", "author": "sophokles73", "createdAt": "2020-03-17T13:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcwMjY2OA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393702668", "bodyText": "sure, I'll have a look.", "author": "calohmn", "createdAt": "2020-03-17T14:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2MTM5OQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393761399", "bodyText": "I've just committed the corresponding change.", "author": "calohmn", "createdAt": "2020-03-17T15:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjQ3OQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393506479", "bodyText": "why not pass them in to the create method?", "author": "sophokles73", "createdAt": "2020-03-17T08:17:36Z", "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {\n+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);\n+    }\n+\n+    /**\n+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.\n+     *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done\n+     *            here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     */\n+    void initialize(CommandTargetMapper commandTargetMapper,", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2NTYxMQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393665611", "bodyText": "That's how it was before. Like I described in the ticket text above, taking care of the ConnectionLifecycle of the (contained) client factories inside the CommandConsumerFactory makes things complicated.\nAnd taking care of the ConnectionLifecycle is needed as we have the client factory bean methods (in AbstractAdapterConfig) annotated with @Scope(\"prototype\"), hence dealing with different client factory instances in the places they are used in the AbstractAdapterConfig. And as I understood, we want to keep the @Scope(\"prototype\") annotation there for the case that the adapter is configured with maxInstances > 1, to have each AbstractProtocolAdapterBase verticle instance with its own set of client factory and more importantly connection object instances.", "author": "calohmn", "createdAt": "2020-03-17T13:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MTQzNA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393681434", "bodyText": "Ok, so the biggest change seems to be that the CommandConsumerFactory now uses the protocol adapter's connections to the Device Registration and Device Connection services instead of using (and managing) its own ones, right?", "author": "sophokles73", "createdAt": "2020-03-17T13:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY5OTAxOQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393699019", "bodyText": "yes", "author": "calohmn", "createdAt": "2020-03-17T13:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzE3Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393507173", "bodyText": "what happens if I invoke this method multiple times with the same params?", "author": "sophokles73", "createdAt": "2020-03-17T08:19:01Z", "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {\n+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);\n+    }\n+\n+    /**\n+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.\n+     *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done\n+     *            here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     */\n+    void initialize(CommandTargetMapper commandTargetMapper,\n+            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);\n+\n+    /**\n+     * Creates a command consumer for a device.\n+     * <p>\n+     * For each device only one command consumer may be active at any given time.", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcyMTAwMQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393721001", "bodyText": "Adapted the javadoc accordingly.", "author": "calohmn", "createdAt": "2020-03-17T14:29:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzYxMA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393507610", "bodyText": "for a device that is connected via a gateway?", "author": "sophokles73", "createdAt": "2020-03-17T08:19:57Z", "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {\n+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);\n+    }\n+\n+    /**\n+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.\n+     *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done\n+     *            here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     */\n+    void initialize(CommandTargetMapper commandTargetMapper,\n+            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);\n+\n+    /**\n+     * Creates a command consumer for a device.\n+     * <p>\n+     * For each device only one command consumer may be active at any given time.\n+     * It is the responsibility of the calling code to properly close a consumer\n+     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}\n+     * method.\n+     * <p>\n+     * Note that {@link #initialize(CommandTargetMapper, BasicDeviceConnectionClientFactory)} has to have been called\n+     * already, otherwise a failed future is returned.\n+     * \n+     * @param tenantId The tenant to consume commands from.\n+     * @param deviceId The device for which the consumer will be created.\n+     * @param commandHandler The handler to invoke with every command received.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will be completed with the newly created consumer once the link\n+     *         has been established.\n+     *         <p>\n+     *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating\n+     *         the cause of the failure.\n+     * @throws NullPointerException if any of tenant, device ID or command handler are {@code null}.\n+     */\n+    Future<MessageConsumer> createCommandConsumer(\n+            String tenantId,\n+            String deviceId,\n+            Handler<CommandContext> commandHandler);\n+\n+    /**\n+     * Creates a command consumer for a device.", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTE2Mg==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393509162", "bodyText": "how about returning a boolean indicating whether a handler has been replaced or not?", "author": "sophokles73", "createdAt": "2020-03-17T08:23:13Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.Device;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+\n+/**\n+ * Handler for commands received at the protocol adapter specific address.\n+ */\n+public final class AdapterInstanceCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);\n+\n+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();\n+    private final Tracer tracer;\n+\n+    /**\n+     * Creates a new AdapterInstanceCommandHandler instance.\n+     *\n+     * @param tracer The tracer instance.\n+     */\n+    public AdapterInstanceCommandHandler(final Tracer tracer) {\n+        this.tracer = tracer;\n+    }\n+\n+    /**\n+     * Handles a received command message.\n+     *\n+     * @param msg The command message.\n+     * @param delivery The delivery.\n+     */\n+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {\n+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case\n+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;\n+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", msg.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            delivery.disposition(rejected, true);\n+            return;\n+        }\n+        final String tenantId = resourceIdentifier.getTenantId();\n+        final String originalDeviceId = resourceIdentifier.getResourceId();\n+        // fetch \"via\" property (if set)\n+        String gatewayId = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);\n+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, originalDeviceId, gatewayId);\n+        if (commandHandler != null && gatewayId == null && commandHandler.getGatewayId() != null) {\n+            // there's a gateway having specifically subscribed for commands to that device here;\n+            // in that case the command handler was registered with the specific device id, not the gateway\n+            // (\"deviceConnectionService.setCommandHandlingAdapterInstance()\" doesn't have an extra gateway id parameter)\n+            // => therefore no gateway information was transported with the incoming message here and we have to take\n+            //    the gateway information from the chosen commandHandler.\n+            gatewayId = commandHandler.getGatewayId();\n+        }\n+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);\n+\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);\n+        final Span currentSpan = CommandConsumer.createSpan(\"send command\", tenantId, originalDeviceId,\n+                gatewayId, tracer, spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+\n+        if (commandHandler != null) {\n+            LOG.trace(\"using [{}] for received command [{}]\", commandHandler, command);\n+            // command.isValid() check not done here - it is to be done in the command handler\n+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));\n+        } else {\n+            LOG.info(\"no command handler found for command with device id {}, gateway id {} [tenant-id: {}]\",\n+                    originalDeviceId, gatewayId, tenantId);\n+            TracingHelper.logError(currentSpan, \"no command handler found for command\");\n+            currentSpan.finish();\n+            ProtonHelper.released(delivery, true);\n+        }\n+    }\n+\n+    /**\n+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The identifier of the device that is the target of the commands being handled.\n+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is\n+     *                  the target of the commands being handled, or {@code null} otherwise.\n+     * @param commandHandler The command handler.\n+     * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.\n+     */\n+    public void addDeviceSpecificCommandHandler(final String tenantId, final String deviceId,\n+            final String gatewayId, final Handler<CommandContext> commandHandler) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(commandHandler);\n+\n+        final String key = getDeviceKey(tenantId, deviceId);\n+        if (commandHandlers.containsKey(key)) {\n+            LOG.debug(\"replacing existing command consumer [tenant-id: {}, device-id: {}]\", tenantId, deviceId);\n+            // TODO find provide a notification here so that potential resources associated with the replaced consumer can be freed", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcyMDcyNQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393720725", "bodyText": "I've changed it to return the old value (a boolean would make me think this is about whether adding the handler succeeded or not). I've also adapted the method name (put..).", "author": "calohmn", "createdAt": "2020-03-17T14:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2NDQwNg==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393764406", "bodyText": "I've moved the TODO comment here:\n\n  \n    \n      hono/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java\n    \n    \n         Line 156\n      in\n      22f0073\n    \n    \n    \n    \n\n        \n          \n           // TODO find a way to provide a notification here so that potential resources associated with the replaced consumer can be freed (maybe add a commandHandlerOverwritten Handler param to createCommandConsumer()) \n        \n    \n  \n\n\nCan be fixed in a subsequent PR, IMHO.", "author": "calohmn", "createdAt": "2020-03-17T15:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTg2Mg==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393509862", "bodyText": "what if originalDeviceId is null?", "author": "sophokles73", "createdAt": "2020-03-17T08:24:33Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.Device;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+\n+/**\n+ * Handler for commands received at the protocol adapter specific address.\n+ */\n+public final class AdapterInstanceCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);\n+\n+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();\n+    private final Tracer tracer;\n+\n+    /**\n+     * Creates a new AdapterInstanceCommandHandler instance.\n+     *\n+     * @param tracer The tracer instance.\n+     */\n+    public AdapterInstanceCommandHandler(final Tracer tracer) {\n+        this.tracer = tracer;\n+    }\n+\n+    /**\n+     * Handles a received command message.\n+     *\n+     * @param msg The command message.\n+     * @param delivery The delivery.\n+     */\n+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {\n+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case\n+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;\n+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", msg.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            delivery.disposition(rejected, true);\n+            return;\n+        }\n+        final String tenantId = resourceIdentifier.getTenantId();\n+        final String originalDeviceId = resourceIdentifier.getResourceId();\n+        // fetch \"via\" property (if set)\n+        String gatewayId = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);\n+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, originalDeviceId, gatewayId);\n+        if (commandHandler != null && gatewayId == null && commandHandler.getGatewayId() != null) {\n+            // there's a gateway having specifically subscribed for commands to that device here;\n+            // in that case the command handler was registered with the specific device id, not the gateway\n+            // (\"deviceConnectionService.setCommandHandlingAdapterInstance()\" doesn't have an extra gateway id parameter)\n+            // => therefore no gateway information was transported with the incoming message here and we have to take\n+            //    the gateway information from the chosen commandHandler.\n+            gatewayId = commandHandler.getGatewayId();\n+        }\n+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);\n+\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);\n+        final Span currentSpan = CommandConsumer.createSpan(\"send command\", tenantId, originalDeviceId,\n+                gatewayId, tracer, spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+\n+        if (commandHandler != null) {\n+            LOG.trace(\"using [{}] for received command [{}]\", commandHandler, command);\n+            // command.isValid() check not done here - it is to be done in the command handler\n+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));\n+        } else {\n+            LOG.info(\"no command handler found for command with device id {}, gateway id {} [tenant-id: {}]\",\n+                    originalDeviceId, gatewayId, tenantId);\n+            TracingHelper.logError(currentSpan, \"no command handler found for command\");\n+            currentSpan.finish();\n+            ProtonHelper.released(delivery, true);\n+        }\n+    }\n+\n+    /**\n+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The identifier of the device that is the target of the commands being handled.\n+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is\n+     *                  the target of the commands being handled, or {@code null} otherwise.\n+     * @param commandHandler The command handler.\n+     * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.\n+     */\n+    public void addDeviceSpecificCommandHandler(final String tenantId, final String deviceId,\n+            final String gatewayId, final Handler<CommandContext> commandHandler) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(commandHandler);\n+\n+        final String key = getDeviceKey(tenantId, deviceId);\n+        if (commandHandlers.containsKey(key)) {\n+            LOG.debug(\"replacing existing command consumer [tenant-id: {}, device-id: {}]\", tenantId, deviceId);\n+            // TODO find provide a notification here so that potential resources associated with the replaced consumer can be freed\n+        }\n+        commandHandlers.put(key, new CommandHandlerWrapper(tenantId, deviceId, gatewayId, commandHandler));\n+    }\n+\n+    /**\n+     * Gets a handler for the given device id or for the given gateway id.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param originalDeviceId The device id that the command is originally targeted at.\n+     * @param gatewayId The gateway id. May be {@code null}.\n+     * @return The handler or {@code null}.\n+     */\n+    public CommandHandlerWrapper getDeviceSpecificCommandHandler(final String tenantId, final String originalDeviceId, final String gatewayId) {\n+        // look for a handler with the original device id first\n+        CommandHandlerWrapper handler = commandHandlers.get(getDeviceKey(tenantId, originalDeviceId));", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcxOTE5MA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393719190", "bodyText": "added null check and javadoc hint.", "author": "calohmn", "createdAt": "2020-03-17T14:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNDMxNg==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393514316", "bodyText": "who is finishing the currentSpan?", "author": "sophokles73", "createdAt": "2020-03-17T08:33:35Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.Device;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+\n+/**\n+ * Handler for commands received at the protocol adapter specific address.\n+ */\n+public final class AdapterInstanceCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);\n+\n+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();\n+    private final Tracer tracer;\n+\n+    /**\n+     * Creates a new AdapterInstanceCommandHandler instance.\n+     *\n+     * @param tracer The tracer instance.\n+     */\n+    public AdapterInstanceCommandHandler(final Tracer tracer) {\n+        this.tracer = tracer;\n+    }\n+\n+    /**\n+     * Handles a received command message.\n+     *\n+     * @param msg The command message.\n+     * @param delivery The delivery.\n+     */\n+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {\n+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case\n+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;\n+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", msg.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            delivery.disposition(rejected, true);\n+            return;\n+        }\n+        final String tenantId = resourceIdentifier.getTenantId();\n+        final String originalDeviceId = resourceIdentifier.getResourceId();\n+        // fetch \"via\" property (if set)\n+        String gatewayId = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);\n+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, originalDeviceId, gatewayId);\n+        if (commandHandler != null && gatewayId == null && commandHandler.getGatewayId() != null) {\n+            // there's a gateway having specifically subscribed for commands to that device here;\n+            // in that case the command handler was registered with the specific device id, not the gateway\n+            // (\"deviceConnectionService.setCommandHandlingAdapterInstance()\" doesn't have an extra gateway id parameter)\n+            // => therefore no gateway information was transported with the incoming message here and we have to take\n+            //    the gateway information from the chosen commandHandler.\n+            gatewayId = commandHandler.getGatewayId();\n+        }\n+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);\n+\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);\n+        final Span currentSpan = CommandConsumer.createSpan(\"send command\", tenantId, originalDeviceId,\n+                gatewayId, tracer, spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+\n+        if (commandHandler != null) {\n+            LOG.trace(\"using [{}] for received command [{}]\", commandHandler, command);\n+            // command.isValid() check not done here - it is to be done in the command handler\n+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzNjI5NQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393536295", "bodyText": "The currentSpan inside the CommandContext is finished as part of the disposition update methods (e.g. CommandContext.accept()).", "author": "calohmn", "createdAt": "2020-03-17T09:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NTYyMQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393685621", "bodyText": "IMHO the JavaDoc for the addDeviceSpecificCommandHandler method should be more explicit about the expectations regarding the passed in handler. In particular, it looks like the handler must invoke one of the CommandContext's terminal methods in order to settle the transfer command message transfer and to finish the span, right?", "author": "sophokles73", "createdAt": "2020-03-17T13:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcxODg5Nw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393718897", "bodyText": "Yes. I've adapted the javadoc accordingly, also in the ProtocolAdapterCommandConsumerFactory.", "author": "calohmn", "createdAt": "2020-03-17T14:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNTY5Nw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393515697", "bodyText": "these should be moved down to after the private final fields ...", "author": "sophokles73", "createdAt": "2020-03-17T08:36:18Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public class CommandTargetMapperImpl implements CommandTargetMapper {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);\n+\n+    private final Tracer tracer;\n+    private RegistrationClientFactory registrationClientFactory;\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxOTM5Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393519393", "bodyText": "how about factoring this out into its own method?\nwe could also move it up one level in the compose hierarchy FMPOV ...", "author": "sophokles73", "createdAt": "2020-03-17T08:43:25Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public class CommandTargetMapperImpl implements CommandTargetMapper {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);\n+\n+    private final Tracer tracer;\n+    private RegistrationClientFactory registrationClientFactory;\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;\n+    private final AtomicBoolean initialized = new AtomicBoolean(false);\n+\n+    /**\n+     * Creates a new GatewayMapperImpl instance.\n+     *\n+     * @param tracer The tracer instance.\n+     * @throws NullPointerException if tracer is {@code null}.\n+     */\n+    public CommandTargetMapperImpl(final Tracer tracer) {\n+        this.tracer = Objects.requireNonNull(tracer);\n+    }\n+\n+    @Override\n+    public void initialize(final RegistrationClientFactory registrationClientFactory,\n+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {\n+        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);\n+        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);\n+        initialized.set(true);\n+    }\n+\n+    @Override\n+    public final Future<JsonObject> getTargetGatewayAndAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {\n+        if (!initialized.get()) {\n+            LOG.error(\"not initialized\");\n+            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+        }\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, context, \"get target gateway and adapter instance\",\n+                        CommandTargetMapper.class.getSimpleName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)\n+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)\n+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)\n+                .start();\n+\n+        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)\n+                .compose(client -> client.assertRegistration(deviceId, null, span.context()))\n+                .recover(t -> {\n+                    LOG.debug(\"Error getting registration assertion\", t);\n+                    return Future.failedFuture(t);\n+                })\n+                .compose(registrationAssertionJson -> {\n+                    final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);\n+                    @SuppressWarnings(\"unchecked\")\n+                    final List<String> viaGateways = viaObject instanceof JsonArray\n+                            ? new ArrayList<String>(((JsonArray) viaObject).getList())\n+                            : Collections.emptyList();\n+                    return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)\n+                            .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, span.context()))\n+                            .compose(resultJson -> {\n+                                final JsonArray instancesArray = resultJson.getJsonArray(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                if (instancesArray == null || instancesArray.isEmpty()) {\n+                                    LOG.error(\"Invalid result JSON; field '{}' is null or empty\", DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+\n+                                final JsonObject targetInstanceObject;\n+                                try {\n+                                    if (instancesArray.size() == 1) {\n+                                        targetInstanceObject = instancesArray.getJsonObject(0);\n+                                    } else {\n+                                        targetInstanceObject = chooseTargetGatewayAndAdapterInstance(instancesArray);\n+                                    }\n+                                } catch (final ClassCastException e) {\n+                                    LOG.error(\"Invalid result JSON\", e);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                final String targetDevice = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                                final String targetAdapterInstance = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                                if (targetDevice == null || targetAdapterInstance == null) {\n+                                    LOG.error(\"Invalid result JSON, missing target device and/or adapter instance\");\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                if (!targetDevice.equals(deviceId)) {\n+                                    // target device is a gateway\n+                                    if (!viaGateways.contains(targetDevice)) {\n+                                        LOG.error(\"Invalid result JSON, target gateway {} is not in via gateways list\", targetDevice);\n+                                        return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                    }\n+                                    span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, targetDevice);\n+                                }\n+                                span.finish();\n+                                return Future.succeededFuture(targetInstanceObject);\n+                            });", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0MTkxNQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393541915", "bodyText": "Good point.\n\nwe could also move it up one level in the compose hierarchy FMPOV ...\n\nThat won't work because of the viaGateways list initialized in one compose block.", "author": "calohmn", "createdAt": "2020-03-17T09:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxOTM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcxNzc1MA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393717750", "bodyText": "I've put it in a separate method and improved logging/tracing.", "author": "calohmn", "createdAt": "2020-03-17T14:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxOTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMjAxMA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393522010", "bodyText": "shouldn't this better return an ordered list of adapter instances so that an adapter can try to forward the command to one after the other if one of them rejects the command?", "author": "sophokles73", "createdAt": "2020-03-17T08:48:20Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public class CommandTargetMapperImpl implements CommandTargetMapper {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);\n+\n+    private final Tracer tracer;\n+    private RegistrationClientFactory registrationClientFactory;\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;\n+    private final AtomicBoolean initialized = new AtomicBoolean(false);\n+\n+    /**\n+     * Creates a new GatewayMapperImpl instance.\n+     *\n+     * @param tracer The tracer instance.\n+     * @throws NullPointerException if tracer is {@code null}.\n+     */\n+    public CommandTargetMapperImpl(final Tracer tracer) {\n+        this.tracer = Objects.requireNonNull(tracer);\n+    }\n+\n+    @Override\n+    public void initialize(final RegistrationClientFactory registrationClientFactory,\n+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {\n+        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);\n+        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);\n+        initialized.set(true);\n+    }\n+\n+    @Override\n+    public final Future<JsonObject> getTargetGatewayAndAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {\n+        if (!initialized.get()) {\n+            LOG.error(\"not initialized\");\n+            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+        }\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, context, \"get target gateway and adapter instance\",\n+                        CommandTargetMapper.class.getSimpleName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)\n+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)\n+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)\n+                .start();\n+\n+        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)\n+                .compose(client -> client.assertRegistration(deviceId, null, span.context()))\n+                .recover(t -> {\n+                    LOG.debug(\"Error getting registration assertion\", t);\n+                    return Future.failedFuture(t);\n+                })\n+                .compose(registrationAssertionJson -> {\n+                    final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);\n+                    @SuppressWarnings(\"unchecked\")\n+                    final List<String> viaGateways = viaObject instanceof JsonArray\n+                            ? new ArrayList<String>(((JsonArray) viaObject).getList())\n+                            : Collections.emptyList();\n+                    return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)\n+                            .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, span.context()))\n+                            .compose(resultJson -> {\n+                                final JsonArray instancesArray = resultJson.getJsonArray(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                if (instancesArray == null || instancesArray.isEmpty()) {\n+                                    LOG.error(\"Invalid result JSON; field '{}' is null or empty\", DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+\n+                                final JsonObject targetInstanceObject;\n+                                try {\n+                                    if (instancesArray.size() == 1) {\n+                                        targetInstanceObject = instancesArray.getJsonObject(0);\n+                                    } else {\n+                                        targetInstanceObject = chooseTargetGatewayAndAdapterInstance(instancesArray);\n+                                    }\n+                                } catch (final ClassCastException e) {\n+                                    LOG.error(\"Invalid result JSON\", e);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                final String targetDevice = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                                final String targetAdapterInstance = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                                if (targetDevice == null || targetAdapterInstance == null) {\n+                                    LOG.error(\"Invalid result JSON, missing target device and/or adapter instance\");\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                if (!targetDevice.equals(deviceId)) {\n+                                    // target device is a gateway\n+                                    if (!viaGateways.contains(targetDevice)) {\n+                                        LOG.error(\"Invalid result JSON, target gateway {} is not in via gateways list\", targetDevice);\n+                                        return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                    }\n+                                    span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, targetDevice);\n+                                }\n+                                span.finish();\n+                                return Future.succeededFuture(targetInstanceObject);\n+                            });\n+                }).recover(t -> {\n+                    LOG.debug(\"Error getting target gateway and adapter instance\", t);\n+                    TracingHelper.logError(span, t);\n+                    Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(t));\n+                    span.finish();\n+                    return Future.failedFuture(t);\n+                });\n+    }\n+\n+    /**\n+     * Chooses the target gateway and adapter instance from the given list of entries.\n+     * <p>\n+     * This method returns first entry from the given list.\n+     * <p>\n+     * Subclasses may override this method in order to apply a different algorithm.\n+     *\n+     * @param instancesArray The JSON array containing the target gateway and adapter instance entries to choose from.\n+     * @return The chosen JSON object.\n+     */\n+    protected JsonObject chooseTargetGatewayAndAdapterInstance(final JsonArray instancesArray) {", "originalCommit": "4876be5363e63da184b42f9e138d6a90942891f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU2NzQ1Ng==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393567456", "bodyText": "For such a mechanism, the CommandTargetMapper.getTargetGatewayAndAdapterInstance method would have to be changed so that it can return a result JSON array.\nThe implementation of that mechanism would then be where that method is called, ie. in MappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommand.\nI had decided against such a mechanism mainly because I think it's unclear how a gateway could either say \"I as gateway reject the command because I can't handle it\" (ie. \"try next gateway\") or \"I reject the command because the target device has rejected it\" (ie. \"no use in trying other gateways\").\nOne could argue that this is not important, that it wouldn't matter to try the other gateways. But I don't really like that approach, causing traffic and a delay in acknowledging the command for nothing in many cases.\nI had rather thought of making it possible to override the chooseTargetGatewayAndAdapterInstance method and let a specific implementation better choose the one gateway that the command will be sent to, e.g. by taking extra properties returned in the device connection result into account or by querying the registration service for some gateway device property that helps in deciding which gateway to choose.", "author": "calohmn", "createdAt": "2020-03-17T10:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNDI0Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393634243", "bodyText": "Ok, let's see how we fare with this approach ...", "author": "sophokles73", "createdAt": "2020-03-17T12:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMjAxMA=="}], "type": "inlineReview"}, {"oid": "ef80b826b738980c6395b7632a2c60c819506d85", "url": "https://github.com/eclipse/hono/commit/ef80b826b738980c6395b7632a2c60c819506d85", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-17T14:24:08Z", "type": "forcePushed"}, {"oid": "f798f11d34680c31e27e52fe1da1ed1ce5c39d1c", "url": "https://github.com/eclipse/hono/commit/f798f11d34680c31e27e52fe1da1ed1ce5c39d1c", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-17T15:16:10Z", "type": "forcePushed"}, {"oid": "22f0073941892c831a32b49381de67e038ae5697", "url": "https://github.com/eclipse/hono/commit/22f0073941892c831a32b49381de67e038ae5697", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-17T15:23:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgwNjg1OA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393806858", "bodyText": "2019, 2020?", "author": "sophokles73", "createdAt": "2020-03-17T16:25:33Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation", "originalCommit": "22f0073941892c831a32b49381de67e038ae5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMTgxMw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393811813", "bodyText": "I had hoped that we would be able to get rid of the second parameter altogether. But that might be done in a future PR ...", "author": "sophokles73", "createdAt": "2020-03-17T16:32:43Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.eventbus.Message;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to receive commands and send responses.\n+ * <p>\n+ * The factory uses two kinds of consumer links to receive commands:\n+ * <ul>\n+ * <li>A single consumer link on an address containing the protocol adapter instance id.</li>\n+ * <li>A tenant-scoped link, created (if not already existing for that tenant) when\n+ * {@link #createCommandConsumer(String, String, Handler)} is invoked.</li>\n+ * </ul>\n+ * <p>\n+ * Command messages are first received on the tenant-scoped consumer address. It is then determined whether there is\n+ * a consumer and corresponding command handler for the command message's target device or one of the device's\n+ * possible gateways. If found, that handler is either invoked directly, or, if it is on another protocol adapter\n+ * instance, the command message is sent to that protocol adapter instance to be handled there.\n+ */\n+public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClientFactory implements ProtocolAdapterCommandConsumerFactory {\n+\n+    private static final int RECREATE_CONSUMERS_DELAY = 20;\n+\n+    /**\n+     * Cache key used here is the tenant id.\n+     */\n+    private CachingClientFactory<MessageConsumer> mappingAndDelegatingCommandConsumerFactory;\n+\n+    private final String adapterInstanceId;\n+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;\n+    private final AtomicBoolean recreatingConsumers = new AtomicBoolean(false);\n+    private final AtomicBoolean tryAgainRecreatingConsumers = new AtomicBoolean(false);\n+\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;\n+    private MappingAndDelegatingCommandHandler mappingAndDelegatingCommandHandler;\n+    private ProtonReceiver adapterSpecificConsumer;\n+    private final AtomicBoolean initialized = new AtomicBoolean(false);\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     * \n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public ProtocolAdapterCommandConsumerFactoryImpl(final HonoConnection connection, final String adapterInstanceId) {", "originalCommit": "22f0073941892c831a32b49381de67e038ae5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NzUwMg==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r394897502", "bodyText": "I think \"if applicable\" needs a bit more explanation here (and in the following javacdocs of this interface). It think it is an integral aspect, and it would help, explaining a bit more when it might be applicable.", "author": "ctron", "createdAt": "2020-03-19T09:38:27Z", "path": "client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)", "originalCommit": "22f0073941892c831a32b49381de67e038ae5697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0OTQ1Ng==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395649456", "bodyText": "I've extended the javadoc here.", "author": "calohmn", "createdAt": "2020-03-20T13:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NzUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcxMDI4Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395710283", "bodyText": "did you?", "author": "sophokles73", "createdAt": "2020-03-20T15:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NzUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1MDAxOQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395750019", "bodyText": "Sorry, I mistook this to be aimed at the javadoc of the getTargetGatewayAndAdapterInstance method. I'll update both javadocs (class and method)...", "author": "calohmn", "createdAt": "2020-03-20T16:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NzUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2OTg1NA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395769854", "bodyText": "done", "author": "calohmn", "createdAt": "2020-03-20T16:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NzUwMg=="}], "type": "inlineReview"}, {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "url": "https://github.com/eclipse/hono/commit/0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-19T17:44:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NzkyMA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395477920", "bodyText": "should be added to @throws ...", "author": "sophokles73", "createdAt": "2020-03-20T07:51:29Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java", "diffHunk": "@@ -24,28 +24,36 @@\n  */\n public final class CommandHandlerWrapper {\n \n+    private final String tenantId;\n     private final String deviceId;\n     private final String gatewayId;\n     private final Handler<CommandContext> commandHandler;\n-    private final Handler<Void> remoteCloseHandler;\n \n     /**\n      * Creates a new CommandHandlerWrapper.\n-     * \n+     *\n+     * @param tenantId The tenant id.\n      * @param deviceId The identifier of the device that is the target of the commands being handled.\n      * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is\n      *                  the target of the commands being handled, or {@code null} otherwise.\n      * @param commandHandler The command handler.\n-     * @param remoteCloseHandler The handler to be invoked when the command consumer is closed remotely. May be\n-     *            {@code null}.\n      * @throws NullPointerException If deviceId or commandHandler is {@code null}.\n      */\n-    public CommandHandlerWrapper(final String deviceId, final String gatewayId,\n-            final Handler<CommandContext> commandHandler, final Handler<Void> remoteCloseHandler) {\n+    public CommandHandlerWrapper(final String tenantId, final String deviceId, final String gatewayId,\n+                                 final Handler<CommandContext> commandHandler) {\n+        this.tenantId = Objects.requireNonNull(tenantId);", "originalCommit": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0OTgxNQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395649815", "bodyText": "done", "author": "calohmn", "createdAt": "2020-03-20T13:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3ODU4Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395478583", "bodyText": "FMPOV adapterInstanceId looks like a required param, doesn't it?", "author": "sophokles73", "createdAt": "2020-03-20T07:53:23Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java", "diffHunk": "@@ -225,21 +222,19 @@ private static Message createDelegatedCommandMessage(final Message originalMessa\n      * Creates a new sender for sending the delegated command messages to the AMQP network.\n      *\n      * @param con The connection to the AMQP network.\n-     * @param tenantId The tenant identifier.\n-     * @param deviceId The device identifier.\n+     * @param adapterInstanceId The protocol adapter instance id.\n      * @param closeHook A handler to invoke if the peer closes the link unexpectedly (may be {@code null}).\n      * @return A future indicating the result of the creation attempt.\n      * @throws NullPointerException if con is {@code null}.\n      */\n     public static Future<DelegatedCommandSender> create(\n             final HonoConnection con,\n-            final String tenantId,\n-            final String deviceId,\n+            final String adapterInstanceId,\n             final Handler<String> closeHook) {\n \n         Objects.requireNonNull(con);\n \n-        final String targetAddress = getTargetAddress(tenantId, deviceId);\n+        final String targetAddress = getTargetAddress(adapterInstanceId);", "originalCommit": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MDA5Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395650093", "bodyText": "Added null check and javadoc info.", "author": "calohmn", "createdAt": "2020-03-20T13:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3ODU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4Mjc3Mw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395482773", "bodyText": "it doesn't look like this can happen, can it?", "author": "sophokles73", "createdAt": "2020-03-20T08:05:30Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.DelegatedCommandSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Handler for commands received at the tenant-specific address.\n+ */\n+public class MappingAndDelegatingCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandHandler.class);\n+\n+    /**\n+     * Used for integration tests (with only a single instance of each protocol adapter):\n+     * <p>\n+     * System property value defining whether incoming command messages on the tenant\n+     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific\n+     * consumer even if there is a local handler for the command.<p>\n+     * The second condition for the rerouting to take place is that the command message\n+     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application\n+     * property with a {@code true} value.\n+     */\n+    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean\n+            .valueOf(System.getProperty(\"enableForcedCommandRerouting\", \"false\"));\n+    /**\n+     * Name of the boolean command message application property with which commands are\n+     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.\n+     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property\n+     * is set to {@code true}.\n+     */\n+    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = \"force-command-rerouting\";\n+\n+    private final HonoConnection connection;\n+    private final CommandTargetMapper commandTargetMapper;\n+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;\n+    private final String adapterInstanceId;\n+    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;\n+\n+    /**\n+     * Creates a new MappingAndDelegatingCommandHandler instance.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param commandTargetMapper The mapper component to determine the command target.\n+     * @param adapterInstanceCommandHandler The handler to delegate command handling to if the command is to be\n+     *                                      handled by the local adapter instance.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public MappingAndDelegatingCommandHandler(final HonoConnection connection,\n+            final CommandTargetMapper commandTargetMapper,\n+            final AdapterInstanceCommandHandler adapterInstanceCommandHandler, final String adapterInstanceId) {\n+        this.connection = Objects.requireNonNull(connection);\n+        this.commandTargetMapper = Objects.requireNonNull(commandTargetMapper);\n+        this.adapterInstanceCommandHandler = Objects.requireNonNull(adapterInstanceCommandHandler);\n+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);\n+\n+        this.delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());\n+    }\n+\n+    /**\n+     * Determines the target gateway (if applicable) and protocol adapter instance for an incoming command\n+     * and delegates the command either to the local AdapterInstanceCommandHandler or to the resulting\n+     * protocol adapter instance.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param originalMessageDelivery The delivery of the command message.\n+     * @param message The command message.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public void mapAndDelegateIncomingCommandMessage(final String tenantId,\n+            final ProtonDelivery originalMessageDelivery, final Message message) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(originalMessageDelivery);\n+        Objects.requireNonNull(message);\n+\n+        // this is the place where a command message on the \"command/tenant\" address arrives *first*\n+        final String deviceId = message.getAddress() != null ? ResourceIdentifier.fromString(message.getAddress()).getResourceId() : null;\n+        if (deviceId == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", message.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            originalMessageDelivery.disposition(rejected, true);\n+            return;\n+        }\n+        final Command command = Command.from(message, tenantId, deviceId);\n+        LOG.trace(\"received command [{}]\", command);\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);\n+        final Span currentSpan = CommandConsumer.createSpan(\"map and delegate command\", tenantId, deviceId, null,\n+                connection.getTracer(), spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+        final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);\n+        if (command.isValid()) {\n+            mapAndDelegateIncomingCommand(commandContext);\n+        } else {\n+            // command is invalid, try to find local command handler to let it reject the command (and also report metrics for that), otherwise reject it directly\n+            commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, spanContext)\n+                    .setHandler(ar -> {\n+                        CommandHandlerWrapper commandHandler = null;\n+                        if (ar.succeeded()) {\n+                            final String targetDevice = ar.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                            final String targetAdapterInstance = ar.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                            if (adapterInstanceId.equals(targetAdapterInstance)) {\n+                                final String gatewayId = !deviceId.equals(targetDevice) ? targetDevice : null;\n+                                commandHandler = adapterInstanceCommandHandler\n+                                        .getDeviceSpecificCommandHandler(tenantId, deviceId, gatewayId);\n+                            }\n+                        }\n+                        if (commandHandler != null) {\n+                            // let the device specific handler reject the command\n+                            commandHandler.handleCommand(commandContext);\n+                        } else {\n+                            LOG.debug(\"command message is invalid: {}\", command);\n+                            commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST,\n+                                    \"malformed command message\"));\n+                        }\n+                    });\n+\n+        }\n+    }\n+\n+    private void mapAndDelegateIncomingCommand(final CommandContext originalCommandContext) {\n+        final Command originalCommand = originalCommandContext.getCommand();\n+        if (!originalCommand.isValid()) {\n+            originalCommandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed command message\"));\n+            return;\n+        }", "originalCommit": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4MzYzNA==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395483634", "bodyText": "this is the same code as in the main method, isn't it? would it be possible to change the behavior so that we first try to delegate processing of a command to a local handler in any case (regardless of whether a command is valid or not) and then, if valid, forward it to the correct adapter instance?", "author": "sophokles73", "createdAt": "2020-03-20T08:07:44Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.DelegatedCommandSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Handler for commands received at the tenant-specific address.\n+ */\n+public class MappingAndDelegatingCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandHandler.class);\n+\n+    /**\n+     * Used for integration tests (with only a single instance of each protocol adapter):\n+     * <p>\n+     * System property value defining whether incoming command messages on the tenant\n+     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific\n+     * consumer even if there is a local handler for the command.<p>\n+     * The second condition for the rerouting to take place is that the command message\n+     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application\n+     * property with a {@code true} value.\n+     */\n+    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean\n+            .valueOf(System.getProperty(\"enableForcedCommandRerouting\", \"false\"));\n+    /**\n+     * Name of the boolean command message application property with which commands are\n+     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.\n+     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property\n+     * is set to {@code true}.\n+     */\n+    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = \"force-command-rerouting\";\n+\n+    private final HonoConnection connection;\n+    private final CommandTargetMapper commandTargetMapper;\n+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;\n+    private final String adapterInstanceId;\n+    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;\n+\n+    /**\n+     * Creates a new MappingAndDelegatingCommandHandler instance.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param commandTargetMapper The mapper component to determine the command target.\n+     * @param adapterInstanceCommandHandler The handler to delegate command handling to if the command is to be\n+     *                                      handled by the local adapter instance.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public MappingAndDelegatingCommandHandler(final HonoConnection connection,\n+            final CommandTargetMapper commandTargetMapper,\n+            final AdapterInstanceCommandHandler adapterInstanceCommandHandler, final String adapterInstanceId) {\n+        this.connection = Objects.requireNonNull(connection);\n+        this.commandTargetMapper = Objects.requireNonNull(commandTargetMapper);\n+        this.adapterInstanceCommandHandler = Objects.requireNonNull(adapterInstanceCommandHandler);\n+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);\n+\n+        this.delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());\n+    }\n+\n+    /**\n+     * Determines the target gateway (if applicable) and protocol adapter instance for an incoming command\n+     * and delegates the command either to the local AdapterInstanceCommandHandler or to the resulting\n+     * protocol adapter instance.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param originalMessageDelivery The delivery of the command message.\n+     * @param message The command message.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public void mapAndDelegateIncomingCommandMessage(final String tenantId,\n+            final ProtonDelivery originalMessageDelivery, final Message message) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(originalMessageDelivery);\n+        Objects.requireNonNull(message);\n+\n+        // this is the place where a command message on the \"command/tenant\" address arrives *first*\n+        final String deviceId = message.getAddress() != null ? ResourceIdentifier.fromString(message.getAddress()).getResourceId() : null;\n+        if (deviceId == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", message.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            originalMessageDelivery.disposition(rejected, true);\n+            return;\n+        }\n+        final Command command = Command.from(message, tenantId, deviceId);\n+        LOG.trace(\"received command [{}]\", command);\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);\n+        final Span currentSpan = CommandConsumer.createSpan(\"map and delegate command\", tenantId, deviceId, null,\n+                connection.getTracer(), spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+        final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);\n+        if (command.isValid()) {\n+            mapAndDelegateIncomingCommand(commandContext);\n+        } else {\n+            // command is invalid, try to find local command handler to let it reject the command (and also report metrics for that), otherwise reject it directly\n+            commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, spanContext)\n+                    .setHandler(ar -> {\n+                        CommandHandlerWrapper commandHandler = null;\n+                        if (ar.succeeded()) {\n+                            final String targetDevice = ar.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                            final String targetAdapterInstance = ar.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                            if (adapterInstanceId.equals(targetAdapterInstance)) {\n+                                final String gatewayId = !deviceId.equals(targetDevice) ? targetDevice : null;\n+                                commandHandler = adapterInstanceCommandHandler\n+                                        .getDeviceSpecificCommandHandler(tenantId, deviceId, gatewayId);\n+                            }\n+                        }\n+                        if (commandHandler != null) {\n+                            // let the device specific handler reject the command\n+                            commandHandler.handleCommand(commandContext);\n+                        } else {\n+                            LOG.debug(\"command message is invalid: {}\", command);\n+                            commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST,\n+                                    \"malformed command message\"));\n+                        }\n+                    });\n+\n+        }\n+    }\n+\n+    private void mapAndDelegateIncomingCommand(final CommandContext originalCommandContext) {\n+        final Command originalCommand = originalCommandContext.getCommand();\n+        if (!originalCommand.isValid()) {\n+            originalCommandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed command message\"));\n+            return;\n+        }\n+        final String tenantId = originalCommand.getTenant();\n+        final String originalDeviceId = originalCommand.getDeviceId();\n+        // determine last used gateway device id\n+        LOG.trace(\"determine command target gateway/adapter for [{}]\", originalCommand);\n+        final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, originalDeviceId,\n+                originalCommandContext.getTracingContext());\n+\n+        commandTargetFuture.setHandler(commandTargetResult -> {\n+            if (commandTargetResult.succeeded()) {\n+                final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+", "originalCommit": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MDc4MQ==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395650781", "bodyText": "Good point. I've refactored the method here and made that change.", "author": "calohmn", "createdAt": "2020-03-20T13:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4MzYzNA=="}], "type": "inlineReview"}, {"oid": "ec04ccaf65ad1a9a9998d1eda961116cd55f4b91", "url": "https://github.com/eclipse/hono/commit/ec04ccaf65ad1a9a9998d1eda961116cd55f4b91", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-20T13:50:46Z", "type": "forcePushed"}, {"oid": "2c3669020f9518c76628ba45a75df6fc20a7d814", "url": "https://github.com/eclipse/hono/commit/2c3669020f9518c76628ba45a75df6fc20a7d814", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-20T16:57:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NjMzMw==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395796333", "bodyText": "the protocol adapter instance?", "author": "sophokles73", "createdAt": "2020-03-20T17:45:14Z", "path": "client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for determining where a incoming command message should be targeted at when processing the message in a\n+ * protocol adapter.\n+ * <p>\n+ * This refers to finding the <em>protocol handler instance</em> that a device or gateway has connected to in order to", "originalCommit": "2c3669020f9518c76628ba45a75df6fc20a7d814", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwMDMxMg==", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395800312", "bodyText": "fixed", "author": "calohmn", "createdAt": "2020-03-20T17:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NjMzMw=="}], "type": "inlineReview"}, {"oid": "b02d8964f84f4c8ca79d9f0b3c7b863e1db71a8e", "url": "https://github.com/eclipse/hono/commit/b02d8964f84f4c8ca79d9f0b3c7b863e1db71a8e", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-20T17:52:14Z", "type": "forcePushed"}, {"oid": "16c4abe919443eb515585739cb728a9630e524d7", "url": "https://github.com/eclipse/hono/commit/16c4abe919443eb515585739cb728a9630e524d7", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-20T19:24:30Z", "type": "commit"}, {"oid": "16c4abe919443eb515585739cb728a9630e524d7", "url": "https://github.com/eclipse/hono/commit/16c4abe919443eb515585739cb728a9630e524d7", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-20T19:24:30Z", "type": "forcePushed"}]}