{"pr_number": 2249, "pr_title": "Add test-utils module", "pr_createdAt": "2020-10-13T11:23:20Z", "pr_url": "https://github.com/eclipse/hono/pull/2249", "timeline": [{"oid": "6ffd65e024d0a50276f5facda49e121909e9edf6", "url": "https://github.com/eclipse/hono/commit/6ffd65e024d0a50276f5facda49e121909e9edf6", "message": "Add test-utils module\n\nThe module contains reusable classes that are helpful with implementing\nunit tests for multiple Hono components.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-10-13T11:02:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkyODYxNg==", "url": "https://github.com/eclipse/hono/pull/2249#discussion_r503928616", "bodyText": "Checkstyle: Missing javadoc. Reported after adding the checkstyle plugin in the pom (see other comment).", "author": "calohmn", "createdAt": "2020-10-13T12:58:13Z", "path": "test-utils/service-base-test-utils/src/main/java/org/eclipse/hono/service/test/ProtocolAdapterTestSupport.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+\n+package org.eclipse.hono.service.test;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.CommandResponse;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.CredentialsClientFactory;\n+import org.eclipse.hono.client.DeviceConnectionClientFactory;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;\n+import org.eclipse.hono.client.RegistrationClient;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.TenantClientFactory;\n+import org.eclipse.hono.config.ProtocolAdapterProperties;\n+import org.eclipse.hono.service.AbstractProtocolAdapterBase;\n+import org.eclipse.hono.service.monitoring.ConnectionEventProducer;\n+import org.junit.jupiter.api.BeforeEach;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * A base class for implementing tests for protocol adapters.\n+ *\n+ * @param <T> The type of protocol adapter to test.\n+ * @param <C> The type of configuration properties the adapter uses.\n+ */\n+public abstract class ProtocolAdapterTestSupport<C extends ProtocolAdapterProperties, T extends AbstractProtocolAdapterBase<C>> {\n+\n+    protected C properties;\n+    protected T adapter;\n+\n+    protected ProtocolAdapterCommandConsumerFactory commandConsumerFactory;\n+    protected CommandTargetMapper commandTargetMapper;\n+    protected ConnectionEventProducer.Context connectionEventProducerContext;\n+    protected CredentialsClientFactory credentialsClientFactory;\n+    protected DeviceConnectionClientFactory deviceConnectionClientFactory;\n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+    protected RegistrationClient registrationClient;\n+    protected RegistrationClientFactory registrationClientFactory;\n+    protected TenantClientFactory tenantClientFactory;\n+\n+    /**\n+     * Sets up the adapter instance to be tested.\n+     */\n+    @BeforeEach\n+    protected void setUpAdapterInstance() {\n+\n+        commandConsumerFactory = mock(ProtocolAdapterCommandConsumerFactory.class);\n+        when(commandConsumerFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        commandTargetMapper = mock(CommandTargetMapper.class);\n+\n+        credentialsClientFactory = mock(CredentialsClientFactory.class);\n+        when(credentialsClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);\n+        when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        downstreamSenderFactory = mock(DownstreamSenderFactory.class);\n+        when(downstreamSenderFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        registrationClientFactory = mock(RegistrationClientFactory.class);\n+        when(registrationClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        registrationClient = mock(RegistrationClient.class);\n+        when(registrationClientFactory.getOrCreateRegistrationClient(anyString())).thenReturn(Future.succeededFuture(registrationClient));\n+\n+        tenantClientFactory = mock(TenantClientFactory.class);\n+        when(tenantClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        connectionEventProducerContext = mock(ConnectionEventProducer.Context.class);\n+        when(connectionEventProducerContext.getMessageSenderClient()).thenReturn(downstreamSenderFactory);\n+        when(connectionEventProducerContext.getTenantClientFactory()).thenReturn(tenantClientFactory);\n+\n+        properties = givenDefaultConfigurationProperties();\n+    }\n+\n+    /**\n+     * Creates default configuration for the adapter.\n+     *\n+     * @return The configuration properties.\n+     */\n+    protected abstract C givenDefaultConfigurationProperties();\n+\n+    /**\n+     * Creates an adapter instance.\n+     *\n+     * @param configuration The configuration properties to use.\n+     * @return The adapter.\n+     */\n+    protected abstract T newAdapter(C configuration);\n+\n+    /**\n+     * Sets the (mock) collaborators on an adapter.\n+     *\n+     * @param adapter The adapter.\n+     */\n+    protected void setCollaborators(final T adapter) {\n+        adapter.setCommandConsumerFactory(commandConsumerFactory);\n+        adapter.setCommandTargetMapper(commandTargetMapper);\n+        adapter.setCredentialsClientFactory(credentialsClientFactory);\n+        adapter.setDeviceConnectionClientFactory(deviceConnectionClientFactory);\n+        adapter.setDownstreamSenderFactory(downstreamSenderFactory);\n+        adapter.setRegistrationClientFactory(registrationClientFactory);\n+        adapter.setTenantClientFactory(tenantClientFactory);\n+    }\n+\n+    /**\n+     * Sets up a new adapter instance as the unit under test.\n+     * <p>\n+     * {@linkplain #newAdapter(ProtocolAdapterProperties) Creates a new instance}\n+     * and then {@linkplain #setCollaborators(AbstractProtocolAdapterBase)\n+     * sets all collaborators} on the new instance.\n+     *\n+     * @param configuration The configuration properties to apply.\n+     * @return The adapter instance to test.\n+     */\n+    protected T givenAnAdapter(final C configuration) {\n+        adapter = newAdapter(configuration);\n+        setCollaborators(adapter);\n+        return adapter;\n+    }\n+\n+    /**\n+     * Configures the downstream sender factory to create a mock sender\n+     * for telemetry messages regardless of tenant ID.\n+     * <p>\n+     * The returned sender's send methods will always return a succeeded future.\n+     *\n+     * @return The sender that the factory will create.\n+     */\n+    protected DownstreamSender givenATelemetrySenderForAnyTenant() {\n+        final Promise<ProtonDelivery> delivery = Promise.promise();\n+        delivery.complete(mock(ProtonDelivery.class));\n+        return givenATelemetrySenderForAnyTenant(delivery);\n+    }\n+\n+    /**\n+     * Configures the downstream sender factory to create a mock sender\n+     * for telemetry messages regardless of tenant ID.\n+     * <p>\n+     * The returned sender's send methods will return the given promise's\n+     * corresponding future.\n+     *\n+     * @param outcome The outcome of sending a message using the returned sender.\n+     * @return The sender that the factory will create.\n+     */\n+    protected DownstreamSender givenATelemetrySenderForAnyTenant(final Promise<ProtonDelivery> outcome) {\n+        final DownstreamSender sender = mock(DownstreamSender.class);\n+        when(sender.send(any(Message.class), any(SpanContext.class)))\n+            .thenReturn(outcome.future());\n+        when(sender.sendAndWaitForOutcome(any(Message.class), any(SpanContext.class)))\n+            .thenReturn(outcome.future());\n+\n+        when(downstreamSenderFactory.getOrCreateTelemetrySender(anyString())).thenReturn(Future.succeededFuture(sender));\n+        return sender;\n+    }\n+\n+    /**\n+     * Configures the downstream sender factory to create a mock sender\n+     * for events regardless of tenant ID.\n+     * <p>\n+     * The returned sender's send methods will return the given promise's\n+     * corresponding future.\n+     *\n+     * @param outcome The outcome of sending a message using the returned sender.\n+     * @return The sender that the factory will create.\n+     */\n+    protected DownstreamSender givenAnEventSender(final Promise<ProtonDelivery> outcome) {\n+        final DownstreamSender sender = mock(DownstreamSender.class);\n+        when(sender.sendAndWaitForOutcome(any(Message.class), (SpanContext) any())).thenReturn(outcome.future());\n+\n+        when(downstreamSenderFactory.getOrCreateEventSender(anyString())).thenReturn(Future.succeededFuture(sender));\n+        return sender;\n+    }\n+\n+    protected CommandResponseSender givenACommandResponseSenderForAnyTenant() {", "originalCommit": "6ffd65e024d0a50276f5facda49e121909e9edf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkyODcyNQ==", "url": "https://github.com/eclipse/hono/pull/2249#discussion_r503928725", "bodyText": "Checkstyle: Missing javadoc.", "author": "calohmn", "createdAt": "2020-10-13T12:58:22Z", "path": "test-utils/service-base-test-utils/src/main/java/org/eclipse/hono/service/test/ProtocolAdapterTestSupport.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+\n+package org.eclipse.hono.service.test;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.CommandResponse;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.CredentialsClientFactory;\n+import org.eclipse.hono.client.DeviceConnectionClientFactory;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;\n+import org.eclipse.hono.client.RegistrationClient;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.TenantClientFactory;\n+import org.eclipse.hono.config.ProtocolAdapterProperties;\n+import org.eclipse.hono.service.AbstractProtocolAdapterBase;\n+import org.eclipse.hono.service.monitoring.ConnectionEventProducer;\n+import org.junit.jupiter.api.BeforeEach;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * A base class for implementing tests for protocol adapters.\n+ *\n+ * @param <T> The type of protocol adapter to test.\n+ * @param <C> The type of configuration properties the adapter uses.\n+ */\n+public abstract class ProtocolAdapterTestSupport<C extends ProtocolAdapterProperties, T extends AbstractProtocolAdapterBase<C>> {\n+\n+    protected C properties;\n+    protected T adapter;\n+\n+    protected ProtocolAdapterCommandConsumerFactory commandConsumerFactory;\n+    protected CommandTargetMapper commandTargetMapper;\n+    protected ConnectionEventProducer.Context connectionEventProducerContext;\n+    protected CredentialsClientFactory credentialsClientFactory;\n+    protected DeviceConnectionClientFactory deviceConnectionClientFactory;\n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+    protected RegistrationClient registrationClient;\n+    protected RegistrationClientFactory registrationClientFactory;\n+    protected TenantClientFactory tenantClientFactory;\n+\n+    /**\n+     * Sets up the adapter instance to be tested.\n+     */\n+    @BeforeEach\n+    protected void setUpAdapterInstance() {\n+\n+        commandConsumerFactory = mock(ProtocolAdapterCommandConsumerFactory.class);\n+        when(commandConsumerFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        commandTargetMapper = mock(CommandTargetMapper.class);\n+\n+        credentialsClientFactory = mock(CredentialsClientFactory.class);\n+        when(credentialsClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);\n+        when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        downstreamSenderFactory = mock(DownstreamSenderFactory.class);\n+        when(downstreamSenderFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        registrationClientFactory = mock(RegistrationClientFactory.class);\n+        when(registrationClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        registrationClient = mock(RegistrationClient.class);\n+        when(registrationClientFactory.getOrCreateRegistrationClient(anyString())).thenReturn(Future.succeededFuture(registrationClient));\n+\n+        tenantClientFactory = mock(TenantClientFactory.class);\n+        when(tenantClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+\n+        connectionEventProducerContext = mock(ConnectionEventProducer.Context.class);\n+        when(connectionEventProducerContext.getMessageSenderClient()).thenReturn(downstreamSenderFactory);\n+        when(connectionEventProducerContext.getTenantClientFactory()).thenReturn(tenantClientFactory);\n+\n+        properties = givenDefaultConfigurationProperties();\n+    }\n+\n+    /**\n+     * Creates default configuration for the adapter.\n+     *\n+     * @return The configuration properties.\n+     */\n+    protected abstract C givenDefaultConfigurationProperties();\n+\n+    /**\n+     * Creates an adapter instance.\n+     *\n+     * @param configuration The configuration properties to use.\n+     * @return The adapter.\n+     */\n+    protected abstract T newAdapter(C configuration);\n+\n+    /**\n+     * Sets the (mock) collaborators on an adapter.\n+     *\n+     * @param adapter The adapter.\n+     */\n+    protected void setCollaborators(final T adapter) {\n+        adapter.setCommandConsumerFactory(commandConsumerFactory);\n+        adapter.setCommandTargetMapper(commandTargetMapper);\n+        adapter.setCredentialsClientFactory(credentialsClientFactory);\n+        adapter.setDeviceConnectionClientFactory(deviceConnectionClientFactory);\n+        adapter.setDownstreamSenderFactory(downstreamSenderFactory);\n+        adapter.setRegistrationClientFactory(registrationClientFactory);\n+        adapter.setTenantClientFactory(tenantClientFactory);\n+    }\n+\n+    /**\n+     * Sets up a new adapter instance as the unit under test.\n+     * <p>\n+     * {@linkplain #newAdapter(ProtocolAdapterProperties) Creates a new instance}\n+     * and then {@linkplain #setCollaborators(AbstractProtocolAdapterBase)\n+     * sets all collaborators} on the new instance.\n+     *\n+     * @param configuration The configuration properties to apply.\n+     * @return The adapter instance to test.\n+     */\n+    protected T givenAnAdapter(final C configuration) {\n+        adapter = newAdapter(configuration);\n+        setCollaborators(adapter);\n+        return adapter;\n+    }\n+\n+    /**\n+     * Configures the downstream sender factory to create a mock sender\n+     * for telemetry messages regardless of tenant ID.\n+     * <p>\n+     * The returned sender's send methods will always return a succeeded future.\n+     *\n+     * @return The sender that the factory will create.\n+     */\n+    protected DownstreamSender givenATelemetrySenderForAnyTenant() {\n+        final Promise<ProtonDelivery> delivery = Promise.promise();\n+        delivery.complete(mock(ProtonDelivery.class));\n+        return givenATelemetrySenderForAnyTenant(delivery);\n+    }\n+\n+    /**\n+     * Configures the downstream sender factory to create a mock sender\n+     * for telemetry messages regardless of tenant ID.\n+     * <p>\n+     * The returned sender's send methods will return the given promise's\n+     * corresponding future.\n+     *\n+     * @param outcome The outcome of sending a message using the returned sender.\n+     * @return The sender that the factory will create.\n+     */\n+    protected DownstreamSender givenATelemetrySenderForAnyTenant(final Promise<ProtonDelivery> outcome) {\n+        final DownstreamSender sender = mock(DownstreamSender.class);\n+        when(sender.send(any(Message.class), any(SpanContext.class)))\n+            .thenReturn(outcome.future());\n+        when(sender.sendAndWaitForOutcome(any(Message.class), any(SpanContext.class)))\n+            .thenReturn(outcome.future());\n+\n+        when(downstreamSenderFactory.getOrCreateTelemetrySender(anyString())).thenReturn(Future.succeededFuture(sender));\n+        return sender;\n+    }\n+\n+    /**\n+     * Configures the downstream sender factory to create a mock sender\n+     * for events regardless of tenant ID.\n+     * <p>\n+     * The returned sender's send methods will return the given promise's\n+     * corresponding future.\n+     *\n+     * @param outcome The outcome of sending a message using the returned sender.\n+     * @return The sender that the factory will create.\n+     */\n+    protected DownstreamSender givenAnEventSender(final Promise<ProtonDelivery> outcome) {\n+        final DownstreamSender sender = mock(DownstreamSender.class);\n+        when(sender.sendAndWaitForOutcome(any(Message.class), (SpanContext) any())).thenReturn(outcome.future());\n+\n+        when(downstreamSenderFactory.getOrCreateEventSender(anyString())).thenReturn(Future.succeededFuture(sender));\n+        return sender;\n+    }\n+\n+    protected CommandResponseSender givenACommandResponseSenderForAnyTenant() {\n+        final Promise<ProtonDelivery> delivery = Promise.promise();\n+        delivery.complete(mock(ProtonDelivery.class));\n+        return givenACommandResponseSenderForAnyTenant(delivery);\n+    }\n+\n+    protected CommandResponseSender givenACommandResponseSenderForAnyTenant(final Promise<ProtonDelivery> outcome) {", "originalCommit": "6ffd65e024d0a50276f5facda49e121909e9edf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ4MzM0Ng==", "url": "https://github.com/eclipse/hono/pull/2249#discussion_r504483346", "bodyText": "The javadoc (including the now unresolvable #newAdapter link) doesn't fit anymore.\nIn general the method doesn't seem to be needed in this class.", "author": "calohmn", "createdAt": "2020-10-14T08:09:20Z", "path": "test-utils/service-base-test-utils/src/main/java/org/eclipse/hono/service/test/ProtocolAdapterTestSupport.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+\n+package org.eclipse.hono.service.test;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.HttpURLConnection;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.CommandResponse;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.CredentialsClientFactory;\n+import org.eclipse.hono.client.DeviceConnectionClientFactory;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;\n+import org.eclipse.hono.client.RegistrationClient;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.TenantClientFactory;\n+import org.eclipse.hono.config.ProtocolAdapterProperties;\n+import org.eclipse.hono.service.AbstractProtocolAdapterBase;\n+import org.eclipse.hono.service.monitoring.ConnectionEventProducer;\n+import org.junit.jupiter.api.BeforeEach;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * A base class for implementing tests for protocol adapters.\n+ *\n+ * @param <T> The type of protocol adapter to test.\n+ * @param <C> The type of configuration properties the adapter uses.\n+ */\n+public abstract class ProtocolAdapterTestSupport<C extends ProtocolAdapterProperties, T extends AbstractProtocolAdapterBase<C>> {\n+\n+    protected C properties;\n+    protected T adapter;\n+\n+    protected ProtocolAdapterCommandConsumerFactory commandConsumerFactory;\n+    protected CommandTargetMapper commandTargetMapper;\n+    protected ConnectionEventProducer.Context connectionEventProducerContext;\n+    protected CredentialsClientFactory credentialsClientFactory;\n+    protected DeviceConnectionClientFactory deviceConnectionClientFactory;\n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+    protected RegistrationClient registrationClient;\n+    protected RegistrationClientFactory registrationClientFactory;\n+    protected TenantClientFactory tenantClientFactory;\n+\n+    /**\n+     * Sets up the adapter instance to be tested.\n+     */\n+    @BeforeEach\n+    protected void setUpAdapterInstance() {\n+\n+        commandConsumerFactory = mock(ProtocolAdapterCommandConsumerFactory.class);\n+        when(commandConsumerFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+        when(commandConsumerFactory.isConnected()).thenReturn(Future.succeededFuture());\n+\n+        commandTargetMapper = mock(CommandTargetMapper.class);\n+\n+        credentialsClientFactory = mock(CredentialsClientFactory.class);\n+        when(credentialsClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+        when(credentialsClientFactory.isConnected()).thenReturn(Future.succeededFuture());\n+\n+        deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);\n+        when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+        when(deviceConnectionClientFactory.isConnected()).thenReturn(Future.succeededFuture());\n+\n+        downstreamSenderFactory = mock(DownstreamSenderFactory.class);\n+        when(downstreamSenderFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+        when(downstreamSenderFactory.isConnected()).thenReturn(Future.succeededFuture());\n+\n+        registrationClientFactory = mock(RegistrationClientFactory.class);\n+        when(registrationClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+        when(registrationClientFactory.isConnected()).thenReturn(Future.succeededFuture());\n+\n+        registrationClient = mock(RegistrationClient.class);\n+        when(registrationClientFactory.getOrCreateRegistrationClient(anyString())).thenReturn(Future.succeededFuture(registrationClient));\n+\n+        tenantClientFactory = mock(TenantClientFactory.class);\n+        when(tenantClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));\n+        when(tenantClientFactory.isConnected()).thenReturn(Future.succeededFuture());\n+\n+        connectionEventProducerContext = mock(ConnectionEventProducer.Context.class);\n+        when(connectionEventProducerContext.getMessageSenderClient()).thenReturn(downstreamSenderFactory);\n+        when(connectionEventProducerContext.getTenantClientFactory()).thenReturn(tenantClientFactory);\n+\n+        properties = givenDefaultConfigurationProperties();\n+    }\n+\n+    /**\n+     * Creates default configuration for the adapter.\n+     *\n+     * @return The configuration properties.\n+     */\n+    protected abstract C givenDefaultConfigurationProperties();\n+\n+    /**\n+     * Sets up a new adapter instance as the unit under test.\n+     * <p>\n+     * {@linkplain #newAdapter(ProtocolAdapterProperties) Creates a new instance}\n+     * and then {@linkplain #setCollaborators(AbstractProtocolAdapterBase)\n+     * sets all collaborators} on the new instance.\n+     *\n+     * @param configuration The configuration properties to apply.\n+     * @return The adapter instance to test.\n+     */\n+    protected abstract T givenAnAdapter(C configuration);", "originalCommit": "02dd60b74636a2b34171fcbcb5e37f9b9587158e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwMjAyOQ==", "url": "https://github.com/eclipse/hono/pull/2249#discussion_r504602029", "bodyText": "true, I have removed the method ...", "author": "sophokles73", "createdAt": "2020-10-14T11:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ4MzM0Ng=="}], "type": "inlineReview"}, {"oid": "601444146370e5ee604fdb37c9c8a9d1862e331a", "url": "https://github.com/eclipse/hono/commit/601444146370e5ee604fdb37c9c8a9d1862e331a", "message": "Remove abstract givenAnAdapter method\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-10-14T10:32:11Z", "type": "commit"}, {"oid": "601444146370e5ee604fdb37c9c8a9d1862e331a", "url": "https://github.com/eclipse/hono/commit/601444146370e5ee604fdb37c9c8a9d1862e331a", "message": "Remove abstract givenAnAdapter method\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-10-14T10:32:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYyMjc4Mw==", "url": "https://github.com/eclipse/hono/pull/2249#discussion_r504622783", "bodyText": "The configuration parameter isn't used, so this looks somewhat confusing.\nAlso in the 2 other adapter test classes.", "author": "calohmn", "createdAt": "2020-10-14T12:06:51Z", "path": "adapters/mqtt-vertx-base/src/test/java/org/eclipse/hono/adapter/mqtt/AbstractVertxBasedMqttProtocolAdapterTest.java", "diffHunk": "@@ -1512,6 +1392,28 @@ private MqttEndpoint getMqttEndpointAuthenticated() {\n         return getMqttEndpointAuthenticated(\"sensor1@DEFAULT_TENANT\", \"test\");\n     }\n \n+    /**\n+     * Creates a new adapter instance to be tested.\n+     * <p>\n+     * This method\n+     * <ol>\n+     * <li>creates a new {@code MqttServer} using {@link #getMqttServer(boolean)}</li>\n+     * <li>assigns the result to property <em>server</em></li>\n+     * <li>passes the server in to {@link #getAdapter(MqttServer)}</li>\n+     * <li>assigns the result to property <em>adapter</em></li>\n+     * </ol>\n+     *\n+     * @param configuration The configuration properties to use.\n+     * @return The adapter instance.\n+     */\n+    private AbstractVertxBasedMqttProtocolAdapter<MqttProtocolAdapterProperties> givenAnAdapter(\n+            final MqttProtocolAdapterProperties configuration) {", "originalCommit": "601444146370e5ee604fdb37c9c8a9d1862e331a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3Njc0OA==", "url": "https://github.com/eclipse/hono/pull/2249#discussion_r504676748", "bodyText": "Yes, I agree, that is not very nice. I have fixed it ...", "author": "sophokles73", "createdAt": "2020-10-14T13:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYyMjc4Mw=="}], "type": "inlineReview"}, {"oid": "f88f691814a14ca57316332a9cc050c2993c6f19", "url": "https://github.com/eclipse/hono/commit/f88f691814a14ca57316332a9cc050c2993c6f19", "message": "Use configuration properties when creating adapter instance\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-10-14T13:28:14Z", "type": "commit"}]}