{"pr_number": 1765, "pr_title": "[#1761] Add AMQP adapter client.", "pr_createdAt": "2020-02-12T11:09:00Z", "pr_url": "https://github.com/eclipse/hono/pull/1765", "timeline": [{"oid": "4de17bb13523467c969c55542fd1c0e3494498fc", "url": "https://github.com/eclipse/hono/commit/4de17bb13523467c969c55542fd1c0e3494498fc", "message": "[#1761] Add AMQP adapter client.\n\nDevice (or gateway) clients that connect to the AMQP adapter can be created\nusing AmqpAdapterClientFactory. The implementation reopens closed connections\nand restores the receiver link for consuming commands afterward. Sender links\nare cached and removed from the cache when closed so that they are recreated\nthe next time they are retrieved from the factory.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-02-19T13:34:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5NjE4Ng==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381796186", "bodyText": "final HonoConnection connection", "author": "calohmn", "createdAt": "2020-02-20T06:22:23Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.function.Consumer;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ConnectionLifecycle;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.impl.AmqpAdapterClientFactoryImpl;\n+\n+import io.vertx.core.Future;\n+\n+/**\n+ * A Vert.x based factory for creating clients for Hono's AMQP adapter.\n+ */\n+public interface AmqpAdapterClientFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to use.\n+     * @param tenantId The ID of the tenant for which the connection is authenticated.\n+     * @return The factory.\n+     * @throws NullPointerException if any of the parameters is {@code null}\n+     */\n+    static AmqpAdapterClientFactory create(HonoConnection connection, final String tenantId) {", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgwODA2Ng==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381808066", "bodyText": "According to the AMQP adapter docs, the correlation id may be null if no reply-to is set. (The actual implementation in the AMQP adapter always sets the correlation id, but that's another matter.)\nTherefore I think we should allow a null value for the correlationId here.", "author": "calohmn", "createdAt": "2020-02-20T06:45:18Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.config.ClientConfigProperties;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.log.Fields;\n+import io.opentracing.noop.NoopTracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+\n+/**\n+ * A wrapper around an AMQP receiver link for consuming commands from Hono's AMQP adapter. This implementation tries to\n+ * restore closed links by trying to create a new link each time the link is closed.\n+ */\n+public class AmqpAdapterClientCommandConsumer extends CommandConsumer {\n+\n+    /**\n+     * Creates a consumer for a connection and a receiver link.\n+     *\n+     * @param connection The connection to the AMQP Messaging Network over which commands are received.\n+     * @param receiver The receiver link for command messages.\n+     */\n+    private AmqpAdapterClientCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {\n+        super(connection, receiver);\n+    }\n+\n+    /**\n+     * Creates a new command consumer for the given device.\n+     * <p>\n+     * The underlying receiver link will be created with its <em>autoAccept</em> property set to {@code true} and with\n+     * the connection's default pre-fetch size.\n+     *\n+     * @param con The connection to the server.\n+     * @param tenantId The tenant to consume commands from.\n+     * @param deviceId The device for which the commands should be consumed.\n+     * @param messageHandler The handler to invoke with every message received.\n+     * @return A future indicating the outcome of the creation attempt.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public static Future<MessageConsumer> create(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final String deviceId,\n+            final BiConsumer<ProtonDelivery, Message> messageHandler) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(messageHandler);\n+\n+        final ResourceIdentifier address = ResourceIdentifier\n+                .from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, deviceId);\n+        return createCommandConsumer(con, messageHandler, address, new AtomicReference<>(), 1);\n+    }\n+\n+    /**\n+     * Creates a new command consumer.\n+     * <p>\n+     * The underlying receiver link will be created with its <em>autoAccept</em> property set to {@code true} and with\n+     * the connection's default pre-fetch size.\n+     *\n+     * @param con The connection to the server.\n+     * @param messageHandler The handler to invoke with every message received.\n+     * @return A future indicating the outcome of the creation attempt.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public static Future<MessageConsumer> create(\n+            final HonoConnection con,\n+            final BiConsumer<ProtonDelivery, Message> messageHandler) {\n+\n+        Objects.requireNonNull(messageHandler);\n+\n+        final ResourceIdentifier address = ResourceIdentifier\n+                .from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, null, null);\n+        return createCommandConsumer(con, messageHandler, address, new AtomicReference<>(), 1);\n+    }\n+\n+    // TODO additionally use addReconnectListener to reopen the link\n+    private static Future<MessageConsumer> createCommandConsumer(final HonoConnection con,\n+            final BiConsumer<ProtonDelivery, Message> messageHandler, final ResourceIdentifier address,\n+            final AtomicReference<AmqpAdapterClientCommandConsumer> commandConsumerRef,\n+            final long reconnectAttempt) {\n+\n+        final Handler<String> closeHandler = sourceAddress -> {\n+            // TODO exponential back-off like in HonoConnectionImpl#reconnect()\n+            final long delay = Math.min((reconnectAttempt * 2), ClientConfigProperties.DEFAULT_RECONNECT_MAX_DELAY);\n+            con.getVertx().setTimer(delay, reconnect -> {\n+                createCommandConsumer(con, messageHandler, address, commandConsumerRef, reconnectAttempt + 1);\n+            });\n+        };\n+\n+        return con.isConnected(con.getConfig().getLinkEstablishmentTimeout())\n+                .compose(v -> con.createReceiver(\n+                        address.toString(),\n+                        ProtonQoS.AT_LEAST_ONCE,\n+                        (protonDelivery, message) -> {\n+                            traceCommand(con, address, message);\n+                            messageHandler.accept(protonDelivery, message);\n+                        },\n+                        closeHandler))\n+                .map(receiver -> {\n+                    AmqpAdapterClientCommandConsumer commandConsumer = commandConsumerRef.get();\n+                    if (commandConsumer == null) { // initial connect\n+                        final AmqpAdapterClientCommandConsumer newCommandConsumer = new AmqpAdapterClientCommandConsumer(\n+                                con, receiver);\n+                        commandConsumerRef.set(newCommandConsumer);\n+                        commandConsumer = newCommandConsumer;\n+                    } else { // on reconnect\n+                        commandConsumer.setReceiver(receiver);\n+                    }\n+                    return commandConsumer;\n+                });\n+\n+    }\n+\n+    private static void traceCommand(final HonoConnection con, final ResourceIdentifier address,\n+            final Message message) {\n+        final Tracer tracer = con.getTracer();\n+        if (tracer instanceof NoopTracer) {\n+            return;\n+        }\n+\n+        // try to extract Span context from incoming message\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, message);\n+        final Span currentSpan = createSpan(\"receive command\", address.getTenantId(),\n+                address.getResourceId(), null, tracer, spanContext);\n+        final Object correlationId = message.getCorrelationId();\n+        if (correlationId instanceof String) {\n+            final Map<String, String> items = new HashMap<>(5);\n+            items.put(Fields.EVENT, \"received command message\");\n+            TracingHelper.TAG_CORRELATION_ID.set(currentSpan, ((String) correlationId));\n+            items.put(\"to\", message.getAddress());\n+            items.put(\"reply-to\", message.getReplyTo());\n+            items.put(\"name\", message.getSubject());\n+            items.put(\"content-type\", message.getContentType());\n+            currentSpan.log(items);\n+        } else {\n+            TracingHelper.logError(currentSpan,\n+                    \"received invalid command message. correlation-id is not of type string.\");", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyNTk1Nw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381825957", "bodyText": "Let's consider a possible scenario where the closeHandler gets called: AMQP adapter is about to shutdown, it sends a detach and closes the connection. As a consequence of the detach, the closeHandler here is called and it tries to re-establish the link. If the reconnect, that happens behind the scenes and while con.isConnected(timeout) is called below, takes longer than the timeout value, the createCommandConsumer invocation would fail and currently no retry to re-establish the link would occur.\nTherefore I think the return value of createCommandConsumer inside the timer handler should be taken into account.\nIn general, while delving into this topic here, it might make sense to already handle the other possible scenario of the closeHandler not getting called when the connection is closed, as noted by the TODO additionally use addReconnectListener to reopen the link comment above.", "author": "calohmn", "createdAt": "2020-02-20T07:36:03Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.config.ClientConfigProperties;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.log.Fields;\n+import io.opentracing.noop.NoopTracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+\n+/**\n+ * A wrapper around an AMQP receiver link for consuming commands from Hono's AMQP adapter. This implementation tries to\n+ * restore closed links by trying to create a new link each time the link is closed.\n+ */\n+public class AmqpAdapterClientCommandConsumer extends CommandConsumer {\n+\n+    /**\n+     * Creates a consumer for a connection and a receiver link.\n+     *\n+     * @param connection The connection to the AMQP Messaging Network over which commands are received.\n+     * @param receiver The receiver link for command messages.\n+     */\n+    private AmqpAdapterClientCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {\n+        super(connection, receiver);\n+    }\n+\n+    /**\n+     * Creates a new command consumer for the given device.\n+     * <p>\n+     * The underlying receiver link will be created with its <em>autoAccept</em> property set to {@code true} and with\n+     * the connection's default pre-fetch size.\n+     *\n+     * @param con The connection to the server.\n+     * @param tenantId The tenant to consume commands from.\n+     * @param deviceId The device for which the commands should be consumed.\n+     * @param messageHandler The handler to invoke with every message received.\n+     * @return A future indicating the outcome of the creation attempt.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public static Future<MessageConsumer> create(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final String deviceId,\n+            final BiConsumer<ProtonDelivery, Message> messageHandler) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(messageHandler);\n+\n+        final ResourceIdentifier address = ResourceIdentifier\n+                .from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, deviceId);\n+        return createCommandConsumer(con, messageHandler, address, new AtomicReference<>(), 1);\n+    }\n+\n+    /**\n+     * Creates a new command consumer.\n+     * <p>\n+     * The underlying receiver link will be created with its <em>autoAccept</em> property set to {@code true} and with\n+     * the connection's default pre-fetch size.\n+     *\n+     * @param con The connection to the server.\n+     * @param messageHandler The handler to invoke with every message received.\n+     * @return A future indicating the outcome of the creation attempt.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public static Future<MessageConsumer> create(\n+            final HonoConnection con,\n+            final BiConsumer<ProtonDelivery, Message> messageHandler) {\n+\n+        Objects.requireNonNull(messageHandler);\n+\n+        final ResourceIdentifier address = ResourceIdentifier\n+                .from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, null, null);\n+        return createCommandConsumer(con, messageHandler, address, new AtomicReference<>(), 1);\n+    }\n+\n+    // TODO additionally use addReconnectListener to reopen the link\n+    private static Future<MessageConsumer> createCommandConsumer(final HonoConnection con,\n+            final BiConsumer<ProtonDelivery, Message> messageHandler, final ResourceIdentifier address,\n+            final AtomicReference<AmqpAdapterClientCommandConsumer> commandConsumerRef,\n+            final long reconnectAttempt) {\n+\n+        final Handler<String> closeHandler = sourceAddress -> {\n+            // TODO exponential back-off like in HonoConnectionImpl#reconnect()\n+            final long delay = Math.min((reconnectAttempt * 2), ClientConfigProperties.DEFAULT_RECONNECT_MAX_DELAY);\n+            con.getVertx().setTimer(delay, reconnect -> {\n+                createCommandConsumer(con, messageHandler, address, commandConsumerRef, reconnectAttempt + 1);", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyODMwOA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381828308", "bodyText": "It seems a bit strange the AmqpAdapterClientCommandConsumer isn't in the same package as the other new AmqpAdapterClient[*] implementation classes.", "author": "calohmn", "createdAt": "2020-02-20T07:43:03Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp.internal;", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4ODQyMA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381888420", "bodyText": "That's right. As mentioned above, I tried to pack the new classes into better-named packages (also to prepare for splitting the clients later). Unfortunately, I could not move some classes because of the visibility of the code used there. If we give higher priority to putting them together in the same package, then we will probably have to put everything back into the client package.", "author": "b-abel", "createdAt": "2020-02-20T09:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyODMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTI1Ng==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381889256", "bodyText": "Do you think it should be moved to client.impl?", "author": "b-abel", "createdAt": "2020-02-20T09:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyODMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjA3Ng==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390132076", "bodyText": "I think the current structure is OK. Probably packages will later be reorganized anyway when splitting up the hono client module.", "author": "calohmn", "createdAt": "2020-03-10T07:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyODMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTM5Nw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381829397", "bodyText": "I would have expected this interface in the parent package. I don't see much of a benefit in kind of hiding this interface in an internal package.", "author": "calohmn", "createdAt": "2020-02-20T07:46:02Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpSenderLink.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp.internal;", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNjcyOA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381836728", "bodyText": "I guess if the messageHandler does not throw an exception is meant here. However, in that case the command message would also be settled (see \n  \n    \n      hono/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java\n    \n    \n         Line 823\n      in\n      525b3aa\n    \n    \n    \n    \n\n        \n          \n           ProtonHelper.released(delivery, true); \n        \n    \n  \n\n). In general, the message handler is not really supposed to throw an exception, though.\nTherefore I think the if part of the sentenced can be removed here.", "author": "calohmn", "createdAt": "2020-02-20T08:04:49Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.function.Consumer;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ConnectionLifecycle;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.impl.AmqpAdapterClientFactoryImpl;\n+\n+import io.vertx.core.Future;\n+\n+/**\n+ * A Vert.x based factory for creating clients for Hono's AMQP adapter.\n+ */\n+public interface AmqpAdapterClientFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to use.\n+     * @param tenantId The ID of the tenant for which the connection is authenticated.\n+     * @return The factory.\n+     * @throws NullPointerException if any of the parameters is {@code null}\n+     */\n+    static AmqpAdapterClientFactory create(HonoConnection connection, final String tenantId) {\n+        return new AmqpAdapterClientFactoryImpl(connection, tenantId);\n+    }\n+\n+    /**\n+     * Gets a client for sending telemetry data to Hono's AMQP protocol adapter.\n+     * <p>\n+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory\n+     * instance belongs to.\n+     * <p>\n+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the\n+     * factory to ensure that it contains a valid and open AMQP link.\n+     *\n+     * @return A future that will complete with the sender once the link has been established. The future will fail if\n+     *         the link cannot be established, e.g. because this client is not connected.\n+     * \n+     * @see \"https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/\"\n+     */\n+    Future<TelemetrySender> getOrCreateTelemetrySender();\n+\n+    /**\n+     * Gets a client for sending events to Hono's AMQP protocol adapter.\n+     * <p>\n+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory\n+     * instance belongs to.\n+     * <p>\n+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the\n+     * factory to ensure that it contains a valid and open AMQP link.\n+     *\n+     * @return A future that will complete with the sender once the link has been established. The future will fail if\n+     *         the link cannot be established, e.g. because this client is not connected.\n+     *\n+     * @see \"https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/\"\n+     */\n+    Future<EventSender> getOrCreateEventSender();\n+\n+    /**\n+     * Creates a client for consuming commands from Hono's AMQP protocol adapter for a specific device.\n+     * <p>\n+     * When implementing a (protocol) gateway, this can be used to receive commands for a specific device.\n+     * <p>\n+     * The command passed in to the command consumer will be settled automatically if the consumer does not throw an\n+     * exception.", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNjg4OA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381836888", "bodyText": "IMHO, the if part of the sentenced can be removed here (see above).", "author": "calohmn", "createdAt": "2020-02-20T08:05:15Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.function.Consumer;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ConnectionLifecycle;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.impl.AmqpAdapterClientFactoryImpl;\n+\n+import io.vertx.core.Future;\n+\n+/**\n+ * A Vert.x based factory for creating clients for Hono's AMQP adapter.\n+ */\n+public interface AmqpAdapterClientFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to use.\n+     * @param tenantId The ID of the tenant for which the connection is authenticated.\n+     * @return The factory.\n+     * @throws NullPointerException if any of the parameters is {@code null}\n+     */\n+    static AmqpAdapterClientFactory create(HonoConnection connection, final String tenantId) {\n+        return new AmqpAdapterClientFactoryImpl(connection, tenantId);\n+    }\n+\n+    /**\n+     * Gets a client for sending telemetry data to Hono's AMQP protocol adapter.\n+     * <p>\n+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory\n+     * instance belongs to.\n+     * <p>\n+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the\n+     * factory to ensure that it contains a valid and open AMQP link.\n+     *\n+     * @return A future that will complete with the sender once the link has been established. The future will fail if\n+     *         the link cannot be established, e.g. because this client is not connected.\n+     * \n+     * @see \"https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/\"\n+     */\n+    Future<TelemetrySender> getOrCreateTelemetrySender();\n+\n+    /**\n+     * Gets a client for sending events to Hono's AMQP protocol adapter.\n+     * <p>\n+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory\n+     * instance belongs to.\n+     * <p>\n+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the\n+     * factory to ensure that it contains a valid and open AMQP link.\n+     *\n+     * @return A future that will complete with the sender once the link has been established. The future will fail if\n+     *         the link cannot be established, e.g. because this client is not connected.\n+     *\n+     * @see \"https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/\"\n+     */\n+    Future<EventSender> getOrCreateEventSender();\n+\n+    /**\n+     * Creates a client for consuming commands from Hono's AMQP protocol adapter for a specific device.\n+     * <p>\n+     * When implementing a (protocol) gateway, this can be used to receive commands for a specific device.\n+     * <p>\n+     * The command passed in to the command consumer will be settled automatically if the consumer does not throw an\n+     * exception.\n+     *\n+     * @param deviceId The device to consume commands for.\n+     * @param messageHandler The handler to invoke with every command received.\n+     * @return A future that will complete with the consumer once the link has been established. The future will fail if\n+     *         the link cannot be established, e.g. because this factory is not connected.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * \n+     * @see \"https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/\"\n+     */\n+    Future<MessageConsumer> createDeviceSpecificCommandConsumer(String deviceId, Consumer<Message> messageHandler);\n+\n+    /**\n+     * Creates a client for consuming commands from Hono's AMQP protocol adapter for an authenticated device or on a\n+     * (protocol) gateway for all devices on whose behalf it acts.\n+     * <p>\n+     * The command passed in to the command consumer will be settled automatically if the consumer does not throw an\n+     * exception.", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MDY0NA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381840644", "bodyText": "IMHO, CommandResponseSender would make it more obvious at first glance, that there is a sender link behind this class.", "author": "calohmn", "createdAt": "2020-02-20T08:14:26Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/CommandResponder.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.Map;\n+\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.device.amqp.internal.AmqpSenderLink;\n+\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * A sender to send back the response message of a command to Hono's AMQP adapter.\n+ */\n+public interface CommandResponder extends AmqpSenderLink {", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg5MzI2OA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381893268", "bodyText": "Yes, that is more obvious. This already exists in the client package. That's why I hesitated to use the same name because it might be too difficult to distinguish between them just by the package.", "author": "b-abel", "createdAt": "2020-02-20T09:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MDY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMDI0Mw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390130243", "bodyText": "Ok, I see.", "author": "calohmn", "createdAt": "2020-03-10T07:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MTEyMg==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381841122", "bodyText": "I would suggest TraceableCommandResponseSender as name here instead (see above).", "author": "calohmn", "createdAt": "2020-02-20T08:15:43Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.Map;\n+\n+import org.eclipse.hono.client.ServiceInvocationException;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * A sender to send back the response message of a command to Hono's AMQP adapter.\n+ */\n+public interface TraceableCommandResponder extends CommandResponder {", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0NzIwMA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381847200", "bodyText": "I think the exception text and the method javadoc is confusing here - if the class and method is used inside a protocol adapter, there is still this exception.\nI guess the javadoc could state that the overridden method is only meant for use by a protocol adapter to send the command response downstream, and that this use case isn't supported for this class.", "author": "calohmn", "createdAt": "2020-02-20T08:29:30Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientCommandResponseSender.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.CommandResponse;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.CommandResponder;\n+import org.eclipse.hono.client.device.amqp.TraceableCommandResponder;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for sending response messages to commands to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientCommandResponseSender extends CommandResponseSenderImpl\n+        implements CommandResponder, TraceableCommandResponder {\n+\n+    AmqpAdapterClientCommandResponseSender(final HonoConnection connection, final ProtonSender sender,\n+            final String tenantId) {\n+        super(connection, sender, tenantId, null);\n+    }\n+\n+    /**\n+     * Creates a new sender to send responses for commands back to the business application.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the events will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<CommandResponder> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        return con.createSender(null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientCommandResponseSender(con, sender, tenantId));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,\n+            final String correlationId, final int status, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        return sendCommandResponse(deviceId, targetAddress, correlationId, status, payload, contentType,\n+                properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,\n+            final String correlationId, final int status, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties, final SpanContext context) {\n+\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(targetAddress);\n+        Objects.requireNonNull(correlationId);\n+\n+        final Message message = ProtonHelper.message();\n+        message.setAddress(targetAddress);\n+        message.setCorrelationId(correlationId);\n+\n+        MessageHelper.setCreationTime(message);\n+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, status);\n+        MessageHelper.setPayload(message, contentType, payload);\n+\n+        setApplicationProperties(message, properties);\n+\n+        return sendAndWaitForOutcome(message, context);\n+    }\n+\n+    /**\n+     * This method must not be used outside a protocol adapter.\n+     * \n+     * @param commandResponse not used.\n+     * @param context not used.\n+     * @return nothing.\n+     * @throws UnsupportedOperationException always.\n+     */\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final CommandResponse commandResponse,\n+            final SpanContext context) {\n+        throw new UnsupportedOperationException(\"This method must not be used outside a protocol adapter\");", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MjQ3NA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381852474", "bodyText": "IMHO, shadowing the (unsupported) parent static factory method with what is now in createWithAnonymousLinkAddress would be a better idea. The unused replyId parameter could be ignored and another create method could be added without the replyId parameter.", "author": "calohmn", "createdAt": "2020-02-20T08:40:56Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientCommandResponseSender.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.CommandResponse;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.CommandResponder;\n+import org.eclipse.hono.client.device.amqp.TraceableCommandResponder;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for sending response messages to commands to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientCommandResponseSender extends CommandResponseSenderImpl\n+        implements CommandResponder, TraceableCommandResponder {\n+\n+    AmqpAdapterClientCommandResponseSender(final HonoConnection connection, final ProtonSender sender,\n+            final String tenantId) {\n+        super(connection, sender, tenantId, null);\n+    }\n+\n+    /**\n+     * Creates a new sender to send responses for commands back to the business application.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the events will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<CommandResponder> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        return con.createSender(null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientCommandResponseSender(con, sender, tenantId));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,\n+            final String correlationId, final int status, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        return sendCommandResponse(deviceId, targetAddress, correlationId, status, payload, contentType,\n+                properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,\n+            final String correlationId, final int status, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties, final SpanContext context) {\n+\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(targetAddress);\n+        Objects.requireNonNull(correlationId);\n+\n+        final Message message = ProtonHelper.message();\n+        message.setAddress(targetAddress);\n+        message.setCorrelationId(correlationId);\n+\n+        MessageHelper.setCreationTime(message);\n+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, status);\n+        MessageHelper.setPayload(message, contentType, payload);\n+\n+        setApplicationProperties(message, properties);\n+\n+        return sendAndWaitForOutcome(message, context);\n+    }\n+\n+    /**\n+     * This method must not be used outside a protocol adapter.\n+     * \n+     * @param commandResponse not used.\n+     * @param context not used.\n+     * @return nothing.\n+     * @throws UnsupportedOperationException always.\n+     */\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final CommandResponse commandResponse,\n+            final SpanContext context) {\n+        throw new UnsupportedOperationException(\"This method must not be used outside a protocol adapter\");\n+    }\n+\n+    /**\n+     * Shadowing the static factory method that must not be used outside a protocol adapter.\n+     *\n+     * @param con not used.\n+     * @param tenantId not used.\n+     * @param replyId not used.\n+     * @param closeHook not used.\n+     * @return nothing.\n+     * @throws UnsupportedOperationException always.\n+     */\n+    public static Future<CommandResponseSender> create(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final String replyId,\n+            final Handler<String> closeHook) {\n+        throw new UnsupportedOperationException(\"This method must not be used outside a protocol adapter\");", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyODIyNg==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381928226", "bodyText": "That does not work because of incompatible return types.", "author": "b-abel", "createdAt": "2020-02-20T10:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5MzU3NA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381993574", "bodyText": "Ok, I see.", "author": "calohmn", "createdAt": "2020-02-20T13:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MzQ2Mw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381853463", "bodyText": "IMHO, shadowing the (unsupported) parent static factory method with what is now in createWithAnonymousLinkAddress would be a better idea (i.e. renaming createWithAnonymousLinkAddress to just create). WDYT?", "author": "calohmn", "createdAt": "2020-02-20T08:42:59Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientEventSenderImpl.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.EventSender;\n+import org.eclipse.hono.client.device.amqp.TraceableEventSender;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for publishing event messages to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientEventSenderImpl extends EventSenderImpl implements EventSender, TraceableEventSender {\n+\n+    AmqpAdapterClientEventSenderImpl(final HonoConnection con, final ProtonSender sender, final String tenantId,\n+            final String targetAddress) {\n+        super(con, sender, tenantId, targetAddress);\n+    }\n+\n+    /**\n+     * Creates a new sender for publishing events to Hono's AMQP adapter.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the events will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<EventSender> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        final String targetAddress = null; // anonymous relay\n+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientEventSenderImpl(con, sender, tenantId, targetAddress));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties, final SpanContext context) {\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(payload);\n+        Objects.requireNonNull(contentType);\n+\n+        final Message msg = ProtonHelper.message();\n+        msg.setAddress(getTo(deviceId));\n+        MessageHelper.setPayload(msg, contentType, payload);\n+        setApplicationProperties(msg, properties);\n+        MessageHelper.addDeviceId(msg, deviceId);\n+        return send(msg, context);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        return send(deviceId, payload, contentType, properties, null);\n+    }\n+\n+    /**\n+     * Shadowing the static factory method that must not be used outside a protocol adapter.\n+     *\n+     * @param con not used.\n+     * @param tenantId not used.\n+     * @param remoteCloseHook not used.\n+     * @return nothing.\n+     * @throws UnsupportedOperationException always.\n+     */\n+    public static Future<DownstreamSender> create(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+        throw new UnsupportedOperationException(\"This method must not be used outside a protocol adapter\");", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MzU1Mg==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381853552", "bodyText": "IMHO, shadowing the (unsupported) parent static factory method with what is now in createWithAnonymousLinkAddress would be a better idea (i.e. renaming createWithAnonymousLinkAddress to just create). WDYT?", "author": "calohmn", "createdAt": "2020-02-20T08:43:10Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientTelemetrySenderImpl.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.TelemetrySender;\n+import org.eclipse.hono.client.device.amqp.TraceableTelemetrySender;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for publishing telemetry messages to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientTelemetrySenderImpl extends TelemetrySenderImpl\n+        implements TelemetrySender, TraceableTelemetrySender {\n+\n+    AmqpAdapterClientTelemetrySenderImpl(final HonoConnection con, final ProtonSender sender, final String tenantId,\n+            final String targetAddress) {\n+        super(con, sender, tenantId, targetAddress);\n+    }\n+\n+    /**\n+     * Creates a new sender for publishing telemetry data to Hono's AMQP adapter.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the telemetry data will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<TelemetrySender> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        final String targetAddress = null; // anonymous relay\n+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientTelemetrySenderImpl(con, sender, tenantId, targetAddress));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        return send(deviceId, payload, contentType, properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties, final SpanContext context) {\n+        final Message msg = createMessage(deviceId, payload, contentType, properties);\n+        return send(msg, context);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendAndWaitForOutcome(final String deviceId, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties) {\n+        return sendAndWaitForOutcome(deviceId, payload, contentType, properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendAndWaitForOutcome(final String deviceId, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties, final SpanContext context) {\n+        final Message msg = createMessage(deviceId, payload, contentType, properties);\n+        return sendAndWaitForOutcome(msg, context);\n+    }\n+\n+    private Message createMessage(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(payload);\n+        Objects.requireNonNull(contentType);\n+\n+        final Message msg = ProtonHelper.message();\n+        msg.setAddress(getTo(deviceId));\n+        MessageHelper.setPayload(msg, contentType, payload);\n+        setApplicationProperties(msg, properties);\n+        MessageHelper.addDeviceId(msg, deviceId);\n+        return msg;\n+    }\n+\n+    /**\n+     * Shadowing the static factory method that must not be used outside a protocol adapter.\n+     *\n+     * @param con not used.\n+     * @param tenantId not used.\n+     * @param remoteCloseHook not used.\n+     * @return nothing.\n+     * @throws UnsupportedOperationException always.\n+     */\n+    public static Future<DownstreamSender> create(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+        throw new UnsupportedOperationException(\"This method must not be used outside a protocol adapter\");", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3ODc4Mw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381878783", "bodyText": "I think we should also set a message id here.", "author": "calohmn", "createdAt": "2020-02-20T09:29:36Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientCommandResponseSender.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.CommandResponse;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.CommandResponder;\n+import org.eclipse.hono.client.device.amqp.TraceableCommandResponder;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for sending response messages to commands to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientCommandResponseSender extends CommandResponseSenderImpl\n+        implements CommandResponder, TraceableCommandResponder {\n+\n+    AmqpAdapterClientCommandResponseSender(final HonoConnection connection, final ProtonSender sender,\n+            final String tenantId) {\n+        super(connection, sender, tenantId, null);\n+    }\n+\n+    /**\n+     * Creates a new sender to send responses for commands back to the business application.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the events will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<CommandResponder> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        return con.createSender(null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientCommandResponseSender(con, sender, tenantId));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,\n+            final String correlationId, final int status, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        return sendCommandResponse(deviceId, targetAddress, correlationId, status, payload, contentType,\n+                properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,\n+            final String correlationId, final int status, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties, final SpanContext context) {\n+\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(targetAddress);\n+        Objects.requireNonNull(correlationId);\n+\n+        final Message message = ProtonHelper.message();", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0MzcwMA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381943700", "bodyText": "This is done further down in AbstractSender#sendMessageAndWaitForOutcome(Message, Span).", "author": "b-abel", "createdAt": "2020-02-20T11:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3ODc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5MDE4OA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381990188", "bodyText": "Ok, right, I've overlooked that.", "author": "calohmn", "createdAt": "2020-02-20T13:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3ODc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MTg1OQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381881859", "bodyText": "I think we should also set a message id here.", "author": "calohmn", "createdAt": "2020-02-20T09:34:50Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientEventSenderImpl.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.EventSender;\n+import org.eclipse.hono.client.device.amqp.TraceableEventSender;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for publishing event messages to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientEventSenderImpl extends EventSenderImpl implements EventSender, TraceableEventSender {\n+\n+    AmqpAdapterClientEventSenderImpl(final HonoConnection con, final ProtonSender sender, final String tenantId,\n+            final String targetAddress) {\n+        super(con, sender, tenantId, targetAddress);\n+    }\n+\n+    /**\n+     * Creates a new sender for publishing events to Hono's AMQP adapter.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the events will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<EventSender> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        final String targetAddress = null; // anonymous relay\n+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientEventSenderImpl(con, sender, tenantId, targetAddress));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties, final SpanContext context) {\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(payload);\n+        Objects.requireNonNull(contentType);\n+\n+        final Message msg = ProtonHelper.message();", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0NTEzNA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381945134", "bodyText": "This is done further down in AbstractSender#sendMessageAndWaitForOutcome(Message, Span).", "author": "b-abel", "createdAt": "2020-02-20T11:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MTg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjMwNw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381882307", "bodyText": "I think we should also set a message id here.", "author": "calohmn", "createdAt": "2020-02-20T09:35:34Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientTelemetrySenderImpl.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.device.amqp.TelemetrySender;\n+import org.eclipse.hono.client.device.amqp.TraceableTelemetrySender;\n+import org.eclipse.hono.util.MessageHelper;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A Vertx-Proton based client for publishing telemetry messages to Hono's AMQP adapter.\n+ */\n+public class AmqpAdapterClientTelemetrySenderImpl extends TelemetrySenderImpl\n+        implements TelemetrySender, TraceableTelemetrySender {\n+\n+    AmqpAdapterClientTelemetrySenderImpl(final HonoConnection con, final ProtonSender sender, final String tenantId,\n+            final String targetAddress) {\n+        super(con, sender, tenantId, targetAddress);\n+    }\n+\n+    /**\n+     * Creates a new sender for publishing telemetry data to Hono's AMQP adapter.\n+     *\n+     * @param con The connection to the Hono server.\n+     * @param tenantId The tenant that the telemetry data will be published for.\n+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The\n+     *            sender's target address is provided as an argument to the handler.\n+     * @return A future indicating the outcome.\n+     * @throws NullPointerException if con or tenantId is {@code null}.\n+     */\n+    public static Future<TelemetrySender> createWithAnonymousLinkAddress(\n+            final HonoConnection con,\n+            final String tenantId,\n+            final Handler<String> remoteCloseHook) {\n+\n+        Objects.requireNonNull(con);\n+        Objects.requireNonNull(tenantId);\n+\n+        final String targetAddress = null; // anonymous relay\n+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)\n+                .map(sender -> new AmqpAdapterClientTelemetrySenderImpl(con, sender, tenantId, targetAddress));\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        return send(deviceId, payload, contentType, properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties, final SpanContext context) {\n+        final Message msg = createMessage(deviceId, payload, contentType, properties);\n+        return send(msg, context);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendAndWaitForOutcome(final String deviceId, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties) {\n+        return sendAndWaitForOutcome(deviceId, payload, contentType, properties, null);\n+    }\n+\n+    @Override\n+    public Future<ProtonDelivery> sendAndWaitForOutcome(final String deviceId, final byte[] payload,\n+            final String contentType, final Map<String, ?> properties, final SpanContext context) {\n+        final Message msg = createMessage(deviceId, payload, contentType, properties);\n+        return sendAndWaitForOutcome(msg, context);\n+    }\n+\n+    private Message createMessage(final String deviceId, final byte[] payload, final String contentType,\n+            final Map<String, ?> properties) {\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(payload);\n+        Objects.requireNonNull(contentType);\n+\n+        final Message msg = ProtonHelper.message();", "originalCommit": "4de17bb13523467c969c55542fd1c0e3494498fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0NTA3OA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r381945078", "bodyText": "This is done further down in AbstractSender#sendMessageAndWaitForOutcome(Message, Span). And for QoS 0 in TelemetrySenderImpl#sendMessage(Message, Span).", "author": "b-abel", "createdAt": "2020-02-20T11:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjMwNw=="}], "type": "inlineReview"}, {"oid": "62d06b125639eca73f0c2b644c327f080ef37453", "url": "https://github.com/eclipse/hono/commit/62d06b125639eca73f0c2b644c327f080ef37453", "message": "[#1761] Add AMQP adapter client.\n\nDevice (or gateway) clients that connect to the AMQP adapter can be created\nusing AmqpAdapterClientFactory. The implementation reopens closed connections\nand restores the receiver link for consuming commands afterward. Sender links\nare cached and removed from the cache when closed so that they are recreated\nthe next time they are retrieved from the factory.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-10T09:10:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MTA0NA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390371044", "bodyText": "why do we need a separate interface for this?", "author": "sophokles73", "createdAt": "2020-03-10T14:49:43Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.Map;\n+\n+import org.eclipse.hono.client.ServiceInvocationException;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * A sender to send back the response message of a command to Hono's AMQP adapter.\n+ */\n+public interface TraceableCommandResponder extends CommandResponder {", "originalCommit": "62d06b125639eca73f0c2b644c327f080ef37453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg0OTIyOA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390849228", "bodyText": "I'm not quite sure what the question is aiming at. Hence the long answer.\nWhy interfaces?\nThe client provides an API that Hono users interact with directly and must therefore remain stable. In our efforts to make changes after the 1.0 release without breaking the API, I have found that this was very difficult, where we had no interfaces and worked directly with the implementations (not really surprising). So I made sure that the user only works with interfaces as much as possible.\nWhy is tracing not included in the interfaces?\nFirst of all, I designed the interfaces for the AMQP adapter client without tracing, because it should be as simple and generally understandable as possible. In the typical use cases, no distributed tracing is needed because it only makes sense if the client and the Hono installation are operated by the same party. In general, I think that overloaded methods in APIs of libraries should be an exception.  However, Carsten asked me to provide tracing support anyway, because it can be helpful in some cases (e.g. for end-to-end testing of a Hono installation). I have hidden these a bit and would document them accordingly (I still have to do that. In Readme or developer guide).", "author": "b-abel", "createdAt": "2020-03-11T09:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzNjA3NQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390936075", "bodyText": "I see", "author": "sophokles73", "createdAt": "2020-03-11T12:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3OTQ3Mw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390379473", "bodyText": "I am not sure if I understand the purpose of this parameter. My understanding is that the factory will be scoped to the tenant that the auth-id resolves to during authentication of the underlying AMQP connection, or am I mistaken?", "author": "sophokles73", "createdAt": "2020-03-10T15:00:07Z", "path": "client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import java.util.function.Consumer;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ConnectionLifecycle;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.impl.AmqpAdapterClientFactoryImpl;\n+\n+import io.vertx.core.Future;\n+\n+/**\n+ * A Vert.x based factory for creating clients for Hono's AMQP adapter.\n+ */\n+public interface AmqpAdapterClientFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to use.\n+     * @param tenantId The ID of the tenant for which the connection is authenticated.", "originalCommit": "62d06b125639eca73f0c2b644c327f080ef37453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg0OTI4NA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390849284", "bodyText": "Unfortunately, the parameter is expected by the parent classes (the constructor in AbstractSender requires the tenantId to be not null). Of course, this is ugly, because the tenant must match the one used for authentication.\nDo you have any ideas on how to get rid of it? Set a dummy or empty string? (would probably only have negative effects for tracing). Read the Auth-Id from the connection and parse it? (wouldn't work for certificate-based authentication). Change the base classes? ...", "author": "b-abel", "createdAt": "2020-03-11T09:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3OTQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzNTM4Ng==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r390935386", "bodyText": "I see", "author": "sophokles73", "createdAt": "2020-03-11T12:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3OTQ3Mw=="}], "type": "inlineReview"}, {"oid": "7ae1740fe7296ab75c61ba343193122ce99223c5", "url": "https://github.com/eclipse/hono/commit/7ae1740fe7296ab75c61ba343193122ce99223c5", "message": "[#1761] Add tests and documentation for the AMQP Adapter Client.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-18T17:52:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgyNjMxOA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r394826318", "bodyText": "FMPOV this test should at least also verify that the TelemetrySender waits for the disposition update from the peer ...", "author": "sophokles73", "createdAt": "2020-03-19T07:09:27Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Map;\n+\n+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientTelemetrySenderImpl;\n+import org.junit.jupiter.api.Test;\n+\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Verifies behavior of {@link TelemetrySender}.\n+ *\n+ */\n+public class TelemetrySenderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n+\n+    /**\n+     * Verifies that the message produced by {@link TelemetrySender#send(String, byte[], String, Map)} conforms to the\n+     * expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testSendProducesValidMessage() {\n+\n+        // GIVEN a TelemetrySender instance\n+        final TelemetrySender telemetrySender = AmqpAdapterClientTelemetrySenderImpl\n+                .createWithAnonymousLinkAddress(connection, tenantId, s -> {\n+                }).result();\n+\n+        // WHEN sending a message using the API\n+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.send(deviceId, payload, contentType,\n+                applicationProperties);\n+\n+        // THEN the AMQP message produces by the client conforms to the expectations of the AMQP protocol adapter\n+        assertThat(deliveryFuture.succeeded());\n+\n+        assertMessageConformsAmqpAdapterSpec(\"telemetry\" + \"/\" + tenantId + \"/\" + deviceId);\n+\n+    }\n+\n+    /**\n+     * Verifies that the message produced by {@link TelemetrySender#sendAndWaitForOutcome(String, byte[], String, Map)}\n+     * conforms to the expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testSendAndWaitForOutcomeProducesValidMessage() {\n+\n+        // GIVEN a TelemetrySender instance\n+        final TelemetrySender telemetrySender = AmqpAdapterClientTelemetrySenderImpl\n+                .createWithAnonymousLinkAddress(connection, tenantId, s -> {\n+                }).result();\n+\n+        // WHEN sending a message using the API\n+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(deviceId, payload,", "originalCommit": "7ae1740fe7296ab75c61ba343193122ce99223c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgyNjQ5MQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r394826491", "bodyText": "FMPOV this test should at also verify that the EventSender waits for the disposition update from the peer ...", "author": "sophokles73", "createdAt": "2020-03-19T07:09:58Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientEventSenderImpl;\n+import org.junit.jupiter.api.Test;\n+\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Verifies behavior of {@link EventSender}.\n+ *\n+ */\n+public class EventSenderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n+\n+    /**\n+     * Verifies that the message produced conforms to the expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testMessageIsValid() {\n+\n+        // GIVEN a EventSender instance\n+        final EventSender eventSender = AmqpAdapterClientEventSenderImpl\n+                .createWithAnonymousLinkAddress(connection, tenantId, s -> {\n+                }).result();\n+\n+        // WHEN sending a message using the API\n+        final Future<ProtonDelivery> deliveryFuture = eventSender.send(deviceId, payload, contentType,", "originalCommit": "7ae1740fe7296ab75c61ba343193122ce99223c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgyNjgzNQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r394826835", "bodyText": "FMPOV this test should also verify that the CommandResponder waits for the disposition update from the peer ...", "author": "sophokles73", "createdAt": "2020-03-19T07:11:05Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponderTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandResponseSender;\n+import org.junit.jupiter.api.Test;\n+\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Verifies behavior of {@link TraceableCommandResponder}.\n+ *\n+ */\n+public class TraceableCommandResponderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n+\n+    /**\n+     * Verifies that the message produced conforms to the expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testMessageIsValid() {\n+\n+        // GIVEN a CommandResponder instance\n+        final TraceableCommandResponder commandResponder = ((TraceableCommandResponder) AmqpAdapterClientCommandResponseSender\n+                .createWithAnonymousLinkAddress(connection, tenantId, s -> {\n+                }).result());\n+\n+        // WHEN sending a message using the API\n+        final String targetAddress = \"command_response/test-tenant/test-device/123\";\n+        final String correlationId = \"0\";\n+        final int status = 200;\n+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(deviceId, targetAddress,", "originalCommit": "7ae1740fe7296ab75c61ba343193122ce99223c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgyNzI0NA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r394827244", "bodyText": "If this is the test for the traceable version then I would expect to find some assertion(s) regarding the tracing actually happening ...", "author": "sophokles73", "createdAt": "2020-03-19T07:12:15Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponderTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandResponseSender;\n+import org.junit.jupiter.api.Test;\n+\n+import io.vertx.core.Future;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Verifies behavior of {@link TraceableCommandResponder}.\n+ *\n+ */\n+public class TraceableCommandResponderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n+\n+    /**\n+     * Verifies that the message produced conforms to the expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testMessageIsValid() {\n+\n+        // GIVEN a CommandResponder instance\n+        final TraceableCommandResponder commandResponder = ((TraceableCommandResponder) AmqpAdapterClientCommandResponseSender\n+                .createWithAnonymousLinkAddress(connection, tenantId, s -> {\n+                }).result());\n+\n+        // WHEN sending a message using the API\n+        final String targetAddress = \"command_response/test-tenant/test-device/123\";\n+        final String correlationId = \"0\";\n+        final int status = 200;\n+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(deviceId, targetAddress,\n+                correlationId, status, payload, contentType,\n+                applicationProperties, null);", "originalCommit": "7ae1740fe7296ab75c61ba343193122ce99223c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxOTcyOA==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r396419728", "bodyText": "MessageHelper.getDeviceId(Message)", "author": "sophokles73", "createdAt": "2020-03-23T12:39:26Z", "path": "client/src/test/java/org/eclipse/hono/client/AbstractAmqpAdapterClientDownstreamSenderTestBase.java", "diffHunk": "@@ -38,50 +46,82 @@\n  */\n public abstract class AbstractAmqpAdapterClientDownstreamSenderTestBase {\n \n-    protected final String tenantId = \"test-tenant\";\n-    protected final String deviceId = \"test-device\";\n-    protected final String contentType = \"text/plain\";\n-    protected final byte[] payload = \"test-value\".getBytes();\n-    protected final String testPropertyKey = \"test-key\";\n-    protected final String testPropertyValue = \"test-value\";\n-    protected final Map<String, ?> applicationProperties = Collections.singletonMap(testPropertyKey, testPropertyValue);\n+    protected static final String TENANT_ID = \"test-tenant\";\n+    protected static final String DEVICE_ID = \"test-device\";\n+    protected static final String CONTENT_TYPE = \"text/plain\";\n+    protected static final byte[] PAYLOAD = \"test-value\".getBytes();\n+    protected static final String TEST_PROPERTY_KEY = \"test-key\";\n+    protected static final String TEST_PROPERTY_VALUE = \"test-value\";\n+    protected static final Map<String, String> APPLICATION_PROPERTIES = Collections.singletonMap(TEST_PROPERTY_KEY,\n+            TEST_PROPERTY_VALUE);\n \n     protected ProtonSender sender;\n     protected HonoConnection connection;\n-    protected ArgumentCaptor<Message> messageArgumentCaptor;\n+    protected ProtonDelivery protonDelivery;\n+    protected Tracer.SpanBuilder spanBuilder;\n \n     /**\n      * Sets up fixture.\n      */\n     @BeforeEach\n     public void setUp() {\n         sender = HonoClientUnitTestHelper.mockProtonSender();\n-        final Vertx vertx = mock(Vertx.class);\n-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);\n+\n+        protonDelivery = mock(ProtonDelivery.class);\n+        when(protonDelivery.remotelySettled()).thenReturn(true);\n+        final Accepted deliveryState = new Accepted();\n+        when(protonDelivery.getRemoteState()).thenReturn(deliveryState);\n+\n+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(protonDelivery);\n+\n+        final Span span = mock(Span.class);\n+        when(span.context()).thenReturn(mock(SpanContext.class));\n+        spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);\n+\n+        final Tracer tracer = mock(Tracer.class);\n+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);\n+\n+        connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class));\n+\n+        when(connection.getTracer()).thenReturn(tracer);\n         when(connection.createSender(any(), any(), any())).thenReturn(Future.succeededFuture(sender));\n-        messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n+\n+    }\n+\n+    /**\n+     * Updates the disposition for the {@link ProtonSender#send(Message, Handler)} operation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void updateDisposition() {\n+        final ArgumentCaptor<Handler<ProtonDelivery>> dispositionHandlerCaptor = ArgumentCaptor.forClass(Handler.class);\n+        verify(sender).send(any(Message.class), dispositionHandlerCaptor.capture());\n+        dispositionHandlerCaptor.getValue().handle(protonDelivery);\n     }\n \n     /**\n-     * Executes the assertions that checkthat the message produced conforms to the expectations of the AMQP adapter.\n-     * \n+     * Executes the assertions that check that the message created by the client conforms to the expectations of the\n+     * AMQP adapter.\n+     *\n      * @param expectedAddress The expected target address.\n+     * @return The captured message.\n      */\n-    protected void assertMessageConformsAmqpAdapterSpec(final String expectedAddress) {\n+    protected Message assertMessageConformsAmqpAdapterSpec(final String expectedAddress) {\n \n+        final ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n         verify(sender).send(messageArgumentCaptor.capture(), any());\n \n         final Message message = messageArgumentCaptor.getValue();\n \n         assertThat(message.getAddress()).isEqualTo(expectedAddress);\n \n-        assertThat(MessageHelper.getPayloadAsString(message)).isEqualTo(new String(payload));\n-        assertThat(message.getContentType()).isEqualTo(contentType);\n+        assertThat(MessageHelper.getPayloadAsString(message)).isEqualTo(new String(PAYLOAD));\n+        assertThat(message.getContentType()).isEqualTo(CONTENT_TYPE);\n+\n+        assertThat(message.getApplicationProperties().getValue().get(TEST_PROPERTY_KEY)).isEqualTo(TEST_PROPERTY_VALUE);\n \n-        final Map<String, Object> applicationProperties = message.getApplicationProperties().getValue();\n-        assertThat(applicationProperties.get(testPropertyKey)).isEqualTo(testPropertyValue);\n+        assertThat(message.getApplicationProperties().getValue().get(\"device_id\")).isEqualTo(DEVICE_ID);", "originalCommit": "636840e47fb1b68a3e29dcbc38375c5e611bb66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyMDA4NQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r396420085", "bodyText": "MessageHelper.getApplicationProperty()?", "author": "sophokles73", "createdAt": "2020-03-23T12:40:03Z", "path": "client/src/test/java/org/eclipse/hono/client/AbstractAmqpAdapterClientDownstreamSenderTestBase.java", "diffHunk": "@@ -38,50 +46,82 @@\n  */\n public abstract class AbstractAmqpAdapterClientDownstreamSenderTestBase {\n \n-    protected final String tenantId = \"test-tenant\";\n-    protected final String deviceId = \"test-device\";\n-    protected final String contentType = \"text/plain\";\n-    protected final byte[] payload = \"test-value\".getBytes();\n-    protected final String testPropertyKey = \"test-key\";\n-    protected final String testPropertyValue = \"test-value\";\n-    protected final Map<String, ?> applicationProperties = Collections.singletonMap(testPropertyKey, testPropertyValue);\n+    protected static final String TENANT_ID = \"test-tenant\";\n+    protected static final String DEVICE_ID = \"test-device\";\n+    protected static final String CONTENT_TYPE = \"text/plain\";\n+    protected static final byte[] PAYLOAD = \"test-value\".getBytes();\n+    protected static final String TEST_PROPERTY_KEY = \"test-key\";\n+    protected static final String TEST_PROPERTY_VALUE = \"test-value\";\n+    protected static final Map<String, String> APPLICATION_PROPERTIES = Collections.singletonMap(TEST_PROPERTY_KEY,\n+            TEST_PROPERTY_VALUE);\n \n     protected ProtonSender sender;\n     protected HonoConnection connection;\n-    protected ArgumentCaptor<Message> messageArgumentCaptor;\n+    protected ProtonDelivery protonDelivery;\n+    protected Tracer.SpanBuilder spanBuilder;\n \n     /**\n      * Sets up fixture.\n      */\n     @BeforeEach\n     public void setUp() {\n         sender = HonoClientUnitTestHelper.mockProtonSender();\n-        final Vertx vertx = mock(Vertx.class);\n-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);\n+\n+        protonDelivery = mock(ProtonDelivery.class);\n+        when(protonDelivery.remotelySettled()).thenReturn(true);\n+        final Accepted deliveryState = new Accepted();\n+        when(protonDelivery.getRemoteState()).thenReturn(deliveryState);\n+\n+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(protonDelivery);\n+\n+        final Span span = mock(Span.class);\n+        when(span.context()).thenReturn(mock(SpanContext.class));\n+        spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);\n+\n+        final Tracer tracer = mock(Tracer.class);\n+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);\n+\n+        connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class));\n+\n+        when(connection.getTracer()).thenReturn(tracer);\n         when(connection.createSender(any(), any(), any())).thenReturn(Future.succeededFuture(sender));\n-        messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n+\n+    }\n+\n+    /**\n+     * Updates the disposition for the {@link ProtonSender#send(Message, Handler)} operation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void updateDisposition() {\n+        final ArgumentCaptor<Handler<ProtonDelivery>> dispositionHandlerCaptor = ArgumentCaptor.forClass(Handler.class);\n+        verify(sender).send(any(Message.class), dispositionHandlerCaptor.capture());\n+        dispositionHandlerCaptor.getValue().handle(protonDelivery);\n     }\n \n     /**\n-     * Executes the assertions that checkthat the message produced conforms to the expectations of the AMQP adapter.\n-     * \n+     * Executes the assertions that check that the message created by the client conforms to the expectations of the\n+     * AMQP adapter.\n+     *\n      * @param expectedAddress The expected target address.\n+     * @return The captured message.\n      */\n-    protected void assertMessageConformsAmqpAdapterSpec(final String expectedAddress) {\n+    protected Message assertMessageConformsAmqpAdapterSpec(final String expectedAddress) {\n \n+        final ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n         verify(sender).send(messageArgumentCaptor.capture(), any());\n \n         final Message message = messageArgumentCaptor.getValue();\n \n         assertThat(message.getAddress()).isEqualTo(expectedAddress);\n \n-        assertThat(MessageHelper.getPayloadAsString(message)).isEqualTo(new String(payload));\n-        assertThat(message.getContentType()).isEqualTo(contentType);\n+        assertThat(MessageHelper.getPayloadAsString(message)).isEqualTo(new String(PAYLOAD));\n+        assertThat(message.getContentType()).isEqualTo(CONTENT_TYPE);\n+\n+        assertThat(message.getApplicationProperties().getValue().get(TEST_PROPERTY_KEY)).isEqualTo(TEST_PROPERTY_VALUE);", "originalCommit": "636840e47fb1b68a3e29dcbc38375c5e611bb66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyMDYwNg==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r396420606", "bodyText": "CommandConstants.COMMAND_RESPONSE_ENDPOINT", "author": "sophokles73", "createdAt": "2020-03-23T12:40:57Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java", "diffHunk": "@@ -14,43 +14,120 @@\n package org.eclipse.hono.client.device.amqp;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n \n+import org.apache.qpid.proton.message.Message;\n import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandResponseSender;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n \n+import io.opentracing.SpanContext;\n import io.vertx.core.Future;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n import io.vertx.proton.ProtonDelivery;\n \n /**\n  * Verifies behavior of {@link CommandResponder}.\n  *\n  */\n+@ExtendWith(VertxExtension.class)\n public class CommandResponderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n \n+    private static final String ADDRESS = \"command_response/\" + TENANT_ID + \"/\" + DEVICE_ID + \"/123\";", "originalCommit": "636840e47fb1b68a3e29dcbc38375c5e611bb66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyMTQ0OQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r396421449", "bodyText": "???", "author": "sophokles73", "createdAt": "2020-03-23T12:42:30Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java", "diffHunk": "@@ -14,43 +14,120 @@\n package org.eclipse.hono.client.device.amqp;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n \n+import org.apache.qpid.proton.message.Message;\n import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandResponseSender;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n \n+import io.opentracing.SpanContext;\n import io.vertx.core.Future;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n import io.vertx.proton.ProtonDelivery;\n \n /**\n  * Verifies behavior of {@link CommandResponder}.\n  *\n  */\n+@ExtendWith(VertxExtension.class)\n public class CommandResponderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n \n+    private static final String ADDRESS = \"command_response/\" + TENANT_ID + \"/\" + DEVICE_ID + \"/123\";\n+    private static final String CORRELATION_ID = \"0\";\n+    private static final int STATUS = 200;\n+\n     /**\n-     * Verifies that the message produced conforms to the expectations of the AMQP adapter.\n+     * Verifies that the message created by the client conforms to the expectations of the AMQP adapter.\n+     *\n+     * @param ctx The test context to use for running asynchronous tests.\n      */\n     @Test\n-    public void testMessageIsValid() {\n+    public void testSendCommandResponseCreatesValidMessage(final VertxTestContext ctx) {\n \n         // GIVEN a CommandResponder instance\n-        final CommandResponder commandResponder = AmqpAdapterClientCommandResponseSender\n-                .createWithAnonymousLinkAddress(connection, tenantId, s -> {\n-                }).result();\n+        final CommandResponder commandResponder = createCommandResponder();\n+\n+        // WHEN sending a message using the API...\n+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID,\n+                ADDRESS, CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);\n+\n+        // ...AND WHEN the disposition is updated by the peer\n+        updateDisposition();\n+\n+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {\n+            // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter\n+            ctx.verify(this::assertMessageConformsAmqpAdapterSpec);\n+            ctx.completeNow();\n+        }));\n+    }\n+\n+    /**\n+     * Verifies that {@link TraceableCommandResponder} uses the given SpanContext.\n+     *\n+     * @param ctx The test context to use for running asynchronous tests.\n+     */\n+    @Test\n+    public void testSendCommandResponseWithTracing(final VertxTestContext ctx) {\n+\n+        // GIVEN a TraceableCommandResponder instance\n+        final TraceableCommandResponder commandResponder = ((TraceableCommandResponder) createCommandResponder());\n+\n+        // WHEN sending a message using the API...\n+        final SpanContext spanContext = mock(SpanContext.class);\n+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID,\n+                ADDRESS, CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES, spanContext);\n+\n+        // ...AND WHEN the disposition is updated by the peer\n+        updateDisposition();\n+\n+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {\n+            // THEN the given SpanContext is used\n+            ctx.verify(() -> {\n+                verify(spanBuilder).addReference(any(), eq(spanContext));\n+                assertMessageConformsAmqpAdapterSpec();\n+            });\n+            ctx.completeNow();\n+        }));\n+    }\n+\n+    /**\n+     * Verifies that sending the command response waits for the disposition update from the peer.\n+     *\n+     * @param ctx The test context to use for running asynchronous tests.\n+     * @throws InterruptedException if test is interrupted while waiting.\n+     */\n+    @Test\n+    public void testSendingWaitsForDispositionUpdate(final VertxTestContext ctx) throws InterruptedException {\n+\n+        // GIVEN a CommandResponder instance\n+        final CommandResponder commandResponder = createCommandResponder();\n \n         // WHEN sending a message using the API\n-        final String targetAddress = \"command_response/test-tenant/test-device/123\";\n-        final String correlationId = \"0\";\n-        final int status = 200;\n-        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(deviceId, targetAddress,\n-                correlationId, status, payload, contentType,\n-                applicationProperties);\n+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID, ADDRESS,\n+                CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);\n \n-        // THEN the AMQP message produces by the client conforms to the expectations of the AMQP protocol adapter\n-        assertThat(deliveryFuture.succeeded());\n+        deliveryFuture.setHandler(ctx.completing());\n \n-        assertMessageConformsAmqpAdapterSpec(targetAddress);\n+        // THEN the future waits for the disposition to be updated by the peer\n+        Thread.sleep(100L);", "originalCommit": "636840e47fb1b68a3e29dcbc38375c5e611bb66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae075f3e0c078ccc9099ffdb93c9dfb47032b8f7", "url": "https://github.com/eclipse/hono/commit/ae075f3e0c078ccc9099ffdb93c9dfb47032b8f7", "message": "[#1761] Add AMQP adapter client.\n\nDevice (or gateway) clients that connect to the AMQP adapter can be created\nusing AmqpAdapterClientFactory. The implementation reopens closed connections\nand restores the receiver link for consuming commands afterward. Sender links\nare cached and removed from the cache when closed so that they are recreated\nthe next time they are retrieved from the factory.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:53:37Z", "type": "commit"}, {"oid": "5532d912c8a5e8d076395dba4f79f6a401f129aa", "url": "https://github.com/eclipse/hono/commit/5532d912c8a5e8d076395dba4f79f6a401f129aa", "message": "[#1761] Fix: Content type is no longer required to send downstream messages.\n\nHaving the content type required to send telemetry, event or command responses\nwas a copy&paste error. The content type might not always be available.\n+ Fix Javadoc around that.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:53:37Z", "type": "commit"}, {"oid": "b22a2ff001413d14ec8d4d13b728d21e02c4487a", "url": "https://github.com/eclipse/hono/commit/b22a2ff001413d14ec8d4d13b728d21e02c4487a", "message": "[#1761] Fix: custom application properties no longer overwrite required ones.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:53:37Z", "type": "commit"}, {"oid": "e9d256828cb1a887d40e0f0c81c1c380bb0c82db", "url": "https://github.com/eclipse/hono/commit/e9d256828cb1a887d40e0f0c81c1c380bb0c82db", "message": "[#1761] Add tests and documentation for the AMQP Adapter Client.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:55:09Z", "type": "commit"}, {"oid": "baaac204c0348f8af632029acd6109f31653011f", "url": "https://github.com/eclipse/hono/commit/baaac204c0348f8af632029acd6109f31653011f", "message": "[#1761] Add tests, documentation and example for the AMQP Adapter Client.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:55:09Z", "type": "commit"}, {"oid": "a89fe005bdc918e4f5fcb3a76f00126e7c6dc4e9", "url": "https://github.com/eclipse/hono/commit/a89fe005bdc918e4f5fcb3a76f00126e7c6dc4e9", "message": "[#1761] Requested changes: use constants and helper methods.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:55:09Z", "type": "commit"}, {"oid": "a89fe005bdc918e4f5fcb3a76f00126e7c6dc4e9", "url": "https://github.com/eclipse/hono/commit/a89fe005bdc918e4f5fcb3a76f00126e7c6dc4e9", "message": "[#1761] Requested changes: use constants and helper methods.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T14:55:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4ODc5Nw==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r396588797", "bodyText": "can you please make sure to remove all occurrences of this?", "author": "sophokles73", "createdAt": "2020-03-23T16:34:33Z", "path": "client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.device.amqp;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+\n+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;\n+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientTelemetrySenderImpl;\n+import org.eclipse.hono.util.TelemetryConstants;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Verifies behavior of {@link TelemetrySender}.\n+ *\n+ */\n+@ExtendWith(VertxExtension.class)\n+public class TelemetrySenderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {\n+\n+    private static final String ADDRESS = TelemetryConstants.TELEMETRY_ENDPOINT + \"/\" + TENANT_ID + \"/\" + DEVICE_ID;\n+\n+    /**\n+     * Verifies that the message created by {@link TelemetrySender#send(String, byte[], String, Map)} conforms to the\n+     * expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testSendCreatesValidMessage() {\n+\n+        // GIVEN a TelemetrySender instance\n+        final TelemetrySender telemetrySender = createTelemetrySender();\n+\n+        // WHEN sending a message using the API\n+        telemetrySender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);\n+\n+        // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter\n+        assertMessageConformsAmqpAdapterSpec(ADDRESS);\n+\n+    }\n+\n+    /**\n+     * Verifies that the message created by {@link TelemetrySender#sendAndWaitForOutcome(String, byte[], String, Map)}\n+     * conforms to the expectations of the AMQP adapter.\n+     *\n+     * @param ctx The test context to use for running asynchronous tests.\n+     */\n+    @Test\n+    public void testSendAndWaitForOutcomeCreatesValidMessage(final VertxTestContext ctx) {\n+\n+        // GIVEN a TelemetrySender instance\n+        final TelemetrySender telemetrySender = createTelemetrySender();\n+\n+        // WHEN sending a message using the API...\n+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,\n+                CONTENT_TYPE, APPLICATION_PROPERTIES);\n+\n+        // ...AND WHEN the disposition is updated by the peer\n+        updateDisposition();\n+\n+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {\n+            // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter\n+            ctx.verify(() -> assertMessageConformsAmqpAdapterSpec(ADDRESS));\n+            ctx.completeNow();\n+        }));\n+    }\n+\n+    /**\n+     * Verifies that the message created by {@link TelemetrySender#send(String, byte[], String, Map)} conforms to the\n+     * expectations of the AMQP adapter.\n+     */\n+    @Test\n+    public void testSendWithTracing() {\n+\n+        // GIVEN a TraceableTelemetrySender instance\n+        final TraceableTelemetrySender telemetrySender = ((TraceableTelemetrySender) createTelemetrySender());\n+\n+        // WHEN sending a message using the API\n+        final SpanContext spanContext = mock(SpanContext.class);\n+        telemetrySender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES, spanContext);\n+\n+        // THEN the given SpanContext is used\n+        verify(spanBuilder).addReference(any(), eq(spanContext));\n+        assertMessageConformsAmqpAdapterSpec(ADDRESS);\n+    }\n+\n+    /**\n+     * Verifies that {@link TraceableTelemetrySender#sendAndWaitForOutcome(String, byte[], String, Map, SpanContext)}\n+     * uses the given SpanContext.\n+     *\n+     * @param ctx The test context to use for running asynchronous tests.\n+     */\n+    @Test\n+    public void testSendAndWaitForOutcomeWithTracing(final VertxTestContext ctx) {\n+\n+        // GIVEN a TraceableTelemetrySender instance\n+        final TraceableTelemetrySender telemetrySender = ((TraceableTelemetrySender) createTelemetrySender());\n+\n+        // WHEN sending a message using the API...\n+        final SpanContext spanContext = mock(SpanContext.class);\n+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,\n+                CONTENT_TYPE, APPLICATION_PROPERTIES, spanContext);\n+\n+        // ...AND WHEN the disposition is updated by the peer\n+        updateDisposition();\n+\n+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {\n+            // THEN the given SpanContext is used\n+            ctx.verify(() -> {\n+                verify(spanBuilder).addReference(any(), eq(spanContext));\n+                assertMessageConformsAmqpAdapterSpec(ADDRESS);\n+            });\n+            ctx.completeNow();\n+        }));\n+    }\n+\n+    /**\n+     * Verifies that sending the message waits for the disposition update from the peer.\n+     *\n+     * @param ctx The test context to use for running asynchronous tests.\n+     * @throws InterruptedException if test is interrupted while waiting.\n+     */\n+    @Test\n+    public void testSendAndWaitForOutcomeWaitsForDispositionUpdate(final VertxTestContext ctx)\n+            throws InterruptedException {\n+\n+        // GIVEN a TelemetrySender instance\n+        final TelemetrySender telemetrySender = createTelemetrySender();\n+\n+        // WHEN sending a message using the API\n+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,\n+                CONTENT_TYPE, APPLICATION_PROPERTIES);\n+\n+        deliveryFuture.setHandler(ctx.completing());\n+\n+        // THEN the future waits for the disposition to be updated by the peer\n+        Thread.sleep(100L);", "originalCommit": "a89fe005bdc918e4f5fcb3a76f00126e7c6dc4e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MDE0MQ==", "url": "https://github.com/eclipse/hono/pull/1765#discussion_r396670141", "bodyText": "Sorry, I missed them.", "author": "b-abel", "createdAt": "2020-03-23T18:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4ODc5Nw=="}], "type": "inlineReview"}, {"oid": "5dcecd46ee79b5f8619469e064db33c99368947d", "url": "https://github.com/eclipse/hono/commit/5dcecd46ee79b5f8619469e064db33c99368947d", "message": "[#1761] Requested changes: remove superfluous Thread.sleep() from tests.\n\nSigned-off-by: Abel Buechner-Mihaljevic <abel.buechner-mihaljevic@bosch.io>", "committedDate": "2020-03-23T18:30:30Z", "type": "commit"}]}