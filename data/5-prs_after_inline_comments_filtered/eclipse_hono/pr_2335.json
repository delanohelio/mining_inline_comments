{"pr_number": 2335, "pr_title": "[#2333] Add integration tests", "pr_createdAt": "2020-11-30T20:22:31Z", "pr_url": "https://github.com/eclipse/hono/pull/2335", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzA2NA==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127064", "bodyText": "how about using a checkpoint here instead and simply relying on the test timeout instead of setting another vert.x timer to wait for the message to arrive?", "author": "sophokles73", "createdAt": "2020-12-01T07:40:05Z", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())", "originalCommit": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzMyMg==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127322", "bodyText": "why do you need to set a timer here?", "author": "sophokles73", "createdAt": "2020-12-01T07:40:35Z", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "originalCommit": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxMzk5Nw==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533413997", "bodyText": "I have removed the timer approach and rewritten the tests.", "author": "kaniyan", "createdAt": "2020-12-01T13:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzkwMg==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127902", "bodyText": "instead of verifying the number of messages here I'd rather assert a particular property of the message that has been sent in the consumer itself, before flagging the checkpoint ...", "author": "sophokles73", "createdAt": "2020-12-01T07:41:51Z", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {\n+                        //THEN verify if the message is received by the consumer\n+                        assertThat(receivedMessageCount.get()).isEqualTo(1);", "originalCommit": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxNDgzOQ==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533414839", "bodyText": "I have made use of a random UUID as a payload message. The event consumer verifies the payload content with that of the random UUID value.", "author": "kaniyan", "createdAt": "2020-12-01T13:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNTMyOQ==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533125329", "bodyText": "\"... receive this event message\"", "author": "calohmn", "createdAt": "2020-12-01T07:36:15Z", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.", "originalCommit": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxMzYzMg==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533413632", "bodyText": "It has been corrected.", "author": "kaniyan", "createdAt": "2020-12-01T13:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNTMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNjc1MA==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533126750", "bodyText": "Is it necessary to wait 4s here? I would have guessed at most 200ms should be enough here, if waiting at all.", "author": "calohmn", "createdAt": "2020-12-01T07:39:21Z", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "originalCommit": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyODk2Mw==", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533128963", "bodyText": "Instead of waiting a second, how about finishing the test in the consumer message handler, and making sure there is a timeout for the whole test method execution?", "author": "calohmn", "createdAt": "2020-12-01T07:44:11Z", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {", "originalCommit": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64314766a60bab68c540e74aa57b7eb57eb8d794", "url": "https://github.com/eclipse/hono/commit/64314766a60bab68c540e74aa57b7eb57eb8d794", "message": "[#2333] Add integration tests\n\n Event messages are supposed to be queued by the Artemis broker when no north bound application is connected.\n Once the north bound application connects those queued messages should be delivered. This was not working as\n expected due to a bug described in the issue #2333. Integration tests are added to test the expected behavior.\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-12-01T13:38:48Z", "type": "commit"}, {"oid": "9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "url": "https://github.com/eclipse/hono/commit/9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "message": "Rewrite tests and incorporate review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-12-01T13:38:48Z", "type": "commit"}, {"oid": "9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "url": "https://github.com/eclipse/hono/commit/9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "message": "Rewrite tests and incorporate review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-12-01T13:38:48Z", "type": "forcePushed"}]}