{"pr_number": 1809, "pr_title": "Refactor Tenant AMQP endpoint not to use event bus", "pr_createdAt": "2020-03-04T13:46:44Z", "pr_url": "https://github.com/eclipse/hono/pull/1809", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkwMTYyOA==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387901628", "bodyText": "if any of endpoint, request or result is {@code null}.\nA (may be {@code null}) hint for the tenantId param would also be good.", "author": "calohmn", "createdAt": "2020-03-04T19:58:51Z", "path": "core/src/main/java/org/eclipse/hono/util/RequestResponseApiConstants.java", "diffHunk": "@@ -128,6 +128,56 @@ public static final Message getAmqpReply(final String endpoint, final EventBusMe\n         return message;\n     }\n \n+    /**\n+     * Creates an AMQP message from a result to a service invocation.\n+     *\n+     * @param endpoint The service endpoint that the operation has been invoked on.\n+     * @param tenantId The id of the tenant.\n+     * @param request The request message.\n+     * @param result The result message.\n+     * @return The AMQP message.\n+     * @throws NullPointerException if endpoint is {@code null}.", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkxMDA4Mg==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387910082", "bodyText": "What if the Future returned from getSenderForConnection fails? There is no recover branch below.", "author": "calohmn", "createdAt": "2020-03-04T20:15:48Z", "path": "service-base/src/main/java/org/eclipse/hono/service/amqp/AbstractRequestResponseEndpoint.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.transport.AmqpError;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.auth.AuthorizationService;\n+import org.eclipse.hono.service.auth.ClaimsBasedAuthorizationService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.HonoProtonHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseApiConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.eventbus.ReplyException;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonConnection;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * An abstract base class for implementing endpoints that implement a request response pattern.\n+ * <p>\n+ * It is used e.g. in the implementation of the device registration and the credentials API endpoints.\n+ *\n+ * @param <T> The type of configuration properties this endpoint uses.\n+ */\n+public abstract class AbstractRequestResponseEndpoint<T extends ServiceConfigProperties> extends AbstractAmqpEndpoint<T> {\n+\n+    /**\n+     * A logger to be shared by subclasses.\n+     */\n+    protected final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final Map<String, ProtonSender> replyToSenderMap = new HashMap<>();\n+\n+    private AuthorizationService authorizationService = new ClaimsBasedAuthorizationService();\n+\n+    /**\n+     * Creates an endpoint for a Vertx instance.\n+     *\n+     * @param vertx The Vertx instance to use.\n+     * @throws NullPointerException if vertx is {@code null};\n+     */\n+    protected AbstractRequestResponseEndpoint(final Vertx vertx) {\n+        super(Objects.requireNonNull(vertx));\n+    }\n+\n+    /**\n+     * Creates the message to send to the service implementation\n+     * via the vert.x event bus in order to invoke an operation.\n+     *\n+     * @param requestMessage The AMQP message representing the service invocation request.\n+     * @param targetAddress The address the message is sent to.\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<Message> handleRequestMessage(\n+            Message requestMessage,\n+            ResourceIdentifier targetAddress);\n+\n+    /**\n+     * Gets the object to use for making authorization decisions.\n+     *\n+     * @return The service.\n+     */\n+    public final AuthorizationService getAuthorizationService() {\n+        return authorizationService;\n+    }\n+\n+    /**\n+     * Sets the object to use for making authorization decisions.\n+     * <p>\n+     * If not set a {@link ClaimsBasedAuthorizationService} instance is used.\n+     *\n+     * @param authService The service.\n+     */\n+    @Autowired(required = false)\n+    public final void setAuthorizationService(final AuthorizationService authService) {\n+        this.authorizationService = authService;\n+    }\n+\n+    /**\n+     * Handles a client's request to establish a link for sending service invocation requests.\n+     * <p>\n+     * Configure and check the receiver link of the endpoint.\n+     * The remote link of the receiver must not demand the AT_MOST_ONCE QoS (not supported).\n+     * The receiver link itself is configured with the AT_LEAST_ONCE QoS and grants the configured credits\n+     * ({@link ServiceConfigProperties#getReceiverLinkCredit()}) with autoAcknowledge.\n+     * <p>\n+     * Handling of request messages is delegated to\n+     * {@link #handleRequestMessage(ProtonConnection, ProtonReceiver, ResourceIdentifier, ProtonDelivery, Message)}.\n+     *\n+     * @param con The AMQP connection that the link is part of.\n+     * @param receiver The ProtonReceiver that has already been created for this endpoint.\n+     * @param targetAddress The resource identifier for this endpoint (see {@link ResourceIdentifier} for details).\n+     */\n+    @Override\n+    public final void onLinkAttach(final ProtonConnection con, final ProtonReceiver receiver, final ResourceIdentifier targetAddress) {\n+\n+        if (ProtonQoS.AT_MOST_ONCE.equals(receiver.getRemoteQoS())) {\n+            logger.debug(\"client wants to use unsupported AT MOST ONCE delivery mode for endpoint [{}], closing link ...\", getName());\n+            receiver.setCondition(ProtonHelper.condition(AmqpError.PRECONDITION_FAILED.toString(), \"endpoint requires AT_LEAST_ONCE QoS\"));\n+            receiver.close();\n+        } else {\n+\n+            logger.debug(\"establishing link for receiving request messages from client [{}]\", receiver.getName());\n+\n+            receiver.setQoS(ProtonQoS.AT_LEAST_ONCE);\n+            receiver.setAutoAccept(true); // settle received messages if the handler succeeds\n+            receiver.setTarget(receiver.getRemoteTarget());\n+            receiver.setSource(receiver.getRemoteSource());\n+            // We do manual flow control, credits are replenished after responses have been sent.\n+            receiver.setPrefetch(0);\n+\n+            // set up handlers\n+\n+            receiver.handler((delivery, message) -> {\n+                try {\n+                    handleRequestMessage(con, receiver, targetAddress, delivery, message);\n+                } catch (final Exception ex) {\n+                    logger.warn(\"error handling message\", ex);\n+                    ProtonHelper.released(delivery, true);\n+                }\n+            });\n+            HonoProtonHelper.setCloseHandler(receiver, remoteClose -> onLinkDetach(receiver));\n+            HonoProtonHelper.setDetachHandler(receiver, remoteDetach -> onLinkDetach(receiver));\n+\n+            // acknowledge the remote open\n+            receiver.open();\n+\n+            // send out initial credits, after opening\n+            logger.debug(\"flowing {} credits to client\", config.getReceiverLinkCredit());\n+            receiver.flow(config.getReceiverLinkCredit());\n+        }\n+    }\n+\n+    /**\n+     * Handles a request message received from a client.\n+     * <p>\n+     * The message gets rejected if\n+     * <ul>\n+     * <li>the message does not pass {@linkplain #passesFormalVerification(ResourceIdentifier, Message) formal\n+     * verification} or</li>\n+     * <li>the client is not {@linkplain #isAuthorized(HonoUser, ResourceIdentifier, Message) authorized to execute the\n+     * operation} indicated by the message's <em>subject</em> or</li>\n+     * <li>its payload cannot be parsed</li>\n+     * </ul>\n+     *\n+     * @param con The connection with the client.\n+     * @param receiver The link over which the message has been received.\n+     * @param targetAddress The address the message is sent to.\n+     * @param delivery The message's delivery status.\n+     * @param requestMessage The request message.\n+     */\n+    protected final void handleRequestMessage(\n+            final ProtonConnection con,\n+            final ProtonReceiver receiver,\n+            final ResourceIdentifier targetAddress,\n+            final ProtonDelivery delivery,\n+            final Message requestMessage) {\n+\n+        final HonoUser clientPrincipal = Constants.getClientPrincipal(con);\n+        final String replyTo = requestMessage.getReplyTo();\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, requestMessage);\n+        final Span currentSpan = TracingHelper.buildChildSpan(tracer, spanContext, \"process request message\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n+                .withTag(Tags.HTTP_METHOD.getKey(), requestMessage.getSubject())\n+                .withTag(Tags.MESSAGE_BUS_DESTINATION.getKey(), targetAddress.toString())\n+                .start();\n+\n+        if (!passesFormalVerification(targetAddress, requestMessage)) {\n+            MessageHelper.rejected(delivery, new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed request message\"));\n+            flowCreditToRequestor(receiver, replyTo);\n+            TracingHelper.logError(currentSpan, \"malformed request message\");\n+            currentSpan.finish();\n+            return;\n+        }\n+\n+        ProtonHelper.accepted(delivery, true);\n+        currentSpan.log(\"request message accepted\");\n+\n+        getSenderForConnection(con, replyTo)", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4ODQ0Nw==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r388388447", "bodyText": "I refactored this to be closer to the original implementation. I would still like to go through this method and see if we can improve the code in the future.", "author": "dejanb", "createdAt": "2020-03-05T15:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkxMDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkxNjY1OQ==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387916659", "bodyText": "When comparing the method here with the corresponding one from RequestResponseEndpoint, this block is missing here:\n        .map(filteredResponse -> {\n            Tags.HTTP_STATUS.set(currentSpan, filteredResponse.getStatus());\n            return getAmqpReply(filteredResponse);\n        })\n\nI guess the getAmqpReply part has been incorporated into handleRequestMessage now.\nThen at least the Tags.HTTP_STATUS.set(currentSpan, filteredResponse.getStatus()); line should still be applied here.", "author": "calohmn", "createdAt": "2020-03-04T20:30:12Z", "path": "service-base/src/main/java/org/eclipse/hono/service/amqp/AbstractRequestResponseEndpoint.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.transport.AmqpError;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.auth.AuthorizationService;\n+import org.eclipse.hono.service.auth.ClaimsBasedAuthorizationService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.HonoProtonHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseApiConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.eventbus.ReplyException;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonConnection;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * An abstract base class for implementing endpoints that implement a request response pattern.\n+ * <p>\n+ * It is used e.g. in the implementation of the device registration and the credentials API endpoints.\n+ *\n+ * @param <T> The type of configuration properties this endpoint uses.\n+ */\n+public abstract class AbstractRequestResponseEndpoint<T extends ServiceConfigProperties> extends AbstractAmqpEndpoint<T> {\n+\n+    /**\n+     * A logger to be shared by subclasses.\n+     */\n+    protected final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final Map<String, ProtonSender> replyToSenderMap = new HashMap<>();\n+\n+    private AuthorizationService authorizationService = new ClaimsBasedAuthorizationService();\n+\n+    /**\n+     * Creates an endpoint for a Vertx instance.\n+     *\n+     * @param vertx The Vertx instance to use.\n+     * @throws NullPointerException if vertx is {@code null};\n+     */\n+    protected AbstractRequestResponseEndpoint(final Vertx vertx) {\n+        super(Objects.requireNonNull(vertx));\n+    }\n+\n+    /**\n+     * Creates the message to send to the service implementation\n+     * via the vert.x event bus in order to invoke an operation.\n+     *\n+     * @param requestMessage The AMQP message representing the service invocation request.\n+     * @param targetAddress The address the message is sent to.\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<Message> handleRequestMessage(\n+            Message requestMessage,\n+            ResourceIdentifier targetAddress);\n+\n+    /**\n+     * Gets the object to use for making authorization decisions.\n+     *\n+     * @return The service.\n+     */\n+    public final AuthorizationService getAuthorizationService() {\n+        return authorizationService;\n+    }\n+\n+    /**\n+     * Sets the object to use for making authorization decisions.\n+     * <p>\n+     * If not set a {@link ClaimsBasedAuthorizationService} instance is used.\n+     *\n+     * @param authService The service.\n+     */\n+    @Autowired(required = false)\n+    public final void setAuthorizationService(final AuthorizationService authService) {\n+        this.authorizationService = authService;\n+    }\n+\n+    /**\n+     * Handles a client's request to establish a link for sending service invocation requests.\n+     * <p>\n+     * Configure and check the receiver link of the endpoint.\n+     * The remote link of the receiver must not demand the AT_MOST_ONCE QoS (not supported).\n+     * The receiver link itself is configured with the AT_LEAST_ONCE QoS and grants the configured credits\n+     * ({@link ServiceConfigProperties#getReceiverLinkCredit()}) with autoAcknowledge.\n+     * <p>\n+     * Handling of request messages is delegated to\n+     * {@link #handleRequestMessage(ProtonConnection, ProtonReceiver, ResourceIdentifier, ProtonDelivery, Message)}.\n+     *\n+     * @param con The AMQP connection that the link is part of.\n+     * @param receiver The ProtonReceiver that has already been created for this endpoint.\n+     * @param targetAddress The resource identifier for this endpoint (see {@link ResourceIdentifier} for details).\n+     */\n+    @Override\n+    public final void onLinkAttach(final ProtonConnection con, final ProtonReceiver receiver, final ResourceIdentifier targetAddress) {\n+\n+        if (ProtonQoS.AT_MOST_ONCE.equals(receiver.getRemoteQoS())) {\n+            logger.debug(\"client wants to use unsupported AT MOST ONCE delivery mode for endpoint [{}], closing link ...\", getName());\n+            receiver.setCondition(ProtonHelper.condition(AmqpError.PRECONDITION_FAILED.toString(), \"endpoint requires AT_LEAST_ONCE QoS\"));\n+            receiver.close();\n+        } else {\n+\n+            logger.debug(\"establishing link for receiving request messages from client [{}]\", receiver.getName());\n+\n+            receiver.setQoS(ProtonQoS.AT_LEAST_ONCE);\n+            receiver.setAutoAccept(true); // settle received messages if the handler succeeds\n+            receiver.setTarget(receiver.getRemoteTarget());\n+            receiver.setSource(receiver.getRemoteSource());\n+            // We do manual flow control, credits are replenished after responses have been sent.\n+            receiver.setPrefetch(0);\n+\n+            // set up handlers\n+\n+            receiver.handler((delivery, message) -> {\n+                try {\n+                    handleRequestMessage(con, receiver, targetAddress, delivery, message);\n+                } catch (final Exception ex) {\n+                    logger.warn(\"error handling message\", ex);\n+                    ProtonHelper.released(delivery, true);\n+                }\n+            });\n+            HonoProtonHelper.setCloseHandler(receiver, remoteClose -> onLinkDetach(receiver));\n+            HonoProtonHelper.setDetachHandler(receiver, remoteDetach -> onLinkDetach(receiver));\n+\n+            // acknowledge the remote open\n+            receiver.open();\n+\n+            // send out initial credits, after opening\n+            logger.debug(\"flowing {} credits to client\", config.getReceiverLinkCredit());\n+            receiver.flow(config.getReceiverLinkCredit());\n+        }\n+    }\n+\n+    /**\n+     * Handles a request message received from a client.\n+     * <p>\n+     * The message gets rejected if\n+     * <ul>\n+     * <li>the message does not pass {@linkplain #passesFormalVerification(ResourceIdentifier, Message) formal\n+     * verification} or</li>\n+     * <li>the client is not {@linkplain #isAuthorized(HonoUser, ResourceIdentifier, Message) authorized to execute the\n+     * operation} indicated by the message's <em>subject</em> or</li>\n+     * <li>its payload cannot be parsed</li>\n+     * </ul>\n+     *\n+     * @param con The connection with the client.\n+     * @param receiver The link over which the message has been received.\n+     * @param targetAddress The address the message is sent to.\n+     * @param delivery The message's delivery status.\n+     * @param requestMessage The request message.\n+     */\n+    protected final void handleRequestMessage(\n+            final ProtonConnection con,\n+            final ProtonReceiver receiver,\n+            final ResourceIdentifier targetAddress,\n+            final ProtonDelivery delivery,\n+            final Message requestMessage) {\n+\n+        final HonoUser clientPrincipal = Constants.getClientPrincipal(con);\n+        final String replyTo = requestMessage.getReplyTo();\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, requestMessage);\n+        final Span currentSpan = TracingHelper.buildChildSpan(tracer, spanContext, \"process request message\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n+                .withTag(Tags.HTTP_METHOD.getKey(), requestMessage.getSubject())\n+                .withTag(Tags.MESSAGE_BUS_DESTINATION.getKey(), targetAddress.toString())\n+                .start();\n+\n+        if (!passesFormalVerification(targetAddress, requestMessage)) {\n+            MessageHelper.rejected(delivery, new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed request message\"));\n+            flowCreditToRequestor(receiver, replyTo);\n+            TracingHelper.logError(currentSpan, \"malformed request message\");\n+            currentSpan.finish();\n+            return;\n+        }\n+\n+        ProtonHelper.accepted(delivery, true);\n+        currentSpan.log(\"request message accepted\");\n+\n+        getSenderForConnection(con, replyTo)\n+                .compose(sender -> {\n+                    isAuthorized(clientPrincipal, targetAddress, requestMessage)\n+                            .map(authorized -> {\n+\n+                                logger.debug(\"client [{}] is {}authorized to {}:{}\", clientPrincipal.getName(),\n+                                        authorized ? \"\" : \"not \", targetAddress, requestMessage.getSubject());\n+\n+                                if (authorized) {\n+                                    return authorized;\n+                                } else {\n+                                    throw new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, \"not authorized to invoke operation\");\n+                                }\n+                            })\n+                            .compose(authorized -> handleRequestMessage(requestMessage, targetAddress))\n+                            .compose(amqpMessage -> filterResponse(clientPrincipal, requestMessage, amqpMessage))", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM5MDgwNg==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r388390806", "bodyText": "Yep. Added it to the final mapping.", "author": "dejanb", "createdAt": "2020-03-05T16:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkxNjY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMjYyOA==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387922628", "bodyText": "What kind of exception do you mean here? In other places where send is invoked we also don't catch exceptions. (And the IllegalArgumentException thrown in ProtonSenderImpl.send can't happen here.)\nOr do you mean passing a handler to react on the remote delivery update - possibly logging a rejected/released disposition?", "author": "calohmn", "createdAt": "2020-03-04T20:42:57Z", "path": "service-base/src/main/java/org/eclipse/hono/service/amqp/AbstractRequestResponseEndpoint.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.transport.AmqpError;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.auth.AuthorizationService;\n+import org.eclipse.hono.service.auth.ClaimsBasedAuthorizationService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.HonoProtonHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseApiConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.eventbus.ReplyException;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonConnection;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * An abstract base class for implementing endpoints that implement a request response pattern.\n+ * <p>\n+ * It is used e.g. in the implementation of the device registration and the credentials API endpoints.\n+ *\n+ * @param <T> The type of configuration properties this endpoint uses.\n+ */\n+public abstract class AbstractRequestResponseEndpoint<T extends ServiceConfigProperties> extends AbstractAmqpEndpoint<T> {\n+\n+    /**\n+     * A logger to be shared by subclasses.\n+     */\n+    protected final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final Map<String, ProtonSender> replyToSenderMap = new HashMap<>();\n+\n+    private AuthorizationService authorizationService = new ClaimsBasedAuthorizationService();\n+\n+    /**\n+     * Creates an endpoint for a Vertx instance.\n+     *\n+     * @param vertx The Vertx instance to use.\n+     * @throws NullPointerException if vertx is {@code null};\n+     */\n+    protected AbstractRequestResponseEndpoint(final Vertx vertx) {\n+        super(Objects.requireNonNull(vertx));\n+    }\n+\n+    /**\n+     * Creates the message to send to the service implementation\n+     * via the vert.x event bus in order to invoke an operation.\n+     *\n+     * @param requestMessage The AMQP message representing the service invocation request.\n+     * @param targetAddress The address the message is sent to.\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<Message> handleRequestMessage(\n+            Message requestMessage,\n+            ResourceIdentifier targetAddress);\n+\n+    /**\n+     * Gets the object to use for making authorization decisions.\n+     *\n+     * @return The service.\n+     */\n+    public final AuthorizationService getAuthorizationService() {\n+        return authorizationService;\n+    }\n+\n+    /**\n+     * Sets the object to use for making authorization decisions.\n+     * <p>\n+     * If not set a {@link ClaimsBasedAuthorizationService} instance is used.\n+     *\n+     * @param authService The service.\n+     */\n+    @Autowired(required = false)\n+    public final void setAuthorizationService(final AuthorizationService authService) {\n+        this.authorizationService = authService;\n+    }\n+\n+    /**\n+     * Handles a client's request to establish a link for sending service invocation requests.\n+     * <p>\n+     * Configure and check the receiver link of the endpoint.\n+     * The remote link of the receiver must not demand the AT_MOST_ONCE QoS (not supported).\n+     * The receiver link itself is configured with the AT_LEAST_ONCE QoS and grants the configured credits\n+     * ({@link ServiceConfigProperties#getReceiverLinkCredit()}) with autoAcknowledge.\n+     * <p>\n+     * Handling of request messages is delegated to\n+     * {@link #handleRequestMessage(ProtonConnection, ProtonReceiver, ResourceIdentifier, ProtonDelivery, Message)}.\n+     *\n+     * @param con The AMQP connection that the link is part of.\n+     * @param receiver The ProtonReceiver that has already been created for this endpoint.\n+     * @param targetAddress The resource identifier for this endpoint (see {@link ResourceIdentifier} for details).\n+     */\n+    @Override\n+    public final void onLinkAttach(final ProtonConnection con, final ProtonReceiver receiver, final ResourceIdentifier targetAddress) {\n+\n+        if (ProtonQoS.AT_MOST_ONCE.equals(receiver.getRemoteQoS())) {\n+            logger.debug(\"client wants to use unsupported AT MOST ONCE delivery mode for endpoint [{}], closing link ...\", getName());\n+            receiver.setCondition(ProtonHelper.condition(AmqpError.PRECONDITION_FAILED.toString(), \"endpoint requires AT_LEAST_ONCE QoS\"));\n+            receiver.close();\n+        } else {\n+\n+            logger.debug(\"establishing link for receiving request messages from client [{}]\", receiver.getName());\n+\n+            receiver.setQoS(ProtonQoS.AT_LEAST_ONCE);\n+            receiver.setAutoAccept(true); // settle received messages if the handler succeeds\n+            receiver.setTarget(receiver.getRemoteTarget());\n+            receiver.setSource(receiver.getRemoteSource());\n+            // We do manual flow control, credits are replenished after responses have been sent.\n+            receiver.setPrefetch(0);\n+\n+            // set up handlers\n+\n+            receiver.handler((delivery, message) -> {\n+                try {\n+                    handleRequestMessage(con, receiver, targetAddress, delivery, message);\n+                } catch (final Exception ex) {\n+                    logger.warn(\"error handling message\", ex);\n+                    ProtonHelper.released(delivery, true);\n+                }\n+            });\n+            HonoProtonHelper.setCloseHandler(receiver, remoteClose -> onLinkDetach(receiver));\n+            HonoProtonHelper.setDetachHandler(receiver, remoteDetach -> onLinkDetach(receiver));\n+\n+            // acknowledge the remote open\n+            receiver.open();\n+\n+            // send out initial credits, after opening\n+            logger.debug(\"flowing {} credits to client\", config.getReceiverLinkCredit());\n+            receiver.flow(config.getReceiverLinkCredit());\n+        }\n+    }\n+\n+    /**\n+     * Handles a request message received from a client.\n+     * <p>\n+     * The message gets rejected if\n+     * <ul>\n+     * <li>the message does not pass {@linkplain #passesFormalVerification(ResourceIdentifier, Message) formal\n+     * verification} or</li>\n+     * <li>the client is not {@linkplain #isAuthorized(HonoUser, ResourceIdentifier, Message) authorized to execute the\n+     * operation} indicated by the message's <em>subject</em> or</li>\n+     * <li>its payload cannot be parsed</li>\n+     * </ul>\n+     *\n+     * @param con The connection with the client.\n+     * @param receiver The link over which the message has been received.\n+     * @param targetAddress The address the message is sent to.\n+     * @param delivery The message's delivery status.\n+     * @param requestMessage The request message.\n+     */\n+    protected final void handleRequestMessage(\n+            final ProtonConnection con,\n+            final ProtonReceiver receiver,\n+            final ResourceIdentifier targetAddress,\n+            final ProtonDelivery delivery,\n+            final Message requestMessage) {\n+\n+        final HonoUser clientPrincipal = Constants.getClientPrincipal(con);\n+        final String replyTo = requestMessage.getReplyTo();\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, requestMessage);\n+        final Span currentSpan = TracingHelper.buildChildSpan(tracer, spanContext, \"process request message\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n+                .withTag(Tags.HTTP_METHOD.getKey(), requestMessage.getSubject())\n+                .withTag(Tags.MESSAGE_BUS_DESTINATION.getKey(), targetAddress.toString())\n+                .start();\n+\n+        if (!passesFormalVerification(targetAddress, requestMessage)) {\n+            MessageHelper.rejected(delivery, new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed request message\"));\n+            flowCreditToRequestor(receiver, replyTo);\n+            TracingHelper.logError(currentSpan, \"malformed request message\");\n+            currentSpan.finish();\n+            return;\n+        }\n+\n+        ProtonHelper.accepted(delivery, true);\n+        currentSpan.log(\"request message accepted\");\n+\n+        getSenderForConnection(con, replyTo)\n+                .compose(sender -> {\n+                    isAuthorized(clientPrincipal, targetAddress, requestMessage)\n+                            .map(authorized -> {\n+\n+                                logger.debug(\"client [{}] is {}authorized to {}:{}\", clientPrincipal.getName(),\n+                                        authorized ? \"\" : \"not \", targetAddress, requestMessage.getSubject());\n+\n+                                if (authorized) {\n+                                    return authorized;\n+                                } else {\n+                                    throw new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, \"not authorized to invoke operation\");\n+                                }\n+                            })\n+                            .compose(authorized -> handleRequestMessage(requestMessage, targetAddress))\n+                            .compose(amqpMessage -> filterResponse(clientPrincipal, requestMessage, amqpMessage))\n+                            .otherwise(t -> {\n+\n+                                logger.debug(\"error processing request [resource: {}, op: {}]: {}\", targetAddress,\n+                                        requestMessage.getSubject(), t.getMessage());\n+                                currentSpan.log(\"error processing request\");\n+                                TracingHelper.logError(currentSpan, t);\n+\n+                                final ServiceInvocationException ex = getServiceInvocationException(t);\n+                                Tags.HTTP_STATUS.set(currentSpan, ex.getErrorCode());\n+                                return RequestResponseApiConstants.getErrorMessage(ex.getErrorCode(), ex.getMessage(), requestMessage);\n+                            })\n+                            .map(amqpMessage -> {\n+                                if (sender.isOpen()) {\n+                                    final ProtonDelivery responseDelivery = sender.send(amqpMessage);\n+                                    //TODO handle send exception", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM5MjUwMw==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r388392503", "bodyText": "So, while playing with all this I managed to get NPE while mapping the message.\nREGISTRYjava.lang.NullPointerException\nREGISTRY\tat org.apache.qpid.proton.codec.MapType.calculateSize(MapType.java:101)\nREGISTRY\tat org.apache.qpid.proton.codec.MapType.getEncoding(MapType.java:66)\nREGISTRY\tat org.apache.qpid.proton.codec.MapType.getEncoding(MapType.java:29)\nREGISTRY\tat org.apache.qpid.proton.codec.AbstractPrimitiveType.write(AbstractPrimitiveType.java:27)\nREGISTRY\tat org.apache.qpid.proton.codec.messaging.FastPathApplicationPropertiesType.write(FastPathApplicationPropertiesType.java:173)\nREGISTRY\tat org.apache.qpid.proton.codec.messaging.FastPathApplicationPropertiesType.write(FastPathApplicationPropertiesType.java:43)\nREGISTRY\tat org.apache.qpid.proton.codec.EncoderImpl.writeObject(EncoderImpl.java:734)\nREGISTRY\tat org.apache.qpid.proton.message.impl.MessageImpl.encode(MessageImpl.java:736)\nREGISTRY\tat io.vertx.proton.impl.ProtonSenderImpl.send(ProtonSenderImpl.java:88)\nREGISTRY\tat io.vertx.proton.impl.ProtonSenderImpl.send(ProtonSenderImpl.java:56)\nREGISTRY\tat io.vertx.proton.impl.ProtonSenderImpl.send(ProtonSenderImpl.java:51)\nREGISTRY\tat org.eclipse.hono.service.amqp.AbstractRequestResponseEndpoint.lambda$handleRequestMessage$7(AbstractRequestResponseEndpoint.java:249)\nREGISTRY\tat io.vertx.core.Future.lambda$map$4(Future.java:402)\nREGISTRY\tat io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:107)\nREGISTRY\tat io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:85)\nREGISTRY\tat io.vertx.core.Future.map(Future.java:398)\nREGISTRY\tat org.eclipse.hono.service.amqp.AbstractRequestResponseEndpoint.lambda$handleRequestMessage$8(AbstractRequestResponseEndpoint.java:245)\nREGISTRY\tat io.vertx.core.Future.lambda$compose$3(Future.java:360)\nREGISTRY\tat io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:107)\nREGISTRY\tat io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:85)\nREGISTRY\tat io.vertx.core.Future.compose(Future.java:356)\nREGISTRY\tat io.vertx.core.Future.compose(Future.java:328)\nREGISTRY\tat org.eclipse.hono.service.amqp.AbstractRequestResponseEndpoint.handleRequestMessage(AbstractRequestResponseEndpoint.java:220)\n\nNot sure if this is something we can encounter in the regular working, so put a placeholder to rethink this later on.", "author": "dejanb", "createdAt": "2020-03-05T16:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMzQ2Mw==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387923463", "bodyText": "The extra line break before s looks a bit odd here.", "author": "calohmn", "createdAt": "2020-03-04T20:44:34Z", "path": "service-base/src/main/java/org/eclipse/hono/service/amqp/AbstractRequestResponseEndpoint.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.transport.AmqpError;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.auth.AuthorizationService;\n+import org.eclipse.hono.service.auth.ClaimsBasedAuthorizationService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.HonoProtonHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseApiConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.eventbus.ReplyException;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonConnection;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * An abstract base class for implementing endpoints that implement a request response pattern.\n+ * <p>\n+ * It is used e.g. in the implementation of the device registration and the credentials API endpoints.\n+ *\n+ * @param <T> The type of configuration properties this endpoint uses.\n+ */\n+public abstract class AbstractRequestResponseEndpoint<T extends ServiceConfigProperties> extends AbstractAmqpEndpoint<T> {\n+\n+    /**\n+     * A logger to be shared by subclasses.\n+     */\n+    protected final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final Map<String, ProtonSender> replyToSenderMap = new HashMap<>();\n+\n+    private AuthorizationService authorizationService = new ClaimsBasedAuthorizationService();\n+\n+    /**\n+     * Creates an endpoint for a Vertx instance.\n+     *\n+     * @param vertx The Vertx instance to use.\n+     * @throws NullPointerException if vertx is {@code null};\n+     */\n+    protected AbstractRequestResponseEndpoint(final Vertx vertx) {\n+        super(Objects.requireNonNull(vertx));\n+    }\n+\n+    /**\n+     * Creates the message to send to the service implementation\n+     * via the vert.x event bus in order to invoke an operation.\n+     *\n+     * @param requestMessage The AMQP message representing the service invocation request.\n+     * @param targetAddress The address the message is sent to.\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<Message> handleRequestMessage(\n+            Message requestMessage,\n+            ResourceIdentifier targetAddress);\n+\n+    /**\n+     * Gets the object to use for making authorization decisions.\n+     *\n+     * @return The service.\n+     */\n+    public final AuthorizationService getAuthorizationService() {\n+        return authorizationService;\n+    }\n+\n+    /**\n+     * Sets the object to use for making authorization decisions.\n+     * <p>\n+     * If not set a {@link ClaimsBasedAuthorizationService} instance is used.\n+     *\n+     * @param authService The service.\n+     */\n+    @Autowired(required = false)\n+    public final void setAuthorizationService(final AuthorizationService authService) {\n+        this.authorizationService = authService;\n+    }\n+\n+    /**\n+     * Handles a client's request to establish a link for sending service invocation requests.\n+     * <p>\n+     * Configure and check the receiver link of the endpoint.\n+     * The remote link of the receiver must not demand the AT_MOST_ONCE QoS (not supported).\n+     * The receiver link itself is configured with the AT_LEAST_ONCE QoS and grants the configured credits\n+     * ({@link ServiceConfigProperties#getReceiverLinkCredit()}) with autoAcknowledge.\n+     * <p>\n+     * Handling of request messages is delegated to\n+     * {@link #handleRequestMessage(ProtonConnection, ProtonReceiver, ResourceIdentifier, ProtonDelivery, Message)}.\n+     *\n+     * @param con The AMQP connection that the link is part of.\n+     * @param receiver The ProtonReceiver that has already been created for this endpoint.\n+     * @param targetAddress The resource identifier for this endpoint (see {@link ResourceIdentifier} for details).\n+     */\n+    @Override\n+    public final void onLinkAttach(final ProtonConnection con, final ProtonReceiver receiver, final ResourceIdentifier targetAddress) {\n+\n+        if (ProtonQoS.AT_MOST_ONCE.equals(receiver.getRemoteQoS())) {\n+            logger.debug(\"client wants to use unsupported AT MOST ONCE delivery mode for endpoint [{}], closing link ...\", getName());\n+            receiver.setCondition(ProtonHelper.condition(AmqpError.PRECONDITION_FAILED.toString(), \"endpoint requires AT_LEAST_ONCE QoS\"));\n+            receiver.close();\n+        } else {\n+\n+            logger.debug(\"establishing link for receiving request messages from client [{}]\", receiver.getName());\n+\n+            receiver.setQoS(ProtonQoS.AT_LEAST_ONCE);\n+            receiver.setAutoAccept(true); // settle received messages if the handler succeeds\n+            receiver.setTarget(receiver.getRemoteTarget());\n+            receiver.setSource(receiver.getRemoteSource());\n+            // We do manual flow control, credits are replenished after responses have been sent.\n+            receiver.setPrefetch(0);\n+\n+            // set up handlers\n+\n+            receiver.handler((delivery, message) -> {\n+                try {\n+                    handleRequestMessage(con, receiver, targetAddress, delivery, message);\n+                } catch (final Exception ex) {\n+                    logger.warn(\"error handling message\", ex);\n+                    ProtonHelper.released(delivery, true);\n+                }\n+            });\n+            HonoProtonHelper.setCloseHandler(receiver, remoteClose -> onLinkDetach(receiver));\n+            HonoProtonHelper.setDetachHandler(receiver, remoteDetach -> onLinkDetach(receiver));\n+\n+            // acknowledge the remote open\n+            receiver.open();\n+\n+            // send out initial credits, after opening\n+            logger.debug(\"flowing {} credits to client\", config.getReceiverLinkCredit());\n+            receiver.flow(config.getReceiverLinkCredit());\n+        }\n+    }\n+\n+    /**\n+     * Handles a request message received from a client.\n+     * <p>\n+     * The message gets rejected if\n+     * <ul>\n+     * <li>the message does not pass {@linkplain #passesFormalVerification(ResourceIdentifier, Message) formal\n+     * verification} or</li>\n+     * <li>the client is not {@linkplain #isAuthorized(HonoUser, ResourceIdentifier, Message) authorized to execute the\n+     * operation} indicated by the message's <em>subject</em> or</li>\n+     * <li>its payload cannot be parsed</li>\n+     * </ul>\n+     *\n+     * @param con The connection with the client.\n+     * @param receiver The link over which the message has been received.\n+     * @param targetAddress The address the message is sent to.\n+     * @param delivery The message's delivery status.\n+     * @param requestMessage The request message.\n+     */\n+    protected final void handleRequestMessage(\n+            final ProtonConnection con,\n+            final ProtonReceiver receiver,\n+            final ResourceIdentifier targetAddress,\n+            final ProtonDelivery delivery,\n+            final Message requestMessage) {\n+\n+        final HonoUser clientPrincipal = Constants.getClientPrincipal(con);\n+        final String replyTo = requestMessage.getReplyTo();\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, requestMessage);\n+        final Span currentSpan = TracingHelper.buildChildSpan(tracer, spanContext, \"process request message\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n+                .withTag(Tags.HTTP_METHOD.getKey(), requestMessage.getSubject())\n+                .withTag(Tags.MESSAGE_BUS_DESTINATION.getKey(), targetAddress.toString())\n+                .start();\n+\n+        if (!passesFormalVerification(targetAddress, requestMessage)) {\n+            MessageHelper.rejected(delivery, new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed request message\"));\n+            flowCreditToRequestor(receiver, replyTo);\n+            TracingHelper.logError(currentSpan, \"malformed request message\");\n+            currentSpan.finish();\n+            return;\n+        }\n+\n+        ProtonHelper.accepted(delivery, true);\n+        currentSpan.log(\"request message accepted\");\n+\n+        getSenderForConnection(con, replyTo)\n+                .compose(sender -> {\n+                    isAuthorized(clientPrincipal, targetAddress, requestMessage)\n+                            .map(authorized -> {\n+\n+                                logger.debug(\"client [{}] is {}authorized to {}:{}\", clientPrincipal.getName(),\n+                                        authorized ? \"\" : \"not \", targetAddress, requestMessage.getSubject());\n+\n+                                if (authorized) {\n+                                    return authorized;\n+                                } else {\n+                                    throw new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, \"not authorized to invoke operation\");\n+                                }\n+                            })\n+                            .compose(authorized -> handleRequestMessage(requestMessage, targetAddress))\n+                            .compose(amqpMessage -> filterResponse(clientPrincipal, requestMessage, amqpMessage))\n+                            .otherwise(t -> {\n+\n+                                logger.debug(\"error processing request [resource: {}, op: {}]: {}\", targetAddress,\n+                                        requestMessage.getSubject(), t.getMessage());\n+                                currentSpan.log(\"error processing request\");\n+                                TracingHelper.logError(currentSpan, t);\n+\n+                                final ServiceInvocationException ex = getServiceInvocationException(t);\n+                                Tags.HTTP_STATUS.set(currentSpan, ex.getErrorCode());\n+                                return RequestResponseApiConstants.getErrorMessage(ex.getErrorCode(), ex.getMessage(), requestMessage);\n+                            })\n+                            .map(amqpMessage -> {\n+                                if (sender.isOpen()) {\n+                                    final ProtonDelivery responseDelivery = sender.send(amqpMessage);\n+                                    //TODO handle send exception\n+                                    logger.debug(\"sent response message to client  [correlation-id: {}, content-type: {}]\",\n+                                            amqpMessage.getCorrelationId(), amqpMessage.getContentType());\n+                                    currentSpan.log(\"sent response message to client\");\n+                                    return responseDelivery;\n+                                } else {\n+                                    TracingHelper.logError(currentSpan, \"cannot send response, reply-to link is closed\");\n+                                    return null;\n+                                }\n+                            }).setHandler(\n+                            s -> {", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyODI0MQ==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387928241", "bodyText": "I think it would be better to enclose only the specific code where the DecodeException can occur with the try-catch block.\nThe tracing span could get created before that block, thereby allowing such a case of an invalid request message to get traced.", "author": "calohmn", "createdAt": "2020-03-04T20:54:17Z", "path": "service-base/src/main/java/org/eclipse/hono/service/tenant/AbstractTenantAmqpEndpoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.tenant;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.JsonObject;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.amqp.AbstractRequestResponseEndpoint;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import javax.security.auth.x500.X500Principal;\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+\n+/**\n+ * An {@code AmqpEndpoint} for managing tenant information.\n+ * <p>\n+ * This endpoint implements Hono's <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>. It receives AMQP 1.0\n+ * messages representing requests and sends them to an address on the vertx event bus for processing. The outcome is\n+ * then returned to the peer in a response message.\n+ */\n+public abstract class AbstractTenantAmqpEndpoint extends AbstractRequestResponseEndpoint<ServiceConfigProperties> {\n+\n+    private static final String SPAN_NAME_GET_TENANT = \"get Tenant\";\n+\n+    private static final String TAG_SUBJECT_DN_NAME = \"subject_dn_name\";\n+\n+    /**\n+     * Creates a new tenant endpoint for a vertx instance.\n+     *\n+     * @param vertx The vertx instance to use.\n+     */\n+    public AbstractTenantAmqpEndpoint(final Vertx vertx) {\n+        super(vertx);\n+    }\n+\n+    @Override\n+    public final String getName() {\n+        return TenantConstants.TENANT_ENDPOINT;\n+    }\n+\n+    /**\n+     * The service to forward requests to.\n+     *\n+     * @return The service to bind to, must never return {@code null}.\n+     */\n+    protected abstract TenantService getService();\n+\n+    @Override\n+    protected Future<Message> handleRequestMessage(final Message requestMessage, final ResourceIdentifier targetAddress) {\n+\n+        Objects.requireNonNull(requestMessage);\n+\n+        switch (TenantConstants.TenantAction.from(requestMessage.getSubject())) {\n+            case get:\n+                return processGetRequest(requestMessage);\n+            default:\n+                return processCustomTenantMessage(requestMessage);\n+        }\n+    }\n+\n+    private Future<Message> processGetRequest(final Message request) {\n+\n+        try {\n+\n+            final String tenantId = MessageHelper.getTenantId(request);\n+            final JsonObject payload = MessageHelper.getJsonPayload(request);\n+\n+            final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, request);\n+            final Span span = newChildSpan(SPAN_NAME_GET_TENANT, spanContext, tenantId);\n+            final Future<Message> resultFuture;\n+            if (tenantId == null && payload == null) {\n+                TracingHelper.logError(span, \"request does not contain any query parameters\");\n+                log.debug(\"request does not contain any query parameters\");\n+                resultFuture = Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+\n+            } else if (tenantId != null) {\n+\n+                // deprecated API\n+                log.debug(\"retrieving tenant [{}] using deprecated variant of get tenant request\", tenantId);\n+                span.log(\"using deprecated variant of get tenant request\");\n+                // span will be finished in processGetByIdRequest\n+                resultFuture = processGetByIdRequest(request, tenantId, span);\n+\n+            } else {\n+\n+                final String tenantIdFromPayload = getTypesafeValueForField(String.class, payload,\n+                        TenantConstants.FIELD_PAYLOAD_TENANT_ID);\n+                final String subjectDn = getTypesafeValueForField(String.class, payload,\n+                        TenantConstants.FIELD_PAYLOAD_SUBJECT_DN);\n+\n+                if (tenantIdFromPayload == null && subjectDn == null) {\n+                    TracingHelper.logError(span, \"request does not contain any query parameters\");\n+                    log.debug(\"payload does not contain any query parameters\");\n+                    resultFuture = Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+                } else if (tenantIdFromPayload != null) {\n+                    log.debug(\"retrieving tenant [id: {}]\", tenantIdFromPayload);\n+                    span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantIdFromPayload);\n+                    resultFuture = processGetByIdRequest(request, tenantIdFromPayload, span);\n+                } else {\n+                    span.setTag(TAG_SUBJECT_DN_NAME, subjectDn);\n+                    resultFuture = processGetByCaRequest(request, subjectDn, span);\n+                }\n+            }\n+\n+            return finishSpanOnFutureCompletion(span, resultFuture);\n+        } catch (DecodeException e) {\n+            logger.debug(\"failed to decode AMQP request message\", e);", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzMjQ0OQ==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387932449", "bodyText": "I guess that should be removed.", "author": "calohmn", "createdAt": "2020-03-04T21:02:49Z", "path": "service-base/src/main/java/org/eclipse/hono/service/amqp/AbstractRequestResponseEndpoint.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.transport.AmqpError;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.auth.AuthorizationService;\n+import org.eclipse.hono.service.auth.ClaimsBasedAuthorizationService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.HonoProtonHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseApiConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.eventbus.ReplyException;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonConnection;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * An abstract base class for implementing endpoints that implement a request response pattern.\n+ * <p>\n+ * It is used e.g. in the implementation of the device registration and the credentials API endpoints.\n+ *\n+ * @param <T> The type of configuration properties this endpoint uses.\n+ */\n+public abstract class AbstractRequestResponseEndpoint<T extends ServiceConfigProperties> extends AbstractAmqpEndpoint<T> {\n+\n+    /**\n+     * A logger to be shared by subclasses.\n+     */\n+    protected final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final Map<String, ProtonSender> replyToSenderMap = new HashMap<>();\n+\n+    private AuthorizationService authorizationService = new ClaimsBasedAuthorizationService();\n+\n+    /**\n+     * Creates an endpoint for a Vertx instance.\n+     *\n+     * @param vertx The Vertx instance to use.\n+     * @throws NullPointerException if vertx is {@code null};\n+     */\n+    protected AbstractRequestResponseEndpoint(final Vertx vertx) {\n+        super(Objects.requireNonNull(vertx));\n+    }\n+\n+    /**\n+     * Creates the message to send to the service implementation\n+     * via the vert.x event bus in order to invoke an operation.\n+     *\n+     * @param requestMessage The AMQP message representing the service invocation request.\n+     * @param targetAddress The address the message is sent to.\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<Message> handleRequestMessage(\n+            Message requestMessage,\n+            ResourceIdentifier targetAddress);\n+\n+    /**\n+     * Gets the object to use for making authorization decisions.\n+     *\n+     * @return The service.\n+     */\n+    public final AuthorizationService getAuthorizationService() {\n+        return authorizationService;\n+    }\n+\n+    /**\n+     * Sets the object to use for making authorization decisions.\n+     * <p>\n+     * If not set a {@link ClaimsBasedAuthorizationService} instance is used.\n+     *\n+     * @param authService The service.\n+     */\n+    @Autowired(required = false)\n+    public final void setAuthorizationService(final AuthorizationService authService) {\n+        this.authorizationService = authService;\n+    }\n+\n+    /**\n+     * Handles a client's request to establish a link for sending service invocation requests.\n+     * <p>\n+     * Configure and check the receiver link of the endpoint.\n+     * The remote link of the receiver must not demand the AT_MOST_ONCE QoS (not supported).\n+     * The receiver link itself is configured with the AT_LEAST_ONCE QoS and grants the configured credits\n+     * ({@link ServiceConfigProperties#getReceiverLinkCredit()}) with autoAcknowledge.\n+     * <p>\n+     * Handling of request messages is delegated to\n+     * {@link #handleRequestMessage(ProtonConnection, ProtonReceiver, ResourceIdentifier, ProtonDelivery, Message)}.\n+     *\n+     * @param con The AMQP connection that the link is part of.\n+     * @param receiver The ProtonReceiver that has already been created for this endpoint.\n+     * @param targetAddress The resource identifier for this endpoint (see {@link ResourceIdentifier} for details).\n+     */\n+    @Override\n+    public final void onLinkAttach(final ProtonConnection con, final ProtonReceiver receiver, final ResourceIdentifier targetAddress) {\n+\n+        if (ProtonQoS.AT_MOST_ONCE.equals(receiver.getRemoteQoS())) {\n+            logger.debug(\"client wants to use unsupported AT MOST ONCE delivery mode for endpoint [{}], closing link ...\", getName());\n+            receiver.setCondition(ProtonHelper.condition(AmqpError.PRECONDITION_FAILED.toString(), \"endpoint requires AT_LEAST_ONCE QoS\"));\n+            receiver.close();\n+        } else {\n+\n+            logger.debug(\"establishing link for receiving request messages from client [{}]\", receiver.getName());\n+\n+            receiver.setQoS(ProtonQoS.AT_LEAST_ONCE);\n+            receiver.setAutoAccept(true); // settle received messages if the handler succeeds\n+            receiver.setTarget(receiver.getRemoteTarget());\n+            receiver.setSource(receiver.getRemoteSource());\n+            // We do manual flow control, credits are replenished after responses have been sent.\n+            receiver.setPrefetch(0);\n+\n+            // set up handlers\n+\n+            receiver.handler((delivery, message) -> {\n+                try {\n+                    handleRequestMessage(con, receiver, targetAddress, delivery, message);\n+                } catch (final Exception ex) {\n+                    logger.warn(\"error handling message\", ex);\n+                    ProtonHelper.released(delivery, true);\n+                }\n+            });\n+            HonoProtonHelper.setCloseHandler(receiver, remoteClose -> onLinkDetach(receiver));\n+            HonoProtonHelper.setDetachHandler(receiver, remoteDetach -> onLinkDetach(receiver));\n+\n+            // acknowledge the remote open\n+            receiver.open();\n+\n+            // send out initial credits, after opening\n+            logger.debug(\"flowing {} credits to client\", config.getReceiverLinkCredit());\n+            receiver.flow(config.getReceiverLinkCredit());\n+        }\n+    }\n+\n+    /**\n+     * Handles a request message received from a client.\n+     * <p>\n+     * The message gets rejected if\n+     * <ul>\n+     * <li>the message does not pass {@linkplain #passesFormalVerification(ResourceIdentifier, Message) formal\n+     * verification} or</li>\n+     * <li>the client is not {@linkplain #isAuthorized(HonoUser, ResourceIdentifier, Message) authorized to execute the\n+     * operation} indicated by the message's <em>subject</em> or</li>\n+     * <li>its payload cannot be parsed</li>\n+     * </ul>\n+     *\n+     * @param con The connection with the client.\n+     * @param receiver The link over which the message has been received.\n+     * @param targetAddress The address the message is sent to.\n+     * @param delivery The message's delivery status.\n+     * @param requestMessage The request message.\n+     */\n+    protected final void handleRequestMessage(\n+            final ProtonConnection con,\n+            final ProtonReceiver receiver,\n+            final ResourceIdentifier targetAddress,\n+            final ProtonDelivery delivery,\n+            final Message requestMessage) {\n+\n+        final HonoUser clientPrincipal = Constants.getClientPrincipal(con);\n+        final String replyTo = requestMessage.getReplyTo();\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, requestMessage);\n+        final Span currentSpan = TracingHelper.buildChildSpan(tracer, spanContext, \"process request message\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n+                .withTag(Tags.HTTP_METHOD.getKey(), requestMessage.getSubject())\n+                .withTag(Tags.MESSAGE_BUS_DESTINATION.getKey(), targetAddress.toString())\n+                .start();\n+\n+        if (!passesFormalVerification(targetAddress, requestMessage)) {\n+            MessageHelper.rejected(delivery, new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed request message\"));\n+            flowCreditToRequestor(receiver, replyTo);\n+            TracingHelper.logError(currentSpan, \"malformed request message\");\n+            currentSpan.finish();\n+            return;\n+        }\n+\n+        ProtonHelper.accepted(delivery, true);\n+        currentSpan.log(\"request message accepted\");\n+\n+        getSenderForConnection(con, replyTo)\n+                .compose(sender -> {\n+                    isAuthorized(clientPrincipal, targetAddress, requestMessage)\n+                            .map(authorized -> {\n+\n+                                logger.debug(\"client [{}] is {}authorized to {}:{}\", clientPrincipal.getName(),\n+                                        authorized ? \"\" : \"not \", targetAddress, requestMessage.getSubject());\n+\n+                                if (authorized) {\n+                                    return authorized;\n+                                } else {\n+                                    throw new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, \"not authorized to invoke operation\");\n+                                }\n+                            })\n+                            .compose(authorized -> handleRequestMessage(requestMessage, targetAddress))\n+                            .compose(amqpMessage -> filterResponse(clientPrincipal, requestMessage, amqpMessage))\n+                            .otherwise(t -> {\n+\n+                                logger.debug(\"error processing request [resource: {}, op: {}]: {}\", targetAddress,\n+                                        requestMessage.getSubject(), t.getMessage());\n+                                currentSpan.log(\"error processing request\");\n+                                TracingHelper.logError(currentSpan, t);\n+\n+                                final ServiceInvocationException ex = getServiceInvocationException(t);\n+                                Tags.HTTP_STATUS.set(currentSpan, ex.getErrorCode());\n+                                return RequestResponseApiConstants.getErrorMessage(ex.getErrorCode(), ex.getMessage(), requestMessage);\n+                            })\n+                            .map(amqpMessage -> {\n+                                if (sender.isOpen()) {\n+                                    final ProtonDelivery responseDelivery = sender.send(amqpMessage);\n+                                    //TODO handle send exception\n+                                    logger.debug(\"sent response message to client  [correlation-id: {}, content-type: {}]\",\n+                                            amqpMessage.getCorrelationId(), amqpMessage.getContentType());\n+                                    currentSpan.log(\"sent response message to client\");\n+                                    return responseDelivery;\n+                                } else {\n+                                    TracingHelper.logError(currentSpan, \"cannot send response, reply-to link is closed\");\n+                                    return null;\n+                                }\n+                            }).setHandler(\n+                            s -> {\n+                                // allow client to send another request\n+                                flowCreditToRequestor(receiver, replyTo);\n+                                currentSpan.finish();\n+                            });\n+                    return Future.succeededFuture();\n+                });\n+    }\n+\n+    /**\n+     * Applies arbitrary filters on the response before it is sent to the client.\n+     * <p>\n+     * Subclasses may override this method in order to e.g. filter the payload based on\n+     * the client's authorities.\n+     * <p>\n+     * This default implementation simply returns a succeeded future containing the\n+     * original response.\n+     *\n+     * @param clientPrincipal The client's identity and authorities.\n+     * @param request The request message.\n+     * @param response The response to send to the client.\n+     * @return A future indicating the outcome.\n+     *         If the future succeeds it will contain the (filtered) response to be sent to the client.\n+     *         Otherwise the future will fail with a {@link ServiceInvocationException} indicating the\n+     *         problem.\n+     */\n+    protected Future<Message> filterResponse(final HonoUser clientPrincipal, final Message request, final Message response) {\n+\n+        return Future.succeededFuture(Objects.requireNonNull(response));\n+    }\n+\n+    /**\n+     * Checks if the client is authorized to execute a given operation.\n+     *\n+     * This method is invoked for every request message received from a client.\n+     * <p>\n+     * This default implementation simply delegates to {@link AuthorizationService#isAuthorized(HonoUser, ResourceIdentifier, String)}.\n+     * <p>\n+     * Subclasses may override this method in order to do more sophisticated checks.\n+     *\n+     * @param clientPrincipal The client.\n+     * @param resource The resource the message belongs to.\n+     * @param message The message for which the authorization shall be checked.\n+     * @return A future indicating the outcome of the check.\n+     *         The future will be succeeded if the client is authorized to execute the operation.\n+     *         Otherwise the future will be failed with a {@link ServiceInvocationException}.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    protected Future<Boolean> isAuthorized(final HonoUser clientPrincipal, final ResourceIdentifier resource, final Message message) {\n+\n+        Objects.requireNonNull(message);\n+        return getAuthorizationService().isAuthorized(clientPrincipal, resource, message.getSubject());\n+    }\n+\n+    /**\n+     * Handles a client's request to establish a link for receiving responses to service invocations.\n+     * <p>\n+     * This method opens a sender for sending request replies back to the client.\n+     *\n+     * @param con The AMQP connection that the link is part of.\n+     * @param sender The link to establish.\n+     * @param replyToAddress The reply-to address to create a consumer on the event bus for.\n+     */\n+    @Override\n+    public final void onLinkAttach(final ProtonConnection con, final ProtonSender sender,\n+            final ResourceIdentifier replyToAddress) {\n+\n+        if (!isValidReplyToAddress(replyToAddress)) {\n+            logger.debug(\"client [{}] provided invalid reply-to address\", sender.getName());\n+            sender.setCondition(ProtonHelper.condition(AmqpError.INVALID_FIELD,\n+                    String.format(\"reply-to address must have the following format %s/<tenant>/<reply-address>\",\n+                            getName())));\n+            sender.close();\n+            return;\n+        }\n+\n+        final String replyTo = replyToAddress.toString();\n+\n+        if (this.replyToSenderMap.containsKey(replyTo)) {\n+            logger.debug(\"client [{}] wanted to subscribe to already subscribed reply-to address [{}]\",\n+                    sender.getName(), replyTo);\n+            sender.setCondition(ProtonHelper.condition(AmqpError.ILLEGAL_STATE,\n+                    String.format(\"reply-to address [%s] is already subscribed\", replyTo)));\n+            sender.close();\n+            return;\n+        }\n+\n+        logger.debug(\"establishing response sender link with client [{}]\", sender.getName());\n+        sender.setQoS(ProtonQoS.AT_LEAST_ONCE);\n+        sender.setSource(sender.getRemoteSource());\n+        sender.setTarget(sender.getRemoteTarget());\n+        registerSenderForReplyTo(replyTo, sender);\n+\n+\n+        HonoProtonHelper.setCloseHandler(sender, remoteClose -> {\n+            logger.debug(\"client [{}] closed sender link\", sender.getName());\n+            unregisterSenderForReplyTo(replyTo);\n+            sender.close();\n+        });\n+        HonoProtonHelper.setDetachHandler(sender, remoteDetach -> {\n+            logger.debug(\"client [{}] detached sender link\", sender.getName());\n+            unregisterSenderForReplyTo(replyTo);\n+            sender.close();\n+        });\n+\n+        sender.open();\n+    }\n+\n+    @Override\n+    public void onConnectionClosed(final ProtonConnection connection) {\n+\n+        Objects.requireNonNull(connection);\n+        deallocateAllSendersForConnection(connection);\n+    }\n+\n+    private Future<ProtonSender> getSenderForConnection(final ProtonConnection con, final String replytoAddress) {\n+\n+        final Promise<ProtonSender> result = Promise.promise();\n+        final ProtonSender sender = replyToSenderMap.get(replytoAddress);\n+        if (sender != null && sender.isOpen() && sender.getSession().getConnection() == con) {\n+            result.complete(sender);\n+        } else {\n+            result.fail(new ClientErrorException(\n+                    HttpURLConnection.HTTP_PRECON_FAILED,\n+                    \"must open receiver link for reply-to address first\"));\n+        }\n+        return result.future();\n+    }\n+\n+    private void registerSenderForReplyTo(final String replyTo, final ProtonSender sender) {\n+\n+        final ProtonSender oldSender = replyToSenderMap.put(replyTo, sender);\n+\n+        if (oldSender == null || oldSender == sender) {\n+            logger.debug(\"registered sender [{}] for replies to [{}]\", sender, replyTo);\n+        } else {\n+            logger.info(\"replaced existing sender [{}] for replies to [{}] with sender [{}]\",\n+                    oldSender, replyTo, sender);\n+        }\n+    }\n+\n+    private void unregisterSenderForReplyTo(final String replyTo) {\n+\n+        final ProtonSender sender = replyToSenderMap.remove(replyTo);\n+        if (sender == null) {\n+            logger.warn(\"sender was not allocated for replyTo address [{}]\", replyTo);\n+        } else {\n+            logger.debug(\"deallocated sender [{}] for replies to [{}]\", sender.getName(), replyTo);\n+        }\n+\n+    }\n+\n+    private void deallocateAllSendersForConnection(final ProtonConnection connection) {\n+        replyToSenderMap\n+                .entrySet()\n+                .removeIf(entry -> entry.getValue().getSession().getConnection() == connection);\n+    }\n+\n+    private void flowCreditToRequestor(final ProtonReceiver receiver, final String replyTo) {\n+\n+        receiver.flow(1);\n+        logger.trace(\"replenished client [reply-to: {}, current credit: {}]\", replyTo,\n+                receiver.getCredit());\n+    }\n+\n+    /**\n+     * Checks if a resource identifier constitutes a valid reply-to address\n+     * for this service endpoint.\n+     * <p>\n+     * This method is invoked during establishment of the reply-to link between\n+     * the client and this endpoint. The link will only be established if this method\n+     * returns {@code true}.\n+     * <p>\n+     * This default implementation verifies that the address consists of three\n+     * segments: an endpoint identifier, a tenant identifier and a resource identifier.\n+     * <p>\n+     * Subclasses should override this method if the service they provide an endpoint for\n+     * uses a different reply-to address format.\n+     *\n+     * @param replyToAddress The address to check.\n+     * @return {@code true} if the address is valid.\n+     */\n+    protected boolean isValidReplyToAddress(final ResourceIdentifier replyToAddress) {\n+\n+        if (replyToAddress == null) {\n+            return false;\n+        } else {\n+            return replyToAddress.getResourcePath().length >= 3;\n+        }\n+    }\n+\n+    /**\n+     * Gets a property value of a given type from a JSON object.\n+     *\n+     * @param clazz Type class of the type\n+     * @param payload The object to get the property from.\n+     * @param field The name of the property.\n+     * @param <T> The type of the field.\n+     * @return The property value or {@code null} if no such property exists or is not of the expected type.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    protected static final <T> T getTypesafeValueForField(final Class<T> clazz, final JsonObject payload,\n+            final String field) {\n+\n+        Objects.requireNonNull(clazz);\n+        Objects.requireNonNull(payload);\n+        Objects.requireNonNull(field);\n+\n+        final Object result = payload.getValue(field);\n+\n+        if (clazz.isInstance(result)) {\n+            return clazz.cast(result);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Composes the given future so that the given <em>OpenTracing</em> span is finished when the future completes.\n+     * <p>\n+     * The result or exception of the given future will be used to set a {@link Tags#HTTP_STATUS} tag on the span\n+     * and to set a {@link Tags#ERROR} tag in case of an exception or a result with error status.\n+     *\n+     * @param span The span to finish.\n+     * @param resultFuture The future to be composed.\n+     * @return The composed future.\n+     */\n+    protected Future<Message> finishSpanOnFutureCompletion(final Span span, final Future<Message> resultFuture) {\n+        return resultFuture.compose(message -> {\n+            final Integer status = MessageHelper.getStatus(message);\n+            Tags.HTTP_STATUS.set(span, MessageHelper.getStatus(message));\n+            if (status != null && (status < 100 || status >= 600)) {\n+                Tags.ERROR.set(span, true);\n+            }\n+            span.finish();\n+            return Future.succeededFuture(message);\n+        }).recover(t -> {\n+            t.printStackTrace();", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk0MDEzNw==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r387940137", "bodyText": "\"request\" instead of \"response\".", "author": "calohmn", "createdAt": "2020-03-04T21:18:44Z", "path": "core/src/main/java/org/eclipse/hono/util/RequestResponseApiConstants.java", "diffHunk": "@@ -128,6 +128,56 @@ public static final Message getAmqpReply(final String endpoint, final EventBusMe\n         return message;\n     }\n \n+    /**\n+     * Creates an AMQP message from a result to a service invocation.\n+     *\n+     * @param endpoint The service endpoint that the operation has been invoked on.\n+     * @param tenantId The id of the tenant.\n+     * @param request The request message.\n+     * @param result The result message.\n+     * @return The AMQP message.\n+     * @throws NullPointerException if endpoint is {@code null}.\n+     * @throws IllegalArgumentException if the result does not contain a correlation ID.\n+     */\n+    public static final Message getAmqpReply(final String endpoint, final String tenantId, final Message request, final RequestResponseResult<JsonObject> result) {\n+\n+        Objects.requireNonNull(endpoint);\n+        Objects.requireNonNull(request);\n+        Objects.requireNonNull(result);\n+\n+        final Object correlationId = MessageHelper.getCorrelationId(request);\n+\n+        if (correlationId == null) {\n+            throw new IllegalArgumentException(\"response must contain correlation ID\");", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE5NTgxNw==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r388195817", "bodyText": "I think that can be moved up or to a Util class so it can be used by the other endpoints. Currently it is duplicated in each of the EventBus*Adapter classes.", "author": "jbtrystram", "createdAt": "2020-03-05T10:12:49Z", "path": "service-base/src/main/java/org/eclipse/hono/service/tenant/AbstractTenantAmqpEndpoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.tenant;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.JsonObject;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.HonoUser;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.amqp.AbstractRequestResponseEndpoint;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import javax.security.auth.x500.X500Principal;\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+\n+/**\n+ * An {@code AmqpEndpoint} for managing tenant information.\n+ * <p>\n+ * This endpoint implements Hono's <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>. It receives AMQP 1.0\n+ * messages representing requests and sends them to an address on the vertx event bus for processing. The outcome is\n+ * then returned to the peer in a response message.\n+ */\n+public abstract class AbstractTenantAmqpEndpoint extends AbstractRequestResponseEndpoint<ServiceConfigProperties> {\n+\n+    private static final String SPAN_NAME_GET_TENANT = \"get Tenant\";\n+\n+    private static final String TAG_SUBJECT_DN_NAME = \"subject_dn_name\";\n+\n+    /**\n+     * Creates a new tenant endpoint for a vertx instance.\n+     *\n+     * @param vertx The vertx instance to use.\n+     */\n+    public AbstractTenantAmqpEndpoint(final Vertx vertx) {\n+        super(vertx);\n+    }\n+\n+    @Override\n+    public final String getName() {\n+        return TenantConstants.TENANT_ENDPOINT;\n+    }\n+\n+    /**\n+     * The service to forward requests to.\n+     *\n+     * @return The service to bind to, must never return {@code null}.\n+     */\n+    protected abstract TenantService getService();\n+\n+    @Override\n+    protected Future<Message> handleRequestMessage(final Message requestMessage, final ResourceIdentifier targetAddress) {\n+\n+        Objects.requireNonNull(requestMessage);\n+\n+        switch (TenantConstants.TenantAction.from(requestMessage.getSubject())) {\n+            case get:\n+                return processGetRequest(requestMessage);\n+            default:\n+                return processCustomTenantMessage(requestMessage);\n+        }\n+    }\n+\n+    private Future<Message> processGetRequest(final Message request) {\n+\n+        try {\n+\n+            final String tenantId = MessageHelper.getTenantId(request);\n+            final JsonObject payload = MessageHelper.getJsonPayload(request);\n+\n+            final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, request);\n+            final Span span = newChildSpan(SPAN_NAME_GET_TENANT, spanContext, tenantId);\n+            final Future<Message> resultFuture;\n+            if (tenantId == null && payload == null) {\n+                TracingHelper.logError(span, \"request does not contain any query parameters\");\n+                log.debug(\"request does not contain any query parameters\");\n+                resultFuture = Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+\n+            } else if (tenantId != null) {\n+\n+                // deprecated API\n+                log.debug(\"retrieving tenant [{}] using deprecated variant of get tenant request\", tenantId);\n+                span.log(\"using deprecated variant of get tenant request\");\n+                // span will be finished in processGetByIdRequest\n+                resultFuture = processGetByIdRequest(request, tenantId, span);\n+\n+            } else {\n+\n+                final String tenantIdFromPayload = getTypesafeValueForField(String.class, payload,\n+                        TenantConstants.FIELD_PAYLOAD_TENANT_ID);\n+                final String subjectDn = getTypesafeValueForField(String.class, payload,\n+                        TenantConstants.FIELD_PAYLOAD_SUBJECT_DN);\n+\n+                if (tenantIdFromPayload == null && subjectDn == null) {\n+                    TracingHelper.logError(span, \"request does not contain any query parameters\");\n+                    log.debug(\"payload does not contain any query parameters\");\n+                    resultFuture = Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+                } else if (tenantIdFromPayload != null) {\n+                    log.debug(\"retrieving tenant [id: {}]\", tenantIdFromPayload);\n+                    span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantIdFromPayload);\n+                    resultFuture = processGetByIdRequest(request, tenantIdFromPayload, span);\n+                } else {\n+                    span.setTag(TAG_SUBJECT_DN_NAME, subjectDn);\n+                    resultFuture = processGetByCaRequest(request, subjectDn, span);\n+                }\n+            }\n+\n+            return finishSpanOnFutureCompletion(span, resultFuture);\n+        } catch (DecodeException e) {\n+            logger.debug(\"failed to decode AMQP request message\", e);\n+            return Future.failedFuture(\n+                    new ClientErrorException(\n+                            HttpURLConnection.HTTP_BAD_REQUEST,\n+                            \"request message body contains malformed JSON\"));\n+        }\n+    }\n+\n+    private Future<Message> processGetByIdRequest(final Message request, final String tenantId,\n+            final Span span) {\n+\n+        final Promise<TenantResult<JsonObject>> getResult = Promise.promise();\n+        getService().get(tenantId, span, getResult);\n+        return getResult.future().map(tr -> TenantConstants.getAmqpReply(TenantConstants.TENANT_ENDPOINT, tenantId, request, tr));\n+    }\n+\n+    private Future<Message> processGetByCaRequest(final Message request, final String subjectDn,\n+            final Span span) {\n+\n+        try {\n+            final X500Principal dn = new X500Principal(subjectDn);\n+            log.debug(\"retrieving tenant [subject DN: {}]\", subjectDn);\n+            final Promise<TenantResult<JsonObject>> getResult = Promise.promise();\n+            getService().get(dn, span, getResult);\n+            return getResult.future().map(tr -> {\n+                String tenantId = null;\n+                if (tr.isOk() && tr.getPayload() != null) {\n+                    tenantId = getTypesafeValueForField(String.class, tr.getPayload(),\n+                            TenantConstants.FIELD_PAYLOAD_TENANT_ID);\n+                    span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+                }\n+                return TenantConstants.getAmqpReply(TenantConstants.TENANT_ENDPOINT, tenantId, request, tr);\n+            });\n+        } catch (final IllegalArgumentException e) {\n+            TracingHelper.logError(span, \"illegal subject DN provided by client: \" + subjectDn);\n+            // the given subject DN is invalid\n+            log.debug(\"cannot parse subject DN [{}] provided by client\", subjectDn);\n+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }\n+    }\n+\n+    /**\n+     * Creates a new <em>OpenTracing</em> span for tracing the execution of a tenant service operation.\n+     * <p>\n+     * The returned span will already contain a tag for the given tenant (if it is not {@code null}).\n+     *\n+     * @param operationName The operation name that the span should be created for.\n+     * @param spanContext Existing span context.\n+     * @param tenantId The tenant id.\n+     * @return The new {@code Span}.\n+     * @throws NullPointerException if operationName is {@code null}.\n+     */\n+    protected final Span newChildSpan(final String operationName, final SpanContext spanContext, final String tenantId) {\n+        Objects.requireNonNull(operationName);\n+        // we set the component tag to the class name because we have no access to\n+        // the name of the enclosing component we are running in\n+        final Tracer.SpanBuilder spanBuilder = TracingHelper.buildChildSpan(tracer, spanContext, operationName)\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getClass().getSimpleName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER);\n+        if (tenantId != null) {\n+            spanBuilder.withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+        }\n+        return spanBuilder.start();\n+    }", "originalCommit": "6900b15337b642b32c4dae9bdf9ff88fd14b15a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMzMjc3MQ==", "url": "https://github.com/eclipse/hono/pull/1809#discussion_r388332771", "bodyText": "Good catch. Meant to have it in the base class, but it slipped.", "author": "dejanb", "createdAt": "2020-03-05T14:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE5NTgxNw=="}], "type": "inlineReview"}, {"oid": "a2fcb9160df00b5678ba1cb2ea44d1d84de05148", "url": "https://github.com/eclipse/hono/commit/a2fcb9160df00b5678ba1cb2ea44d1d84de05148", "message": "Refactor Tenant AMQP endpoint not to use event bus", "committedDate": "2020-03-05T14:35:38Z", "type": "forcePushed"}, {"oid": "a5e179b3214d2fd2158a2c1f19123801c62b3266", "url": "https://github.com/eclipse/hono/commit/a5e179b3214d2fd2158a2c1f19123801c62b3266", "message": "Refactor Tenant AMQP endpoint not to use event bus", "committedDate": "2020-03-05T15:42:41Z", "type": "commit"}, {"oid": "a5e179b3214d2fd2158a2c1f19123801c62b3266", "url": "https://github.com/eclipse/hono/commit/a5e179b3214d2fd2158a2c1f19123801c62b3266", "message": "Refactor Tenant AMQP endpoint not to use event bus", "committedDate": "2020-03-05T15:42:41Z", "type": "forcePushed"}]}