{"pr_number": 1699, "pr_title": "[#1691] Add isConnected(timeout); use it in client factories", "pr_createdAt": "2020-01-10T07:22:57Z", "pr_url": "https://github.com/eclipse/hono/pull/1699", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExMzE5OQ==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365113199", "bodyText": "shouldn't this be connection.isConnected(waitForCurrentConnectionAttemptTimeout)?", "author": "sophokles73", "createdAt": "2020-01-10T08:12:01Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClientFactory.java", "diffHunk": "@@ -95,6 +95,26 @@ public void addReconnectListener(final ReconnectListener<HonoConnection> listene\n         return connection.isConnected();\n     }\n \n+    /**\n+     * Checks whether this client is connected to the service.\n+     * <p>\n+     * If a connection attempt is currently in progress, the returned future is completed\n+     * with the outcome of the connection attempt. If the connection attempt (including\n+     * potential reconnect attempts) isn't finished after the given timeout, the returned\n+     * future is failed.\n+     * <p>\n+     * Simply delegates to {@link HonoConnection#isConnected(long)}.\n+     * \n+     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for\n+     *                                            on ongoing connection attempt to finish.\n+     * @return A succeeded future if this factory is connected.\n+     *         Otherwise, the future will be failed with a {@link ServerErrorException}.\n+     */\n+    @Override\n+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {\n+        return connection.isConnected();", "originalCommit": "e28cb5ad4f824ead00e270591c42751b94439343", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNzQwNg==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365117406", "bodyText": "shouldn't this better be encapsulated in CheckConnectPromise (which might be renamed to ExpiringPromise according to its purpose)?", "author": "sophokles73", "createdAt": "2020-01-10T08:25:57Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java", "diffHunk": "@@ -291,44 +286,82 @@ public final void addReconnectListener(final ReconnectListener<HonoConnection> l\n     private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {\n         if (isConnectedInternal()) {\n             resultHandler.handle(Future.succeededFuture());\n-        } else if (connecting.get()) {\n+        } else {\n+            resultHandler.handle(Future.failedFuture(\n+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {\n+        return executeOnContext(result -> checkConnected(result, waitForCurrentConnectAttemptTimeout));\n+    }\n+\n+    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler, final long waitForCurrentConnectAttemptTimeout) {\n+        if (isConnectedInternal()) {\n+            resultHandler.handle(Future.succeededFuture());\n+        } else if (waitForCurrentConnectAttemptTimeout > 0 && checkConnectedPromises.get() != null) {\n             // connect attempt in progress - let its completion complete the resultHandler here\n             log.debug(\"connection attempt to server [{}:{}] in progress, connection check will be completed with its result\",\n                     connectionFactory.getHost(), connectionFactory.getPort());\n-            final Promise<Void> promiseToAdd = Promise.promise();\n-            promiseToAdd.future().setHandler(resultHandler);\n-            // atomically add the promise to checkConnectedPromises - but only if checkConnectedPromises hasn't been cleared already\n-            final List<Promise<Void>> newCheckConnectedPromises = checkConnectedPromises\n-                    .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {\n-                        // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n-                        if (existing == null) {\n-                            return null;\n-                        }\n-                        final List<Promise<Void>> promises = new ArrayList<>(existing.size() + 1);\n-                        promises.addAll(existing);\n-                        promises.add(toAdd.get(0));\n-                        return promises;\n-                    });\n-            if (newCheckConnectedPromises == null) {\n-                // checkConnectedPromises wasn't updated with our promiseToAdd because the checkConnectedPromises were cleared in between\n-                resultHandler.handle(Future.failedFuture(\n-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+            final CheckConnectedPromise promiseToAdd = new CheckConnectedPromise(resultHandler);\n+            if (!addToCheckConnectedPromises(promiseToAdd)) {\n+                // checkConnectedPromises has been cleared in between\n+                checkConnected(resultHandler);\n+            } else {\n+                // promise added to list, now use a timer to ensure that we wait no more than the given timeout\n+                promiseToAdd.setTimerId(vertx.setTimer(waitForCurrentConnectAttemptTimeout, id -> {", "originalCommit": "e28cb5ad4f824ead00e270591c42751b94439343", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNzgzMQ==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365117831", "bodyText": "how about moving all of this into a separate class?", "author": "sophokles73", "createdAt": "2020-01-10T08:27:25Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java", "diffHunk": "@@ -291,44 +286,82 @@ public final void addReconnectListener(final ReconnectListener<HonoConnection> l\n     private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {\n         if (isConnectedInternal()) {\n             resultHandler.handle(Future.succeededFuture());\n-        } else if (connecting.get()) {\n+        } else {\n+            resultHandler.handle(Future.failedFuture(\n+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {\n+        return executeOnContext(result -> checkConnected(result, waitForCurrentConnectAttemptTimeout));\n+    }\n+\n+    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler, final long waitForCurrentConnectAttemptTimeout) {\n+        if (isConnectedInternal()) {\n+            resultHandler.handle(Future.succeededFuture());\n+        } else if (waitForCurrentConnectAttemptTimeout > 0 && checkConnectedPromises.get() != null) {\n             // connect attempt in progress - let its completion complete the resultHandler here\n             log.debug(\"connection attempt to server [{}:{}] in progress, connection check will be completed with its result\",\n                     connectionFactory.getHost(), connectionFactory.getPort());\n-            final Promise<Void> promiseToAdd = Promise.promise();\n-            promiseToAdd.future().setHandler(resultHandler);\n-            // atomically add the promise to checkConnectedPromises - but only if checkConnectedPromises hasn't been cleared already\n-            final List<Promise<Void>> newCheckConnectedPromises = checkConnectedPromises\n-                    .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {\n-                        // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n-                        if (existing == null) {\n-                            return null;\n-                        }\n-                        final List<Promise<Void>> promises = new ArrayList<>(existing.size() + 1);\n-                        promises.addAll(existing);\n-                        promises.add(toAdd.get(0));\n-                        return promises;\n-                    });\n-            if (newCheckConnectedPromises == null) {\n-                // checkConnectedPromises wasn't updated with our promiseToAdd because the checkConnectedPromises were cleared in between\n-                resultHandler.handle(Future.failedFuture(\n-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+            final CheckConnectedPromise promiseToAdd = new CheckConnectedPromise(resultHandler);\n+            if (!addToCheckConnectedPromises(promiseToAdd)) {\n+                // checkConnectedPromises has been cleared in between\n+                checkConnected(resultHandler);\n+            } else {\n+                // promise added to list, now use a timer to ensure that we wait no more than the given timeout\n+                promiseToAdd.setTimerId(vertx.setTimer(waitForCurrentConnectAttemptTimeout, id -> {\n+                    log.debug(\"canceling connection check after {}ms\", waitForCurrentConnectAttemptTimeout);\n+                    promiseToAdd.setTimerId(null);\n+                    promiseToAdd.tryCompleteAndCancelTimer(Future.failedFuture(\n+                            new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+                    removeFromCheckConnectedPromises(promiseToAdd); // not strictly necessary but keeps the list from growing if connection attempts keep on failing\n+                }));\n             }\n         } else {\n             resultHandler.handle(Future.failedFuture(\n                     new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n         }\n     }\n \n+    private boolean addToCheckConnectedPromises(final CheckConnectedPromise promiseToAdd) {\n+        // atomically add to checkConnectedPromises - but only if checkConnectedPromises hasn't been set to null\n+        final List<CheckConnectedPromise> newPromises = checkConnectedPromises\n+                .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {\n+                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n+                    if (existing == null) {\n+                        return null;\n+                    }\n+                    final List<CheckConnectedPromise> promises = new ArrayList<>(existing.size() + 1);\n+                    promises.addAll(existing);\n+                    promises.add(toAdd.get(0));\n+                    return promises;\n+                });\n+        return newPromises != null;\n+    }\n+\n+    private void removeFromCheckConnectedPromises(final CheckConnectedPromise promiseToRemove) {\n+        checkConnectedPromises\n+                .accumulateAndGet(Collections.singletonList(promiseToRemove), (existing, toRemove) -> {\n+                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n+                    if (existing == null) {\n+                        return null;\n+                    }\n+                    final List<CheckConnectedPromise> promises = new ArrayList<>(existing);\n+                    promises.remove(toRemove.get(0));\n+                    return promises;\n+                });\n+    }\n+\n     private void removeAndCompleteCheckConnectedPromises(final AsyncResult<HonoConnection> connectionResult) {\n-        final List<Promise<Void>> promises = checkConnectedPromises.getAndSet(null);\n-        if (promises != null) {\n+        final List<CheckConnectedPromise> promises = checkConnectedPromises.getAndSet(null);\n+        if (promises != null && !promises.isEmpty()) {\n+            log.trace(\"completing {} accumulated connection checks\", promises.size());\n             final Context ctx = vertx.getOrCreateContext();\n-            if (connectionResult.succeeded()) {\n-                promises.forEach(promise -> ctx.runOnContext(v -> promise.complete()));\n-            } else {\n-                promises.forEach(promise -> ctx.runOnContext(v -> promise.fail(connectionResult.cause())));\n-            }\n+            promises.forEach(promise -> ctx.runOnContext(v -> promise.tryCompleteAndCancelTimer(connectionResult)));", "originalCommit": "e28cb5ad4f824ead00e270591c42751b94439343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEzNjQwNg==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365136406", "bodyText": "I'll have a look...", "author": "calohmn", "createdAt": "2020-01-10T09:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNzgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MDg1Ng==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365250856", "bodyText": "Yes, I've refactored it accordingly.", "author": "calohmn", "createdAt": "2020-01-10T14:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExOTA5MA==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365119090", "bodyText": "in all the other places we use the request timeout for limiting the time to wait for the processing of a request over an already established connection, don't we? So, in order to improve chances that the request, that his method invocation is part of, succeeds, we might want to slightly reduce the time to wait a little so that there is some time left to establish the link and send the request message?", "author": "sophokles73", "createdAt": "2020-01-10T08:31:31Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java", "diffHunk": "@@ -67,17 +67,18 @@ protected void onDisconnect() {\n             final String tenantId) {\n \n         Objects.requireNonNull(tenantId);\n-        return connection.executeOnContext(result -> {\n-            credentialsClientFactory.getOrCreateClient(\n-                    CredentialsClientImpl.getTargetAddress(tenantId),\n-                    () -> CredentialsClientImpl.create(\n-                            cacheProvider,\n-                            connection,\n-                            tenantId,\n-                            this::removeCredentialsClient,\n-                            this::removeCredentialsClient),\n-                    result);\n-        });\n+        return connection.isConnected(connection.getConfig().getRequestTimeout())", "originalCommit": "e28cb5ad4f824ead00e270591c42751b94439343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzODgyOA==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365238828", "bodyText": "That would only be needed if we had another timeout mechanism around the combind \"getOrCreateClient+sendRequest\" invocations, with a timeout value of requestTimeout+X.\nBut I don't see such a timeout mechanism being in place and therefore the number of milliseconds to subtract here would just be arbitrary. And then I would prefer to keep using the full request timeout value.\nAnd thinking of the default value of 200ms here, I wouldn't want to decrease that value further (I think a somewhat higher value would even be better in many cases).", "author": "calohmn", "createdAt": "2020-01-10T13:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExOTA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI4MzY3NQ==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365283675", "bodyText": "You are right in pointing out that the request timeout only covers the time it takes to send the request and receive the response over an already established link. In fact, when a client invokes this method and the connection is established but the link for the given tenant is not established, then the client will wait for at most ClientConfigProperties.linkEstablishmentTimeout milis for the link to be established before timing out.\nSo, if the connection is not established but an attempt to connect is already going on, I guess that if we allow for roughly the same amount of time to establish the connection, the client should get a fair chance to get its request fulfilled but should not be required to wait exceptionally long for a failed result. WDYT?", "author": "sophokles73", "createdAt": "2020-01-10T15:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExOTA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxNDE1MA==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365714150", "bodyText": "Yes, I think that would be a good choice. I've adapted the commit accordingly.", "author": "calohmn", "createdAt": "2020-01-13T09:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExOTA5MA=="}], "type": "inlineReview"}, {"oid": "720c061f1f62eb39c4b24699681bd6be7177bb7b", "url": "https://github.com/eclipse/hono/commit/720c061f1f62eb39c4b24699681bd6be7177bb7b", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>", "committedDate": "2020-01-10T09:09:20Z", "type": "forcePushed"}, {"oid": "b5dc0b24a6783aaee1703cc95136f336f8bafb76", "url": "https://github.com/eclipse/hono/commit/b5dc0b24a6783aaee1703cc95136f336f8bafb76", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>", "committedDate": "2020-01-10T14:10:29Z", "type": "forcePushed"}, {"oid": "e26172b56fb22d82b460a223df4ed6c91952b161", "url": "https://github.com/eclipse/hono/commit/e26172b56fb22d82b460a223df4ed6c91952b161", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>", "committedDate": "2020-01-13T09:47:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2Mjk1OQ==", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365762959", "bodyText": "final ?", "author": "sophokles73", "createdAt": "2020-01-13T11:47:38Z", "path": "client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Context;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+\n+/**\n+ * Handles connection checks that should be completed only when a concurrent connection attempt has finished\n+ * (or when a timeout period has elapsed).\n+ */\n+public class DeferredConnectionCheckHandler {", "originalCommit": "e26172b56fb22d82b460a223df4ed6c91952b161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "url": "https://github.com/eclipse/hono/commit/2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>", "committedDate": "2020-01-13T16:11:45Z", "type": "commit"}, {"oid": "2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "url": "https://github.com/eclipse/hono/commit/2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>", "committedDate": "2020-01-13T16:11:45Z", "type": "forcePushed"}]}