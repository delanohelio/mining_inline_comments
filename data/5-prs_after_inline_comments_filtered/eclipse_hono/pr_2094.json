{"pr_number": 2094, "pr_title": "[#2053] Implementing auto provisioning of devices for gateways", "pr_createdAt": "2020-07-31T12:21:43Z", "pr_url": "https://github.com/eclipse/hono/pull/2094", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQyNTczNA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464425734", "bodyText": "FMPOV this should be a set ... and can we rename the field to authorities? Permissions are usually granted on a particular subject like you have permission READ on field address ...", "author": "sophokles73", "createdAt": "2020-08-03T13:50:01Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -68,6 +68,11 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.PERMISSIONS)\n+    @JsonInclude(value = Include.NON_EMPTY)\n+    @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)\n+    private List<String> permissions = new LinkedList<>();", "originalCommit": "49c1080d0b757b5f6992eec8aad7c564a83d1c73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQyNzI3Mw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464427273", "bodyText": "I'd rather not allow for this variability. We define this as a JSON array of strings and that's it. No ambiguity there, right?", "author": "sophokles73", "createdAt": "2020-08-03T13:52:29Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -68,6 +68,11 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.PERMISSIONS)\n+    @JsonInclude(value = Include.NON_EMPTY)\n+    @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)", "originalCommit": "49c1080d0b757b5f6992eec8aad7c564a83d1c73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQzMDQwNw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464430407", "bodyText": "how about adding an addEdgeDevice() method to AbstractRegistrationService instead? Subclasses can then either directly implement the logic to add the record to the persistent store or delegate to an existing collaborator.", "author": "sophokles73", "createdAt": "2020-08-03T13:57:29Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +213,36 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasPermissionForAutoRegistration(gatewayResult)) {\n+\n+                                    if (deviceBackend == null) {\n+                                        LOG.warn(\"cannot auto-provision device - no backend set\");\n+                                        return Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                                    }\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistrationConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    return deviceBackend.createDevice(tenantId, Optional.ofNullable(deviceId), device, span)", "originalCommit": "49c1080d0b757b5f6992eec8aad7c564a83d1c73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4ODk0MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464888940", "bodyText": "Yes that makes sense, especially since MongoDbBasedRegistrationService actually takes the direct implementation route...", "author": "fkaltner", "createdAt": "2020-08-04T08:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQzMDQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgyODIwMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464828200", "bodyText": "we should add the value from the context, shouldn't we?", "author": "sophokles73", "createdAt": "2020-08-04T06:30:54Z", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, RegistrationConstants.REGISTRATION_STATUS.NEW.name());", "originalCommit": "49c1080d0b757b5f6992eec8aad7c564a83d1c73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f69c5aabb6583abd35858392f043553bfb2fdc2f", "url": "https://github.com/eclipse/hono/commit/f69c5aabb6583abd35858392f043553bfb2fdc2f", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nWIP\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-08-04T11:51:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTU0NA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465691544", "bodyText": "at this point we verify the registration status of the gateway itself. There is no need to handle auto provisioning as the device ID is the same as the authenticated (gateway) ID. In fact, the device ID is unknown at this point in time and will be (finally) established after the mapper has been invoked.\nThe auto provisioning will be handled in the uploadMessage method ...", "author": "sophokles73", "createdAt": "2020-08-05T12:32:07Z", "path": "adapters/mqtt-vertx-base/src/main/java/org/eclipse/hono/adapter/mqtt/impl/VertxBasedMqttProtocolAdapter.java", "diffHunk": "@@ -102,10 +102,16 @@ public void setMessageMapping(final MessageMapping<MqttContext> messageMappingSe\n             final ResourceIdentifier targetAddress) {\n \n         return getRegistrationAssertion(\n-                targetAddress.getTenantId(),\n-                targetAddress.getResourceId(),\n-                ctx.authenticatedDevice(),\n-                ctx.getTracingContext())\n+                    targetAddress.getTenantId(),\n+                    targetAddress.getResourceId(),\n+                    ctx.authenticatedDevice(),\n+                    ctx.getTracingContext())\n+                .compose(handleAutoProvisioning(ctx,\n+                    ctx.endpoint(),\n+                    targetAddress.getTenantId(),\n+                    targetAddress.getResourceId(),\n+                    ctx.authenticatedDevice()\n+                ))", "originalCommit": "5a3046fb518d979acc553f6536f8651425947157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NjE5OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539176199", "bodyText": "As auto-provisioning has been moved to the registration service completely, I guess this can be resolved?", "author": "fkaltner", "createdAt": "2020-12-09T10:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465692892", "bodyText": "so, in case of a telemetry message being used for auto-provisioning a device, the downstream application will receive two messages containing this property: the empty notification event and the telemetry message, right?", "author": "sophokles73", "createdAt": "2020-08-05T12:34:36Z", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "originalCommit": "5a3046fb518d979acc553f6536f8651425947157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5NjI2NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465696265", "bodyText": "Yes, that is correct.\nAfter a second thought: I guess setting the property in the telemetry message might be redundant since an application should always act upon an event with that property, since the event will be delivered at least once.\nSo I tend to not set the property for the telemetry message. WDYT?", "author": "fkaltner", "createdAt": "2020-08-05T12:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyODMwMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465728300", "bodyText": "I am afraid that the whole mechanism as currently devised is not very robust. For example, if the connection between the adapter and the registry fails after the device has been provisioned but before the response message containing the registration info has reached the adapter, then the downstream application (Ditto) will not be notified about the newly provisioned device. However, subsequent requests from the gateway on behalf of the device will not trigger auto-provisioning again because the device now exists in the registry. Thus, Ditto will effectively never be notified about the new device.", "author": "sophokles73", "createdAt": "2020-08-05T13:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2OTYwMQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465769601", "bodyText": "Yes, that is a potential edge case.\nAn implementation without such edge cases would involve keeping persistent state as far as I can see. We could keep a flag in the Device Registry Service implementation which indicates if the registration event was already sent downstream.\nThe protocol adapters then would need to check that flag as well and send an event as long as it is set to \"pending delivery\". When the event was successfully delivered to the AMQP network, the protocol adapters may set that flag to \"delivered\" with another call to the Device Registry Service.\nHowever there may be still edge cases I guess, since the AMQP network \"ack\" is not an application-level \"ack\" - yet I think this should be sufficient.", "author": "fkaltner", "createdAt": "2020-08-05T14:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc3NDU4NA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465774584", "bodyText": "FMPOV all of this actually makes it more reasonable to let the registry emit the event that a device has been provisioned on-the-fly. We already follow that approach for auto-provisioning devices based on client certs, so this would actually be the more consistent approach anyway ...", "author": "sophokles73", "createdAt": "2020-08-05T14:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMTI1NA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465801254", "bodyText": "Maybe I missed something but I do not think that the device registry sends an event for auto-provisioning based on client certificates. It creates the device as well which is consistent with the implementation for gateway-based auto-provisioning.\nFrom the perspective of the device registries' responsibilities it makes sense to put it there - however there is one thing which the device registry does not know: was it an event or a telemetry message? (i.e. do I need to send an event or not)\nI found that rather odd to add a flag or the endpoint to the device registry's api since it doesn't have anything in common with device registration as far as I can see.\nOr did you have a different approach in mind?", "author": "fkaltner", "createdAt": "2020-08-05T15:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0MzkyNg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465843926", "bodyText": "Maybe I missed something but I do not think that the device registry sends an event for auto-provisioning based on client certificates. It creates the device as well which is consistent with the implementation for gateway-based auto-provisioning.\n\nOur example implementation (currently) doesn't, that's right. However, when we talked about how we wanted the client cert auto-provisioning to work, we agreed that it would be the responsibility of the registry implementation to notify other applications about the newly provisioned device. We left open how that should be done, but you can easily imagine that publishing an event would be a feasible option.\n\nFrom the perspective of the device registries' responsibilities it makes sense to put it there - however there is one thing which the device registry does not know: was it an event or a telemetry message? (i.e. do I need to send an event or not)\n\nIt doesn't need to because the registry would always publish an event indicating that the device has been provisioned while the protocol adapters would simply forward the telemetry message it received from the device as is.\n\nI found that rather odd to add a flag or the endpoint to the device registry's api since it doesn't have anything in common with device registration as far as I can see.\n\nIf the registry is responsible for emitting the event, there is no need to expose such a flag via its API.", "author": "sophokles73", "createdAt": "2020-08-05T16:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NDk3NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539174975", "bodyText": "The implementation is now adapted so that it emits an empty event, so I guess this can be resolved?", "author": "fkaltner", "createdAt": "2020-12-09T10:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}], "type": "inlineReview"}, {"oid": "b93e23aacf1361d116d750ccacb2cca26fdb83c9", "url": "https://github.com/eclipse/hono/commit/b93e23aacf1361d116d750ccacb2cca26fdb83c9", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-08-11T10:22:50Z", "type": "forcePushed"}, {"oid": "dad14130345309afd4bceebafcf231c9aa15744e", "url": "https://github.com/eclipse/hono/commit/dad14130345309afd4bceebafcf231c9aa15744e", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-08-11T12:52:43Z", "type": "forcePushed"}, {"oid": "8d9ee329e626f6014b1ba33b02893c041a52f6bd", "url": "https://github.com/eclipse/hono/commit/8d9ee329e626f6014b1ba33b02893c041a52f6bd", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-08-11T12:58:18Z", "type": "forcePushed"}, {"oid": "bfdf16ed6a265066f9db2b84e47be82590e155b9", "url": "https://github.com/eclipse/hono/commit/bfdf16ed6a265066f9db2b84e47be82590e155b9", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-08-12T09:09:43Z", "type": "forcePushed"}, {"oid": "fb17303a0071554e627bcabcb2b1373c2669eda2", "url": "https://github.com/eclipse/hono/commit/fb17303a0071554e627bcabcb2b1373c2669eda2", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-08-12T12:13:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NDQzMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469994430", "bodyText": "why don't we simply provide DeviceRegistry as the adapter type name and keep the null check?", "author": "sophokles73", "createdAt": "2020-08-13T14:28:49Z", "path": "core/src/main/java/org/eclipse/hono/util/MessageHelper.java", "diffHunk": "@@ -1123,7 +1120,9 @@ public static Message addProperties(\n         setCreationTime(msg);\n         msg.setAddress(ri.getBasePath());\n         addDeviceId(msg, ri.getResourceId());\n-        addProperty(msg, MessageHelper.APP_PROPERTY_ORIG_ADAPTER, adapterTypeName);\n+        if (adapterTypeName != null) {", "originalCommit": "61e3955b9389002312011209fb46a90db8bd1161", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MjE2OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471542169", "bodyText": "It's not really an adapter then but I guess it is worth the trade-off to keep the null check.", "author": "fkaltner", "createdAt": "2020-08-17T15:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NjUyNA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469996524", "bodyText": "none of these are used in the Device Registration API, are they? If not, then they should be moved to RegistryManagementConstants or some other appropriate location...", "author": "sophokles73", "createdAt": "2020-08-13T14:31:30Z", "path": "core/src/main/java/org/eclipse/hono/util/RegistrationConstants.java", "diffHunk": "@@ -56,6 +56,32 @@\n      */\n     public static final String FIELD_MAPPER = \"mapper\";\n \n+    /**\n+     * The name of the field in a response to the <em>assert Device Registration</em> operation\n+     * that contains the authorities of a gateway.\n+     */\n+    public static final String FIELD_AUTHORITIES = \"authorities\";\n+\n+    /**\n+     * The name of the field in a response to the <em>assert Device Registration</em> operation\n+     * that contains the name of the gateway groups.\n+     */\n+    public static final String FIELD_MEMBER_OF = \"memberOf\";\n+\n+    /**\n+     * The name of the authority which authorizes a gateway to perform auto-provisioning.\n+     */\n+    public static final String AUTHORITY_AUTO_PROVISIONING_ENABLED = \"auto-provisioning-enabled\";\n+\n+    /**\n+     * The registration status of a device.\n+     */\n+    public enum REGISTRATION_STATUS {\n+        NEW;\n+\n+        public static final String KEY = \"hono_registration_status\";\n+    }", "originalCommit": "61e3955b9389002312011209fb46a90db8bd1161", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MTc4NA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471541784", "bodyText": "That's true. I used the constants defined in RegistryManagementConstants instead, moved one to EventConstants and one to MessageHelper instead.\nHope this fits better.", "author": "fkaltner", "createdAt": "2020-08-17T15:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDYxNw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r470054617", "bodyText": "why do we need this?", "author": "sophokles73", "createdAt": "2020-08-13T15:53:59Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -55,8 +75,108 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "originalCommit": "61e3955b9389002312011209fb46a90db8bd1161", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2NTA0Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471465046", "bodyText": "We don't. I didn't know about the mapTo() method in JsonObject which I learnt just today.", "author": "fkaltner", "createdAt": "2020-08-17T13:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDgzOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r470054838", "bodyText": "why do we need this?", "author": "sophokles73", "createdAt": "2020-08-13T15:54:18Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -32,6 +37,7 @@\n public class AutowiredTenantInformationService implements TenantInformationService {\n \n     private static final Logger LOG = LoggerFactory.getLogger(AutowiredTenantInformationService.class);\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "originalCommit": "61e3955b9389002312011209fb46a90db8bd1161", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2NTExMg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471465112", "bodyText": "See: #2094 (comment)", "author": "fkaltner", "createdAt": "2020-08-17T13:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NTE0OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r470055149", "bodyText": "what if there is no such tenant?", "author": "sophokles73", "createdAt": "2020-08-13T15:54:48Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,16 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     *\n+     * @return A future whose outcome contains the requested tenant.", "originalCommit": "61e3955b9389002312011209fb46a90db8bd1161", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MjQyMQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471542421", "bodyText": "Adapted the documentation accordingly.", "author": "fkaltner", "createdAt": "2020-08-17T15:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwNDIzOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472204238", "bodyText": "We use standard camel case names for enums ...", "author": "sophokles73", "createdAt": "2020-08-18T13:39:11Z", "path": "core/src/main/java/org/eclipse/hono/util/EventConstants.java", "diffHunk": "@@ -37,6 +37,13 @@\n      */\n     public static final String CONTENT_TYPE_EMPTY_NOTIFICATION = \"application/vnd.eclipse-hono-empty-notification\";\n \n+    /**\n+     * The registration status of a device.\n+     */\n+    public enum REGISTRATION_STATUS {", "originalCommit": "a6b467294d9babc281973504c66a24513396041e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwNzEwNg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472207106", "bodyText": "We always use active form present tense for JavaDocs.\n\nAdds a new edge ...", "author": "sophokles73", "createdAt": "2020-08-18T13:43:12Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -159,6 +276,38 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Add a new edge device in the process of auto-provisioning of not yet registered edge devices sending data", "originalCommit": "a6b467294d9babc281973504c66a24513396041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMTA5Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484501097", "bodyText": "I know but missed that one. Thanks for spotting.", "author": "fkaltner", "createdAt": "2020-09-07T15:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwNzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwODIwNQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472208205", "bodyText": "What will be contained in the future if the operation fails? Why should it fail?", "author": "sophokles73", "createdAt": "2020-08-18T13:44:46Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -159,6 +276,38 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Add a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.", "originalCommit": "a6b467294d9babc281973504c66a24513396041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMTI5OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484501299", "bodyText": "Fixed.", "author": "fkaltner", "createdAt": "2020-09-07T15:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwODIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472209887", "bodyText": "this will only work if the result has status 200 and thus the payload contains JSON .... see implementation of tenantExists ...", "author": "sophokles73", "createdAt": "2020-08-18T13:47:13Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,12 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .map(tenantJson -> TenantResult.from(HttpURLConnection.HTTP_OK, tenantJson.getPayload().mapTo(TenantObject.class)));", "originalCommit": "a6b467294d9babc281973504c66a24513396041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDA0MQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473104041", "bodyText": "True.\nFMPOV a failed Future would make more sense (in contrast to the implementation of tenantExists). Otherwise every caller of the getTenant method would need to start with an if examining the result.\nIn general I find this pattern (returning a result which is possibly an error) cumbersome - isn't that what the onFailure methods in a Future are meant for?", "author": "fkaltner", "createdAt": "2020-08-19T15:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMzk3Mw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473113973", "bodyText": "yes, and we all agree that we need to change the service interfaces accordingly (some time). But we will definitely not have some methods in some interfaces follow one approach while others follow another one. At least we want to be consistent ...", "author": "sophokles73", "createdAt": "2020-08-19T15:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMTY1Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484501657", "bodyText": "Fixed (in a consistent way ;-) )", "author": "fkaltner", "createdAt": "2020-09-07T15:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472212320", "bodyText": "IMHO these should better be moved to the device's status property because we do not want clients to be able to update these, right?", "author": "sophokles73", "createdAt": "2020-08-18T13:50:37Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "originalCommit": "a6b467294d9babc281973504c66a24513396041e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3NzI1OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473077259", "bodyText": "Yes that it is right. I looked at the implementation of the status property and it seems like it is not complete yet. Consequently on my local deployment (with file based registry) there is only the current time returned as created and updated timestamp.\nThere is also an open issue regarding this: #1960\nSo I guess it makes sense to implement the status property first and then come back to this PR?", "author": "fkaltner", "createdAt": "2020-08-19T14:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NTYwMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473665600", "bodyText": "Either that or do not include the fields in the device object being transferred between the client and the registry", "author": "sophokles73", "createdAt": "2020-08-20T06:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc4OTUwOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473789508", "bodyText": "I am struggling with what you mean with\n\ndo not include the fields in the device object being transferred between the client and the registry\n\nI was looking for some kind of \"internal model\" initially already but went to re-investigate if there is such a thing after you remark. As far as I can see the org.eclipse.hono.service.management.device.Device class is used as the sole model class - internally as well as for the API. So the only option I see to have those two fields persistent is to include them in that class.\nDid I miss something?", "author": "fkaltner", "createdAt": "2020-08-20T09:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMDA0OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473910049", "bodyText": "No, you didn't. However, that doesn't mean that you need to transfer their values hence and forth between the registry and the client, does it?", "author": "sophokles73", "createdAt": "2020-08-20T11:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMzc3Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484503777", "bodyText": "Okay, so I guess you mean FileBasedDeviceBackend and MongoDbBasedDeviceBackend with client.\nThe problem is that we do a replace of the device when persisting for the file-based registry (there we just replace the entry in the HashMap) as well as for the MongoDb-based registry (there we replace the document of the device).\nIf I do not transfer the values (i.e. setting them to null) the present flags will be overwritten (with null). In order to put this to work I would need to implement some kind of \"merge\" as far as I can see.\nBut I do think that the status property is a better alternative than implementing merge-logic (which is just a workaround for the missing status property in my opinion).\nHence I do actually only see the implementation of the status property as a solution. So I would continue there and come back to this PR.\nWDYT?", "author": "fkaltner", "createdAt": "2020-09-07T15:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyNDU3OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r500124579", "bodyText": "Finally #2189 is near being merged. After it was merged I am able to continue on this one.\nI guess it makes sense to squash my commits to the present one and then continue with moving the auto-provisioning properties to the device status in a separate commit. WDYT?", "author": "fkaltner", "createdAt": "2020-10-06T09:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}], "type": "inlineReview"}, {"oid": "12cfb75b28b04c40e6d06ba7a9b8bafb99485672", "url": "https://github.com/eclipse/hono/commit/12cfb75b28b04c40e6d06ba7a9b8bafb99485672", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-09-07T15:28:14Z", "type": "forcePushed"}, {"oid": "4cfe0a6a35da900833b7016044b94aa216921fe1", "url": "https://github.com/eclipse/hono/commit/4cfe0a6a35da900833b7016044b94aa216921fe1", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-09-08T07:55:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg3NTA0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484875045", "bodyText": "StatusCodeMapper.from(final int statusCode, final String detailMessage) should take care of this mapping.", "author": "kaniyan", "createdAt": "2020-09-08T12:25:17Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -359,16 +367,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n \n                                     LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n                                     return addEdgeDevice(tenantId, Optional.ofNullable(deviceId), device, span)\n-                                            .compose(addDeviceOk -> sendEmptyEvent(tenantId, deviceId, gatewayId, span)\n-                                                .compose(sendEmptyEventOk -> processAssertRegistration(DeviceKey.from(tenantKey, deviceId), span)\n-                                                    .compose(deviceRegistrationData -> {\n-                                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n-                                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n-                                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n-                                                            .compose(idOperationResult -> createSuccessfulRegistrationResult(tenantId, deviceId, deviceData, span));\n-                                                    })\n-                                                )\n-                                            );\n+                                            .compose(registrationResult -> {\n+                                                if (registrationResult.isError()) {\n+                                                    if (registrationResult.getStatus() < 400 || registrationResult.getStatus() >= 500) {", "originalCommit": "4cfe0a6a35da900833b7016044b94aa216921fe1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3NTgzNw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r487675837", "bodyText": "Concerning Optional.ofNullable(deviceId): deviceId can't be null here.", "author": "calohmn", "createdAt": "2020-09-14T06:23:32Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +351,42 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    return addEdgeDevice(tenantId, Optional.ofNullable(deviceId), device, span)", "originalCommit": "4cfe0a6a35da900833b7016044b94aa216921fe1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MjI3Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r487682272", "bodyText": "I would be good to create a new child span here, and use it in this block (for everything except createSuccessfulRegistrationResult, I guess). That would allow filtering for that operation in the Tracing UI.", "author": "calohmn", "createdAt": "2020-09-14T06:39:51Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +351,42 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);", "originalCommit": "4cfe0a6a35da900833b7016044b94aa216921fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxOTkyNQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r488419925", "bodyText": "That makes sense. But I would also use the child span for createSuccessfulRegistrationResult since it is also done in the context of auto provisioning.", "author": "fkaltner", "createdAt": "2020-09-15T06:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MjI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ0MTI1Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r488441256", "bodyText": "I just think the auto provisioning is finished at that point, and a possible error like \"failed to resolve group members\", returned in createSuccessfulRegistrationResult, would be better of getting logged in the assert Device Registration span.", "author": "calohmn", "createdAt": "2020-09-15T07:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MjI3Mg=="}], "type": "inlineReview"}, {"oid": "f0e8393655a7c6309fcc88671317efa3f9d0853a", "url": "https://github.com/eclipse/hono/commit/f0e8393655a7c6309fcc88671317efa3f9d0853a", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-09-15T06:49:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyNzUwNg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r512527506", "bodyText": "This span isn't getting finished below. And naming it \"perform auto-provisioning\" would fit the usual naming style better FMPOV.", "author": "calohmn", "createdAt": "2020-10-27T09:17:31Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +405,41 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    final Span childSpan = TracingHelper.buildChildSpan(tracer, span.context(), \"auto-provisioning\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)", "originalCommit": "f0e8393655a7c6309fcc88671317efa3f9d0853a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NTI3Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r535355272", "bodyText": "I think this should be fixed now by the most recent refactoring.", "author": "fkaltner", "createdAt": "2020-12-03T15:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyNzUwNg=="}], "type": "inlineReview"}, {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "url": "https://github.com/eclipse/hono/commit/a3467601a96b1383ffda871cfdcade7a3bf1b761", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-11-09T13:30:21Z", "type": "forcePushed"}, {"oid": "e447f73f143721391a3055513c927a98dd117112", "url": "https://github.com/eclipse/hono/commit/e447f73f143721391a3055513c927a98dd117112", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-11-24T10:12:15Z", "type": "forcePushed"}, {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3", "url": "https://github.com/eclipse/hono/commit/1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-11-24T11:28:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDAxNg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521220016", "bodyText": "Missing info about the null check of the opentracingTracer in the JavaDoc.", "author": "kaniyan", "createdAt": "2020-11-11T09:17:18Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */", "originalCommit": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMDg5Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534000892", "bodyText": "Added.", "author": "fkaltner", "createdAt": "2020-12-02T09:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDA2Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521220066", "bodyText": "Null check of opentracingTracer should precede the log statement. If opentracingTracer is null then  opentracingTracer.getClass() will throw NullPointerException.", "author": "kaniyan", "createdAt": "2020-11-11T09:17:23Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);", "originalCommit": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMTAxOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534001018", "bodyText": "Good catch. Changed order.", "author": "fkaltner", "createdAt": "2020-12-02T09:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDEwNA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521220104", "bodyText": "This method is deprecated.  How about using newMessage(ResourceIdentifier, String, Buffer, TenantObject, Map, Map, boolean, boolean) instead.", "author": "kaniyan", "createdAt": "2020-11-11T09:17:28Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    private Future<ProtonDelivery> sendEmptyEvent(\n+            final String tenant,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenant);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device {} via gateway {}\", deviceId, gatewayId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenant, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenant);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Message msg = MessageHelper.newMessage(", "originalCommit": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMTQ5Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534001496", "bodyText": "Right, the method has become deprecated in the meantime. Switched to the advised one.", "author": "fkaltner", "createdAt": "2020-12-02T09:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDQ4Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521244487", "bodyText": "How about adding information about null check of parameters using @throws in the JavaDoc?", "author": "kaniyan", "createdAt": "2020-11-11T09:58:56Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */", "originalCommit": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAxOTA2Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534019067", "bodyText": "As this is a abstract method and the implementations differ regarding their null checks I am not sure if it will be of any help for the reader.\nAlso usually I have rarely seen a NullpointerException being catched.\nI think we should rather add documentation to the @param tags stating that the parameter must not be null making it part of the method's contract.\nWDYT?", "author": "fkaltner", "createdAt": "2020-12-02T09:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxMzA5OA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r538613098", "bodyText": "This became obsolete in the refactored version.", "author": "fkaltner", "createdAt": "2020-12-08T17:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTAyOQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521245029", "bodyText": "How about adding information about null check of parameters using @throws in the JavaDoc?", "author": "kaniyan", "createdAt": "2020-11-11T09:59:51Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Device device, Optional<String> resourceVersion, Span span);", "originalCommit": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAyMjYzMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534022630", "bodyText": "See above.", "author": "fkaltner", "createdAt": "2020-12-02T09:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxMzM1Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r538613352", "bodyText": "This became obsolete in the refactored version.", "author": "fkaltner", "createdAt": "2020-12-08T17:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2MTEwMg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521261102", "bodyText": "How about updating the JavaDoc of this method about auto provisioning of devices for gateways?", "author": "kaniyan", "createdAt": "2020-11-11T10:27:46Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +405,41 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    final Span childSpan = TracingHelper.buildChildSpan(tracer, span.context(), \"auto-provisioning\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                                            .start();\n+                                    return addEdgeDevice(tenantId, Optional.of(deviceId), device, childSpan)", "originalCommit": "a3467601a96b1383ffda871cfdcade7a3bf1b761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA1ODU4OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534058589", "bodyText": "Added to the doc of RegistrationService.", "author": "fkaltner", "createdAt": "2020-12-02T10:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2MTEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMzc1Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529523757", "bodyText": "How about adding information about null check of parameters in this public method?", "author": "kaniyan", "createdAt": "2020-11-24T12:55:41Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,45 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        return updateDevice(tenantId, deviceId, Optional.of(true), device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param autoProvisioningNotificationSent Marks the auto-provisioning notification for this device as sent.\n+     *                                         If set to {@link Optional#empty()} the value will not be updated.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Optional<Boolean> autoProvisioningNotificationSent, Device device,  Optional<String> resourceVersion, Span span);", "originalCommit": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4OTg5NA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539189894", "bodyText": "This method doesn't exist any more after refactoring", "author": "kaniyan", "createdAt": "2020-12-09T10:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMzc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MjE2Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539192162", "bodyText": "Yes, now it is reusing the methods as defined in DeviceManagementService.", "author": "fkaltner", "createdAt": "2020-12-09T10:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMzc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2ODQ1Mw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529568453", "bodyText": "How about adding info about null checks in the JavaDoc  * @throws NullPointerException if any of the parameters are {@code null}.?", "author": "kaniyan", "createdAt": "2020-11-24T14:03:58Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,22 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>\n+     */\n+     Future<TenantResult<TenantObject>> getTenant(String tenantId, Span span);", "originalCommit": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMjc3OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540402779", "bodyText": "How about adding info about null checks in the JavaDoc * @throws NullPointerException if any of the parameters are {@code null}.?\n\nAny update on this?", "author": "kaniyan", "createdAt": "2020-12-10T18:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2ODQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529577190", "bodyText": "There are many longer lines as the one above and could be formatted to fit the Hono code style provided in\nhono/eclipse/hono-code-style.xml. I have my IDE's code formatter configured to use the hono-code-style.xml.", "author": "kaniyan", "createdAt": "2020-11-24T14:16:10Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "originalCommit": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA0Njc5Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534046792", "bodyText": "Indeed. Since the code style is not enforced by the maven build I assumed it to be not \"binding\" especially since there is a lot of code which does not fully adhere to it.\nI did the reformat but personally I did not find the result more readable than before \ud83d\ude12. Hence I would rather not apply it...", "author": "fkaltner", "createdAt": "2020-12-02T10:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkyNDk0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540924945", "bodyText": "The project code style guide aims to create a consistent code style irrespective of personal preferences which makes easier understanding of a large code base.  IMHO it is good to adhere to it.  As you said there are places where some code doesn't confirm to the code style and FMPOV those should also be updated whenever possible. @calohmn @sophokles73 WDYT?", "author": "kaniyan", "createdAt": "2020-12-11T12:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5MzQ1Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540993456", "bodyText": "I think it would be good to adhere to the Hono code formatting style when possible, with the freedom to keep some lines with custom formatting. While I think some added linebreaks in the code in this PR for overly long lines wouldn't hurt, I don't see a direct need to change things.", "author": "calohmn", "createdAt": "2020-12-11T14:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NTQ0Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540995447", "bodyText": "I applied the formatter in the latest commit. As I said, in my opinion it makes things worse... :-(", "author": "fkaltner", "createdAt": "2020-12-11T14:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA0MjEwMQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r541042101", "bodyText": "I managed to find a middle ground between the formatter and readability together with @kaniyan.", "author": "fkaltner", "createdAt": "2020-12-11T15:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4MjIzNw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529582237", "bodyText": "I think it has been accidentally misspelt as authorties instead of authorities.", "author": "kaniyan", "createdAt": "2020-11-24T14:23:06Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -433,10 +653,27 @@ private boolean isDeviceEnabled(final RegistrationResult registrationResult) {\n                 isDeviceEnabled(registrationResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA));\n     }\n \n+    private boolean wasDeviceAutoProvisioned(final JsonObject registrationData) {\n+        return registrationData.getJsonObject(RegistryManagementConstants.FIELD_STATUS, new JsonObject())\n+                .getBoolean(RegistrationConstants.FIELD_AUTO_PROVISIONED, Boolean.FALSE);\n+    }\n+\n+    private boolean wasAutoProvisioningNotificationSent(final JsonObject registrationData) {\n+        return registrationData.getJsonObject(RegistryManagementConstants.FIELD_STATUS, new JsonObject())\n+                .getBoolean(RegistrationConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT, Boolean.FALSE);\n+    }\n+\n     private boolean isDeviceEnabled(final JsonObject registrationData) {\n         return registrationData.getBoolean(RegistrationConstants.FIELD_ENABLED, Boolean.TRUE);\n     }\n \n+    private boolean hasAuthorityForAutoRegistration(final RegistrationResult registrationResult) {\n+        final JsonArray authorties = registrationResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)", "originalCommit": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAyODg2Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534028866", "bodyText": "Yes, thanks for spotting.", "author": "fkaltner", "createdAt": "2020-12-02T09:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4MjIzNw=="}], "type": "inlineReview"}, {"oid": "76025722054b401bc51583b28a8ddda51aa6877c", "url": "https://github.com/eclipse/hono/commit/76025722054b401bc51583b28a8ddda51aa6877c", "message": "Adding integration tests.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-11-30T16:14:59Z", "type": "forcePushed"}, {"oid": "ec01306e52184d89c6fb36b94219eaaecd796e7e", "url": "https://github.com/eclipse/hono/commit/ec01306e52184d89c6fb36b94219eaaecd796e7e", "message": "Adding integration tests.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-01T15:57:24Z", "type": "forcePushed"}, {"oid": "4558ac2223b6568e53230215448863f7830fa0c4", "url": "https://github.com/eclipse/hono/commit/4558ac2223b6568e53230215448863f7830fa0c4", "message": "Adding integration tests.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-01T16:35:26Z", "type": "forcePushed"}, {"oid": "abcaec5f876db01960e8f75a292ad169c438244e", "url": "https://github.com/eclipse/hono/commit/abcaec5f876db01960e8f75a292ad169c438244e", "message": "- Taking care of possible conflicts when adding a device in the course of auto-provisioning\n- Refactoring into a separate method\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-03T15:21:37Z", "type": "forcePushed"}, {"oid": "664f109a5c98c1b620542ba7f82fa82c413982df", "url": "https://github.com/eclipse/hono/commit/664f109a5c98c1b620542ba7f82fa82c413982df", "message": "- Taking care of possible conflicts when adding a device in the course of auto-provisioning\n- Refactoring into a separate method\n- Taking care of failed assertion requests\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-04T12:07:20Z", "type": "forcePushed"}, {"oid": "7b5ce6b7865ddaf2038eb5f86f3870491370cdc0", "url": "https://github.com/eclipse/hono/commit/7b5ce6b7865ddaf2038eb5f86f3870491370cdc0", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-04T15:00:25Z", "type": "forcePushed"}, {"oid": "86c4f7a084d2bdce41239db4a1bb64dada69641f", "url": "https://github.com/eclipse/hono/commit/86c4f7a084d2bdce41239db4a1bb64dada69641f", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-04T16:11:19Z", "type": "forcePushed"}, {"oid": "802225739750527d3dd786af75769fb3b51d0883", "url": "https://github.com/eclipse/hono/commit/802225739750527d3dd786af75769fb3b51d0883", "message": "[#2053] Adding integration tests for gateway-based auto provisioning.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-08T12:19:07Z", "type": "forcePushed"}, {"oid": "479d5276895cdc0314b6d4a715b3bba6ec290693", "url": "https://github.com/eclipse/hono/commit/479d5276895cdc0314b6d4a715b3bba6ec290693", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-08T15:31:08Z", "type": "forcePushed"}, {"oid": "ea5ba45d19a5d80dbc673f6684c87fe179898372", "url": "https://github.com/eclipse/hono/commit/ea5ba45d19a5d80dbc673f6684c87fe179898372", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-08T16:11:56Z", "type": "forcePushed"}, {"oid": "c1e0fb99921a83e95f882453799faab012512ef9", "url": "https://github.com/eclipse/hono/commit/c1e0fb99921a83e95f882453799faab012512ef9", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-08T16:30:45Z", "type": "forcePushed"}, {"oid": "6e11c9e947e8dacc8a928c29a0b65b59f13057ec", "url": "https://github.com/eclipse/hono/commit/6e11c9e947e8dacc8a928c29a0b65b59f13057ec", "message": "[#2053] Implementing auto provisioning of devices for gateways\n\nBased on newly introduced authorities for a registered device a gateway is now enabled to perform auto-provisioning of edge devices. Applications are notified of auto-provisioned devices by receiving an empty event with corresponding application properties set.\n\nThis fixes #2053\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-08T16:43:10Z", "type": "forcePushed"}, {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "url": "https://github.com/eclipse/hono/commit/50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "message": "[#2053] Adding capability to auto-provision devices to registration service base classes.\n\nBuilding upon the implementation of auto-provisioning edge devices in the registration service bases classes, Hono's device registry implementation can be adapted to support auto-provisioning of edge devices which send telemetry data via gateway.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-08T17:01:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzMzOQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539043339", "bodyText": "Missing Javadoc.", "author": "calohmn", "createdAt": "2020-12-09T06:29:58Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -73,27 +111,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n         this.tenantInformationService = tenantInformationService;\n     }\n \n+    public TenantInformationService getTenantInformationService() {", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NDg4Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539154887", "bodyText": "Removed method, was obsolete anyway.", "author": "fkaltner", "createdAt": "2020-12-09T09:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzY0Mw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539043643", "bodyText": "Add comma: \"If set,\"", "author": "calohmn", "createdAt": "2020-12-09T06:30:50Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -73,27 +111,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n         this.tenantInformationService = tenantInformationService;\n     }\n \n+    public TenantInformationService getTenantInformationService() {\n+        return tenantInformationService;\n+    }\n+\n     /**\n-     * Gets device registration data by device ID.\n+     * Sets the AutoProvisioner to use.\n+     * <p>\n+     * If set gateway based auto-provisioning will be performed. Defaults to {@code null} meaning auto-provisioning", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NTAwOQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539155009", "bodyText": "Done.", "author": "fkaltner", "createdAt": "2020-12-09T09:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NDA2MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539044060", "bodyText": "deviceManagementService and deviceRegistrationInformationService can be final.", "author": "calohmn", "createdAt": "2020-12-09T06:31:55Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NTA2Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539155066", "bodyText": "Done.", "author": "fkaltner", "createdAt": "2020-12-09T09:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0ODA3MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539048070", "bodyText": "In almost all of Hono (except for the JDBC packages), Future.compose instead of Future.flatMap is used (flatMap is an alias for compose here). Therefore I would prefer that here for better readability.", "author": "calohmn", "createdAt": "2020-12-09T06:41:39Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NTEwMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539155100", "bodyText": "Done.", "author": "fkaltner", "createdAt": "2020-12-09T09:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0ODA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539051325", "bodyText": "According to the Javadoc in the interface, this method returns a succeeded Future with 404 status if no corresponding tenant was found. So, a result.isNotFound() case, returning a succeeded Future, seems to be missing here.", "author": "calohmn", "createdAt": "2020-12-09T06:49:29Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE2ODY5OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539168699", "bodyText": "I adapted the JavaDoc, since there is no client code relying on this.", "author": "fkaltner", "createdAt": "2020-12-09T10:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NjE1Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539176157", "bodyText": "I think returning a succeeded Future with 404 result would be more consistent here, though. That is also the behaviour of TenantService.get and CredentialsService.get for example.", "author": "calohmn", "createdAt": "2020-12-09T10:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3ODc2Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539178767", "bodyText": "In my opinion this just adds more unnecessary code which has to be maintained (and understood). I tend to follow the YAGNI principle here rather. If there's actually more than one client, this code can still be adapted.", "author": "fkaltner", "createdAt": "2020-12-09T10:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQzMDM0MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539430340", "bodyText": "FMPOV, letting the places where getTenant gets called also handle the isError() case, would also make the code more robust against other TenantInformationService implementations which might (by accident) just pass along the TenantService.get result.\nAnd passing along that result would probably make the code above simpler. I guess this should work:\nreturn Future.succeededFuture(result.map(p -> p.mapTo(TenantObject.class)));  (instead of the \"if.. else\" block).\n@kaniyan @sophokles73 Other opinions?", "author": "calohmn", "createdAt": "2020-12-09T15:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NDMxOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540794318", "bodyText": "I think the result cannot be mapped to a TenantObject in an error case, since there is no such object in the payload then.\nHence the if clause is still required as far as I can see. It will then have to return null as the tenant object.", "author": "fkaltner", "createdAt": "2020-12-11T09:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MjYzMQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540882631", "bodyText": "The p -> p.mapTo(TenantObject.class) parameter will only be applied on a non-null payload, the TenantResult.map() method using a null TenantObject in the created TenantResult if the payload is null. But your solution works just as well.", "author": "calohmn", "createdAt": "2020-12-11T11:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MjA0Mw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539052043", "bodyText": "\"device's\" - same in getter below.", "author": "calohmn", "createdAt": "2020-12-09T06:51:20Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The devices' authorities.", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MzM2Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539073362", "bodyText": "I think this is correct as this is a possessive of a plural noun:\nThe possessive of a plural noun is formed by adding only an apostrophe when the noun ends in s, and by adding both        an apostrophe and s when it ends in a letter other than s.\n\nSee: https://www.thepunctuationguide.com/apostrophe.html#possessives", "author": "fkaltner", "createdAt": "2020-12-09T07:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3Njg0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539076845", "bodyText": "But it's about the authorities of one device (\"this\") here, isn't it?", "author": "calohmn", "createdAt": "2020-12-09T07:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1Mzg5Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539053896", "bodyText": "To make this more robust, I would suggest adding:\nif (!deviceId.isPresent()) return Future.failedFuture(\"missing device id\");", "author": "calohmn", "createdAt": "2020-12-09T06:55:48Z", "path": "services/device-registry-base/src/test/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationServiceTest.java", "diffHunk": "@@ -113,6 +165,255 @@ public void testAssertRegistrationContainsDeviceInfo(final VertxTestContext ctx)\n             }));\n     }\n \n+    /**\n+     * Verifies that a device is auto-provisioned when an authorized gateway sends data on behalf of it.\n+     *\n+     * @param ctx The vert.x test context.\n+     */\n+    @Test\n+    public void testAssertRegistrationPerformsAutoProvisioningForAuthorizedGateway(final VertxTestContext ctx) {\n+        mockAssertRegistration(GATEWAY_ID, Collections.singletonList(GATEWAY_GROUP_ID), Collections.singletonList(RegistryManagementConstants.AUTHORITY_AUTO_PROVISIONING_ENABLED));\n+        mockAssertRegistration(DEVICE_ID, true);\n+        mockAddEdgeDevice(HttpURLConnection.HTTP_CREATED);\n+\n+        service.assertRegistration(Constants.DEFAULT_TENANT, DEVICE_ID, GATEWAY_ID, span)\n+                .onComplete(ctx.succeeding(result -> {\n+                    ctx.verify(() -> {\n+                        verifySuccessfulAutoProvisioning(result);\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    private void mockAssertRegistration(final String deviceId, final List<String> memberOf, final List<String> authorities) {\n+        final JsonObject registeredGateway = new JsonObject()\n+                .put(RegistryManagementConstants.FIELD_MEMBER_OF, new JsonArray(memberOf))\n+                .put(RegistryManagementConstants.FIELD_AUTHORITIES, new JsonArray(authorities));\n+\n+        when(service.processAssertRegistration(eq(DeviceKey.from(TenantKey.from(Constants.DEFAULT_TENANT), deviceId)), any(Span.class)))\n+                .thenReturn(Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                                .put(RegistrationConstants.FIELD_DATA, registeredGateway))));\n+\n+    }\n+\n+    private void mockAssertRegistration(final String deviceId, final boolean autoProvisioningNotificationSent) {\n+        when(service.processAssertRegistration(eq(DeviceKey.from(TenantKey.from(Constants.DEFAULT_TENANT), deviceId)), any(Span.class)))\n+                .thenReturn(Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_NOT_FOUND)))\n+                .thenReturn(Future.succeededFuture(newRegistrationResult(deviceId, autoProvisioningNotificationSent)));\n+\n+    }\n+\n+    private RegistrationResult newRegistrationResult(final String deviceId, final boolean autoProvisioningNotificationSent) {\n+        return RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                        .put(RegistrationConstants.FIELD_DATA, new JsonObject()\n+                                .put(RegistrationConstants.FIELD_VIA, AbstractRegistrationServiceTest.GATEWAY_ID)\n+                                .put(RegistryManagementConstants.FIELD_STATUS, new JsonObject()\n+                                        .put(RegistrationConstants.FIELD_AUTO_PROVISIONED, true)\n+                                        .put(RegistrationConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT, autoProvisioningNotificationSent))));\n+    }\n+\n+    /**\n+     * Verifies that auto-provisioning still succeeds if the device to be auto-provisioned has already been created\n+     * (e.g. by a concurrently running request) and the notification has already been sent.\n+     *\n+     * @param ctx The vert.x test context.\n+     */\n+    @Test\n+    public void testAssertRegistrationCanAutoProvisionForAlreadyPresentEdgeDevice(final VertxTestContext ctx) {\n+        mockAssertRegistration(GATEWAY_ID, Collections.singletonList(GATEWAY_GROUP_ID), Collections.singletonList(RegistryManagementConstants.AUTHORITY_AUTO_PROVISIONING_ENABLED));\n+        mockAssertRegistration(DEVICE_ID, true);\n+        mockAddEdgeDevice(HttpURLConnection.HTTP_CONFLICT);\n+\n+        service.assertRegistration(Constants.DEFAULT_TENANT, DEVICE_ID, GATEWAY_ID, span)\n+                .onComplete(ctx.succeeding(result -> {\n+                    ctx.verify(() -> {\n+                        assertThat(result.getStatus()).isEqualTo(HttpURLConnection.HTTP_OK);\n+\n+                        verify(service).createDevice(any(), any(), any(), any());\n+\n+                        verify(sender, never()).sendAndWaitForOutcome(any(), any());\n+                        verify(service, never()).updateDevice(eq(Constants.DEFAULT_TENANT), eq(DEVICE_ID), any(), any(), any());\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    private void mockAddEdgeDevice(final int httpOk) {\n+        when(service.createDevice(any(), any(), any(), any()))\n+                .thenAnswer((Answer<Future<OperationResult<Id>>>) invocation -> {\n+                    final Optional<String> deviceId = invocation.getArgument(1);\n+                    return Future.succeededFuture(OperationResult.ok(httpOk, Id.of(deviceId.get()),", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3MjI0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539172245", "bodyText": "Added...", "author": "fkaltner", "createdAt": "2020-12-09T10:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1Mzg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1NDQyMg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539054422", "bodyText": "Just 2020.", "author": "calohmn", "createdAt": "2020-12-09T06:57:05Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation", "originalCommit": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "url": "https://github.com/eclipse/hono/commit/7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "message": "[#2053] Adding capability to auto-provision devices to registration service base classes.\n\nBuilding upon the implementation of auto-provisioning edge devices in the registration service bases classes, Hono's device registry implementation can be adapted to support auto-provisioning of edge devices which send telemetry data via gateway.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-09T10:30:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4NjczNA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540386734", "bodyText": "What will happen to opentracingTracer.getClass().getName() when opentracingTracer is null? The null check in the next line should be done first.", "author": "kaniyan", "createdAt": "2020-12-10T18:07:41Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540389119", "bodyText": "AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY is inaccessible from here as it is declared as private.", "author": "kaniyan", "createdAt": "2020-12-10T18:11:14Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk3MzY5MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540973690", "bodyText": "I think it's ok to keep it like this. It doesn't lead to a Javadoc generation error and in an earlier discussion we kept it as well.", "author": "calohmn", "createdAt": "2020-12-11T14:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA1ODQ0MQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r541058441", "bodyText": "It won't throw any error. But in the generated doc, it will show as an invalid link and on clicking it takes to the target class and no information regarding that private field will be available.", "author": "kaniyan", "createdAt": "2020-12-11T16:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1MzIxNA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542153214", "bodyText": "Then this javadoc part wouldn't be useful in the generated docs, but it would still be useful when browsing the code and reading the javadoc in the IDE.", "author": "calohmn", "createdAt": "2020-12-14T07:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5MTc2MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540391760", "bodyText": "Missing null check for both arguments.", "author": "kaniyan", "createdAt": "2020-12-10T18:15:14Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5Mjk0Mg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540392942", "bodyText": "Also the span should be null checked, otherwise span.context() will throw error.", "author": "kaniyan", "createdAt": "2020-12-10T18:17:05Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5Nzk0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540397945", "bodyText": "It is a public method and FMPOV the arguments should be null checked if applicable.", "author": "kaniyan", "createdAt": "2020-12-10T18:24:50Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5ODEyOQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540398129", "bodyText": "It is a public method and FMPOV the arguments should be null checked if applicable.", "author": "kaniyan", "createdAt": "2020-12-10T18:25:07Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY\n+     */\n+    public Future<Void> sendDelayedAutoProvisioningNotificationIfNeeded(final String tenantId,\n+            final String deviceId, final String gatewayId, final JsonObject deviceData, final Span span) {", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMDQ2Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540400466", "bodyText": "IllegalArgumentException is thrown when the retryEventSendingDelay is less than 0 but the error message doesn't match that.\nHow about retryEventSendingDelay must not be negative or retryEventSendingDelay must be >= 0?", "author": "kaniyan", "createdAt": "2020-12-10T18:28:45Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisionerConfigProperties.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationConstants;\n+\n+/**\n+ * Configuration properties for Hono's gateway-based auto-provisioning.\n+ */\n+public class AutoProvisionerConfigProperties {\n+\n+    /**\n+     * Delay in milliseconds before trying to send the auto-provisioning notification if the initial attempt\n+     * to send the event hasn't completed yet.\n+     * <p>\n+     * This will only be invoked for requests that have <i>not</i> triggered the auto-provisioning,\n+     * but instead have found the {@link RegistrationConstants#FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT} flag\n+     * in the device data to be {@code false}. Assuming that such a request has occurred very shortly after\n+     * the auto-provisioning, with the notification event still in the process of getting sent, the intention\n+     * here is to wait some time til the event was most probably sent. After the delay, the flag is checked\n+     * again and only if the flag is still {@code false}, meaning there was possibly an error sending the event\n+     * during auto-provisioning, the event will be sent as part of that request.\n+     */\n+    private static final long DEFAULT_RETRY_EVENT_SENDING_DELAY = 50;\n+\n+    private long retryEventSendingDelay = DEFAULT_RETRY_EVENT_SENDING_DELAY;\n+\n+    /**\n+     * Gets the delay when sending auto-provisioning notifications.\n+     *\n+     * @return The delay.\n+     */\n+    public long getRetryEventSendingDelay() {\n+        return retryEventSendingDelay;\n+    }\n+\n+    /**\n+     * Sets the delay when sending auto-provisioning notifications.\n+     *\n+     * @param retryEventSendingDelay The delay to be set.\n+     * @throws IllegalArgumentException if the number of devices is &lt; 0.\n+     */\n+    public void setRetryEventSendingDelay(final long retryEventSendingDelay) {\n+        if (retryEventSendingDelay < 0) {\n+            throw new IllegalArgumentException(\"retryEventSendingDelay must be > 0\");", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTQ0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540401445", "bodyText": "IMHO the method name processAssertRegistration doesn't suit this context. As I understood, this method will return the registration information of a device. It can be something like getRegistration or getDeviceRegistration  as we have getTenant in the TenantInformationService. WDYT?", "author": "kaniyan", "createdAt": "2020-12-10T18:30:08Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {\n+\n+    /**\n+     * Gets device registration data by device ID.\n+     *\n+     * @param deviceKey The ID of the device to get registration data for.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *            <ul>\n+     *            <li><em>200 OK</em>, if a device with the given ID is registered for the tenant.<br>\n+     *            The <em>payload</em> will contain a JSON object with the following properties:\n+     *              <ul>\n+     *              <li><em>device-id</em> - the device identifier</li>\n+     *              <li><em>data</em> - the information registered for the device</li>\n+     *              </ul>\n+     *            </li>\n+     *            <li><em>404 Not Found</em>, if no device with the given identifier is registered for the tenant.</li>\n+     *            </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    Future<RegistrationResult> processAssertRegistration(DeviceKey deviceKey, Span span);", "originalCommit": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2MjM4Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540762386", "bodyText": "Yes, that is right. Actually I changed that method to that name, but reverted it to keep the change smaller for review.", "author": "fkaltner", "createdAt": "2020-12-11T08:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAwMDY2MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r541000660", "bodyText": "May be it can be done in a subsequent PR.", "author": "kaniyan", "createdAt": "2020-12-11T14:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTQ0NQ=="}], "type": "inlineReview"}, {"oid": "7d2c0666e620dfd5234d2f9d54ee746d1be4fab0", "url": "https://github.com/eclipse/hono/commit/7d2c0666e620dfd5234d2f9d54ee746d1be4fab0", "message": "Review suggestions kaniyan, calohmn\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-11T09:46:19Z", "type": "forcePushed"}, {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892", "url": "https://github.com/eclipse/hono/commit/60f734809e115a0f0825dcc7b7b8162d58d46892", "message": "[#2053] Adding capability to auto-provision devices to registration service base classes.\n\nBuilding upon the implementation of auto-provisioning edge devices in the registration service bases classes, Hono's device registry implementation can be adapted to support auto-provisioning of edge devices which send telemetry data via gateway.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-11T15:59:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MjcyMA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542162720", "bodyText": "this looks a little misleading as the device registry clearly is not a protocol adapter, is it?", "author": "sophokles73", "createdAt": "2020-12-14T07:25:02Z", "path": "core/src/main/java/org/eclipse/hono/util/Constants.java", "diffHunk": "@@ -77,6 +77,10 @@\n      * The type of the sigfox protocol adapter.\n      */\n     public static final String PROTOCOL_ADAPTER_TYPE_SIGFOX = \"hono-sigfox\";\n+    /**\n+     * The type of the protocol adapter which actually denotes the device registry.\n+     */\n+    public static final String PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY = \"hono-device-registry\";", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyODM1OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542328359", "bodyText": "Yes, see the discussion we already had on this: #2094 (comment)\nSince the application property name whose value is set to the constant's value is orig_adapter I thought it doesn't make sense to \"hide\" this in the name...", "author": "fkaltner", "createdAt": "2020-12-14T11:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MjcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NjQwNg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542166406", "bodyText": "If this field becomes a part of the Device object, it needs to be added to the Device Registry Management API spec as well.", "author": "sophokles73", "createdAt": "2020-12-14T07:33:37Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -70,6 +72,10 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTHORITIES)", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYyNTU4OA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542625588", "bodyText": "It is not returned if it is not set, but with the change this property may be set via API (and subsequently it will be returned then).\nHence I included in the specification.", "author": "fkaltner", "createdAt": "2020-12-14T18:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NzA1MA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542167050", "bodyText": "in order to prevent hard to find problems when the parameter is being changed after invoking this method, the field should better be set to a copy of the given set ...", "author": "sophokles73", "createdAt": "2020-12-14T07:34:53Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The device's authorities.\n+     *\n+     * @return A reference to this for fluent use.\n+     */\n+    public final Device setAuthorities(final Set<String> authorities) {\n+        this.authorities = authorities;", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NzQxOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542167418", "bodyText": "IMHO it would be safer to return an unmodifiable view on the set in order to prevent alteration by the client", "author": "sophokles73", "createdAt": "2020-12-14T07:35:44Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The device's authorities.\n+     *\n+     * @return A reference to this for fluent use.\n+     */\n+    public final Device setAuthorities(final Set<String> authorities) {\n+        this.authorities = authorities;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the authorities granted to this device.\n+     *\n+     * @return The device's authorities.\n+     */\n+    public final Set<String> getAuthorities() {\n+        return authorities;", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2ODc4MQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542168781", "bodyText": "IMHO we should replace should with may here and we should also provide an indication of how an implementing class might verify if the device has the required authority (which one is that, by the way?) ...\nThis additional paragraph should also be added to the other variant of this method which doesn't require a Span, or is only relevant to this variant?", "author": "sophokles73", "createdAt": "2020-12-14T07:38:36Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/registration/RegistrationService.java", "diffHunk": "@@ -114,6 +114,9 @@\n      * Such a check might be based on a specific role that the client needs to have or on an\n      * explicitly defined relation between the gateway and the device(s).\n      * <p>\n+     * Also they should perform an automatic provisioning of edge devices, if the gateway which sends telemetry on", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542173548", "bodyText": "can the returned future be failed as well?", "author": "sophokles73", "createdAt": "2020-12-14T07:48:46Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,24 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation, must not be {@code null}.\n+     *            It is not to be closed in this method! An implementation should log (error) events on this span and\n+     *            it may set tags and use this span as the parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1MzY3Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542453677", "bodyText": "No, as far as I can see not, in an error case it will always be a TenantResult with status code 404, similar to tenantExists.", "author": "fkaltner", "createdAt": "2020-12-14T15:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwMjA2OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542502069", "bodyText": "Then the wording should probably changed to reflect the fact that this will always return a succeeded future?", "author": "sophokles73", "createdAt": "2020-12-14T16:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxODI4OQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542518289", "bodyText": "I think this method should be in line with the TenantInformationService.tenantExists method and the TenantService methods in that respect.\nThese other methods don't make the promise, that always a succeeded Future will be returned. And looking at the current implementation of TenantService.get in the JDBC implementation, the returned Future can actually be failed. This would mean that AutowiredTenantInformationService.getTenant would also return a failed Future.\nTherefore I would keep the javadoc as is, and maybe change all related method javadocs and the JDBC implementation in that respect in a separate PR.", "author": "calohmn", "createdAt": "2020-12-14T16:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3NzkzOQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542177939", "bodyText": "is it really necessary to implement this functionality as a component with its own life cycle?\nHow about turning this into an interface and let its methods accept the necessary collaborators as parameters (maybe hidden behind a context object facade?). That way we can test it much easier and we would be more flexible regarding the implementation of the required collaborators. We have applied this pattern in org.eclipse.hono.client.CommandTargetMapper where it turned out very helpful.", "author": "sophokles73", "createdAt": "2020-12-14T07:57:26Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NDA3Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542374076", "bodyText": "we can defer this discussion to after the 1.5.0 release, though", "author": "sophokles73", "createdAt": "2020-12-14T13:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3NzkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542184428", "bodyText": "I don't quite get why some (required) collaborators are passed in via the constructor while others are injected by means of a setter. Is there a pattern that I don't see?\nWhy do we need a dedicated DeviceRegistrationInformationService? Can't we simply use the existing RegistrationService for this purpose?", "author": "sophokles73", "createdAt": "2020-12-14T08:10:31Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     *\n+     * @throws NullPointerException if any argument is {@code null}.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3NjU0OA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542476548", "bodyText": "No, actually there is no pattern. Refactored it to using setters.\nI could not find a method in RegistrationService which just gets the registration data of a device. That's also implied by their names since they start with \"assert...\" - these methods also query the tenant service which is unnecessary overhead when the intention is just to get the registration data.\nAlso I thought RegistrationService should represent the Device Registration API. Since there is no simple \"get\" method defined there and its only for internal use I did not want to extend the API. Also I did want to add the method there in order not to mix up \"API definitions\" and \"internal helpers\".\nAnd, finally \ud83d\ude05, I got the impression that TenantInformationService was defined because of similar reasons.", "author": "fkaltner", "createdAt": "2020-12-14T15:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwODUwNQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542508505", "bodyText": "well, the TenantInformationService has been created because there are deployment environments where Tenants will not be managed as part of the device registry and will instead be represented by e.g. custom resources in a kubernetes cluster.\nI might not fully understand what the DeviceRegistrationInformationService.processAssertRegistration method is actually returning. The JavaDoc ist quite vaguely referring to the information registered for the device.\nI wonder why the method is named processAssertRegistration if it is not about performing the assertion of the device's registration status. if it is about retrieving the device's registration information then why isn't it called getRegistrationInformation?\nit would be helpful if the JavaDoc would define more precisely what data is actually being returned by the method. You might be able to refer to the Device object definition in the Management API?", "author": "sophokles73", "createdAt": "2020-12-14T16:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzNjYxNQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542636615", "bodyText": "It is still named processAssertRegistration because I tried to keep the PR as small as possible, see #2094 (comment)\nI am happy to change it though, since two reviewers have now stumbled upon it - I guess the change is still \"digestible\" then.\n\nit would be helpful if the JavaDoc would define more precisely what data is actually being returned by the method. You might be able to refer to the Device object definition in the Management API?\n\nYes, that makes sense.", "author": "fkaltner", "createdAt": "2020-12-14T18:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODExOA==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542188118", "bodyText": "I do not see why we need this additional interface. Does it provide anything different from what the existing RegistrationService does?", "author": "sophokles73", "createdAt": "2020-12-14T08:17:09Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ4NTYwMg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542485602", "bodyText": "See above (#2094 (comment)).", "author": "fkaltner", "createdAt": "2020-12-14T15:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MjAwMQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542372001", "bodyText": "\"shutdown process\"", "author": "calohmn", "createdAt": "2020-12-14T13:12:27Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -58,6 +62,40 @@\n \n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    private AutoProvisioner autoProvisioner;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        return startInternal()\n+            .compose(ok -> supportsAutoProvisioning() ? autoProvisioner.start() : Future.succeededFuture())\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal()\n+            .compose(ok -> supportsAutoProvisioning() ? autoProvisioner.stop() : Future.succeededFuture())\n+            .mapEmpty();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.", "originalCommit": "60f734809e115a0f0825dcc7b7b8162d58d46892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "285fede816cc85413fe6495321cfe93c11376c12", "url": "https://github.com/eclipse/hono/commit/285fede816cc85413fe6495321cfe93c11376c12", "message": "[#2053] Adding capability to auto-provision devices to registration service base classes.\n\nBuilding upon the implementation of auto-provisioning edge devices in the registration service bases classes, Hono's device registry implementation can be adapted to support auto-provisioning of edge devices which send telemetry data via gateway.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-14T16:02:18Z", "type": "commit"}, {"oid": "00cb3f3823b046519c409716636186245451b471", "url": "https://github.com/eclipse/hono/commit/00cb3f3823b046519c409716636186245451b471", "message": "Review suggestions calohmn and sophokles73.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-14T19:01:19Z", "type": "commit"}, {"oid": "00cb3f3823b046519c409716636186245451b471", "url": "https://github.com/eclipse/hono/commit/00cb3f3823b046519c409716636186245451b471", "message": "Review suggestions calohmn and sophokles73.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-14T19:01:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1NTg3Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543155877", "bodyText": "this means that the property will always be included in the JSON document. Is that what you want to achieve?", "author": "sophokles73", "createdAt": "2020-12-15T08:51:10Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/DeviceStatus.java", "diffHunk": "@@ -39,6 +37,7 @@\n      *\n      * @return {@code true} if this device was auto-provisioned.\n      */\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)", "originalCommit": "00cb3f3823b046519c409716636186245451b471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3NTY2Ng==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543175666", "bodyText": "I moved that annotation to the getter, since I found out when doing manual testing for double-checking if the authorities property is included (see #2094 (comment)) that it seems like this annotation has no effect when it is put on the field level, meaning the property is serialised using a camel-cased name.\nUnfortunately I did not manage yet to find out what the root-cause for this behaviour is. There's even a unit test which is still succeeding when the property is on the field level. So I guess this must be caused by using Jackson together with Vert.x...\nBesides that I think that the property being always serialised is not the effect of this annotation being put on the method level, but stems from the primitive type being returned by the getter (which we deliberately set to avoid null-checking).\nSemantically I think it is correct: devices which were created before the implementation of auto-provisioning won't have the corresponding flag set resulting in returning false for the auto-provisioned property. In my opinion this is correct as they actually haven't been auto-provisioned.\nI didn't see any value in exposing if the device was created before or after this feature was implemented to the client which is why I deemed it acceptable.", "author": "fkaltner", "createdAt": "2020-12-15T09:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1NTg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543158187", "bodyText": "if we already have a DeviceManagementService then why do we also need a DeviceRegistrationInformationService? Couldn't we simply use DeviceManagementService.readDevice()?", "author": "sophokles73", "createdAt": "2020-12-15T08:54:30Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceManagementService} to use.\n+     *\n+     * @param deviceManagementService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceManagementService(final DeviceManagementService deviceManagementService) {\n+        this.deviceManagementService = Objects.requireNonNull(deviceManagementService);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceRegistrationInformationService} to use.\n+     *\n+     * @param deviceRegistrationInformationService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceRegistrationInformationService(final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "originalCommit": "00cb3f3823b046519c409716636186245451b471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MDk0NQ==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543190945", "bodyText": "Hmm. Good question. When refactoring I noticed that the implementation of the getRegistrationInformation method is slightly different from readDevice.\nI think (at least for MongoDb) it can be replaced but I didn't want to add this to the scope of this PR (especially as this will affect all registries then...)", "author": "fkaltner", "createdAt": "2020-12-15T09:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5MTQxNw==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543291417", "bodyText": "In particular, DeviceManagementService.readDevice() returns a Device object instance instead of just Json which should actually make implementation of the sendDelayedAutoProvisioningNotificationIfNeeded method easier as there is no need to parse Json ...\nSo, unless there is a more specific reason than\n\nthe implementation of the getRegistrationInformation method is slightly different from readDevice\n\nI think we should remove this field ...", "author": "sophokles73", "createdAt": "2020-12-15T12:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NzQzMg==", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543477432", "bodyText": "Done.", "author": "fkaltner", "createdAt": "2020-12-15T16:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw=="}], "type": "inlineReview"}, {"oid": "17ca3c0eecdddcbf232b78d8be26f83110efab39", "url": "https://github.com/eclipse/hono/commit/17ca3c0eecdddcbf232b78d8be26f83110efab39", "message": "Review suggestions sophokles73.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-15T09:47:02Z", "type": "commit"}, {"oid": "f643f81d4b3250748b14ea15f02daa578552ff7b", "url": "https://github.com/eclipse/hono/commit/f643f81d4b3250748b14ea15f02daa578552ff7b", "message": "Review suggestions sophokles73.\n\nSigned-off-by: Florian Kaltner <florian.kaltner@bosch.io>", "committedDate": "2020-12-15T16:07:25Z", "type": "commit"}]}