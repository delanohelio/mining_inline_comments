{"pr_number": 1379, "pr_title": "[#622] Improved concurrency behavior of RequestManager", "pr_createdAt": "2020-02-08T21:52:14Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1379", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MTY1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377491659", "bodyText": "the may interrup is ignored by intention?", "author": "cdietrich", "createdAt": "2020-02-11T08:23:27Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/AbstractRequest.java", "diffHunk": "@@ -10,17 +10,32 @@\n \n import java.util.concurrent.CompletableFuture;\n \n+import org.apache.log4j.Logger;\n+\n /**\n  * Abstract base type for read and write requests.\n  * \n  * @author kosyakov - Initial contribution and API\n  * @since 2.11\n  */\n public abstract class AbstractRequest<V> implements Runnable, Cancellable {\n+\t\n+\tprivate class ResultFuture extends CompletableFuture<V> {\n+\t\t@Override\n+\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {", "originalCommit": "a3fc1defb8d306a800363ff739c3f23c86ec262f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTAxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377495010", "bodyText": "Good point, I'll pass this on to the AbstractRequest.", "author": "szarnekow", "createdAt": "2020-02-11T08:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MTgwNA==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377491804", "bodyText": "package private by intention?", "author": "cdietrich", "createdAt": "2020-02-11T08:23:51Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/AbstractRequest.java", "diffHunk": "@@ -34,19 +49,42 @@\n \n \tprotected AbstractRequest(RequestManager requestManager) {\n \t\tthis.requestManager = requestManager;\n-\t\tthis.result = new CompletableFuture<>();\n-\t\tthis.cancelIndicator = new RequestCancelIndicator(this.result);\n+\t\tthis.result = new ResultFuture();\n+\t\tthis.cancelIndicator = new RequestCancelIndicator(this);\n+\t}\n+\n+\tvoid cancelResult() {", "originalCommit": "a3fc1defb8d306a800363ff739c3f23c86ec262f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTE4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377495181", "bodyText": "Yes, it was intentionally - but only for the local code. I'll make it protected.", "author": "szarnekow", "createdAt": "2020-02-11T08:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MzAwNA==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377493004", "bodyText": "no logging here?", "author": "cdietrich", "createdAt": "2020-02-11T08:27:01Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/WriteRequest.java", "diffHunk": "@@ -42,18 +42,23 @@ public void run() {\n \t\ttry {\n \t\t\tprevious.join();\n \t\t} catch (Throwable t) {\n-\t\t\t// We are not interested in results, only to make sure that all previous requests are finished before running next write request.\n+\t\t\tif (!requestManager.isCancelException(t)) {\n+\t\t\t\tLOG.error(\"Error during request: \", t);\n+\t\t\t}\n \t\t}\n \t\ttry {\n \t\t\tU intermediateResult = this.nonCancellable.apply();\n \t\t\tcancelIndicator.checkCanceled();\n-\t\t\tresult.complete(cancellable.apply(cancelIndicator, intermediateResult));\n+\t\t\tV writeResult = cancellable.apply(cancelIndicator, intermediateResult);\n+\t\t\tcomplete(writeResult);\n \t\t} catch (Throwable t) {\n-\t\t\tif (!requestManager.isCancelException(t)) {\n-\t\t\t\tLOG.error(\"Error during request: \", t);\n-\t\t\t}\n-\t\t\tresult.completeExceptionally(t);\n+\t\t\tcompleteExceptionally(t);", "originalCommit": "a3fc1defb8d306a800363ff739c3f23c86ec262f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTk1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377495955", "bodyText": "completeExceptionally will log. I'll rename the method to make it more obvious.", "author": "szarnekow", "createdAt": "2020-02-11T08:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MzAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTYzOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377495639", "bodyText": "We could also make the fields protected. What do you think?", "author": "szarnekow", "createdAt": "2020-02-11T08:34:09Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/RequestManager.java", "diffHunk": "@@ -51,18 +51,26 @@ public void shutdown() {\n \t\tparallel.shutdown();\n \t\tcancel();\n \t}\n+\t\n+\tprotected void setParallel(ExecutorService parallel) {", "originalCommit": "a3fc1defb8d306a800363ff739c3f23c86ec262f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NjA0Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r377496046", "bodyText": "am not sure. if prefer protected setter getter over protced fields", "author": "cdietrich", "createdAt": "2020-02-11T08:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTYzOQ=="}], "type": "inlineReview"}, {"oid": "b5cea66092538d28b26d8d764c2bdd6f6f169cb9", "url": "https://github.com/eclipse/xtext-core/commit/b5cea66092538d28b26d8d764c2bdd6f6f169cb9", "message": "Avoid warnings in test class: add synchronized modifier", "committedDate": "2020-02-11T11:03:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3MDIxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380270210", "bodyText": "Peculiar: xtend-gen code is not very efficient.", "author": "mark-christiaens", "createdAt": "2020-02-17T16:16:06Z", "path": "org.eclipse.xtext.testing/xtend-gen/org/eclipse/xtext/testing/AbstractLanguageServerTest.java", "diffHunk": "@@ -137,6 +138,62 @@\n @FinalFieldsConstructor\n @SuppressWarnings(\"all\")\n public abstract class AbstractLanguageServerTest implements Endpoint {\n+  /**\n+   * A request manager that will run the given read and write actions in the same thread immediatly, sequentially.\n+   */\n+  @Singleton\n+  public static class DirectRequestManager extends RequestManager {\n+    @Inject\n+    public DirectRequestManager(final OperationCanceledManager operationCanceledManager) {\n+      super(null, operationCanceledManager);\n+    }\n+    \n+    @Override\n+    public synchronized <V extends Object> CompletableFuture<V> runRead(final Function1<? super CancelIndicator, ? extends V> request) {\n+      final CompletableFuture<V> result = new CompletableFuture<V>();\n+      try {\n+        final CancelIndicator _function = () -> {\n+          return false;\n+        };\n+        result.complete(request.apply(_function));\n+      } catch (final Throwable _t) {\n+        if (_t instanceof Throwable) {", "originalCommit": "808ed37b22dffbf2a02a728be754b90b37e5e16f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwMTMxOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380601319", "bodyText": "True. That's why the non-test code was already ported to plain Java.", "author": "szarnekow", "createdAt": "2020-02-18T10:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3MDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2NTM4Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380565383", "bodyText": "underyling -> underlying", "author": "mark-christiaens", "createdAt": "2020-02-18T09:53:56Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/AbstractRequest.java", "diffHunk": "@@ -10,17 +10,32 @@\n \n import java.util.concurrent.CompletableFuture;\n \n+import org.apache.log4j.Logger;\n+\n /**\n  * Abstract base type for read and write requests.\n  * \n  * @author kosyakov - Initial contribution and API\n  * @since 2.11\n  */\n public abstract class AbstractRequest<V> implements Runnable, Cancellable {\n+\t\n+\tprivate class ResultFuture extends CompletableFuture<V> {\n+\t\t@Override\n+\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n+\t\t\tAbstractRequest.this.cancel(mayInterruptIfRunning);\n+\t\t\treturn isCancelled();\n+\t\t}\n+\n+\t\tvoid doCancel(boolean mayInterruptIfRunning) {\n+\t\t\tsuper.cancel(mayInterruptIfRunning);\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * The underyling future.", "originalCommit": "808ed37b22dffbf2a02a728be754b90b37e5e16f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzQ0MA==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380577440", "bodyText": "I'm not sure whether I understand it all but I think you are attempting to make sure that consumers of the readResult are canceled if the ReadRequest itself is canceled.  Suppose that a cancellation is requested after readResult is produced.  Then complete will go ahead  regardless since org.eclipse.xtext.ide.server.concurrent.AbstractRequest.cancel() doesn't cancel the ResultFuture?   Is that intended behaviour?", "author": "mark-christiaens", "createdAt": "2020-02-18T10:14:54Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/ReadRequest.java", "diffHunk": "@@ -21,33 +22,58 @@\n public class ReadRequest<V> extends AbstractRequest<V> {\n \tprivate static final Logger LOG = Logger.getLogger(ReadRequest.class);\n \n-\tprivate final Function1<? super CancelIndicator, ? extends V> cancellable;\n+\tprivate final Function1<? super CancelIndicator, ? extends V> readOperation;\n+\n+\t/**\n+\t * The initializer future allows to track the running state of this request, e.g. if it was already started or not.\n+\t */\n+\tprivate final CompletableFuture<Void> initializer;\n \n \tprivate final ExecutorService executor;\n \n-\tpublic ReadRequest(RequestManager requestManager, Function1<? super CancelIndicator, ? extends V> cancellable,\n+\tpublic ReadRequest(RequestManager requestManager, Function1<? super CancelIndicator, ? extends V> readOperation,\n \t\t\tExecutorService executor) {\n \t\tsuper(requestManager);\n-\t\tthis.cancellable = cancellable;\n+\t\tthis.readOperation = readOperation;\n \t\tthis.executor = executor;\n+\t\tthis.initializer = new CompletableFuture<>();\n+\t\tthis.initializer.thenRun(this::doRun);\n \t}\n-\n+\t\n+\t@Override\n+\tprotected void cancel(boolean mayInterruptIfRunning) {\n+\t\tsuper.cancel(mayInterruptIfRunning);\n+\t\tif (initializer.cancel(mayInterruptIfRunning)) {\n+\t\t\tcancelResult(mayInterruptIfRunning);\n+\t\t}\n+\t}\n+\t\n \t@Override\n \tpublic void run() {\n-\t\tif (result.isCancelled()) {\n+\t\tinitializer.complete(null);\n+\t}\n+\n+\tprivate void doRun() {\n+\t\tif (isDone()) {\n \t\t\treturn;\n \t\t}\n \t\tthis.executor.submit(() -> {\n \t\t\ttry {\n+\t\t\t\tif (isDone()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t\tcancelIndicator.checkCanceled();\n-\t\t\t\tresult.complete(cancellable.apply(cancelIndicator));\n+\t\t\t\tV readResult = readOperation.apply(cancelIndicator);\n+\t\t\t\tcomplete(readResult);", "originalCommit": "808ed37b22dffbf2a02a728be754b90b37e5e16f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwMzk0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380603949", "bodyText": "The line of thought was like this:\nConsumers of the readResult must wait until the read request is finished (normally or exceptionally), to ensure that we do not start a subsequent write request when there are still readers. Now that the readOperation did complete normally (let's say it ignored the cancelIndicator), it was considered to be ok to return the result independently from intermitted cancel attempts. Does that make sense or am I in weird state of mind?", "author": "szarnekow", "createdAt": "2020-02-18T11:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU4NTgwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380585801", "bodyText": "Is synchronized necessary here?  IIUIC then there is a single connection (socket) that is feeding us read and write commands.  I think therefore there is only one thread invoking runRead and runWrite in a nice, sequential way?", "author": "mark-christiaens", "createdAt": "2020-02-18T10:29:53Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/RequestManager.java", "diffHunk": "@@ -51,18 +55,26 @@ public void shutdown() {\n \t\tparallel.shutdown();\n \t\tcancel();\n \t}\n-\n+\t\n+\tprotected final OperationCanceledManager getOperationCanceledManager() {\n+\t\treturn operationCanceledManager;\n+\t}\n+\t\n+\tprotected final ExecutorService getParallelExecutorService() {\n+\t\treturn parallel;\n+\t}\n+\t\n \t/**\n \t * Run the given cancellable logic as a read request.\n \t */\n-\tpublic <V> CompletableFuture<V> runRead(Function1<? super CancelIndicator, ? extends V> cancellable) {\n+\tpublic synchronized <V> CompletableFuture<V> runRead(Function1<? super CancelIndicator, ? extends V> cancellable) {", "originalCommit": "808ed37b22dffbf2a02a728be754b90b37e5e16f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwMTc1NA==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380601754", "bodyText": "Client code (especially ExecuteCommandServices) can inject the RequestManager to trigger write requests from arbitrary threads. That's why we do need the sync here.", "author": "szarnekow", "createdAt": "2020-02-18T11:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU4NTgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NTc5NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1379#discussion_r380595795", "bodyText": "I'd rename previous to allPreviousRequestResults or something to clarify that it is a future that will block until all previous requests have yielded a result (and hence all computation for these previous results is concluded).", "author": "mark-christiaens", "createdAt": "2020-02-18T10:48:42Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/concurrent/WriteRequest.java", "diffHunk": "@@ -42,18 +42,23 @@ public void run() {\n \t\ttry {\n \t\t\tprevious.join();", "originalCommit": "808ed37b22dffbf2a02a728be754b90b37e5e16f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0de5cbb27e0d8b13b49542fa3c0ed849ef5277bb", "url": "https://github.com/eclipse/xtext-core/commit/0de5cbb27e0d8b13b49542fa3c0ed849ef5277bb", "message": "[#622] Improved concurrency behavior of RequestManager", "committedDate": "2020-02-23T13:16:15Z", "type": "forcePushed"}, {"oid": "5d26ea026a3b3ddc063b2b749cc944dcb86ad462", "url": "https://github.com/eclipse/xtext-core/commit/5d26ea026a3b3ddc063b2b749cc944dcb86ad462", "message": "[#622] Improved concurrency behavior of RequestManager", "committedDate": "2020-02-23T13:17:39Z", "type": "forcePushed"}, {"oid": "5d3aa4a6c2160af5735ee0203db3bd6b82acf2ea", "url": "https://github.com/eclipse/xtext-core/commit/5d3aa4a6c2160af5735ee0203db3bd6b82acf2ea", "message": "[#622] Improved concurrency behavior of RequestManager", "committedDate": "2020-02-23T13:21:02Z", "type": "forcePushed"}, {"oid": "839e4e01b98bf4564cf5156bd38b878ce724a79b", "url": "https://github.com/eclipse/xtext-core/commit/839e4e01b98bf4564cf5156bd38b878ce724a79b", "message": "[#622] Improved concurrency behavior of RequestManager", "committedDate": "2020-02-23T13:21:39Z", "type": "commit"}, {"oid": "839e4e01b98bf4564cf5156bd38b878ce724a79b", "url": "https://github.com/eclipse/xtext-core/commit/839e4e01b98bf4564cf5156bd38b878ce724a79b", "message": "[#622] Improved concurrency behavior of RequestManager", "committedDate": "2020-02-23T13:21:39Z", "type": "forcePushed"}]}