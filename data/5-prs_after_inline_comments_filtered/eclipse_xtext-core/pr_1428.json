{"pr_number": 1428, "pr_title": "[eclipse/xtext#1679] Refactor more Xtend to Java", "pr_createdAt": "2020-03-22T17:24:04Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1428", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDQ2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396120461", "bodyText": "Year 2018, 2020", "author": "nbhusare", "createdAt": "2020-03-22T17:38:04Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDc4OA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396120788", "bodyText": "Please remove this. from the lines - 73, 77, 81, 159, 162.", "author": "nbhusare", "createdAt": "2020-03-22T17:41:16Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTI1Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396121257", "bodyText": "Please format code.", "author": "nbhusare", "createdAt": "2020-03-22T17:45:53Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTg0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396121844", "bodyText": "Returns null if no portable URI can be constructed...", "author": "nbhusare", "createdAt": "2020-03-22T17:51:33Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTk1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396121955", "bodyText": "PS comments above.", "author": "nbhusare", "createdAt": "2020-03-22T17:52:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjExOA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122118", "bodyText": "Excessive ((", "author": "nbhusare", "createdAt": "2020-03-22T17:53:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif ((portableFragment != null)) {", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjI3MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122271", "bodyText": "Excessive ((", "author": "nbhusare", "createdAt": "2020-03-22T17:55:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif ((portableFragment != null)) {\n+\t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return a portable URI fragment, or <code>null</code> if the give EObject isn't itself or is not contained in an\n+\t *         exported EObjectDescription\n+\t */\n+\tprotected String getPortableURIFragment(EObject obj) {\n+\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n+\t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n+\t\tif ((desc == null)) {", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjUyOA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122528", "bodyText": "Did you purposefully use FluentIterable here?", "author": "nbhusare", "createdAt": "2020-03-22T17:57:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif ((portableFragment != null)) {\n+\t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return a portable URI fragment, or <code>null</code> if the give EObject isn't itself or is not contained in an\n+\t *         exported EObjectDescription\n+\t */\n+\tprotected String getPortableURIFragment(EObject obj) {\n+\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n+\t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n+\t\tif ((desc == null)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn FluentIterable.from(desc.getExportedObjects()).filter(description->{", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1NTg3NA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396255874", "bodyText": "In fact I did, but it was trivial to use Streams.stream instead.", "author": "szarnekow", "createdAt": "2020-03-23T07:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjczOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122739", "bodyText": "NL", "author": "nbhusare", "createdAt": "2020-03-22T18:00:24Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageProviderAdapter.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+\n+/**\n+ * An adapter that can be installed into a SerializableResource, to provide resource state. It is used with dirty\n+ * editors providing the dirty non persisted state to other editors.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageProviderAdapter extends AdapterImpl {\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn ResourceStorageProviderAdapter.class.equals(type);\n+\t}\n+\n+\tpublic ResourceStorageLoadable getResourceStorageLoadable(StorageAwareResource resource) {\n+\t\treturn null;\n+\t}\n+}", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjgxNA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122814", "bodyText": "2014, 2020", "author": "nbhusare", "createdAt": "2020-03-22T18:00:53Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2014 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjkxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122918", "bodyText": "this. not needed.\nreturn Collections.unmodifiableSet(this.sourceLevelURIs) -> return sourceLevelURIs", "author": "nbhusare", "createdAt": "2020-03-22T18:02:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2014 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * An adapter to be installed into a ResourceSet.\n+ * \n+ * It's used as a protocol to tell whether a StorageAwareResource should load from source or could load from serialized\n+ * data.\n+ * \n+ * @see ResourceStorageProviderAdapter\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SourceLevelURIsAdapter extends AdapterImpl {\n+\t\n+\tpublic static void setSourceLevelUris(ResourceSet resourceSet, Collection<URI> uris) {\n+\t\tSourceLevelURIsAdapter adapter = findOrCreateAdapter(resourceSet);\n+\t\tadapter.sourceLevelURIs = ImmutableSet.copyOf(uris);\n+\t}\n+\n+\tprotected static SourceLevelURIsAdapter findOrCreateAdapter(ResourceSet resourceSet) {\n+\t\tSourceLevelURIsAdapter adapter = findInstalledAdapter(resourceSet);\n+\t\tif (adapter != null) {\n+\t\t\treturn adapter;\n+\t\t}\n+\t\tadapter = new SourceLevelURIsAdapter();\n+\t\tresourceSet.eAdapters().add(adapter);\n+\t\treturn adapter;\n+\t}\n+\n+\t/**\n+\t * Installs the given set of URIs as the source level URIs. Does not copy the given set but uses it directly.\n+\t */\n+\tpublic static void setSourceLevelUrisWithoutCopy(ResourceSet resourceSet, Set<URI> uris) {\n+\t\tSourceLevelURIsAdapter adapter = findOrCreateAdapter(resourceSet);\n+\t\tadapter.sourceLevelURIs = uris;\n+\t}\n+\n+\tpublic static SourceLevelURIsAdapter findInstalledAdapter(ResourceSet resourceSet) {\n+\t\tfor (Adapter adapter : resourceSet.eAdapters()) {\n+\t\t\tif (adapter instanceof SourceLevelURIsAdapter) {\n+\t\t\t\treturn (SourceLevelURIsAdapter) adapter;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\t\n+\tprivate Set<URI> sourceLevelURIs;\n+\n+\tpublic Set<URI> getSourceLevelURIs() {\n+\t\treturn Collections.unmodifiableSet(this.sourceLevelURIs);", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1NjMwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396256308", "bodyText": "I'll still return the unmodifiableSet though.", "author": "szarnekow", "createdAt": "2020-03-23T07:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzEyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396123127", "bodyText": "2014, 2020", "author": "nbhusare", "createdAt": "2020-03-22T18:03:52Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzE4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396123185", "bodyText": "Please remove if there are no warnings in the code.", "author": "nbhusare", "createdAt": "2020-03-22T18:04:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+@SuppressWarnings(\"all\")", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzMwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396123301", "bodyText": "The Code inside the catch block looks incorrectly formatted.", "author": "nbhusare", "createdAt": "2020-03-22T18:05:41Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+@SuppressWarnings(\"all\")\n+public class StorageAwareResource extends LazyLinkingResource {\n+\tpublic static final String UNRESOLVABLE_FRAGMENT = \"UNRESOLVABLE\";\n+\n+\tprivate static final Logger LOG = Logger.getLogger(StorageAwareResource.class);\n+\n+\t@Inject(optional = true)\n+\tprivate IResourceStorageFacade resourceStorageFacade;\n+\n+\t@Inject\n+\tprivate PortableURIs portableURIs;\n+\n+\tprivate boolean isLoadedFromStorage = false;\n+\n+\tprivate IResourceDescription resourceDescription = null;\n+\n+\t@Override\n+\tpublic void load(Map<?, ?> options) throws IOException {\n+\t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n+\t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tResourceStorageLoadable in = resourceStorageFacade.getOrCreateResourceStorageLoadable(this);\n+\t\t\t\tloadFromStorage(in);\n+\t\t\t\treturn;\n+\t\t\t} catch (IOException e) {", "originalCommit": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "79e6a92b696d1d52b30ee0865794ba1c0163713f", "url": "https://github.com/eclipse/xtext-core/commit/79e6a92b696d1d52b30ee0865794ba1c0163713f", "message": "[eclipse/xtext#1679] Refactor more Xtend to Java", "committedDate": "2020-03-23T07:41:02Z", "type": "commit"}, {"oid": "79e6a92b696d1d52b30ee0865794ba1c0163713f", "url": "https://github.com/eclipse/xtext-core/commit/79e6a92b696d1d52b30ee0865794ba1c0163713f", "message": "[eclipse/xtext#1679] Refactor more Xtend to Java", "committedDate": "2020-03-23T07:41:02Z", "type": "forcePushed"}, {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "url": "https://github.com/eclipse/xtext-core/commit/a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "message": "Fix tests, added JavaDoc", "committedDate": "2020-03-23T07:45:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyMzg3Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397823872", "bodyText": "You might like to change the detailed message to the parameter 'storageInputStream' must not be null or something better.", "author": "nbhusare", "createdAt": "2020-03-25T12:43:37Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class StorageAwareResource extends LazyLinkingResource {\n+\tpublic static final String UNRESOLVABLE_FRAGMENT = \"UNRESOLVABLE\";\n+\n+\tprivate static final Logger LOG = Logger.getLogger(StorageAwareResource.class);\n+\n+\t@Inject(optional = true)\n+\tprivate IResourceStorageFacade resourceStorageFacade;\n+\n+\t@Inject\n+\tprivate PortableURIs portableURIs;\n+\n+\tprivate boolean isLoadedFromStorage = false;\n+\n+\tprivate IResourceDescription resourceDescription = null;\n+\n+\t@Override\n+\tpublic void load(Map<?, ?> options) throws IOException {\n+\t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n+\t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tResourceStorageLoadable in = resourceStorageFacade.getOrCreateResourceStorageLoadable(this);\n+\t\t\t\tloadFromStorage(in);\n+\t\t\t\treturn;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tif (contents != null) {\n+\t\t\t\t\tcontents.clear();\n+\t\t\t\t}\n+\t\t\t\tif (eAdapters != null) {\n+\t\t\t\t\teAdapters.clear();\n+\t\t\t\t}\n+\t\t\t\tunload();\n+\t\t\t}\n+\t\t}\n+\t\tsuper.load(options);\n+\t}\n+\n+\tpublic void loadFromStorage(ResourceStorageLoadable storageInputStream) throws IOException {\n+\t\tif (storageInputStream == null) {\n+\t\t\tthrow new NullPointerException(\"storageInputStream\");", "originalCommit": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNTA0Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397825042", "bodyText": "Please remove line.", "author": "nbhusare", "createdAt": "2020-03-25T12:45:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream( //\n+\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d -> {\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> if no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif (portableFragment != null) {\n+\t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return a portable URI fragment, or <code>null</code> if the give EObject isn't itself or is not contained in an\n+\t *         exported EObjectDescription\n+\t */\n+\tprotected String getPortableURIFragment(EObject obj) {\n+\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n+\t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n+\t\tif (desc == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n+", "originalCommit": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNjM2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397826361", "bodyText": "Please remove this on lines 158, and 161.", "author": "nbhusare", "createdAt": "2020-03-25T12:47:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);", "originalCommit": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzMzOA==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397827338", "bodyText": "Please add 2020 to the Copyright if you think its required.", "author": "nbhusare", "createdAt": "2020-03-25T12:49:38Z", "path": "org.eclipse.xtext.tests/xtend-gen/org/eclipse/xtext/resource/persistence/PortableURIsTest.java", "diffHunk": "@@ -22,6 +22,7 @@\n import org.eclipse.xtext.linking.langATestLanguage.Type;", "originalCommit": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NDA2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397864062", "bodyText": "Isn't this just done in LOG.debug?", "author": "tivervac", "createdAt": "2020-03-25T13:45:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class StorageAwareResource extends LazyLinkingResource {\n+\tpublic static final String UNRESOLVABLE_FRAGMENT = \"UNRESOLVABLE\";\n+\n+\tprivate static final Logger LOG = Logger.getLogger(StorageAwareResource.class);\n+\n+\t@Inject(optional = true)\n+\tprivate IResourceStorageFacade resourceStorageFacade;\n+\n+\t@Inject\n+\tprivate PortableURIs portableURIs;\n+\n+\tprivate boolean isLoadedFromStorage = false;\n+\n+\tprivate IResourceDescription resourceDescription = null;\n+\n+\t@Override\n+\tpublic void load(Map<?, ?> options) throws IOException {\n+\t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n+\t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled()) {", "originalCommit": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2383316e9447994b015ecba1d883c308442043a", "url": "https://github.com/eclipse/xtext-core/commit/d2383316e9447994b015ecba1d883c308442043a", "message": "Incorporated review feedback", "committedDate": "2020-03-25T15:06:42Z", "type": "commit"}, {"oid": "d2383316e9447994b015ecba1d883c308442043a", "url": "https://github.com/eclipse/xtext-core/commit/d2383316e9447994b015ecba1d883c308442043a", "message": "Incorporated review feedback", "committedDate": "2020-03-25T15:06:42Z", "type": "forcePushed"}]}