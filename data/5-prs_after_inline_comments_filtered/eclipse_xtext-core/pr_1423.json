{"pr_number": 1423, "pr_title": "[eclipse/xtext#1679] Refactor more Xtend to java.", "pr_createdAt": "2020-03-20T12:16:36Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1423", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyNjI2Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395626267", "bodyText": "Removing while iterating? This seems like a very bad plan", "author": "tivervac", "createdAt": "2020-03-20T13:13:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/preferences/PreferenceValuesByLanguage.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.preferences;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+\n+public class PreferenceValuesByLanguage {\n+\tprivate final Map<String, IPreferenceValues> preferencesByLanguage = new HashMap<>();\n+\n+\tpublic IPreferenceValues get(String languageId) {\n+\t\treturn preferencesByLanguage.get(languageId);\n+\t}\n+\n+\tpublic IPreferenceValues put(String languageId, IPreferenceValues values) {\n+\t\treturn preferencesByLanguage.put(languageId, values);\n+\t}\n+\n+\tpublic static PreferenceValuesByLanguage findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters())\n+\t\t\tif (adapter instanceof PreferenceValuesByLanguageAdapter)\n+\t\t\t\treturn ((PreferenceValuesByLanguageAdapter) adapter).get();\n+\t\treturn null;\n+\t}\n+\n+\tpublic static PreferenceValuesByLanguage removeFromEmfObject(Notifier emfObject) {\n+\t\tList<Adapter> adapters = emfObject.eAdapters();\n+\t\tfor (int i = 0, max = adapters.size(); i < max; i++) {\n+\t\t\tAdapter adapter = adapters.get(i);\n+\t\t\tif (adapter instanceof PreferenceValuesByLanguageAdapter) {\n+\t\t\t\temfObject.eAdapters().remove(i);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwODU0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396108549", "bodyText": "The code returns immediately after the removal, so it should be ok. EmfAdaptabel should stay like that to avoid unnecessary noise in other generated code.", "author": "szarnekow", "createdAt": "2020-03-22T15:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyNjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyNjU2OA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395626568", "bodyText": "This max isn't needed, we just need to use an iterator.", "author": "tivervac", "createdAt": "2020-03-20T13:13:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/preferences/PreferenceValuesByLanguage.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.preferences;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+\n+public class PreferenceValuesByLanguage {\n+\tprivate final Map<String, IPreferenceValues> preferencesByLanguage = new HashMap<>();\n+\n+\tpublic IPreferenceValues get(String languageId) {\n+\t\treturn preferencesByLanguage.get(languageId);\n+\t}\n+\n+\tpublic IPreferenceValues put(String languageId, IPreferenceValues values) {\n+\t\treturn preferencesByLanguage.put(languageId, values);\n+\t}\n+\n+\tpublic static PreferenceValuesByLanguage findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters())\n+\t\t\tif (adapter instanceof PreferenceValuesByLanguageAdapter)\n+\t\t\t\treturn ((PreferenceValuesByLanguageAdapter) adapter).get();\n+\t\treturn null;\n+\t}\n+\n+\tpublic static PreferenceValuesByLanguage removeFromEmfObject(Notifier emfObject) {\n+\t\tList<Adapter> adapters = emfObject.eAdapters();\n+\t\tfor (int i = 0, max = adapters.size(); i < max; i++) {", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwODc0Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396108743", "bodyText": "It's pretty much the coding style that is used in org.eclipse.emf.ecore.util.EcoreUtil.getAdapter(List<Adapter>, Object) - apart from the fact that instanceof is used rather than isAdapterForType", "author": "szarnekow", "createdAt": "2020-03-22T15:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE1MDY3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399150677", "bodyText": "Will remove the max.", "author": "ArneDeutsch", "createdAt": "2020-03-27T09:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyNjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMDA4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395630085", "bodyText": "Unneeded final", "author": "tivervac", "createdAt": "2020-03-20T13:19:58Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/OutdatedStateManager.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.service.OperationCanceledError;\n+import org.eclipse.xtext.service.OperationCanceledManager;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.util.concurrent.CancelableUnitOfWork;\n+import org.eclipse.xtext.util.concurrent.IUnitOfWork;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class OutdatedStateManager {\n+\t@Inject\n+\tprivate OperationCanceledManager canceledManager;\n+\n+\tprivate final ThreadLocal<Boolean> cancelationAllowed = new ThreadLocal<Boolean>() {\n+\t\t@Override\n+\t\tpublic Boolean initialValue() {\n+\t\t\treturn Boolean.valueOf(true);\n+\t\t}\n+\t};\n+\n+\t/**\n+\t * Created a fresh CancelIndicator\n+\t */\n+\tpublic CancelIndicator newCancelIndicator(ResourceSet rs) {\n+\t\tif (rs instanceof XtextResourceSet) {\n+\t\t\tboolean isCancelationAllowed = cancelationAllowed.get().booleanValue();\n+\t\t\tXtextResourceSet xtextRs = (XtextResourceSet) rs;\n+\t\t\tint current = xtextRs.getModificationStamp();\n+\t\t\treturn () -> isCancelationAllowed && (xtextRs.isOutdated() || current != xtextRs.getModificationStamp());\n+\t\t} else {\n+\t\t\treturn CancelIndicator.NullImpl;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks whether the given ResourceSet is in an outdated state and throws an {@link OperationCanceledError} if so.\n+\t */\n+\tpublic void checkCanceled(final ResourceSet rs) {", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMDY0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395630649", "bodyText": "Update date", "author": "tivervac", "createdAt": "2020-03-20T13:20:57Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/ResourceServiceProviderServiceLoader.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2016 TypeFox GmbH (http://www.typefox.io) and others.", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMDk5OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395630999", "bodyText": "Can be final", "author": "tivervac", "createdAt": "2020-03-20T13:21:37Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/ResourceServiceProviderServiceLoader.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2016 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource;\n+\n+import java.util.ServiceLoader;\n+\n+import org.eclipse.xtext.ISetup;\n+import org.eclipse.xtext.resource.IResourceServiceProvider.Registry;\n+import org.eclipse.xtext.resource.impl.ResourceServiceProviderRegistryImpl;\n+\n+import com.google.inject.Injector;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+@Singleton\n+public class ResourceServiceProviderServiceLoader implements Provider<Registry> {\n+\t\n+\tprivate ServiceLoader<ISetup> setupLoader = ServiceLoader.load(ISetup.class);\n+\n+\tprivate Registry registry = loadRegistry();", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMTI1Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395631252", "bodyText": "Can be final, not sure if it's allowed to be static?", "author": "tivervac", "createdAt": "2020-03-20T13:22:02Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/ResourceServiceProviderServiceLoader.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2016 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource;\n+\n+import java.util.ServiceLoader;\n+\n+import org.eclipse.xtext.ISetup;\n+import org.eclipse.xtext.resource.IResourceServiceProvider.Registry;\n+import org.eclipse.xtext.resource.impl.ResourceServiceProviderRegistryImpl;\n+\n+import com.google.inject.Injector;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+@Singleton\n+public class ResourceServiceProviderServiceLoader implements Provider<Registry> {\n+\t\n+\tprivate ServiceLoader<ISetup> setupLoader = ServiceLoader.load(ISetup.class);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE1MTkxNA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399151914", "bodyText": "Will make it final only.", "author": "ArneDeutsch", "createdAt": "2020-03-27T09:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMTI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMTk2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395631961", "bodyText": "Unneeded this, this can be fixed using cleanup actions normally", "author": "tivervac", "createdAt": "2020-03-20T13:23:16Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/LiveShadowedChunkedContainer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.containers;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.LiveShadowedChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author koehnlein - Initial contribution and API\n+ * @since 2.14\n+ */\n+@Beta\n+public class LiveShadowedChunkedContainer implements IContainer {\n+\tprivate final LiveShadowedChunkedResourceDescriptions descriptions;\n+\n+\tprivate final String containerName;\n+\n+\tprivate IProjectConfig projectConfig;\n+\n+\tprivate boolean isProjectConfigSet = false;\n+\n+\tpublic LiveShadowedChunkedContainer(LiveShadowedChunkedResourceDescriptions descriptions, String containerName) {\n+\t\tthis.descriptions = descriptions;\n+\t\tthis.containerName = containerName;\n+\t}\n+\n+\tprotected ChunkedResourceDescriptions getChunkedResourceDescriptions() {\n+\t\treturn (ChunkedResourceDescriptions) descriptions.getGlobalDescriptions();\n+\t}\n+\n+\tprotected IProjectConfig getProjectConfig() {\n+\t\tif (!isProjectConfigSet) {\n+\t\t\tprojectConfig = descriptions.getWorkspaceConfig() == null ? null\n+\t\t\t\t\t: descriptions.getWorkspaceConfig().findProjectByName(this.containerName);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE1MjcxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399152710", "bodyText": "Don't like that my code gets modified when I save. Usually have them disabled. But thx for the hint.", "author": "ArneDeutsch", "createdAt": "2020-03-27T10:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMTk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMjQzOA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395632438", "bodyText": "@szarnekow should this be volatile? i.e. is this accessed in a multithreaded way?", "author": "tivervac", "createdAt": "2020-03-20T13:24:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/LiveShadowedChunkedContainer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.containers;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.LiveShadowedChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author koehnlein - Initial contribution and API\n+ * @since 2.14\n+ */\n+@Beta\n+public class LiveShadowedChunkedContainer implements IContainer {\n+\tprivate final LiveShadowedChunkedResourceDescriptions descriptions;\n+\n+\tprivate final String containerName;\n+\n+\tprivate IProjectConfig projectConfig;\n+\n+\tprivate boolean isProjectConfigSet = false;", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTA0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396109048", "bodyText": "I don't think so. If the field projectConfig was Optional<IProjectConfig>, the boolean flag could become obsolete. So it's just a locally cached init state.", "author": "szarnekow", "createdAt": "2020-03-22T15:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMjQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzMjc0NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395632745", "bodyText": "That's the same as Collections.emptyList() right?", "author": "tivervac", "createdAt": "2020-03-20T13:24:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/LiveShadowedChunkedContainer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.containers;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.LiveShadowedChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author koehnlein - Initial contribution and API\n+ * @since 2.14\n+ */\n+@Beta\n+public class LiveShadowedChunkedContainer implements IContainer {\n+\tprivate final LiveShadowedChunkedResourceDescriptions descriptions;\n+\n+\tprivate final String containerName;\n+\n+\tprivate IProjectConfig projectConfig;\n+\n+\tprivate boolean isProjectConfigSet = false;\n+\n+\tpublic LiveShadowedChunkedContainer(LiveShadowedChunkedResourceDescriptions descriptions, String containerName) {\n+\t\tthis.descriptions = descriptions;\n+\t\tthis.containerName = containerName;\n+\t}\n+\n+\tprotected ChunkedResourceDescriptions getChunkedResourceDescriptions() {\n+\t\treturn (ChunkedResourceDescriptions) descriptions.getGlobalDescriptions();\n+\t}\n+\n+\tprotected IProjectConfig getProjectConfig() {\n+\t\tif (!isProjectConfigSet) {\n+\t\t\tprojectConfig = descriptions.getWorkspaceConfig() == null ? null\n+\t\t\t\t\t: descriptions.getWorkspaceConfig().findProjectByName(this.containerName);\n+\t\t\tisProjectConfigSet = true;\n+\t\t}\n+\t\treturn projectConfig;\n+\t}\n+\n+\tprotected ResourceDescriptionsData getChunk() {\n+\t\tResourceDescriptionsData container = getChunkedResourceDescriptions().getContainer(containerName);\n+\t\tif (container != null)\n+\t\t\treturn container;\n+\t\treturn new ResourceDescriptionsData(Collections.unmodifiableList(new ArrayList<>()));", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNjE0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395636149", "bodyText": "Few unneeded this in this file", "author": "tivervac", "createdAt": "2020-03-20T13:30:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/ChunkedResourceDescriptions.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.impl;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.containers.ProjectDescriptionBasedContainerManager;\n+import org.eclipse.xtext.resource.persistence.SerializableResourceDescription;\n+import org.eclipse.xtext.xbase.lib.ExclusiveRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * A IResourceDescriptions implementation that holds its resource description in chunks, each identified by a string.\n+ * The strings represent units such as projects, source sets, and libraries.\n+ * \n+ * @see ProjectDescription\n+ * @see ProjectDescriptionBasedContainerManager\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+public class ChunkedResourceDescriptions extends AbstractCompoundSelectable\n+\t\timplements IResourceDescriptions, Externalizable {\n+\n+\tprotected ConcurrentHashMap<String, ResourceDescriptionsData> chunk2resourceDescriptions = new ConcurrentHashMap<>();\n+\tprotected ResourceSet resourceSet;\n+\n+\tpublic ChunkedResourceDescriptions() {\n+\t}\n+\n+\tpublic ChunkedResourceDescriptions(Map<String, ResourceDescriptionsData> initialData) {\n+\t\tchunk2resourceDescriptions = new ConcurrentHashMap<>(initialData);\n+\t}\n+\n+\tpublic ChunkedResourceDescriptions(Map<String, ResourceDescriptionsData> initialData, ResourceSet resourceSet) {\n+\t\tthis(initialData);\n+\t\tsetResourceSet(resourceSet);\n+\t}\n+\n+\t/**\n+\t * Creates a shallow copy of the resource descriptions map and installs it with the given ResourceSet.\n+\t */\n+\tpublic ChunkedResourceDescriptions createShallowCopyWith(ResourceSet resourceSet) {\n+\t\treturn new ChunkedResourceDescriptions(chunk2resourceDescriptions, resourceSet);\n+\t}\n+\n+\tpublic ResourceSet getResourceSet() {\n+\t\treturn this.resourceSet;", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE1NDAzNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399154035", "bodyText": "Only one ... the others are needed to avoid name clashes.", "author": "ArneDeutsch", "createdAt": "2020-03-27T10:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNzE5NA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395637194", "bodyText": "Same code, just use an iterator", "author": "tivervac", "createdAt": "2020-03-20T13:32:01Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/ChunkedResourceDescriptions.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.impl;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.containers.ProjectDescriptionBasedContainerManager;\n+import org.eclipse.xtext.resource.persistence.SerializableResourceDescription;\n+import org.eclipse.xtext.xbase.lib.ExclusiveRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * A IResourceDescriptions implementation that holds its resource description in chunks, each identified by a string.\n+ * The strings represent units such as projects, source sets, and libraries.\n+ * \n+ * @see ProjectDescription\n+ * @see ProjectDescriptionBasedContainerManager\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+public class ChunkedResourceDescriptions extends AbstractCompoundSelectable\n+\t\timplements IResourceDescriptions, Externalizable {\n+\n+\tprotected ConcurrentHashMap<String, ResourceDescriptionsData> chunk2resourceDescriptions = new ConcurrentHashMap<>();\n+\tprotected ResourceSet resourceSet;\n+\n+\tpublic ChunkedResourceDescriptions() {\n+\t}\n+\n+\tpublic ChunkedResourceDescriptions(Map<String, ResourceDescriptionsData> initialData) {\n+\t\tchunk2resourceDescriptions = new ConcurrentHashMap<>(initialData);\n+\t}\n+\n+\tpublic ChunkedResourceDescriptions(Map<String, ResourceDescriptionsData> initialData, ResourceSet resourceSet) {\n+\t\tthis(initialData);\n+\t\tsetResourceSet(resourceSet);\n+\t}\n+\n+\t/**\n+\t * Creates a shallow copy of the resource descriptions map and installs it with the given ResourceSet.\n+\t */\n+\tpublic ChunkedResourceDescriptions createShallowCopyWith(ResourceSet resourceSet) {\n+\t\treturn new ChunkedResourceDescriptions(chunk2resourceDescriptions, resourceSet);\n+\t}\n+\n+\tpublic ResourceSet getResourceSet() {\n+\t\treturn this.resourceSet;\n+\t}\n+\n+\tprotected void setResourceSet(ResourceSet resourceSet) {\n+\t\tif (this.resourceSet != null)\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"This \" + getClass().getName() + \" is already associated with a different resource set.\");\n+\t\tif (ChunkedResourceDescriptions.findInEmfObject(resourceSet) != null)\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"There is already a different \" + getClass().getName() + \" installed in the given resource set.\");\n+\t\tthis.resourceSet = resourceSet;\n+\t\tattachToEmfObject(resourceSet);\n+\t}\n+\n+\tpublic ResourceDescriptionsData setContainer(String name, ResourceDescriptionsData descriptions) {\n+\t\treturn chunk2resourceDescriptions.put(name, descriptions);\n+\t}\n+\n+\tpublic ResourceDescriptionsData removeContainer(String name) {\n+\t\treturn chunk2resourceDescriptions.remove(name);\n+\t}\n+\n+\t@Override\n+\tprotected Iterable<? extends ISelectable> getSelectables() {\n+\t\treturn chunk2resourceDescriptions.values();\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IResourceDescription> getAllResourceDescriptions() {\n+\t\treturn concat(map(chunk2resourceDescriptions.values(), it -> it.getAllResourceDescriptions()));\n+\t}\n+\n+\t@Override\n+\tpublic IResourceDescription getResourceDescription(URI uri) {\n+\t\tfor (ResourceDescriptionsData selectable : chunk2resourceDescriptions.values()) {\n+\t\t\tIResourceDescription result = selectable.getResourceDescription(uri);\n+\t\t\tif (result != null)\n+\t\t\t\treturn result;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic ResourceDescriptionsData getContainer(URI uri) {\n+\t\tfor (ResourceDescriptionsData container : chunk2resourceDescriptions.values()) {\n+\t\t\tIResourceDescription description = container.getResourceDescription(uri);\n+\t\t\tif (description != null)\n+\t\t\t\treturn container;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic ResourceDescriptionsData getContainer(String containerHandle) {\n+\t\treturn chunk2resourceDescriptions.get(containerHandle);\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unused\")\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tint numChunks = in.readInt();\n+\t\tfor (Integer i : new ExclusiveRange(0, numChunks, true)) {\n+\t\t\tString chunkName = in.readUTF();\n+\t\t\tint numDescriptions = in.readInt();\n+\t\t\tList<IResourceDescription> descriptions = new ArrayList<IResourceDescription>(numDescriptions);\n+\t\t\tfor (Integer j : new ExclusiveRange(0, numDescriptions, true))\n+\t\t\t\tdescriptions.add((IResourceDescription) in.readObject());\n+\t\t\tchunk2resourceDescriptions.put(chunkName, new ResourceDescriptionsData(descriptions));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\tMap<String, ResourceDescriptionsData> copy = new HashMap<>(chunk2resourceDescriptions);\n+\t\tout.writeInt(copy.entrySet().size());\n+\t\tfor (Entry<String, ResourceDescriptionsData> entry : copy.entrySet()) {\n+\t\t\tout.writeUTF(entry.getKey());\n+\t\t\tIterable<Object> descriptions = map(entry.getValue().getAllResourceDescriptions(),\n+\t\t\t\t\td -> d instanceof Serializable ? d : SerializableResourceDescription.createCopy(d));\n+\t\t\tout.writeInt(IterableExtensions.size(descriptions));\n+\t\t\tfor (Object d : descriptions)\n+\t\t\t\tout.writeObject(d);\n+\t\t}\n+\t}\n+\n+\tpublic static ChunkedResourceDescriptions findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof ChunkedResourceDescriptionsAdapter)\n+\t\t\t\treturn ((ChunkedResourceDescriptionsAdapter) adapter).get();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static ChunkedResourceDescriptions removeFromEmfObject(Notifier emfObject) {\n+\t\tList<Adapter> adapters = emfObject.eAdapters();\n+\t\tfor (int i = 0, max = adapters.size(); i < max; i++) {\n+\t\t\tAdapter adapter = adapters.get(i);\n+\t\t\tif (adapter instanceof ChunkedResourceDescriptionsAdapter) {\n+\t\t\t\temfObject.eAdapters().remove(i);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNzU2NA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395637564", "bodyText": "s/expected/Expected/", "author": "tivervac", "createdAt": "2020-03-20T13:32:38Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/ProjectDescriptionBasedContainerManager.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.containers;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.LiveShadowedChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsBasedContainer;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+public class ProjectDescriptionBasedContainerManager implements IContainer.Manager {\n+\tpublic boolean shouldUseProjectDescriptionBasedContainers(IResourceDescriptions resourceDescriptions) {\n+\t\tChunkedResourceDescriptions descriptions = getChunkedResourceDescriptions(resourceDescriptions);\n+\t\treturn (descriptions != null && descriptions.getResourceSet() != null\n+\t\t\t\t&& ProjectDescription.findInEmfObject(descriptions.getResourceSet()) != null);\n+\t}\n+\n+\t@Override\n+\tpublic IContainer getContainer(IResourceDescription desc, IResourceDescriptions resourceDescriptions) {\n+\t\tChunkedResourceDescriptions descriptions = getChunkedResourceDescriptions(resourceDescriptions);\n+\t\tif (descriptions == null)\n+\t\t\tthrow new IllegalArgumentException(\"expected \" + ChunkedResourceDescriptions.class.getName());\n+\t\treturn createContainer(resourceDescriptions, descriptions,\n+\t\t\t\tProjectDescription.findInEmfObject(descriptions.getResourceSet()).getName());\n+\t}\n+\n+\t@Override\n+\tpublic List<IContainer> getVisibleContainers(IResourceDescription desc,\n+\t\t\tIResourceDescriptions resourceDescriptions) {\n+\t\tChunkedResourceDescriptions descriptions = getChunkedResourceDescriptions(resourceDescriptions);\n+\t\tif (descriptions == null)\n+\t\t\tthrow new IllegalArgumentException(\"expected \" + ChunkedResourceDescriptions.class.getName());", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzODkxMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395638911", "bodyText": "Useless in Java", "author": "tivervac", "createdAt": "2020-03-20T13:34:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/LiveShadowedChunkedResourceDescriptions.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Copyright (c) 2011, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.impl;\n+\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.IProjectConfigProvider;\n+import org.eclipse.xtext.workspace.IWorkspaceConfig;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Jan Koehnlein - Initial contribution and API\n+ * @since 2.14\n+ */\n+public class LiveShadowedChunkedResourceDescriptions extends LiveShadowedResourceDescriptions {\n+\t@Inject(optional = true)\n+\tprivate IProjectConfigProvider projectConfigProvider;\n+\n+\tprivate IWorkspaceConfig workspaceConfig;\n+\n+\t@Override\n+\tpublic void setContext(Notifier ctx) {\n+\t\tResourceSetBasedResourceDescriptions localDescriptions = (ResourceSetBasedResourceDescriptions) getLocalDescriptions();\n+\t\tlocalDescriptions.setContext(ctx);\n+\t\tlocalDescriptions.setData(null);\n+\t\tResourceSet resourceSet = EcoreUtil2.getResourceSet(ctx);\n+\t\tsetGlobalDescriptions(ChunkedResourceDescriptions.findInEmfObject(resourceSet));\n+\t\tif (projectConfigProvider == null) {\n+\t\t\tworkspaceConfig = null;\n+\t\t} else {\n+\t\t\tIProjectConfig projectConfig = projectConfigProvider.getProjectConfig(resourceSet);\n+\t\t\tworkspaceConfig = projectConfig == null ? null : projectConfig.getWorkspaceConfig();\n+\t\t}\n+\t}\n+\n+\t@Pure", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzOTA4OA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395639088", "bodyText": "Update date", "author": "tivervac", "createdAt": "2020-03-20T13:35:13Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/ProjectDescription.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2015, 2017 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzOTI4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395639282", "bodyText": "Iterator please", "author": "tivervac", "createdAt": "2020-03-20T13:35:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/ProjectDescription.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2015, 2017 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+public class ProjectDescription {\n+\n+\t/**\n+\t * A unique name for this project\n+\t */\n+\tprivate String name;\n+\n+\t/**\n+\t * list of logical names of upstream dependencies\n+\t */\n+\tprivate List<String> dependencies = new ArrayList<>();\n+\n+\tpublic static ProjectDescription findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof ProjectDescriptionAdapter)\n+\t\t\t\treturn ((ProjectDescriptionAdapter) adapter).get();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static ProjectDescription removeFromEmfObject(Notifier emfObject) {\n+\t\tList<Adapter> adapters = emfObject.eAdapters();\n+\t\tfor (int i = 0, max = adapters.size(); i < max; i++) {\n+\t\t\tAdapter adapter = adapters.get(i);\n+\t\t\tif (adapter instanceof ProjectDescriptionAdapter) {\n+\t\t\t\temfObject.eAdapters().remove(i);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTE1MA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395641150", "bodyText": "Please also update @EmfAdaptable", "author": "tivervac", "createdAt": "2020-03-20T13:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzOTI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTczNA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396109734", "bodyText": "No, please don't.\nCatfight :)", "author": "szarnekow", "createdAt": "2020-03-22T16:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzOTI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE1NjQyNA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399156424", "bodyText": "I have removed the max but stay with ordinary for loop. Hope all can live with that (MIAOU).", "author": "ArneDeutsch", "createdAt": "2020-03-27T10:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzOTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0Mjk5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r395642992", "bodyText": "More of the same", "author": "tivervac", "createdAt": "2020-03-20T13:41:33Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/xtext/FlattenedGrammarAccess.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.CompoundElement;\n+import org.eclipse.xtext.Condition;\n+import org.eclipse.xtext.EnumRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Group;\n+import org.eclipse.xtext.Parameter;\n+import org.eclipse.xtext.ParserRule;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.XtextPackage;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class FlattenedGrammarAccess {\n+\tprivate final Grammar flattenedGrammar;\n+\n+\tpublic FlattenedGrammarAccess(RuleNames names, RuleFilter filter) {\n+\t\tGrammar grammar = names.getContextGrammar();\n+\t\tGrammar flattenedGrammar = copy(grammar);\n+\t\tflattenedGrammar.setName(grammar.getName());\n+\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy = new LinkedHashMap<>();\n+\t\tList<AbstractRule> copies = copyRuleStubs(names, origToCopy, filter.getRules(grammar),\n+\t\t\t\tfilter.isDiscardRuleTypeRef());\n+\t\taddAll(flattenedGrammar.getRules(), copies);\n+\t\tMultimap<TerminalRule, AbstractRule> calledFrom = copyRuleBodies(copies, origToCopy);\n+\t\tsetHiddenTokens(flattenedGrammar, grammar, origToCopy);\n+\t\tmarkAsFragment(calledFrom);\n+\t\tif (filter.isDiscardUnreachableRules()) {\n+\t\t\tSet<AbstractRule> usedRules = new HashSet<>();\n+\t\t\tif (!filter.isDiscardTerminalRules())\n+\t\t\t\tusedRules.addAll(GrammarUtil.allTerminalRules(flattenedGrammar));\n+\t\t\tUsedRulesFinder finder = new UsedRulesFinder(usedRules);\n+\t\t\tfinder.compute(flattenedGrammar);\n+\t\t\tflattenedGrammar.getRules().retainAll(usedRules);\n+\t\t}\n+\t\tthis.flattenedGrammar = flattenedGrammar;\n+\t\tnew OriginalGrammar(grammar).attachToEmfObject(flattenedGrammar);\n+\t}\n+\n+\tprivate void setHiddenTokens(Grammar copy, Grammar orig, Map<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tif (orig == null) {\n+\t\t\tcopy.setDefinesHiddenTokens(true);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!orig.isDefinesHiddenTokens()) {\n+\t\t\tsetHiddenTokens(copy, head(orig.getUsedGrammars()), origToCopy);\n+\t\t\treturn;\n+\t\t}\n+\t\tcopy.setDefinesHiddenTokens(true);\n+\t\taddAll(copy.getHiddenTokens(), ListExtensions.map(orig.getHiddenTokens(),\n+\t\t\t\thidden -> origToCopy.get(new RuleWithParameterValues(hidden))));\n+\t}\n+\n+\tprivate void markAsFragment(Multimap<TerminalRule, AbstractRule> calledFrom) {\n+\t\tfilter(filter(filter(calledFrom.keySet(), it -> !it.isFragment()),\n+\t\t\t\tit -> allAreTerminalRules(calledFrom.get(it))),\n+\t\t\t\tit -> !((Grammar) it.eContainer()).getHiddenTokens().contains(it)).forEach(it -> it.setFragment(true));\n+\t}\n+\n+\tprivate Multimap<TerminalRule, AbstractRule> copyRuleBodies(List<AbstractRule> copies,\n+\t\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tHashMultimap<TerminalRule, AbstractRule> calledFrom = HashMultimap.create();\n+\t\tfor (AbstractRule copy : copies) {\n+\t\t\tAbstractRule orig = RuleWithParameterValues.getOriginalRule(copy);\n+\t\t\tSet<Parameter> paramValues = RuleWithParameterValues.getParamValues(copy);\n+\t\t\t@SuppressWarnings(\"serial\")\n+\t\t\tEcoreUtil.Copier copier = new EcoreUtil.Copier() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void copyReference(EReference eReference, EObject eObject, EObject copyEObject) {\n+\t\t\t\t\tif (XtextPackage.Literals.RULE_CALL__RULE == eReference) {\n+\t\t\t\t\t\tRuleCall origRuleCall = (RuleCall) eObject;\n+\t\t\t\t\t\tRuleCall copyRuleCall = (RuleCall) copyEObject;\n+\t\t\t\t\t\tAbstractRule calledCopy = origToCopy.get(new RuleWithParameterValues(origRuleCall.getRule(),\n+\t\t\t\t\t\t\t\tgetParameterConfig(origRuleCall, copyRuleCall)));\n+\t\t\t\t\t\tcopyRuleCall.setRule(calledCopy);\n+\t\t\t\t\t\tif (calledCopy instanceof TerminalRule)\n+\t\t\t\t\t\t\tcalledFrom.put(((TerminalRule) calledCopy), copy);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsuper.copyReference(eReference, eObject, copyEObject);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tSet<Parameter> getParameterConfig(RuleCall origRuleCall, RuleCall copyRuleCall) {\n+\t\t\t\t\tif (origRuleCall.getArguments().isEmpty())\n+\t\t\t\t\t\treturn Collections.emptySet();\n+\t\t\t\t\treturn toSet(map(filter(origRuleCall.getArguments(), it -> evaluate(it.getValue())),\n+\t\t\t\t\t\t\tit -> it.getParameter()));\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tprotected void copyContainment(EReference eReference, EObject eObject, EObject copyEObject) {\n+\t\t\t\t\tif (XtextPackage.Literals.RULE_CALL__ARGUMENTS == eReference\n+\t\t\t\t\t\t\t|| XtextPackage.Literals.GROUP__GUARD_CONDITION == eReference)\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tsuper.copyContainment(eReference, eObject, copyEObject);\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic EObject copy(EObject eObject) {\n+\t\t\t\t\tif (eObject instanceof Group && ((Group) eObject).getGuardCondition() != null\n+\t\t\t\t\t\t\t&& !evaluate(((Group) eObject).getGuardCondition()))\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\tEObject result = super.copy(eObject);\n+\t\t\t\t\tif (result instanceof CompoundElement) {\n+\t\t\t\t\t\tCompoundElement compoundElement = (CompoundElement) result;\n+\t\t\t\t\t\tList<AbstractElement> elements = compoundElement.getElements();\n+\t\t\t\t\t\tif (elements.size() == 1) {\n+\t\t\t\t\t\t\tif (!compoundElement.isFirstSetPredicated() && !compoundElement.isPredicated()) {\n+\t\t\t\t\t\t\t\tAbstractElement firstElement = elements.get(0);\n+\t\t\t\t\t\t\t\tmergeCardinalities(firstElement, compoundElement);\n+\t\t\t\t\t\t\t\tmergePredicates(firstElement, compoundElement);\n+\t\t\t\t\t\t\t\treturn firstElement;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tAbstractElement firstElement = elements.get(0);\n+\t\t\t\t\t\t\t\tmergePredicates(compoundElement, firstElement);\n+\t\t\t\t\t\t\t\tfirstElement.setFirstSetPredicated(false);\n+\t\t\t\t\t\t\t\tfirstElement.setPredicated(false);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ((eObject instanceof AbstractElement)) {\n+\t\t\t\t\t\tAbstractElement abstractElement = (AbstractElement) eObject;\n+\t\t\t\t\t\tif (!abstractElement.eClass().equals(result.eClass())) {\n+\t\t\t\t\t\t\tthrow new IllegalStateException(\"copy is: \\'\" + result.eClass().getName()\n+\t\t\t\t\t\t\t\t\t+ \"\\' but original was: \\'\" + abstractElement.eClass().getName() + \"\\'\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tnew OriginalElement(abstractElement).attachToEmfObject(result);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\n+\t\t\t\tvoid mergePredicates(AbstractElement into, AbstractElement from) {\n+\t\t\t\t\tif (from.isPredicated()) {\n+\t\t\t\t\t\tinto.setPredicated(true);\n+\t\t\t\t\t\tinto.setFirstSetPredicated(false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!into.isPredicated() && from.isFirstSetPredicated())\n+\t\t\t\t\t\t\tinto.setFirstSetPredicated(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tvoid mergeCardinalities(AbstractElement into, AbstractElement from) {\n+\t\t\t\t\tString c1 = into.getCardinality();\n+\t\t\t\t\tString c2 = from.getCardinality();\n+\t\t\t\t\tString resultCardinality = c1 == null ? c2 : c1;\n+\t\t\t\t\tif ((\"*\".equals(c1) || \"*\".equals(c2)) || (\"+\".equals(c1) && \"?\".equals(c2))\n+\t\t\t\t\t\t\t|| (\"?\".equals(c1) && \"+\".equals(c2)))\n+\t\t\t\t\t\tresultCardinality = \"*\";\n+\t\t\t\t\tinto.setCardinality(resultCardinality);\n+\t\t\t\t}\n+\n+\t\t\t\tboolean evaluate(final Condition condition) {\n+\t\t\t\t\treturn new ConditionEvaluator(paramValues).evaluate(condition);\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tAbstractElement copiedBody = (AbstractElement) copier.copy(orig.getAlternatives());\n+\t\t\tcopier.copyReferences();\n+\t\t\tcopy.setAlternatives(copiedBody);\n+\t\t\tif (orig instanceof ParserRule) {\n+\t\t\t\tParserRule castedCopy = ((ParserRule) copy);\n+\t\t\t\tif (((ParserRule) orig).isDefinesHiddenTokens()) {\n+\t\t\t\t\tcastedCopy.setDefinesHiddenTokens(true);\n+\t\t\t\t\tfor (AbstractRule rule : ((ParserRule) orig).getHiddenTokens()) {\n+\t\t\t\t\t\tAbstractRule copiedTerminalRule = origToCopy.get(new RuleWithParameterValues(rule));\n+\t\t\t\t\t\tcastedCopy.getHiddenTokens().add(copiedTerminalRule);\n+\t\t\t\t\t\tcalledFrom.put((TerminalRule) copiedTerminalRule, castedCopy);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn calledFrom;\n+\t}\n+\n+\tprivate TypeRef copyTypeRef(TypeRef ref) {\n+\t\tif (ref == null)\n+\t\t\treturn null;\n+\t\tTypeRef copy = copy(ref);\n+\t\tcopy.setClassifier(ref.getClassifier());\n+\t\treturn copy;\n+\t}\n+\n+\tprivate List<AbstractRule> copyRuleStubs(RuleNames names, Map<RuleWithParameterValues, AbstractRule> origToCopy,\n+\t\t\tList<AbstractRule> rulesToCopy, boolean discardTypeRef) {\n+\t\tList<AbstractRule> result = new ArrayList<>();\n+\t\tfor (AbstractRule rule : rulesToCopy) {\n+\t\t\tString ruleName = names.getAntlrRuleName(rule);\n+\t\t\tif (rule instanceof ParserRule) {\n+\t\t\t\tList<Parameter> params = ((ParserRule) rule).getParameters();\n+\t\t\t\tif (params.isEmpty()) {\n+\t\t\t\t\tParserRule copy = copy((ParserRule) rule);\n+\t\t\t\t\tcopy.setName(ruleName);\n+\t\t\t\t\tcopy.setFragment(((ParserRule) rule).isFragment());\n+\t\t\t\t\tcopy.setWildcard(((ParserRule) rule).isWildcard());\n+\t\t\t\t\tif ((!discardTypeRef))\n+\t\t\t\t\t\tcopy.setType(copyTypeRef(((ParserRule) rule).getType()));\n+\t\t\t\t\tattachTo(copy, rule, origToCopy);\n+\t\t\t\t\tresult.add(copy);\n+\t\t\t\t} else {\n+\t\t\t\t\tforEach(Sets.powerSet(ImmutableSet.copyOf(params)), (parameterConfig, i) -> {\n+\t\t\t\t\t\tRuleWithParameterValues parameterValues = new RuleWithParameterValues(rule, parameterConfig);\n+\t\t\t\t\t\tParserRule copy = copy((ParserRule) rule);\n+\t\t\t\t\t\tcopy.setName(names.getAntlrRuleName(rule, i.intValue()));\n+\t\t\t\t\t\tcopy.setFragment(((ParserRule) rule).isFragment());\n+\t\t\t\t\t\tcopy.setWildcard(((ParserRule) rule).isWildcard());\n+\t\t\t\t\t\tif ((!discardTypeRef))\n+\t\t\t\t\t\t\tcopy.setType(copyTypeRef(((ParserRule) rule).getType()));\n+\t\t\t\t\t\torigToCopy.put(parameterValues, copy);\n+\t\t\t\t\t\tparameterValues.attachToEmfObject(copy);\n+\t\t\t\t\t\tresult.add(copy);\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t} else if (rule instanceof TerminalRule) {\n+\t\t\t\tTerminalRule orig = ((TerminalRule) rule);\n+\t\t\t\tTerminalRule copy = copy(orig);\n+\t\t\t\tcopy.setName(ruleName);\n+\t\t\t\tcopy.setFragment(orig.isFragment());\n+\t\t\t\tattachTo(copy, orig, origToCopy);\n+\t\t\t\tresult.add(copy);\n+\t\t\t} else if (rule instanceof EnumRule) {\n+\t\t\t\tEnumRule copy = copy((EnumRule) rule);\n+\t\t\t\tcopy.setName(ruleName);\n+\t\t\t\tattachTo(copy, rule, origToCopy);\n+\t\t\t\tresult.add(copy);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate AbstractRule attachTo(AbstractRule copy, AbstractRule orig,\n+\t\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tRuleWithParameterValues parameterValues = new RuleWithParameterValues(orig);\n+\t\tparameterValues.attachToEmfObject(copy);\n+\t\treturn origToCopy.put(parameterValues, copy);\n+\t}\n+\n+\tprivate boolean allAreTerminalRules(Collection<AbstractRule> callers) {\n+\t\treturn forall(callers, it -> it instanceof TerminalRule);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate <T extends EObject> T copy(final T t) {\n+\t\treturn (T) EcoreUtil.create(t.eClass());\n+\t}\n+\n+\tpublic static FlattenedGrammarAccess findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof FlattenedGrammarAccessAdapter)\n+\t\t\t\treturn ((FlattenedGrammarAccessAdapter) adapter).get();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static FlattenedGrammarAccess removeFromEmfObject(Notifier emfObject) {\n+\t\tList<Adapter> adapters = emfObject.eAdapters();\n+\t\tfor (int i = 0, max = adapters.size(); i < max; i++) {\n+\t\t\tAdapter adapter = adapters.get(i);\n+\t\t\tif (adapter instanceof FlattenedGrammarAccessAdapter) {\n+\t\t\t\temfObject.eAdapters().remove(i);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2NDc4MA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396064780", "bodyText": "\"ResourceSet is not a ResourceSetImpl\" -> \"ResourceSet is not an instance of ResourceSetImpl\"", "author": "nbhusare", "createdAt": "2020-03-22T07:54:40Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/LiveShadowedChunkedContainer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.containers;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.LiveShadowedChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author koehnlein - Initial contribution and API\n+ * @since 2.14\n+ */\n+@Beta\n+public class LiveShadowedChunkedContainer implements IContainer {\n+\tprivate final LiveShadowedChunkedResourceDescriptions descriptions;\n+\n+\tprivate final String containerName;\n+\n+\tprivate IProjectConfig projectConfig;\n+\n+\tprivate boolean isProjectConfigSet = false;\n+\n+\tpublic LiveShadowedChunkedContainer(LiveShadowedChunkedResourceDescriptions descriptions, String containerName) {\n+\t\tthis.descriptions = descriptions;\n+\t\tthis.containerName = containerName;\n+\t}\n+\n+\tprotected ChunkedResourceDescriptions getChunkedResourceDescriptions() {\n+\t\treturn (ChunkedResourceDescriptions) descriptions.getGlobalDescriptions();\n+\t}\n+\n+\tprotected IProjectConfig getProjectConfig() {\n+\t\tif (!isProjectConfigSet) {\n+\t\t\tprojectConfig = descriptions.getWorkspaceConfig() == null ? null\n+\t\t\t\t\t: descriptions.getWorkspaceConfig().findProjectByName(this.containerName);\n+\t\t\tisProjectConfigSet = true;\n+\t\t}\n+\t\treturn projectConfig;\n+\t}\n+\n+\tprotected ResourceDescriptionsData getChunk() {\n+\t\tResourceDescriptionsData container = getChunkedResourceDescriptions().getContainer(containerName);\n+\t\tif (container != null)\n+\t\t\treturn container;\n+\t\treturn new ResourceDescriptionsData(Collections.unmodifiableList(new ArrayList<>()));\n+\t}\n+\n+\tprotected Iterable<IResourceDescription> getContainedLocalDescriptions() {\n+\t\treturn filter(descriptions.getLocalDescriptions().getAllResourceDescriptions(), it -> isContained(it.getURI()));\n+\t}\n+\n+\tprotected boolean isContained(URI uri) {\n+\t\treturn (getChunk().getResourceDescription(uri) != null)\n+\t\t\t\t|| (getProjectConfig() != null && getProjectConfig().findSourceFolderContaining(uri) != null);\n+\t}\n+\n+\t@Override\n+\tpublic IResourceDescription getResourceDescription(URI uri) {\n+\t\treturn isContained(uri) ? descriptions.getResourceDescription(uri) : null;\n+\t}\n+\n+\t@Override\n+\tpublic int getResourceDescriptionCount() {\n+\t\treturn size(getResourceDescriptions());\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IResourceDescription> getResourceDescriptions() {\n+\t\tSet<URI> localURIs = getExistingOrRenamedResourceURIs();\n+\t\treturn Iterables.concat(getContainedLocalDescriptions(),\n+\t\t\t\tfilter(getChunk().getAllResourceDescriptions(), it -> !localURIs.contains(it.getURI())));\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasResourceDescription(URI uri) {\n+\t\treturn getChunk().getResourceDescription(uri) != null;\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects() {\n+\t\tSet<URI> localURIs = getExistingOrRenamedResourceURIs();\n+\t\treturn Iterables.concat(Iterables.concat(map(getContainedLocalDescriptions(), it -> it.getExportedObjects())),\n+\t\t\t\tfilter(getChunk().getExportedObjects(), it -> !localURIs.contains(it.getEObjectURI().trimFragment())));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects(EClass type, QualifiedName name, boolean ignoreCase) {\n+\t\tSet<URI> localURIs = getExistingOrRenamedResourceURIs();\n+\t\treturn Iterables.concat(\n+\t\t\t\tIterables.concat(\n+\t\t\t\t\t\tmap(getContainedLocalDescriptions(), it -> it.getExportedObjects(type, name, ignoreCase))),\n+\t\t\t\tfilter(getChunk().getExportedObjects(type, name, ignoreCase),\n+\t\t\t\t\t\tit -> !localURIs.contains(it.getEObjectURI().trimFragment())));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByObject(final EObject object) {\n+\t\tSet<URI> localURIs = getExistingOrRenamedResourceURIs();\n+\t\treturn Iterables.concat(\n+\t\t\t\tIterables.concat(map(getContainedLocalDescriptions(), it -> it.getExportedObjectsByObject(object))),\n+\t\t\t\tfilter(getChunk().getExportedObjectsByObject(object),\n+\t\t\t\t\t\tit -> !localURIs.contains(it.getEObjectURI().trimFragment())));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByType(EClass type) {\n+\t\tSet<URI> localURIs = getExistingOrRenamedResourceURIs();\n+\t\treturn Iterables.concat(\n+\t\t\t\tIterables.concat(map(getContainedLocalDescriptions(), it -> it.getExportedObjectsByType(type))),\n+\t\t\t\tfilter(getChunk().getExportedObjectsByType(type),\n+\t\t\t\t\t\tit -> !localURIs.contains(it.getEObjectURI().trimFragment())));\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\treturn IterableExtensions.isEmpty(getContainedLocalDescriptions()) && getChunk().isEmpty();\n+\t}\n+\n+\tprotected Set<URI> getExistingOrRenamedResourceURIs() {\n+\t\tResourceSet resourceSet = descriptions.getResourceSet();\n+\t\tif (resourceSet instanceof ResourceSetImpl)\n+\t\t\treturn ((ResourceSetImpl) resourceSet).getURIResourceMap().keySet();\n+\t\tthrow new IllegalStateException(\"ResourceSet is not a ResourceSetImpl\");", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE1ODQ3MA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399158470", "bodyText": "Could you please be more specific!? I am not sure what I should do with this comment.", "author": "ArneDeutsch", "createdAt": "2020-03-27T10:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2NDc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI4ODE2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399288161", "bodyText": "I was suggesting to replace the detailed message with - ResourceSet is not an instance of ResourceSetImpl.", "author": "nbhusare", "createdAt": "2020-03-27T14:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2NDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2NTQyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396065427", "bodyText": "Extra ((", "author": "nbhusare", "createdAt": "2020-03-22T08:03:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/xtext/FlattenedGrammarAccess.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.CompoundElement;\n+import org.eclipse.xtext.Condition;\n+import org.eclipse.xtext.EnumRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Group;\n+import org.eclipse.xtext.Parameter;\n+import org.eclipse.xtext.ParserRule;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.XtextPackage;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class FlattenedGrammarAccess {\n+\tprivate final Grammar flattenedGrammar;\n+\n+\tpublic FlattenedGrammarAccess(RuleNames names, RuleFilter filter) {\n+\t\tGrammar grammar = names.getContextGrammar();\n+\t\tGrammar flattenedGrammar = copy(grammar);\n+\t\tflattenedGrammar.setName(grammar.getName());\n+\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy = new LinkedHashMap<>();\n+\t\tList<AbstractRule> copies = copyRuleStubs(names, origToCopy, filter.getRules(grammar),\n+\t\t\t\tfilter.isDiscardRuleTypeRef());\n+\t\taddAll(flattenedGrammar.getRules(), copies);\n+\t\tMultimap<TerminalRule, AbstractRule> calledFrom = copyRuleBodies(copies, origToCopy);\n+\t\tsetHiddenTokens(flattenedGrammar, grammar, origToCopy);\n+\t\tmarkAsFragment(calledFrom);\n+\t\tif (filter.isDiscardUnreachableRules()) {\n+\t\t\tSet<AbstractRule> usedRules = new HashSet<>();\n+\t\t\tif (!filter.isDiscardTerminalRules())\n+\t\t\t\tusedRules.addAll(GrammarUtil.allTerminalRules(flattenedGrammar));\n+\t\t\tUsedRulesFinder finder = new UsedRulesFinder(usedRules);\n+\t\t\tfinder.compute(flattenedGrammar);\n+\t\t\tflattenedGrammar.getRules().retainAll(usedRules);\n+\t\t}\n+\t\tthis.flattenedGrammar = flattenedGrammar;\n+\t\tnew OriginalGrammar(grammar).attachToEmfObject(flattenedGrammar);\n+\t}\n+\n+\tprivate void setHiddenTokens(Grammar copy, Grammar orig, Map<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tif (orig == null) {\n+\t\t\tcopy.setDefinesHiddenTokens(true);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!orig.isDefinesHiddenTokens()) {\n+\t\t\tsetHiddenTokens(copy, head(orig.getUsedGrammars()), origToCopy);\n+\t\t\treturn;\n+\t\t}\n+\t\tcopy.setDefinesHiddenTokens(true);\n+\t\taddAll(copy.getHiddenTokens(), ListExtensions.map(orig.getHiddenTokens(),\n+\t\t\t\thidden -> origToCopy.get(new RuleWithParameterValues(hidden))));\n+\t}\n+\n+\tprivate void markAsFragment(Multimap<TerminalRule, AbstractRule> calledFrom) {\n+\t\tfilter(filter(filter(calledFrom.keySet(), it -> !it.isFragment()),\n+\t\t\t\tit -> allAreTerminalRules(calledFrom.get(it))),\n+\t\t\t\tit -> !((Grammar) it.eContainer()).getHiddenTokens().contains(it)).forEach(it -> it.setFragment(true));\n+\t}\n+\n+\tprivate Multimap<TerminalRule, AbstractRule> copyRuleBodies(List<AbstractRule> copies,\n+\t\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tHashMultimap<TerminalRule, AbstractRule> calledFrom = HashMultimap.create();\n+\t\tfor (AbstractRule copy : copies) {\n+\t\t\tAbstractRule orig = RuleWithParameterValues.getOriginalRule(copy);\n+\t\t\tSet<Parameter> paramValues = RuleWithParameterValues.getParamValues(copy);\n+\t\t\t@SuppressWarnings(\"serial\")\n+\t\t\tEcoreUtil.Copier copier = new EcoreUtil.Copier() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void copyReference(EReference eReference, EObject eObject, EObject copyEObject) {\n+\t\t\t\t\tif (XtextPackage.Literals.RULE_CALL__RULE == eReference) {\n+\t\t\t\t\t\tRuleCall origRuleCall = (RuleCall) eObject;\n+\t\t\t\t\t\tRuleCall copyRuleCall = (RuleCall) copyEObject;\n+\t\t\t\t\t\tAbstractRule calledCopy = origToCopy.get(new RuleWithParameterValues(origRuleCall.getRule(),\n+\t\t\t\t\t\t\t\tgetParameterConfig(origRuleCall, copyRuleCall)));\n+\t\t\t\t\t\tcopyRuleCall.setRule(calledCopy);\n+\t\t\t\t\t\tif (calledCopy instanceof TerminalRule)\n+\t\t\t\t\t\t\tcalledFrom.put(((TerminalRule) calledCopy), copy);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsuper.copyReference(eReference, eObject, copyEObject);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tSet<Parameter> getParameterConfig(RuleCall origRuleCall, RuleCall copyRuleCall) {\n+\t\t\t\t\tif (origRuleCall.getArguments().isEmpty())\n+\t\t\t\t\t\treturn Collections.emptySet();\n+\t\t\t\t\treturn toSet(map(filter(origRuleCall.getArguments(), it -> evaluate(it.getValue())),\n+\t\t\t\t\t\t\tit -> it.getParameter()));\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tprotected void copyContainment(EReference eReference, EObject eObject, EObject copyEObject) {\n+\t\t\t\t\tif (XtextPackage.Literals.RULE_CALL__ARGUMENTS == eReference\n+\t\t\t\t\t\t\t|| XtextPackage.Literals.GROUP__GUARD_CONDITION == eReference)\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tsuper.copyContainment(eReference, eObject, copyEObject);\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic EObject copy(EObject eObject) {\n+\t\t\t\t\tif (eObject instanceof Group && ((Group) eObject).getGuardCondition() != null\n+\t\t\t\t\t\t\t&& !evaluate(((Group) eObject).getGuardCondition()))\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\tEObject result = super.copy(eObject);\n+\t\t\t\t\tif (result instanceof CompoundElement) {\n+\t\t\t\t\t\tCompoundElement compoundElement = (CompoundElement) result;\n+\t\t\t\t\t\tList<AbstractElement> elements = compoundElement.getElements();\n+\t\t\t\t\t\tif (elements.size() == 1) {\n+\t\t\t\t\t\t\tif (!compoundElement.isFirstSetPredicated() && !compoundElement.isPredicated()) {\n+\t\t\t\t\t\t\t\tAbstractElement firstElement = elements.get(0);\n+\t\t\t\t\t\t\t\tmergeCardinalities(firstElement, compoundElement);\n+\t\t\t\t\t\t\t\tmergePredicates(firstElement, compoundElement);\n+\t\t\t\t\t\t\t\treturn firstElement;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tAbstractElement firstElement = elements.get(0);\n+\t\t\t\t\t\t\t\tmergePredicates(compoundElement, firstElement);\n+\t\t\t\t\t\t\t\tfirstElement.setFirstSetPredicated(false);\n+\t\t\t\t\t\t\t\tfirstElement.setPredicated(false);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ((eObject instanceof AbstractElement)) {\n+\t\t\t\t\t\tAbstractElement abstractElement = (AbstractElement) eObject;\n+\t\t\t\t\t\tif (!abstractElement.eClass().equals(result.eClass())) {\n+\t\t\t\t\t\t\tthrow new IllegalStateException(\"copy is: \\'\" + result.eClass().getName()\n+\t\t\t\t\t\t\t\t\t+ \"\\' but original was: \\'\" + abstractElement.eClass().getName() + \"\\'\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tnew OriginalElement(abstractElement).attachToEmfObject(result);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\n+\t\t\t\tvoid mergePredicates(AbstractElement into, AbstractElement from) {\n+\t\t\t\t\tif (from.isPredicated()) {\n+\t\t\t\t\t\tinto.setPredicated(true);\n+\t\t\t\t\t\tinto.setFirstSetPredicated(false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!into.isPredicated() && from.isFirstSetPredicated())\n+\t\t\t\t\t\t\tinto.setFirstSetPredicated(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tvoid mergeCardinalities(AbstractElement into, AbstractElement from) {\n+\t\t\t\t\tString c1 = into.getCardinality();\n+\t\t\t\t\tString c2 = from.getCardinality();\n+\t\t\t\t\tString resultCardinality = c1 == null ? c2 : c1;\n+\t\t\t\t\tif ((\"*\".equals(c1) || \"*\".equals(c2)) || (\"+\".equals(c1) && \"?\".equals(c2))\n+\t\t\t\t\t\t\t|| (\"?\".equals(c1) && \"+\".equals(c2)))\n+\t\t\t\t\t\tresultCardinality = \"*\";\n+\t\t\t\t\tinto.setCardinality(resultCardinality);\n+\t\t\t\t}\n+\n+\t\t\t\tboolean evaluate(final Condition condition) {\n+\t\t\t\t\treturn new ConditionEvaluator(paramValues).evaluate(condition);\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tAbstractElement copiedBody = (AbstractElement) copier.copy(orig.getAlternatives());\n+\t\t\tcopier.copyReferences();\n+\t\t\tcopy.setAlternatives(copiedBody);\n+\t\t\tif (orig instanceof ParserRule) {\n+\t\t\t\tParserRule castedCopy = ((ParserRule) copy);\n+\t\t\t\tif (((ParserRule) orig).isDefinesHiddenTokens()) {\n+\t\t\t\t\tcastedCopy.setDefinesHiddenTokens(true);\n+\t\t\t\t\tfor (AbstractRule rule : ((ParserRule) orig).getHiddenTokens()) {\n+\t\t\t\t\t\tAbstractRule copiedTerminalRule = origToCopy.get(new RuleWithParameterValues(rule));\n+\t\t\t\t\t\tcastedCopy.getHiddenTokens().add(copiedTerminalRule);\n+\t\t\t\t\t\tcalledFrom.put((TerminalRule) copiedTerminalRule, castedCopy);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn calledFrom;\n+\t}\n+\n+\tprivate TypeRef copyTypeRef(TypeRef ref) {\n+\t\tif (ref == null)\n+\t\t\treturn null;\n+\t\tTypeRef copy = copy(ref);\n+\t\tcopy.setClassifier(ref.getClassifier());\n+\t\treturn copy;\n+\t}\n+\n+\tprivate List<AbstractRule> copyRuleStubs(RuleNames names, Map<RuleWithParameterValues, AbstractRule> origToCopy,\n+\t\t\tList<AbstractRule> rulesToCopy, boolean discardTypeRef) {\n+\t\tList<AbstractRule> result = new ArrayList<>();\n+\t\tfor (AbstractRule rule : rulesToCopy) {\n+\t\t\tString ruleName = names.getAntlrRuleName(rule);\n+\t\t\tif (rule instanceof ParserRule) {\n+\t\t\t\tList<Parameter> params = ((ParserRule) rule).getParameters();\n+\t\t\t\tif (params.isEmpty()) {\n+\t\t\t\t\tParserRule copy = copy((ParserRule) rule);\n+\t\t\t\t\tcopy.setName(ruleName);\n+\t\t\t\t\tcopy.setFragment(((ParserRule) rule).isFragment());\n+\t\t\t\t\tcopy.setWildcard(((ParserRule) rule).isWildcard());\n+\t\t\t\t\tif ((!discardTypeRef))", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2NTQzOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396065439", "bodyText": "Extra ((", "author": "nbhusare", "createdAt": "2020-03-22T08:03:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/xtext/FlattenedGrammarAccess.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.CompoundElement;\n+import org.eclipse.xtext.Condition;\n+import org.eclipse.xtext.EnumRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Group;\n+import org.eclipse.xtext.Parameter;\n+import org.eclipse.xtext.ParserRule;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.XtextPackage;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class FlattenedGrammarAccess {\n+\tprivate final Grammar flattenedGrammar;\n+\n+\tpublic FlattenedGrammarAccess(RuleNames names, RuleFilter filter) {\n+\t\tGrammar grammar = names.getContextGrammar();\n+\t\tGrammar flattenedGrammar = copy(grammar);\n+\t\tflattenedGrammar.setName(grammar.getName());\n+\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy = new LinkedHashMap<>();\n+\t\tList<AbstractRule> copies = copyRuleStubs(names, origToCopy, filter.getRules(grammar),\n+\t\t\t\tfilter.isDiscardRuleTypeRef());\n+\t\taddAll(flattenedGrammar.getRules(), copies);\n+\t\tMultimap<TerminalRule, AbstractRule> calledFrom = copyRuleBodies(copies, origToCopy);\n+\t\tsetHiddenTokens(flattenedGrammar, grammar, origToCopy);\n+\t\tmarkAsFragment(calledFrom);\n+\t\tif (filter.isDiscardUnreachableRules()) {\n+\t\t\tSet<AbstractRule> usedRules = new HashSet<>();\n+\t\t\tif (!filter.isDiscardTerminalRules())\n+\t\t\t\tusedRules.addAll(GrammarUtil.allTerminalRules(flattenedGrammar));\n+\t\t\tUsedRulesFinder finder = new UsedRulesFinder(usedRules);\n+\t\t\tfinder.compute(flattenedGrammar);\n+\t\t\tflattenedGrammar.getRules().retainAll(usedRules);\n+\t\t}\n+\t\tthis.flattenedGrammar = flattenedGrammar;\n+\t\tnew OriginalGrammar(grammar).attachToEmfObject(flattenedGrammar);\n+\t}\n+\n+\tprivate void setHiddenTokens(Grammar copy, Grammar orig, Map<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tif (orig == null) {\n+\t\t\tcopy.setDefinesHiddenTokens(true);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!orig.isDefinesHiddenTokens()) {\n+\t\t\tsetHiddenTokens(copy, head(orig.getUsedGrammars()), origToCopy);\n+\t\t\treturn;\n+\t\t}\n+\t\tcopy.setDefinesHiddenTokens(true);\n+\t\taddAll(copy.getHiddenTokens(), ListExtensions.map(orig.getHiddenTokens(),\n+\t\t\t\thidden -> origToCopy.get(new RuleWithParameterValues(hidden))));\n+\t}\n+\n+\tprivate void markAsFragment(Multimap<TerminalRule, AbstractRule> calledFrom) {\n+\t\tfilter(filter(filter(calledFrom.keySet(), it -> !it.isFragment()),\n+\t\t\t\tit -> allAreTerminalRules(calledFrom.get(it))),\n+\t\t\t\tit -> !((Grammar) it.eContainer()).getHiddenTokens().contains(it)).forEach(it -> it.setFragment(true));\n+\t}\n+\n+\tprivate Multimap<TerminalRule, AbstractRule> copyRuleBodies(List<AbstractRule> copies,\n+\t\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tHashMultimap<TerminalRule, AbstractRule> calledFrom = HashMultimap.create();\n+\t\tfor (AbstractRule copy : copies) {\n+\t\t\tAbstractRule orig = RuleWithParameterValues.getOriginalRule(copy);\n+\t\t\tSet<Parameter> paramValues = RuleWithParameterValues.getParamValues(copy);\n+\t\t\t@SuppressWarnings(\"serial\")\n+\t\t\tEcoreUtil.Copier copier = new EcoreUtil.Copier() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void copyReference(EReference eReference, EObject eObject, EObject copyEObject) {\n+\t\t\t\t\tif (XtextPackage.Literals.RULE_CALL__RULE == eReference) {\n+\t\t\t\t\t\tRuleCall origRuleCall = (RuleCall) eObject;\n+\t\t\t\t\t\tRuleCall copyRuleCall = (RuleCall) copyEObject;\n+\t\t\t\t\t\tAbstractRule calledCopy = origToCopy.get(new RuleWithParameterValues(origRuleCall.getRule(),\n+\t\t\t\t\t\t\t\tgetParameterConfig(origRuleCall, copyRuleCall)));\n+\t\t\t\t\t\tcopyRuleCall.setRule(calledCopy);\n+\t\t\t\t\t\tif (calledCopy instanceof TerminalRule)\n+\t\t\t\t\t\t\tcalledFrom.put(((TerminalRule) calledCopy), copy);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsuper.copyReference(eReference, eObject, copyEObject);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tSet<Parameter> getParameterConfig(RuleCall origRuleCall, RuleCall copyRuleCall) {\n+\t\t\t\t\tif (origRuleCall.getArguments().isEmpty())\n+\t\t\t\t\t\treturn Collections.emptySet();\n+\t\t\t\t\treturn toSet(map(filter(origRuleCall.getArguments(), it -> evaluate(it.getValue())),\n+\t\t\t\t\t\t\tit -> it.getParameter()));\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tprotected void copyContainment(EReference eReference, EObject eObject, EObject copyEObject) {\n+\t\t\t\t\tif (XtextPackage.Literals.RULE_CALL__ARGUMENTS == eReference\n+\t\t\t\t\t\t\t|| XtextPackage.Literals.GROUP__GUARD_CONDITION == eReference)\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tsuper.copyContainment(eReference, eObject, copyEObject);\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic EObject copy(EObject eObject) {\n+\t\t\t\t\tif (eObject instanceof Group && ((Group) eObject).getGuardCondition() != null\n+\t\t\t\t\t\t\t&& !evaluate(((Group) eObject).getGuardCondition()))\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\tEObject result = super.copy(eObject);\n+\t\t\t\t\tif (result instanceof CompoundElement) {\n+\t\t\t\t\t\tCompoundElement compoundElement = (CompoundElement) result;\n+\t\t\t\t\t\tList<AbstractElement> elements = compoundElement.getElements();\n+\t\t\t\t\t\tif (elements.size() == 1) {\n+\t\t\t\t\t\t\tif (!compoundElement.isFirstSetPredicated() && !compoundElement.isPredicated()) {\n+\t\t\t\t\t\t\t\tAbstractElement firstElement = elements.get(0);\n+\t\t\t\t\t\t\t\tmergeCardinalities(firstElement, compoundElement);\n+\t\t\t\t\t\t\t\tmergePredicates(firstElement, compoundElement);\n+\t\t\t\t\t\t\t\treturn firstElement;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tAbstractElement firstElement = elements.get(0);\n+\t\t\t\t\t\t\t\tmergePredicates(compoundElement, firstElement);\n+\t\t\t\t\t\t\t\tfirstElement.setFirstSetPredicated(false);\n+\t\t\t\t\t\t\t\tfirstElement.setPredicated(false);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ((eObject instanceof AbstractElement)) {\n+\t\t\t\t\t\tAbstractElement abstractElement = (AbstractElement) eObject;\n+\t\t\t\t\t\tif (!abstractElement.eClass().equals(result.eClass())) {\n+\t\t\t\t\t\t\tthrow new IllegalStateException(\"copy is: \\'\" + result.eClass().getName()\n+\t\t\t\t\t\t\t\t\t+ \"\\' but original was: \\'\" + abstractElement.eClass().getName() + \"\\'\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tnew OriginalElement(abstractElement).attachToEmfObject(result);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\n+\t\t\t\tvoid mergePredicates(AbstractElement into, AbstractElement from) {\n+\t\t\t\t\tif (from.isPredicated()) {\n+\t\t\t\t\t\tinto.setPredicated(true);\n+\t\t\t\t\t\tinto.setFirstSetPredicated(false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!into.isPredicated() && from.isFirstSetPredicated())\n+\t\t\t\t\t\t\tinto.setFirstSetPredicated(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tvoid mergeCardinalities(AbstractElement into, AbstractElement from) {\n+\t\t\t\t\tString c1 = into.getCardinality();\n+\t\t\t\t\tString c2 = from.getCardinality();\n+\t\t\t\t\tString resultCardinality = c1 == null ? c2 : c1;\n+\t\t\t\t\tif ((\"*\".equals(c1) || \"*\".equals(c2)) || (\"+\".equals(c1) && \"?\".equals(c2))\n+\t\t\t\t\t\t\t|| (\"?\".equals(c1) && \"+\".equals(c2)))\n+\t\t\t\t\t\tresultCardinality = \"*\";\n+\t\t\t\t\tinto.setCardinality(resultCardinality);\n+\t\t\t\t}\n+\n+\t\t\t\tboolean evaluate(final Condition condition) {\n+\t\t\t\t\treturn new ConditionEvaluator(paramValues).evaluate(condition);\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tAbstractElement copiedBody = (AbstractElement) copier.copy(orig.getAlternatives());\n+\t\t\tcopier.copyReferences();\n+\t\t\tcopy.setAlternatives(copiedBody);\n+\t\t\tif (orig instanceof ParserRule) {\n+\t\t\t\tParserRule castedCopy = ((ParserRule) copy);\n+\t\t\t\tif (((ParserRule) orig).isDefinesHiddenTokens()) {\n+\t\t\t\t\tcastedCopy.setDefinesHiddenTokens(true);\n+\t\t\t\t\tfor (AbstractRule rule : ((ParserRule) orig).getHiddenTokens()) {\n+\t\t\t\t\t\tAbstractRule copiedTerminalRule = origToCopy.get(new RuleWithParameterValues(rule));\n+\t\t\t\t\t\tcastedCopy.getHiddenTokens().add(copiedTerminalRule);\n+\t\t\t\t\t\tcalledFrom.put((TerminalRule) copiedTerminalRule, castedCopy);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn calledFrom;\n+\t}\n+\n+\tprivate TypeRef copyTypeRef(TypeRef ref) {\n+\t\tif (ref == null)\n+\t\t\treturn null;\n+\t\tTypeRef copy = copy(ref);\n+\t\tcopy.setClassifier(ref.getClassifier());\n+\t\treturn copy;\n+\t}\n+\n+\tprivate List<AbstractRule> copyRuleStubs(RuleNames names, Map<RuleWithParameterValues, AbstractRule> origToCopy,\n+\t\t\tList<AbstractRule> rulesToCopy, boolean discardTypeRef) {\n+\t\tList<AbstractRule> result = new ArrayList<>();\n+\t\tfor (AbstractRule rule : rulesToCopy) {\n+\t\t\tString ruleName = names.getAntlrRuleName(rule);\n+\t\t\tif (rule instanceof ParserRule) {\n+\t\t\t\tList<Parameter> params = ((ParserRule) rule).getParameters();\n+\t\t\t\tif (params.isEmpty()) {\n+\t\t\t\t\tParserRule copy = copy((ParserRule) rule);\n+\t\t\t\t\tcopy.setName(ruleName);\n+\t\t\t\t\tcopy.setFragment(((ParserRule) rule).isFragment());\n+\t\t\t\t\tcopy.setWildcard(((ParserRule) rule).isWildcard());\n+\t\t\t\t\tif ((!discardTypeRef))\n+\t\t\t\t\t\tcopy.setType(copyTypeRef(((ParserRule) rule).getType()));\n+\t\t\t\t\tattachTo(copy, rule, origToCopy);\n+\t\t\t\t\tresult.add(copy);\n+\t\t\t\t} else {\n+\t\t\t\t\tforEach(Sets.powerSet(ImmutableSet.copyOf(params)), (parameterConfig, i) -> {\n+\t\t\t\t\t\tRuleWithParameterValues parameterValues = new RuleWithParameterValues(rule, parameterConfig);\n+\t\t\t\t\t\tParserRule copy = copy((ParserRule) rule);\n+\t\t\t\t\t\tcopy.setName(names.getAntlrRuleName(rule, i.intValue()));\n+\t\t\t\t\t\tcopy.setFragment(((ParserRule) rule).isFragment());\n+\t\t\t\t\t\tcopy.setWildcard(((ParserRule) rule).isWildcard());\n+\t\t\t\t\t\tif ((!discardTypeRef))", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3MjMyMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396072321", "bodyText": "If possible, please try to replace the references to the code from xbase.lib. with the Java equivalent.", "author": "nbhusare", "createdAt": "2020-03-22T09:31:27Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/LiveShadowedChunkedContainer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.containers;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTkwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396109908", "bodyText": "\ud83d\udc4d", "author": "szarnekow", "createdAt": "2020-03-22T16:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3MjMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MzYxNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399163615", "bodyText": "For \"map\" there is simple replacement in guava \"Iterables\". Will replace all others.", "author": "ArneDeutsch", "createdAt": "2020-03-27T10:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3MjMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwODc2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396108761", "bodyText": "Unnecessary explicit boxing.", "author": "szarnekow", "createdAt": "2020-03-22T15:52:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/OutdatedStateManager.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.service.OperationCanceledError;\n+import org.eclipse.xtext.service.OperationCanceledManager;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.util.concurrent.CancelableUnitOfWork;\n+import org.eclipse.xtext.util.concurrent.IUnitOfWork;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class OutdatedStateManager {\n+\t@Inject\n+\tprivate OperationCanceledManager canceledManager;\n+\n+\tprivate final ThreadLocal<Boolean> cancelationAllowed = new ThreadLocal<Boolean>() {\n+\t\t@Override\n+\t\tpublic Boolean initialValue() {\n+\t\t\treturn Boolean.valueOf(true);", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwODkyNA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396108924", "bodyText": "I'd prefer a gradual migration towards 'cancellation'  vs 'cancelation' :) We could start with local vars and parameter names.", "author": "szarnekow", "createdAt": "2020-03-22T15:53:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/OutdatedStateManager.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.service.OperationCanceledError;\n+import org.eclipse.xtext.service.OperationCanceledManager;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.util.concurrent.CancelableUnitOfWork;\n+import org.eclipse.xtext.util.concurrent.IUnitOfWork;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class OutdatedStateManager {\n+\t@Inject\n+\tprivate OperationCanceledManager canceledManager;\n+\n+\tprivate final ThreadLocal<Boolean> cancelationAllowed = new ThreadLocal<Boolean>() {\n+\t\t@Override\n+\t\tpublic Boolean initialValue() {\n+\t\t\treturn Boolean.valueOf(true);\n+\t\t}\n+\t};\n+\n+\t/**\n+\t * Created a fresh CancelIndicator\n+\t */\n+\tpublic CancelIndicator newCancelIndicator(ResourceSet rs) {\n+\t\tif (rs instanceof XtextResourceSet) {\n+\t\t\tboolean isCancelationAllowed = cancelationAllowed.get().booleanValue();", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI2MjQ0MA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399262440", "bodyText": "According to leo both writings are valid (american vs. british) ... will not start to rename the local variables.", "author": "ArneDeutsch", "createdAt": "2020-03-27T13:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwODkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTY0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396109648", "bodyText": "a plain forLoop for (int i = 0; i < numChunks; i++)  would be better.", "author": "szarnekow", "createdAt": "2020-03-22T16:00:01Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/ChunkedResourceDescriptions.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.impl;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.containers.ProjectDescriptionBasedContainerManager;\n+import org.eclipse.xtext.resource.persistence.SerializableResourceDescription;\n+import org.eclipse.xtext.xbase.lib.ExclusiveRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * A IResourceDescriptions implementation that holds its resource description in chunks, each identified by a string.\n+ * The strings represent units such as projects, source sets, and libraries.\n+ * \n+ * @see ProjectDescription\n+ * @see ProjectDescriptionBasedContainerManager\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+public class ChunkedResourceDescriptions extends AbstractCompoundSelectable\n+\t\timplements IResourceDescriptions, Externalizable {\n+\n+\tprotected ConcurrentHashMap<String, ResourceDescriptionsData> chunk2resourceDescriptions = new ConcurrentHashMap<>();\n+\tprotected ResourceSet resourceSet;\n+\n+\tpublic ChunkedResourceDescriptions() {\n+\t}\n+\n+\tpublic ChunkedResourceDescriptions(Map<String, ResourceDescriptionsData> initialData) {\n+\t\tchunk2resourceDescriptions = new ConcurrentHashMap<>(initialData);\n+\t}\n+\n+\tpublic ChunkedResourceDescriptions(Map<String, ResourceDescriptionsData> initialData, ResourceSet resourceSet) {\n+\t\tthis(initialData);\n+\t\tsetResourceSet(resourceSet);\n+\t}\n+\n+\t/**\n+\t * Creates a shallow copy of the resource descriptions map and installs it with the given ResourceSet.\n+\t */\n+\tpublic ChunkedResourceDescriptions createShallowCopyWith(ResourceSet resourceSet) {\n+\t\treturn new ChunkedResourceDescriptions(chunk2resourceDescriptions, resourceSet);\n+\t}\n+\n+\tpublic ResourceSet getResourceSet() {\n+\t\treturn this.resourceSet;\n+\t}\n+\n+\tprotected void setResourceSet(ResourceSet resourceSet) {\n+\t\tif (this.resourceSet != null)\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"This \" + getClass().getName() + \" is already associated with a different resource set.\");\n+\t\tif (ChunkedResourceDescriptions.findInEmfObject(resourceSet) != null)\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"There is already a different \" + getClass().getName() + \" installed in the given resource set.\");\n+\t\tthis.resourceSet = resourceSet;\n+\t\tattachToEmfObject(resourceSet);\n+\t}\n+\n+\tpublic ResourceDescriptionsData setContainer(String name, ResourceDescriptionsData descriptions) {\n+\t\treturn chunk2resourceDescriptions.put(name, descriptions);\n+\t}\n+\n+\tpublic ResourceDescriptionsData removeContainer(String name) {\n+\t\treturn chunk2resourceDescriptions.remove(name);\n+\t}\n+\n+\t@Override\n+\tprotected Iterable<? extends ISelectable> getSelectables() {\n+\t\treturn chunk2resourceDescriptions.values();\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IResourceDescription> getAllResourceDescriptions() {\n+\t\treturn concat(map(chunk2resourceDescriptions.values(), it -> it.getAllResourceDescriptions()));\n+\t}\n+\n+\t@Override\n+\tpublic IResourceDescription getResourceDescription(URI uri) {\n+\t\tfor (ResourceDescriptionsData selectable : chunk2resourceDescriptions.values()) {\n+\t\t\tIResourceDescription result = selectable.getResourceDescription(uri);\n+\t\t\tif (result != null)\n+\t\t\t\treturn result;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic ResourceDescriptionsData getContainer(URI uri) {\n+\t\tfor (ResourceDescriptionsData container : chunk2resourceDescriptions.values()) {\n+\t\t\tIResourceDescription description = container.getResourceDescription(uri);\n+\t\t\tif (description != null)\n+\t\t\t\treturn container;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic ResourceDescriptionsData getContainer(String containerHandle) {\n+\t\treturn chunk2resourceDescriptions.get(containerHandle);\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unused\")\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tint numChunks = in.readInt();\n+\t\tfor (Integer i : new ExclusiveRange(0, numChunks, true)) {", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI2NDc5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399264792", "bodyText": "Will do.", "author": "ArneDeutsch", "createdAt": "2020-03-27T13:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTgzMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r396109831", "bodyText": "Meh...\nFluentIterable.from(..).filter(..).filter(..) would be easier to read.", "author": "szarnekow", "createdAt": "2020-03-22T16:01:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/xtext/FlattenedGrammarAccess.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.CompoundElement;\n+import org.eclipse.xtext.Condition;\n+import org.eclipse.xtext.EnumRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Group;\n+import org.eclipse.xtext.Parameter;\n+import org.eclipse.xtext.ParserRule;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.XtextPackage;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class FlattenedGrammarAccess {\n+\tprivate final Grammar flattenedGrammar;\n+\n+\tpublic FlattenedGrammarAccess(RuleNames names, RuleFilter filter) {\n+\t\tGrammar grammar = names.getContextGrammar();\n+\t\tGrammar flattenedGrammar = copy(grammar);\n+\t\tflattenedGrammar.setName(grammar.getName());\n+\t\tMap<RuleWithParameterValues, AbstractRule> origToCopy = new LinkedHashMap<>();\n+\t\tList<AbstractRule> copies = copyRuleStubs(names, origToCopy, filter.getRules(grammar),\n+\t\t\t\tfilter.isDiscardRuleTypeRef());\n+\t\taddAll(flattenedGrammar.getRules(), copies);\n+\t\tMultimap<TerminalRule, AbstractRule> calledFrom = copyRuleBodies(copies, origToCopy);\n+\t\tsetHiddenTokens(flattenedGrammar, grammar, origToCopy);\n+\t\tmarkAsFragment(calledFrom);\n+\t\tif (filter.isDiscardUnreachableRules()) {\n+\t\t\tSet<AbstractRule> usedRules = new HashSet<>();\n+\t\t\tif (!filter.isDiscardTerminalRules())\n+\t\t\t\tusedRules.addAll(GrammarUtil.allTerminalRules(flattenedGrammar));\n+\t\t\tUsedRulesFinder finder = new UsedRulesFinder(usedRules);\n+\t\t\tfinder.compute(flattenedGrammar);\n+\t\t\tflattenedGrammar.getRules().retainAll(usedRules);\n+\t\t}\n+\t\tthis.flattenedGrammar = flattenedGrammar;\n+\t\tnew OriginalGrammar(grammar).attachToEmfObject(flattenedGrammar);\n+\t}\n+\n+\tprivate void setHiddenTokens(Grammar copy, Grammar orig, Map<RuleWithParameterValues, AbstractRule> origToCopy) {\n+\t\tif (orig == null) {\n+\t\t\tcopy.setDefinesHiddenTokens(true);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!orig.isDefinesHiddenTokens()) {\n+\t\t\tsetHiddenTokens(copy, head(orig.getUsedGrammars()), origToCopy);\n+\t\t\treturn;\n+\t\t}\n+\t\tcopy.setDefinesHiddenTokens(true);\n+\t\taddAll(copy.getHiddenTokens(), ListExtensions.map(orig.getHiddenTokens(),\n+\t\t\t\thidden -> origToCopy.get(new RuleWithParameterValues(hidden))));\n+\t}\n+\n+\tprivate void markAsFragment(Multimap<TerminalRule, AbstractRule> calledFrom) {\n+\t\tfilter(filter(filter(calledFrom.keySet(), it -> !it.isFragment()),", "originalCommit": "7f2d199cb5a4773e1e87669ec1d6bb43c55c1614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI2NzcxMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1423#discussion_r399267711", "bodyText": "Will do .... please review that I have done it right.", "author": "ArneDeutsch", "createdAt": "2020-03-27T13:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEwOTgzMQ=="}], "type": "inlineReview"}, {"oid": "d2c3f7188f500be9d6843a76ed01cf717bf5e725", "url": "https://github.com/eclipse/xtext-core/commit/d2c3f7188f500be9d6843a76ed01cf717bf5e725", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-27T13:37:46Z", "type": "forcePushed"}, {"oid": "98ba18e78f3f15c98345d61629eb31cbe98efb19", "url": "https://github.com/eclipse/xtext-core/commit/98ba18e78f3f15c98345d61629eb31cbe98efb19", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-30T07:49:49Z", "type": "commit"}, {"oid": "98ba18e78f3f15c98345d61629eb31cbe98efb19", "url": "https://github.com/eclipse/xtext-core/commit/98ba18e78f3f15c98345d61629eb31cbe98efb19", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-30T07:49:49Z", "type": "forcePushed"}]}