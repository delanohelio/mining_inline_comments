{"pr_number": 1437, "pr_title": "[eclipse/xtext#1679] Refactor more Xtend to java.", "pr_createdAt": "2020-04-03T08:40:20Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1437", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDQzMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402854431", "bodyText": "This was already Java on master. Let's see if we do have any semantic changes :)", "author": "szarnekow", "createdAt": "2020-04-03T08:55:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -155,20 +83,19 @@ public boolean isPortableURIFragment(String uriFragment) {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NTU4Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402855586", "bodyText": "this reverts the fixed comment", "author": "szarnekow", "createdAt": "2020-04-03T08:57:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -155,20 +83,19 @@ public boolean isPortableURIFragment(String uriFragment) {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);\n \t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n \t\tmock.setEType(desc.descriptionEClass);\n-\t\tIScope scope = globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n-\t\tOptional<IEObjectDescription> description = Streams.stream( //\n-\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n-\t\treturn description.map(d -> {\n-\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n-\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n-\t\t}).orElse(null);\n+\t\tIScope scope = globalScopeProvider.getScope(resource, mock, alwaysTrue());\n+\t\tIEObjectDescription description = head(scope.getElements(desc.descriptionQualifiedName));\n+\t\tif (description == null)\n+\t\t\treturn null;\n+\t\tEObject container = EcoreUtil.resolve(description.getEObjectOrProxy(), resource);\n+\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n \t}\n \n \t/**\n-\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjAwNA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402856004", "bodyText": "Version on master appears to be cleaner and has the original source comment.", "author": "szarnekow", "createdAt": "2020-04-03T08:57:42Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -180,16 +107,15 @@ public EObject resolve(StorageAwareResource resource, String portableFragment) {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n-\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n-\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n-\t\tif (object == null || object.eResource().getResourceSet() != null) {\n-\t\t\treturn toPortableURI(sourceResource, object);\n-\t\t}\n+\t\tResource resource = sourceResource.getResourceSet().getResource(targetURI.trimFragment(), false);", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjM2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402856361", "bodyText": "I prefer the curly braces on master", "author": "szarnekow", "createdAt": "2020-04-03T08:58:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -200,13 +126,11 @@ public URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n-\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\tif (targetObject == null || targetObject.eIsProxy())", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NzMwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402857303", "bodyText": "isAncestor does this check already", "author": "szarnekow", "createdAt": "2020-04-03T08:59:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1Nzg1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402857855", "bodyText": "Not sure if I like IterableExtensions being used here given that this class was already reviewed and ported to Java a few days ago", "author": "szarnekow", "createdAt": "2020-04-03T08:59:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -8,9 +8,12 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n+import static com.google.common.base.Predicates.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODMyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858323", "bodyText": "I prefer the version on master.", "author": "szarnekow", "createdAt": "2020-04-03T09:00:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t});\n+\t\tif (containerDesc != null)\n+\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n+\t\treturn null;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n-\t\t\tEObject target) {\n+\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n-\t\t\t\tfragmentToTarget);\n+\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n-\t\tif (desc.descriptionRelativeFragment != null) {\n+\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n+\t\tif (desc.descriptionRelativeFragment != null)\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n-\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODU0NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858545", "bodyText": "Could use the short class name for the inner type, though.", "author": "szarnekow", "createdAt": "2020-04-03T09:00:33Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t});\n+\t\tif (containerDesc != null)\n+\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n+\t\treturn null;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n-\t\t\tEObject target) {\n+\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n-\t\t\t\tfragmentToTarget);\n+\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n-\t\tif (desc.descriptionRelativeFragment != null) {\n+\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n+\t\tif (desc.descriptionRelativeFragment != null)\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n-\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {\n \t\tIterator<String> segments = Splitter.on(\"#\").split(fragmentString).iterator();\n-\t\tsegments.next(); // skip first\n+\t\tsegments.next();\n \t\tURI eClassURI = URI.createURI(URI.decode(segments.next()));\n-\t\tEPackage ePackage = this.packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n-\t\tEClass eClass = EcorePackage.Literals.EOBJECT;\n-\t\tif (ePackage != null) {\n-\t\t\tResource resource = ePackage.eResource();\n-\t\t\tif (resource != null) {\n-\t\t\t\teClass = (EClass) resource.getEObject(eClassURI.fragment());\n-\t\t\t}\n-\t\t}\n-\t\tQualifiedName qname = QualifiedName.create(Splitter.on(\":\").splitToList(URI.decode(segments.next())));\n+\t\tEPackage ePackage = packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n+\t\tResource eResource = ePackage == null ? null : ePackage.eResource();\n+\t\tEClass eClass = (EClass) (eResource == null ? null : eResource.getEObject(eClassURI.fragment()));\n+\t\tQualifiedName qname = QualifiedName.create(toList(Splitter.on(\":\").split(URI.decode(segments.next()))));\n \t\tString fragment = segments.hasNext() ? URI.decode(segments.next()) : null;\n-\t\treturn new PortableURIs.PortableFragmentDescription(eClass, qname, fragment);\n+\t\treturn new PortableFragmentDescription(eClass == null ? EcorePackage.Literals.EOBJECT : eClass, qname,", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODgxMg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858812", "bodyText": "This reverts the cleanup that is present on master.", "author": "szarnekow", "createdAt": "2020-04-03T09:00:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -276,10 +192,21 @@ protected String toFragmentString(PortableURIs.PortableFragmentDescription desc)\n \t * @return a fragment path from the given container to the child, or <code>null</null> is fromContainer == toChild\n \t * \n \t * @see #getEObject(EObject,String)\n-\t * @throws IllegalArgumentException if the child is not a child of the given container.\n \t */\n-\tpublic String getFragment(EObject fromContainer, EObject toChild) throws IllegalArgumentException {\n-\t\treturn Strings.emptyToNull(EcoreUtil.getRelativeURIFragmentPath(fromContainer, toChild));\n+\tpublic String getFragment(EObject fromContainer, EObject toChild) {", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDAwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860001", "bodyText": "IterableExtensions are still being used here. Can this be simplified, e.g. by using FluentIterable or streams?", "author": "szarnekow", "createdAt": "2020-04-03T09:02:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDcxMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860711", "bodyText": "@Pure can be removed", "author": "szarnekow", "createdAt": "2020-04-03T09:03:13Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\treturn;\n+\t\t}\n+\t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n+\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n+\t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n+\t}\n+\n+\t/**\n+\t * @return whether a stored resource state exists for the given resource\n+\t */\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\tif (stateProvider != null && stateProvider.getResourceStorageLoadable(resource) != null)\n+\t\t\treturn true;\n+\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\tCollections.emptyMap()))\n+\t\t\treturn true;\n+\t\tif (resource.getURI().isArchive())\n+\t\t\treturn false;\n+\t\tURI uri = getFileSystemAccess(resource).getURI(computeOutputPath(resource));\n+\t\treturn uri != null && resource.getResourceSet().getURIConverter().exists(uri, null);\n+\t}\n+\n+\tprotected AbstractFileSystemAccess2 getFileSystemAccess(StorageAwareResource resource) {\n+\t\tAbstractFileSystemAccess2 fsa = fileSystemAccessProvider.get();\n+\t\tfsa.setContext(resource);\n+\t\tfsa.setOutputConfigurations(\n+\t\t\t\ttoMap(outputConfigurationProvider.getOutputConfigurations(resource), it -> it.getName()));\n+\t\treturn fsa;\n+\t}\n+\n+\tprotected String computeOutputPath(StorageAwareResource resource) {\n+\t\treturn getBinaryStorageURI(resource.getURI()).deresolve(getSourceContainerURI(resource), false, false, true)\n+\t\t\t\t.path();\n+\t}\n+\n+\tprotected URI getSourceContainerURI(StorageAwareResource resource) {\n+\t\treturn resource.getURI().trimSegments(1).appendSegment(\"\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasStorageFor(URI uri) {\n+\t\treturn new ExtensibleURIConverterImpl().exists(getBinaryStorageURI(uri), Collections.emptyMap());\n+\t}\n+\n+\tprotected URI getBinaryStorageURI(URI sourceURI) {\n+\t\treturn sourceURI.trimSegments(1).appendSegment(\".\" + sourceURI.lastSegment() + \"bin\");\n+\t}\n+\n+\t@Pure", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDkwNw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860907", "bodyText": "@Accessors can be removed", "author": "szarnekow", "createdAt": "2020-04-03T09:03:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MTM1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402861359", "bodyText": "EcoreUtil.getAdapter?", "author": "szarnekow", "createdAt": "2020-04-03T09:03:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\treturn;\n+\t\t}\n+\t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n+\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n+\t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n+\t}\n+\n+\t/**\n+\t * @return whether a stored resource state exists for the given resource\n+\t */\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceStorageProviderAdapter stateProvider = head(", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODc5MA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402868790", "bodyText": "I prefer equals", "author": "szarnekow", "createdAt": "2020-04-03T09:13:15Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageProviderAdapter.java", "diffHunk": "@@ -19,7 +19,7 @@\n public class ResourceStorageProviderAdapter extends AdapterImpl {\n \t@Override\n \tpublic boolean isAdapterForType(Object type) {\n-\t\treturn ResourceStorageProviderAdapter.class.equals(type);\n+\t\treturn type == ResourceStorageProviderAdapter.class;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDE1Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402870153", "bodyText": "fieldname should be uri", "author": "szarnekow", "createdAt": "2020-04-03T09:15:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDMzMA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402870330", "bodyText": "parametername should be uri", "author": "szarnekow", "createdAt": "2020-04-03T09:15:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTA2Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871067", "bodyText": "I prefer the version on master", "author": "szarnekow", "createdAt": "2020-04-03T09:17:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -8,11 +8,12 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTI2MA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871260", "bodyText": "I prefer the version on master", "author": "szarnekow", "createdAt": "2020-04-03T09:17:41Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -46,27 +45,25 @@\n \tpublic void load(Map<?, ?> options) throws IOException {\n \t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n \t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n-\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled())", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTQ3Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871476", "bodyText": "I prefer the version on matser", "author": "szarnekow", "createdAt": "2020-04-03T09:18:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResourceDescriptionManager.java", "diffHunk": "@@ -21,10 +21,9 @@\n \t@Override\n \tpublic IResourceDescription getResourceDescription(Resource resource) {\n \t\tif (resource instanceof StorageAwareResource) {\n-\t\t\tIResourceDescription result = ((StorageAwareResource) resource).getResourceDescription();\n-\t\t\tif (result != null) {\n-\t\t\t\treturn result;\n-\t\t\t}\n+\t\t\tIResourceDescription resourceDescription = ((StorageAwareResource) resource).getResourceDescription();", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "url": "https://github.com/eclipse/xtext-core/commit/6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-03T09:31:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MDQ4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403040482", "bodyText": "{@link #shouldLoadFromStorage}", "author": "tivervac", "createdAt": "2020-04-03T14:21:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MDg3MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403040871", "bodyText": "Doesn't agree with the actual return type, and it's a useless comment", "author": "tivervac", "createdAt": "2020-04-03T14:22:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MTI1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403041255", "bodyText": "@link these types please", "author": "tivervac", "createdAt": "2020-04-03T14:22:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n+\n+\t/**\n+\t * Saves the resource using the given file system access.\n+\t */\n+\tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MTMwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403041308", "bodyText": "@link these types please", "author": "tivervac", "createdAt": "2020-04-03T14:22:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n+\n+\t/**\n+\t * Saves the resource using the given file system access.\n+\t */\n+\tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n+\t */\n+\tResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageLoadable wrapping the given InputStream", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MjI3Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403042272", "bodyText": "Doesn't agree with actual type and is a pretty useless comment", "author": "tivervac", "createdAt": "2020-04-03T14:24:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MzE4NA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403043184", "bodyText": "s/ResourceStorageFacade.LOG/LOG/", "author": "tivervac", "createdAt": "2020-04-03T14:25:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MzU2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403043562", "bodyText": "@link on this and the next line please", "author": "tivervac", "createdAt": "2020-04-03T14:26:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0NDUzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403044532", "bodyText": "s/ResourceStorageLoadable.LOG/LOG/", "author": "tivervac", "createdAt": "2020-04-03T14:27:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.zip.ZipInputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.nodemodel.impl.SerializableNodeModel;\n+import org.eclipse.xtext.nodemodel.serialization.DeserializationConversionContext;\n+import org.eclipse.xtext.parser.ParseResult;\n+\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageLoadable {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageLoadable.class);\n+\n+\tprivate final InputStream in;\n+\n+\tprivate final boolean storeNodeModel;\n+\n+\tpublic ResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tthis.in = in;\n+\t\tthis.storeNodeModel = storeNodeModel;\n+\t}\n+\n+\tprotected void loadIntoResource(StorageAwareResource resource) throws IOException {\n+\t\tif (!resource.isLoadedFromStorage())\n+\t\t\tthrow new IllegalStateException(\"Please use StorageAwareResource#load(ResourceStorageLoadable).\");\n+\t\ttry (ZipInputStream zin = new ZipInputStream(in)) {\n+\t\t\tloadEntries(resource, zin);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Load entries from the storage. Overriding methods should first delegate to super before adding their own entries.\n+\t */\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tzipIn.getNextEntry();\n+\t\treadContents(resource, new BufferedInputStream(zipIn));\n+\t\tzipIn.getNextEntry();\n+\t\treadResourceDescription(resource, new BufferedInputStream(zipIn));\n+\t\tif (storeNodeModel) {\n+\t\t\tzipIn.getNextEntry();\n+\t\t\treadNodeModel(resource, new BufferedInputStream(zipIn));\n+\t\t}\n+\t}\n+\n+\tprotected void readContents(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\tnew BinaryResourceImpl.EObjectInputStream(inputStream, Collections.emptyMap()) {\n+\t\t\t@Override\n+\t\t\tpublic int readCompressedInt() throws IOException {\n+\t\t\t\tresourceSet = null;\n+\t\t\t\treturn super.readCompressedInt();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic InternalEObject loadEObject() throws IOException {\n+\t\t\t\tInternalEObject result = super.loadEObject();\n+\t\t\t\thandleLoadEObject(result, this);\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}.loadResource(resource);\n+\t}\n+\n+\tprotected Object handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\treturn null;\n+\t}\n+\n+\tprotected void readResourceDescription(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\ttry {\n+\t\t\tSerializableResourceDescription description = (SerializableResourceDescription) new ObjectInputStream(\n+\t\t\t\t\tinputStream).readObject();\n+\t\t\tdescription.updateResourceURI(resource.getURI());\n+\t\t\tresource.setResourceDescription(description);\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\tprotected void readNodeModel(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\tSerializableNodeModel serializableNodeModel = new SerializableNodeModel(resource);\n+\t\tif (!resource.getResourceSet().getURIConverter().exists(resource.getURI(),\n+\t\t\t\tresource.getResourceSet().getLoadOptions())) {\n+\t\t\tResourceStorageLoadable.LOG.info(\"Skipping loading node model for synthetic resource \" + resource.getURI());", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0ODUzNA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403048534", "bodyText": "You could use userData.keySet().stream().toArray(String[]::new)", "author": "tivervac", "createdAt": "2020-04-03T14:32:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.HashMap;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+\n+/**\n+ * @since 2.8\n+ */\n+public class SerializableEObjectDescription\n+\t\timplements IEObjectDescription, Externalizable, SerializableEObjectDescriptionProvider {\n+\tprotected URI eObjectURI;\n+\n+\tprotected EClass eClass;\n+\n+\tprotected QualifiedName qualifiedName;\n+\n+\tprotected HashMap<String, String> userData;\n+\n+\tprotected transient EObject eObjectOrProxy;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\teObjectURI = uri.appendFragment(eObjectURI.fragment());\n+\t}\n+\n+\t@Override\n+\tpublic EObject getEObjectOrProxy() {\n+\t\tif (eObjectOrProxy == null) {\n+\t\t\tEObject proxy = EcoreUtil.create(eClass);\n+\t\t\t((InternalEObject) proxy).eSetProxyURI(eObjectURI);\n+\t\t\teObjectOrProxy = proxy;\n+\t\t}\n+\t\treturn eObjectOrProxy;\n+\t}\n+\n+\t@Override\n+\tpublic QualifiedName getName() {\n+\t\treturn qualifiedName;\n+\t}\n+\n+\t@Override\n+\tpublic String getUserData(String key) {\n+\t\treturn userData.get(key);\n+\t}\n+\n+\t@Override\n+\tpublic String[] getUserDataKeys() {\n+\t\treturn (String[]) Conversions.unwrapArray(userData.keySet(), String.class);", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0OTIyMA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403049220", "bodyText": "Update copyright", "author": "tivervac", "createdAt": "2020-04-03T14:34:00Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MDU0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403050547", "bodyText": "I don't immediately say why the casts are needed? Isn't SerializableEObjectDescription instanceof IEObjectDescription", "author": "tivervac", "createdAt": "2020-04-03T14:35:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NDM2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r412994362", "bodyText": "True. But a List< SerializableEObjectDescription> is not a List<IEObjectDescription>.", "author": "szarnekow", "createdAt": "2020-04-22T13:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MTEzOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403051139", "bodyText": "SerializableResourceDescription::createCopy", "author": "tivervac", "createdAt": "2020-04-03T14:36:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {\n+\t\tthis.uRI = uRI;\n+\t}\n+\n+\tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n+\t\tSerializableResourceDescription description = new SerializableResourceDescription();\n+\t\tdescription.setURI(desc.getURI());\n+\t\tdescription.descriptions = toList(\n+\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MTE5MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403051191", "bodyText": "SerializableResourceDescription::createCopy", "author": "tivervac", "createdAt": "2020-04-03T14:36:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {\n+\t\tthis.uRI = uRI;\n+\t}\n+\n+\tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n+\t\tSerializableResourceDescription description = new SerializableResourceDescription();\n+\t\tdescription.setURI(desc.getURI());\n+\t\tdescription.descriptions = toList(\n+\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));\n+\t\tdescription.references = toList(\n+\t\t\t\tmap(desc.getReferenceDescriptions(), it -> SerializableResourceDescription.createCopy(it)));", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d66845132010a2e32fc8de27be2a9fca04f28850", "url": "https://github.com/eclipse/xtext-core/commit/d66845132010a2e32fc8de27be2a9fca04f28850", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-22T13:31:43Z", "type": "forcePushed"}, {"oid": "fe6bd769753173588d1d7a544783cae0cbd38d82", "url": "https://github.com/eclipse/xtext-core/commit/fe6bd769753173588d1d7a544783cae0cbd38d82", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-24T06:30:38Z", "type": "commit"}, {"oid": "fe6bd769753173588d1d7a544783cae0cbd38d82", "url": "https://github.com/eclipse/xtext-core/commit/fe6bd769753173588d1d7a544783cae0cbd38d82", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-24T06:30:38Z", "type": "forcePushed"}]}