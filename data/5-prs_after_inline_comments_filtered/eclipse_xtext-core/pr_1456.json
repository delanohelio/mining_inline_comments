{"pr_number": 1456, "pr_title": "[eclipse/xtext#1679]ported more code to java", "pr_createdAt": "2020-04-26T16:33:25Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1456", "timeline": [{"oid": "bc9007e535b99e404159a02b535c81449fb7f1a8", "url": "https://github.com/eclipse/xtext-core/commit/bc9007e535b99e404159a02b535c81449fb7f1a8", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T07:32:24Z", "type": "forcePushed"}, {"oid": "d4d1383482d3b16b7ace082fe7e211b0427cb439", "url": "https://github.com/eclipse/xtext-core/commit/d4d1383482d3b16b7ace082fe7e211b0427cb439", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T07:37:18Z", "type": "forcePushed"}, {"oid": "d41e52826f53187d828d8a2da98fef88e1c3edf8", "url": "https://github.com/eclipse/xtext-core/commit/d41e52826f53187d828d8a2da98fef88e1c3edf8", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T07:53:28Z", "type": "forcePushed"}, {"oid": "f51a9ac64602ec74b8a06c94112b2bfe6bfedec1", "url": "https://github.com/eclipse/xtext-core/commit/f51a9ac64602ec74b8a06c94112b2bfe6bfedec1", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T08:46:27Z", "type": "forcePushed"}, {"oid": "f7d75cae6788137dafe73c42920e2661ebbf4d2e", "url": "https://github.com/eclipse/xtext-core/commit/f7d75cae6788137dafe73c42920e2661ebbf4d2e", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T08:56:43Z", "type": "forcePushed"}, {"oid": "24cfaf18d0af4d8771acba9b40641c70e8b856b2", "url": "https://github.com/eclipse/xtext-core/commit/24cfaf18d0af4d8771acba9b40641c70e8b856b2", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T09:02:53Z", "type": "forcePushed"}, {"oid": "2a262df26ea2b060a29bdcd6304187755441ce42", "url": "https://github.com/eclipse/xtext-core/commit/2a262df26ea2b060a29bdcd6304187755441ce42", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T10:34:59Z", "type": "forcePushed"}, {"oid": "4d0e94b7cb07ebd6d11e5eb38212d41a17f97112", "url": "https://github.com/eclipse/xtext-core/commit/4d0e94b7cb07ebd6d11e5eb38212d41a17f97112", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T10:54:37Z", "type": "forcePushed"}, {"oid": "cbf4dfe4b7d62a5561cccbcbe4bbf3a720e85c2d", "url": "https://github.com/eclipse/xtext-core/commit/cbf4dfe4b7d62a5561cccbcbe4bbf3a720e85c2d", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-27T14:23:25Z", "type": "forcePushed"}, {"oid": "65270d177e5ece6eaf2cf129b38123867f5f21e8", "url": "https://github.com/eclipse/xtext-core/commit/65270d177e5ece6eaf2cf129b38123867f5f21e8", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T11:01:11Z", "type": "forcePushed"}, {"oid": "e5278b992db6726b3e63ed1f849325658561d9f4", "url": "https://github.com/eclipse/xtext-core/commit/e5278b992db6726b3e63ed1f849325658561d9f4", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T11:11:15Z", "type": "forcePushed"}, {"oid": "99d28db54b7097f38b9438434c60a517a978a45e", "url": "https://github.com/eclipse/xtext-core/commit/99d28db54b7097f38b9438434c60a517a978a45e", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T11:44:13Z", "type": "forcePushed"}, {"oid": "76d0cc2b26ee11fc38bae064010a949b138b3bbd", "url": "https://github.com/eclipse/xtext-core/commit/76d0cc2b26ee11fc38bae064010a949b138b3bbd", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T14:54:17Z", "type": "forcePushed"}, {"oid": "e579ed295edb15f4f158882fa87b35a0edf25549", "url": "https://github.com/eclipse/xtext-core/commit/e579ed295edb15f4f158882fa87b35a0edf25549", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T15:09:11Z", "type": "forcePushed"}, {"oid": "ce320ba2081f92880b6ea6135809f842d834d9ac", "url": "https://github.com/eclipse/xtext-core/commit/ce320ba2081f92880b6ea6135809f842d834d9ac", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T15:20:11Z", "type": "forcePushed"}, {"oid": "229aaed0c13b8e60f7c54de4ca972eff6738bb0d", "url": "https://github.com/eclipse/xtext-core/commit/229aaed0c13b8e60f7c54de4ca972eff6738bb0d", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-28T15:41:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNjExNw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417106117", "bodyText": "needed", "author": "cdietrich", "createdAt": "2020-04-29T07:04:22Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/TopologicalSorter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+\n+/**\n+ * @author Jan Koehnlein - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class TopologicalSorter {\n+\tprotected static class Entry {\n+\t\tprivate final ProjectDescription description;\n+\n+\t\tprivate boolean marked;\n+\n+\t\tprivate boolean cyclic;\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn description.getName();\n+\t\t}\n+\n+\t\tpublic Entry(ProjectDescription description) {\n+\t\t\tthis.description = description;\n+\t\t}\n+\t}\n+\n+\tprivate LinkedHashSet<ProjectDescription> result;\n+\n+\tprivate Map<String, TopologicalSorter.Entry> name2entry;\n+\n+\tprivate IAcceptor<ProjectDescription> cyclicAcceptor;\n+\n+\tpublic List<ProjectDescription> sortByDependencies(Iterable<ProjectDescription> descriptions,\n+\t\t\tProcedure1<? super ProjectDescription> cyclicAcceptor) {\n+\t\tthis.cyclicAcceptor = new IAcceptor<ProjectDescription>() {", "originalCommit": "229aaed0c13b8e60f7c54de4ca972eff6738bb0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1Mjc5MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417152791", "bodyText": "this.cyclicAcceptor = cyclicAcceptor::apply", "author": "szarnekow", "createdAt": "2020-04-29T08:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNjExNw=="}], "type": "inlineReview"}, {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "url": "https://github.com/eclipse/xtext-core/commit/f763ab94c45e628f5bef55f0e9ed360e59bd7493", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-29T07:08:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzE1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147159", "bodyText": "return true means include keyword?", "author": "szarnekow", "createdAt": "2020-04-29T08:25:47Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.contentassist;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EClassifier;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Keyword;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.scoping.IScope;\n+import org.eclipse.xtext.scoping.IScopeProvider;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xtext.CurrentTypeFinder;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Generic content proposal provider for use in different IDE contexts. This provider is <em>not</em> used by the\n+ * Eclipse integration, which has its own abstraction for content assist proposals.\n+ * \n+ * @noreference\n+ */\n+public class IdeContentProposalProvider {\n+\t@Inject\n+\tprivate IScopeProvider scopeProvider;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IdeCrossrefProposalProvider crossrefProposalProvider;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate CurrentTypeFinder currentTypeFinder;\n+\n+\t/**\n+\t * Create content assist proposals and pass them to the given acceptor.\n+\t */\n+\tpublic void createProposals(Collection<ContentAssistContext> contexts, IIdeContentProposalAcceptor acceptor) {\n+\t\tfor (ContentAssistContext context : getFilteredContexts(contexts)) {\n+\t\t\tfor (AbstractElement element : context.getFirstSetGrammarElements()) {\n+\t\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcreateProposals(element, context, acceptor);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ContentAssistContext> getFilteredContexts(Collection<ContentAssistContext> contexts) {\n+\t\treturn contexts;\n+\t}\n+\n+\tprotected void _createProposals(AbstractElement element, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(Assignment assignment, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tAbstractElement terminal = assignment.getTerminal();\n+\t\tif (terminal instanceof CrossReference) {\n+\t\t\tcreateProposals(terminal, context, acceptor);\n+\t\t} else {\n+\t\t\tif (terminal instanceof RuleCall) {\n+\t\t\t\tAbstractRule rule = ((RuleCall) terminal).getRule();\n+\t\t\t\tif (rule instanceof TerminalRule && context.getPrefix().isEmpty()) {\n+\t\t\t\t\tfinal String proposal;\n+\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\tproposal = \"\\\"\" + assignment.getFeature() + \"\\\"\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tproposal = assignment.getFeature();\n+\t\t\t\t\t}\n+\t\t\t\t\tContentAssistEntry entry = proposalCreator.createProposal(proposal, context,\n+\t\t\t\t\t\t\t(ContentAssistEntry it) -> {\n+\t\t\t\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions()\n+\t\t\t\t\t\t\t\t\t\t\t.add(new TextRegion(context.getOffset() + 1, proposal.length() - 2));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_TEXT);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions().add(new TextRegion(context.getOffset(), proposal.length()));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_VALUE);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tit.setDescription(rule.getName());\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\tacceptor.accept(entry, proposalPriorities.getDefaultPriority(entry));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void _createProposals(Keyword keyword, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tif (filterKeyword(keyword, context)) {\n+\t\t\tContentAssistEntry entry = proposalCreator.createProposal(keyword.getValue(), context,\n+\t\t\t\t\tContentAssistEntry.KIND_KEYWORD, null);\n+\t\t\tif (entry != null) {\n+\t\t\t\tacceptor.accept(entry, proposalPriorities.getKeywordPriority(keyword.getValue(), entry));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean filterKeyword(Keyword keyword, ContentAssistContext context) {\n+\t\treturn true;", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2NTMxNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417165315", "bodyText": "yes, api from hell.", "author": "cdietrich", "createdAt": "2020-04-29T08:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzE1OQ=="}], "type": "inlineReview"}, {"oid": "2cac2c7658543d52666dbe43a94a3da894bbd78f", "url": "https://github.com/eclipse/xtext-core/commit/2cac2c7658543d52666dbe43a94a3da894bbd78f", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-29T08:40:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzM3NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147375", "bodyText": "s/ereference/eReference", "author": "szarnekow", "createdAt": "2020-04-29T08:26:10Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.contentassist;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EClassifier;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Keyword;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.scoping.IScope;\n+import org.eclipse.xtext.scoping.IScopeProvider;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xtext.CurrentTypeFinder;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Generic content proposal provider for use in different IDE contexts. This provider is <em>not</em> used by the\n+ * Eclipse integration, which has its own abstraction for content assist proposals.\n+ * \n+ * @noreference\n+ */\n+public class IdeContentProposalProvider {\n+\t@Inject\n+\tprivate IScopeProvider scopeProvider;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IdeCrossrefProposalProvider crossrefProposalProvider;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate CurrentTypeFinder currentTypeFinder;\n+\n+\t/**\n+\t * Create content assist proposals and pass them to the given acceptor.\n+\t */\n+\tpublic void createProposals(Collection<ContentAssistContext> contexts, IIdeContentProposalAcceptor acceptor) {\n+\t\tfor (ContentAssistContext context : getFilteredContexts(contexts)) {\n+\t\t\tfor (AbstractElement element : context.getFirstSetGrammarElements()) {\n+\t\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcreateProposals(element, context, acceptor);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ContentAssistContext> getFilteredContexts(Collection<ContentAssistContext> contexts) {\n+\t\treturn contexts;\n+\t}\n+\n+\tprotected void _createProposals(AbstractElement element, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(Assignment assignment, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tAbstractElement terminal = assignment.getTerminal();\n+\t\tif (terminal instanceof CrossReference) {\n+\t\t\tcreateProposals(terminal, context, acceptor);\n+\t\t} else {\n+\t\t\tif (terminal instanceof RuleCall) {\n+\t\t\t\tAbstractRule rule = ((RuleCall) terminal).getRule();\n+\t\t\t\tif (rule instanceof TerminalRule && context.getPrefix().isEmpty()) {\n+\t\t\t\t\tfinal String proposal;\n+\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\tproposal = \"\\\"\" + assignment.getFeature() + \"\\\"\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tproposal = assignment.getFeature();\n+\t\t\t\t\t}\n+\t\t\t\t\tContentAssistEntry entry = proposalCreator.createProposal(proposal, context,\n+\t\t\t\t\t\t\t(ContentAssistEntry it) -> {\n+\t\t\t\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions()\n+\t\t\t\t\t\t\t\t\t\t\t.add(new TextRegion(context.getOffset() + 1, proposal.length() - 2));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_TEXT);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions().add(new TextRegion(context.getOffset(), proposal.length()));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_VALUE);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tit.setDescription(rule.getName());\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\tacceptor.accept(entry, proposalPriorities.getDefaultPriority(entry));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void _createProposals(Keyword keyword, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tif (filterKeyword(keyword, context)) {\n+\t\t\tContentAssistEntry entry = proposalCreator.createProposal(keyword.getValue(), context,\n+\t\t\t\t\tContentAssistEntry.KIND_KEYWORD, null);\n+\t\t\tif (entry != null) {\n+\t\t\t\tacceptor.accept(entry, proposalPriorities.getKeywordPriority(keyword.getValue(), entry));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean filterKeyword(Keyword keyword, ContentAssistContext context) {\n+\t\treturn true;\n+\t}\n+\n+\tprotected void _createProposals(RuleCall ruleCall, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(CrossReference reference, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tEClassifier type = currentTypeFinder.findCurrentTypeAfter(reference);\n+\t\tif (type instanceof EClass) {\n+\t\t\tEReference ereference = GrammarUtil.getReference(reference, ((EClass) type));", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzcxNw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147717", "bodyText": "ICallHierarchyBuilder.CallHierarchyType -> CallHierarchyType", "author": "szarnekow", "createdAt": "2020-04-29T08:26:44Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzgyNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147825", "bodyText": "Unnecessary types", "author": "szarnekow", "createdAt": "2020-04-29T08:26:55Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODAxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148010", "bodyText": "unnecessary type", "author": "szarnekow", "createdAt": "2020-04-29T08:27:13Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODA5Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148093", "bodyText": "same", "author": "szarnekow", "createdAt": "2020-04-29T08:27:20Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\t\tIEObjectDescription targetDeclaration = null;\n+\t\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\t\ttargetDeclaration = findTargetDeclaration(reference);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tacceptor.apply(targetDeclaration, reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tgetReferenceFinder().findAllReferences(sourceDeclaration, referenceAcceptor, monitor);\n+\t\t\treturn null;\n+\t\t});\n+\t}\n+\n+\tprotected void findSourceDeclarations(URI targetDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tTargetURIs targetURIs = collectTargetURIs(targetDeclarationURI);\n+\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t(IReferenceDescription reference) -> {", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODE4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148182", "bodyText": "same", "author": "szarnekow", "createdAt": "2020-04-29T08:27:29Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\t\tIEObjectDescription targetDeclaration = null;\n+\t\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\t\ttargetDeclaration = findTargetDeclaration(reference);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tacceptor.apply(targetDeclaration, reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tgetReferenceFinder().findAllReferences(sourceDeclaration, referenceAcceptor, monitor);\n+\t\t\treturn null;\n+\t\t});\n+\t}\n+\n+\tprotected void findSourceDeclarations(URI targetDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tTargetURIs targetURIs = collectTargetURIs(targetDeclarationURI);\n+\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\tIEObjectDescription sourceDeclaration = null;\n+\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\tsourceDeclaration = findSourceDeclaration(reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tacceptor.apply(sourceDeclaration, reference);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\tgetReferenceFinder().findAllReferences(targetURIs, getResourceAccess(), getIndexData(), referenceAcceptor, monitor);\n+\t}\n+\n+\tprotected TargetURIs collectTargetURIs(URI targetURI) {\n+\t\tTargetURIs targetURIs = getTargetURIProvider().get();\n+\t\tif (targetURI == null) {\n+\t\t\treturn targetURIs;\n+\t\t}\n+\t\treadOnly(targetURI, (EObject targetObject) -> {", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODI4Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148287", "bodyText": "same", "author": "szarnekow", "createdAt": "2020-04-29T08:27:40Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\t\tIEObjectDescription targetDeclaration = null;\n+\t\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\t\ttargetDeclaration = findTargetDeclaration(reference);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tacceptor.apply(targetDeclaration, reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tgetReferenceFinder().findAllReferences(sourceDeclaration, referenceAcceptor, monitor);\n+\t\t\treturn null;\n+\t\t});\n+\t}\n+\n+\tprotected void findSourceDeclarations(URI targetDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tTargetURIs targetURIs = collectTargetURIs(targetDeclarationURI);\n+\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\tIEObjectDescription sourceDeclaration = null;\n+\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\tsourceDeclaration = findSourceDeclaration(reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tacceptor.apply(sourceDeclaration, reference);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\tgetReferenceFinder().findAllReferences(targetURIs, getResourceAccess(), getIndexData(), referenceAcceptor, monitor);\n+\t}\n+\n+\tprotected TargetURIs collectTargetURIs(URI targetURI) {\n+\t\tTargetURIs targetURIs = getTargetURIProvider().get();\n+\t\tif (targetURI == null) {\n+\t\t\treturn targetURIs;\n+\t\t}\n+\t\treadOnly(targetURI, (EObject targetObject) -> {\n+\t\t\tif (targetObject != null) {\n+\t\t\t\tgetTargetURICollector().add(targetObject, targetURIs);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t});\n+\t\treturn targetURIs;\n+\t}\n+\n+\tprotected boolean filterReference(IReferenceDescription reference) {\n+\t\treturn reference != null;\n+\t}\n+\n+\tprotected IEObjectDescription findDeclaration(URI objectURI) {\n+\t\treturn getDescription(objectURI);\n+\t}\n+\n+\tprotected IEObjectDescription findTargetDeclaration(IReferenceDescription reference) {\n+\t\treturn findDeclaration(reference.getTargetEObjectUri());\n+\t}\n+\n+\tprotected IEObjectDescription findSourceDeclaration(IReferenceDescription reference) {\n+\t\treturn findDeclaration(reference.getContainerEObjectURI());\n+\t}\n+\n+\t/**\n+\t * @return a root hierarchy node for the given declaration; cannot be <code>null</code>\n+\t */\n+\tprotected IHierarchyNode createRoot(IEObjectDescription declaration) {\n+\t\tDefaultHierarchyNode node = new DefaultHierarchyNode();\n+\t\tnode.setElement(declaration);\n+\t\tnode.setMayHaveChildren(true);\n+\t\treturn node;\n+\t}\n+\n+\t/**\n+\t * @return a child node for the given declaration and the parent node; cannot be <code>null</code>\n+\t */\n+\tprotected IHierarchyNode createChild(IEObjectDescription declaration, IHierarchyNode parent) {\n+\t\tDefaultHierarchyNode node = new DefaultHierarchyNode();\n+\t\tnode.setParent(parent);\n+\t\tnode.setElement(declaration);\n+\t\tnode.setMayHaveChildren(!node.isRecursive());\n+\t\treturn node;\n+\t}\n+\n+\tprotected IHierarchyNode createChild(Map<URI, IHierarchyNode> children, IEObjectDescription declaration,\n+\t\t\tIHierarchyNode parent) {\n+\t\tif (declaration == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tIHierarchyNode childNode = children.get(declaration.getEObjectURI());\n+\t\tif (childNode == null) {\n+\t\t\tchildNode = createChild(declaration, parent);\n+\t\t\tchildren.put(declaration.getEObjectURI(), childNode);\n+\t\t}\n+\t\treturn childNode;\n+\t}\n+\n+\t/**\n+\t * @return a hierarchy node reference for the given reference; cannot be <code>null</code>\n+\t */\n+\tprotected IHierarchyNodeReference createNodeReference(IReferenceDescription reference) {\n+\t\treturn readOnly(reference.getSourceEObjectUri(), (EObject sourceObject) -> {", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODgxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148818", "bodyText": "Integer.valueOf not necessary", "author": "szarnekow", "createdAt": "2020-04-29T08:28:39Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tchar LF = '\\r';\n+\t\tint l = contents.length();\n+\t\tStringBuilder lineContent = new StringBuilder();\n+\t\tint line = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tif (line > lineNumber) {\n+\t\t\t\treturn lineContent.toString();\n+\t\t\t}\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (line == lineNumber && ch != NL && ch != LF) {\n+\t\t\t\tlineContent.append(ch);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t}\n+\t\t}\n+\t\tif (line < lineNumber) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MDA4OA==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417150088", "bodyText": "can be inlined", "author": "szarnekow", "createdAt": "2020-04-29T08:30:52Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MDE1MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417150151", "bodyText": "Integer.valueOf", "author": "szarnekow", "createdAt": "2020-04-29T08:31:00Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MDI2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417150262", "bodyText": "inline", "author": "szarnekow", "createdAt": "2020-04-29T08:31:12Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTM1Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417151353", "bodyText": "Hmm should contents be part of toString if printSourceOnError is false?", "author": "szarnekow", "createdAt": "2020-04-29T08:33:13Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tchar LF = '\\r';\n+\t\tint l = contents.length();\n+\t\tStringBuilder lineContent = new StringBuilder();\n+\t\tint line = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tif (line > lineNumber) {\n+\t\t\t\treturn lineContent.toString();\n+\t\t\t}\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (line == lineNumber && ch != NL && ch != LF) {\n+\t\t\t\tlineContent.append(ch);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t}\n+\t\t}\n+\t\tif (line < lineNumber) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\treturn lineContent.toString();\n+\t}\n+\n+\t/**\n+\t * Get the number of lines in the document. Empty document has line count: {@code 1}.\n+\t */\n+\tpublic int getLineCount() {\n+\t\treturn getPosition(contents.length()).getLine() + 1;\n+\t}\n+\n+\tpublic String getSubstring(Range range) {\n+\t\tint start = getOffSet(range.getStart());\n+\t\tint end = getOffSet(range.getEnd());\n+\t\treturn contents.substring(start, end);\n+\t}\n+\n+\t/**\n+\t * As opposed to {@link TextEdit}[] the positions in the edits of a {@link DidChangeTextDocumentParams} refer to the\n+\t * state after applying the preceding edits. See\n+\t * https://microsoft.github.io/language-server-protocol/specification#textedit-1 and\n+\t * https://github.com/microsoft/vscode/issues/23173#issuecomment-289378160 for details.\n+\t * \n+\t * @return a new document with an incremented version and the text document changes applied.\n+\t * @since 2.18\n+\t */\n+\tpublic Document applyTextDocumentChanges(Iterable<? extends TextDocumentContentChangeEvent> changes) {\n+\t\tDocument currentDocument = this;\n+\t\tInteger newVersion = null;\n+\t\tif (currentDocument.version != null) {\n+\t\t\tnewVersion = Integer.valueOf(currentDocument.version.intValue() + 1);\n+\t\t}\n+\t\tfor (TextDocumentContentChangeEvent change : changes) {\n+\t\t\tfinal String newContent;\n+\t\t\tif (change.getRange() == null) {\n+\t\t\t\tnewContent = change.getText();\n+\t\t\t} else {\n+\t\t\t\tint start = currentDocument.getOffSet(change.getRange().getStart());\n+\t\t\t\tint end = currentDocument.getOffSet(change.getRange().getEnd());\n+\t\t\t\tnewContent = currentDocument.contents.substring(0, start) + change.getText()\n+\t\t\t\t\t\t+ currentDocument.contents.substring(end);\n+\t\t\t}\n+\t\t\tcurrentDocument = new Document(newVersion, newContent, printSourceOnError);\n+\t\t}\n+\t\treturn currentDocument;\n+\t}\n+\n+\t/**\n+\t * Only use for testing.\n+\t * \n+\t * All positions in the {@link TextEdit}s refer to the same original document (this).\n+\t */\n+\tpublic Document applyChanges(Iterable<? extends TextEdit> changes) {\n+\t\tString newContent = contents;\n+\t\tfor (TextEdit change : changes) {\n+\t\t\tif (change.getRange() == null) {\n+\t\t\t\tnewContent = change.getNewText();\n+\t\t\t} else {\n+\t\t\t\tint start = getOffSet(change.getRange().getStart());\n+\t\t\t\tint end = getOffSet(change.getRange().getEnd());\n+\t\t\t\tnewContent = newContent.substring(0, start) + change.getNewText() + newContent.substring(end);\n+\t\t\t}\n+\t\t}\n+\t\tInteger newVersion = null;\n+\t\tif (version != null) {\n+\t\t\tnewVersion = Integer.valueOf(version.intValue() + 1);\n+\t\t}\n+\t\treturn new Document(newVersion, newContent);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic boolean isPrintSourceOnError() {\n+\t\treturn printSourceOnError;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tfinal int prime = 31;\n+\t\tint result = 1;\n+\t\tresult = prime * result + ((contents == null) ? 0 : contents.hashCode());\n+\t\tresult = prime * result + (printSourceOnError ? 1231 : 1237);\n+\t\tresult = prime * result + ((version == null) ? 0 : version.hashCode());\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tDocument other = (Document) obj;\n+\t\tif (contents == null) {\n+\t\t\tif (other.contents != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!contents.equals(other.contents))\n+\t\t\treturn false;\n+\t\tif (printSourceOnError != other.printSourceOnError)\n+\t\t\treturn false;\n+\t\tif (version == null) {\n+\t\t\tif (other.version != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!version.equals(other.version))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\tb.add(\"version\", version);\n+\t\tb.add(\"contents\", contents);", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTU3Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417151573", "bodyText": "It would make me so happy to have getOffset instead of getOffSet :D", "author": "szarnekow", "createdAt": "2020-04-29T08:33:37Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MjE0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417152147", "bodyText": "we could extract a method that created the exception consistently", "author": "szarnekow", "createdAt": "2020-04-29T08:34:38Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tchar LF = '\\r';\n+\t\tint l = contents.length();\n+\t\tStringBuilder lineContent = new StringBuilder();\n+\t\tint line = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tif (line > lineNumber) {\n+\t\t\t\treturn lineContent.toString();\n+\t\t\t}\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (line == lineNumber && ch != NL && ch != LF) {\n+\t\t\t\tlineContent.append(ch);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t}\n+\t\t}\n+\t\tif (line < lineNumber) {\n+\t\t\tString source = \"\";", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1Mzc1NA==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417153754", "bodyText": "Accessors", "author": "szarnekow", "createdAt": "2020-04-29T08:37:24Z", "path": "org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/SubProjectConfig.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext.generator.model.project;\n+\n+import org.eclipse.xtend.lib.annotations.AccessorType;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.xtext.generator.Issues;\n+import org.eclipse.xtext.xtext.generator.model.IXtextGeneratorFileSystemAccess;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+\n+/**\n+ * Configuration of subprojects.\n+ * \n+ * @noextend This class should not be extended by clients.\n+ */\n+public class SubProjectConfig implements ISubProjectConfig {\n+\t@Inject\n+\tprivate XtextProjectConfig owner;\n+\n+\tprivate boolean enabled;\n+\n+\tprivate boolean overwriteSrc;\n+\n+\tprivate String name;\n+\n+\tprivate String rootPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess root;\n+\n+\tprivate String metaInfPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess metaInf;\n+\n+\tprivate String srcPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess src;\n+\n+\tprivate String srcGenPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess srcGen;\n+\n+\t@Accessors(AccessorType.PUBLIC_GETTER)", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NDUxNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417154515", "bodyText": "", "author": "szarnekow", "createdAt": "2020-04-29T08:38:51Z", "path": "org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/serializer/NamedSerializationContexts.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2016, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext.generator.serializer;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.xtext.serializer.ISerializationContext;\n+\n+public class NamedSerializationContexts<T extends Object> {", "originalCommit": "f763ab94c45e628f5bef55f0e9ed360e59bd7493", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f4b3dd6fa5cfc62be1a3007af3c22409d1880e2", "url": "https://github.com/eclipse/xtext-core/commit/2f4b3dd6fa5cfc62be1a3007af3c22409d1880e2", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-29T08:52:49Z", "type": "forcePushed"}, {"oid": "2f53887e63691c88b29ca8411bd6e8b9e546f6f9", "url": "https://github.com/eclipse/xtext-core/commit/2f53887e63691c88b29ca8411bd6e8b9e546f6f9", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-29T09:25:11Z", "type": "forcePushed"}, {"oid": "71f17744ebdc187dff969b82611eaaf36b90a7b0", "url": "https://github.com/eclipse/xtext-core/commit/71f17744ebdc187dff969b82611eaaf36b90a7b0", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-29T09:42:44Z", "type": "commit"}, {"oid": "71f17744ebdc187dff969b82611eaaf36b90a7b0", "url": "https://github.com/eclipse/xtext-core/commit/71f17744ebdc187dff969b82611eaaf36b90a7b0", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-29T09:42:44Z", "type": "forcePushed"}]}