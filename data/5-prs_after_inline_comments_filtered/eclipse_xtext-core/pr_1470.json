{"pr_number": 1470, "pr_title": "Fixed the synchronization strategy in ExecutorServiceProvider", "pr_createdAt": "2020-05-04T10:42:48Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1470", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r419894987", "bodyText": "Given that ConcurrentHashMap does not allow null-keys or null-values, it may also be ok to use Collections.synchronizedMap here, since I don't expect a lot of pressure on the lookup of an ExecutorService.\nget(String key) should be rewritten to use computeIfAbsent(..).", "author": "szarnekow", "createdAt": "2020-05-05T06:43:58Z", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "originalCommit": "76f94d1e01fdcc4196fb0390863da46253502a36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NTI2OA==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r419895268", "bodyText": "dispose must sync on the map, too.", "author": "szarnekow", "createdAt": "2020-05-05T06:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2MDQ2NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420060465", "bodyText": "get(String key) should be rewritten to use computeIfAbsent(..).\n\nI can think of two ways; however, I am not convinced by either. In the first one, calling  computeIfAbsent(...) inside the if (result == null) doesn't make much sense. We already know that the value is null before calling computeIfAbsent(...). The second one would block threads even if the map has a non-null value for the key requested by the second thread.\n@szarnekow Please suggest if there is any other way to rewrite this method.\nExecutorService result = instanceCache.get(key);                            \nif (result == null) {                                                       \n\tsynchronized (instanceCache) {                                          \n\t\tresult = instanceCache.computeIfAbsent(key, k -> createInstance(k));\n\t}                                                                       \n}                                                                           \nreturn result; \n\nsynchronized (instanceCache) {                                         \n\treturn instanceCache.computeIfAbsent(key, k -> createInstance(k)); \n}", "author": "nbhusare", "createdAt": "2020-05-05T12:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTczMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420065731", "bodyText": "Steps:\n\nUse a Collections.synchronizedMap(new HashMap<>()) for the field initializer\nRewrite and simplify get(String) towards public ExecutorService get(String key) { return instanceCache.computeIfAbsent(key, this::createInstance)); }\nfix dispose to sync on the instanceCache, too: public void dipose() { synchronized(instanceCache) { .. } }", "author": "szarnekow", "createdAt": "2020-05-05T12:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0NTgyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420145823", "bodyText": "@szarnekow computeIfAbsent(...) is not atomic. Don't we have to sync on the map?", "author": "nbhusare", "createdAt": "2020-05-05T14:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NDU3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420154578", "bodyText": "SynchronizedMap.computeIfAbsent(K, Function<? super K, ? extends V>) is safe.", "author": "szarnekow", "createdAt": "2020-05-05T14:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2MzAxMg==", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420163012", "bodyText": "ok, tx for clarification.", "author": "nbhusare", "createdAt": "2020-05-05T14:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}], "type": "inlineReview"}, {"oid": "e82e6988dc824b7bb199c524d9c541f0983bde85", "url": "https://github.com/eclipse/xtext-core/commit/e82e6988dc824b7bb199c524d9c541f0983bde85", "message": "Fixed the synchronization strategy\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-05-05T15:20:22Z", "type": "commit"}, {"oid": "e82e6988dc824b7bb199c524d9c541f0983bde85", "url": "https://github.com/eclipse/xtext-core/commit/e82e6988dc824b7bb199c524d9c541f0983bde85", "message": "Fixed the synchronization strategy\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-05-05T15:20:22Z", "type": "forcePushed"}]}