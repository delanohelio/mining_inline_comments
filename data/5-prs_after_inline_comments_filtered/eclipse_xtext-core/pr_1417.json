{"pr_number": 1417, "pr_title": "Refactor more xtend to java", "pr_createdAt": "2020-03-06T07:19:56Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1417", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1Mjk1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388752959", "bodyText": "you should remove final from all parameters", "author": "cdietrich", "createdAt": "2020-03-06T07:43:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(final IResourceServiceProvider.Registry resourceServiceProviderRegistry,", "originalCommit": "160bdb1022650cb315717906b182eb5812c4cd12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc5MDY0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388790648", "bodyText": "I will do.", "author": "ArneDeutsch", "createdAt": "2020-03-06T09:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1Mjk1OQ=="}], "type": "inlineReview"}, {"oid": "67ab803d8b2e316e47273e4b16ff6caa5c471045", "url": "https://github.com/eclipse/xtext-core/commit/67ab803d8b2e316e47273e4b16ff6caa5c471045", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T09:29:21Z", "type": "forcePushed"}, {"oid": "716c6eb69f58840bc816e2731e3690b7de20f841", "url": "https://github.com/eclipse/xtext-core/commit/716c6eb69f58840bc816e2731e3690b7de20f841", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T09:36:02Z", "type": "forcePushed"}, {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "url": "https://github.com/eclipse/xtext-core/commit/c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T09:44:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwNjkwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388806908", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T09:50:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwNzM3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388807377", "bodyText": "I don't really like this new HashMap<>() works as well", "author": "tivervac", "createdAt": "2020-03-06T09:51:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODMzOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808338", "bodyText": "Collections.emptyMap()", "author": "tivervac", "createdAt": "2020-03-06T09:52:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODU4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808589", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T09:53:21Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();\n+\t\t}\n+\t}\n+\n+\tprotected URI findExportedContainer(EObject obj) {\n+\t\tif (exportedContainersInCurrentResource.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEObject source = obj;\n+\t\tURI result = exportedContainersInCurrentResource.get(source);\n+\t\twhile ((result == null)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODY3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808678", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T09:53:29Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();\n+\t\t}\n+\t}\n+\n+\tprotected URI findExportedContainer(EObject obj) {\n+\t\tif (exportedContainersInCurrentResource.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEObject source = obj;\n+\t\tURI result = exportedContainersInCurrentResource.get(source);\n+\t\twhile ((result == null)) {\n+\t\t\tif (exportedContainersInCurrentResource.containsKey(source)) {\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t\tsource = source.eContainer();\n+\t\t\tif ((source == null)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTIwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809203", "bodyText": "@szarnekow We prefer not to have there in the java code right?", "author": "tivervac", "createdAt": "2020-03-06T09:54:29Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyNjUxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388826510", "bodyText": "True. catch(Throwable) is a bad sign in general.", "author": "szarnekow", "createdAt": "2020-03-06T10:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTM1Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809356", "bodyText": "@cdietrich We're 2.21 one now, is this still beta?", "author": "tivervac", "createdAt": "2020-03-06T09:54:49Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @since 2.14\n+\t */\n+\t@Beta", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NjI1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389796259", "bodyText": "I'd like to keep this @Beta - the code tickles me. I've doubts that it is really safe to to do it like this.", "author": "szarnekow", "createdAt": "2020-03-09T16:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTU2Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809563", "bodyText": "We really don't want these ;)", "author": "tivervac", "createdAt": "2020-03-06T09:55:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+@SuppressWarnings(\"all\")", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTY3Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809673", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T09:55:26Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+@SuppressWarnings(\"all\")\n+public class FileSystemAccessRequest implements Runnable {\n+\tprivate final URI uri;\n+\n+\tprivate final Runnable runMe;\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {\n+\t\tthis.uri = uri;\n+\t\tthis.runMe = runMe;\n+\t}\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTc4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809789", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T09:55:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class GeneratorContext implements IGeneratorContext {\n+\tprivate CancelIndicator cancelIndicator;\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDAwNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388810007", "bodyText": "@cdietrich Is this still beta? It's been so long", "author": "tivervac", "createdAt": "2020-03-06T09:55:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NDMyOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388844328", "bodyText": "Almost all implementations that I saw do need access to the issues. If we want to de-betarize this, we should consider passing the issues directly to this API. The caller would make sure that the issues are only computed once.", "author": "szarnekow", "createdAt": "2020-03-06T11:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDI2OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388810268", "bodyText": "s/whether/Whether/", "author": "tivervac", "createdAt": "2020-03-06T09:56:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+@ImplementedBy(IShouldGenerate.OnlyWithoutErrors.class)\n+public interface IShouldGenerate {\n+\t@Beta\n+\t@Singleton\n+\tclass OnlyWithoutErrors implements IShouldGenerate {\n+\t\t@Inject\n+\t\tprivate IResourceValidator resourceValidator;\n+\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tif (!resource.getErrors().isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<Issue> issues = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, cancelIndicator);\n+\t\t\treturn !exists(issues, (Issue issue) -> Objects.equal(issue.getSeverity(), Severity.ERROR));\n+\t\t}\n+\t}\n+\n+\t@Beta\n+\t@Singleton\n+\tclass Always implements IShouldGenerate {\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * whether code should be generated for this resource.", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjI4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812289", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjM4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812389", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:34Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjQ0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812444", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic String toString() {\n+\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjQ3Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812472", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:42Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzQ5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813492", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:02:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813692", "bodyText": "API typos make me sad :(", "author": "tivervac", "createdAt": "2020-03-06T10:03:11Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwMDA3NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388900074", "bodyText": "Nothing I can change here, right? It's protected.", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNzU5Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388927596", "bodyText": "Nope, sadly you can't do anything about this", "author": "tivervac", "createdAt": "2020-03-06T14:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzkyNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813926", "bodyText": "Sneaky throw", "author": "tivervac", "createdAt": "2020-03-06T10:03:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzk5Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813996", "bodyText": "Sneaky throw", "author": "tivervac", "createdAt": "2020-03-06T10:03:44Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDExMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814112", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:03:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDE4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814185", "bodyText": "sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:04:04Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDI2NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814264", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:04:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDMwOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814309", "bodyText": "Double try?", "author": "tivervac", "createdAt": "2020-03-06T10:04:18Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDM4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814382", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:04:26Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDQ0Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814443", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:35Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDQ4NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814484", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:40Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDUxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814510", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDU0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814544", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDU5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814592", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDY0MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814641", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:01Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeDelete getBeforeDelete() {\n+\t\treturn beforeDelete;\n+\t}\n+\n+\tpublic void setBeforeDelete(URIBasedFileSystemAccess.BeforeDelete beforeDelete) {\n+\t\tthis.beforeDelete = beforeDelete;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeWrite getBeforeWrite() {\n+\t\treturn beforeWrite;\n+\t}\n+\n+\tpublic void setBeforeWrite(URIBasedFileSystemAccess.BeforeWrite beforeWrite) {\n+\t\tthis.beforeWrite = beforeWrite;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDY3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814679", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeDelete getBeforeDelete() {\n+\t\treturn beforeDelete;\n+\t}\n+\n+\tpublic void setBeforeDelete(URIBasedFileSystemAccess.BeforeDelete beforeDelete) {\n+\t\tthis.beforeDelete = beforeDelete;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDcxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814718", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDc1OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814758", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTEwMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815100", "bodyText": "absoluteURI.toUri()", "author": "tivervac", "createdAt": "2020-03-06T10:05:52Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjIwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388846203", "bodyText": "you mean toString()?", "author": "szarnekow", "createdAt": "2020-03-06T11:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTI0Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815243", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:06:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof IllegalArgumentException) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTYyMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815621", "bodyText": "obj.toString()", "author": "tivervac", "createdAt": "2020-03-06T10:06:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof IllegalArgumentException) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(ISourceFolder sourceFolder) {\n+\t\treturn deresolve(sourceFolder.getPath());\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(IProjectConfig projectConfig) {\n+\t\tISourceFolder sourceFolder = projectConfig.findSourceFolderContaining(getURI());\n+\t\treturn sourceFolder != null ? deresolve(sourceFolder) : null;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj != null && !Objects.equal(obj.getClass(), AbsoluteURI.class)) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTg1NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815854", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:21Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTg4Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815887", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTkxNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815915", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTk3Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815976", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjA0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816047", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjA4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816081", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:48Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjEyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816127", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjI0Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816246", "bodyText": "new ArrayList<>();", "author": "tivervac", "createdAt": "2020-03-06T10:08:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjM3NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816375", "bodyText": "new ArrayList<>()", "author": "tivervac", "createdAt": "2020-03-06T10:08:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjQ5MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816491", "bodyText": "new ArrayList<>();", "author": "tivervac", "createdAt": "2020-03-06T10:08:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjU1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816555", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:08:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjgyMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816820", "bodyText": "Just remove every @Pure in this file", "author": "tivervac", "createdAt": "2020-03-06T10:09:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzYyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817623", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:10:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDM3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930378", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzg1Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817857", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:11:24Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDQzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930432", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzkxNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817914", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:11:32Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDQ4Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930483", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODEzNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818136", "bodyText": "sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:11:57Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM1Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818357", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:12:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDU0Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930542", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818389", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:12:26Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDUyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930527", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODQ3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818477", "bodyText": "CollectionLiterals", "author": "tivervac", "createdAt": "2020-03-06T10:12:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODcwNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818705", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:13:01Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODc5NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818795", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:13:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODg1NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818854", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:13:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODk2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818962", "bodyText": "CollectionLiterals", "author": "tivervac", "createdAt": "2020-03-06T10:13:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTEzMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819130", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:13:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTM3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819377", "bodyText": "Is the Integer.valueOf really needed?", "author": "tivervac", "createdAt": "2020-03-06T10:14:15Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDg5NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930895", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTUwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819501", "bodyText": "same, also it_1 is a pretty bad name", "author": "tivervac", "createdAt": "2020-03-06T10:14:33Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDkyOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930929", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTc5OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819798", "bodyText": "Conversions.unwrapArray this really isnt needed", "author": "tivervac", "createdAt": "2020-03-06T10:15:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg5NTkyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388895927", "bodyText": "Fixed, but please have a look if you agree that I got the meaning right.", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTk2Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819963", "bodyText": "Bad naming", "author": "tivervac", "createdAt": "2020-03-06T10:15:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDAzNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820037", "bodyText": "More sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:15:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;\n+\t\ttry {\n+\t\t\treturn render();\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof Exception) {\n+\t\t\t\t_xtrycatchfinallyexpression = Throwables.getStackTraceAsString(t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg5NjYzMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388896631", "bodyText": "Not sure what to do with this ... any suggestion?", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDEyNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820125", "bodyText": "more pure", "author": "tivervac", "createdAt": "2020-03-06T10:15:47Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;\n+\t\ttry {\n+\t\t\treturn render();\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof Exception) {\n+\t\t\t\t_xtrycatchfinallyexpression = Throwables.getStackTraceAsString(t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t\treturn _xtrycatchfinallyexpression;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDI2Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820266", "bodyText": "More pure", "author": "tivervac", "createdAt": "2020-03-06T10:16:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public abstract class AbstractURIWrapper {\n+\tprivate final URI uri;\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn uri.toString();\n+\t}\n+\n+\tpublic AbstractURIWrapper(URI uri) {\n+\t\tthis.uri = uri;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTQ3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388845479", "bodyText": "sneaky", "author": "szarnekow", "createdAt": "2020-03-06T11:11:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTY4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388845689", "bodyText": "Not sure if out should better be buffered if it isn't already.", "author": "szarnekow", "createdAt": "2020-03-06T11:11:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwMTczNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388901734", "bodyText": "Not sure, too. As this is refactoring only I tend to not change behaviour.", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjQ3MA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388846470", "bodyText": "obj.toString", "author": "szarnekow", "createdAt": "2020-03-06T11:13:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * A source relative URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class SourceRelativeURI extends AbstractURIWrapper {\n+\tpublic static SourceRelativeURI fromAbsolute(URI uri) {\n+\t\tif (uri.isRelative()) {\n+\t\t\tthrow new IllegalArgumentException(uri.toString());\n+\t\t}\n+\t\treturn new SourceRelativeURI(uri.path().substring(1));\n+\t}\n+\n+\tpublic SourceRelativeURI(URI sourceRelativeURI) {\n+\t\tsuper(sourceRelativeURI);\n+\t\tif (!sourceRelativeURI.isRelative() || sourceRelativeURI.path().startsWith(\"/\")) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(sourceRelativeURI));\n+\t\t}\n+\t}\n+\n+\tpublic SourceRelativeURI(String relativeURI) {\n+\t\tthis(URI.createURI(relativeURI));\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj != null && !Objects.equal(obj.getClass(), SourceRelativeURI.class)) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439", "url": "https://github.com/eclipse/xtext-core/commit/1822521ec3c6e302f6b864c091a9449b16ead439", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T13:57:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388924692", "bodyText": "Sure this should be an identity check?", "author": "tivervac", "createdAt": "2020-03-06T14:14:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index, EObject targetOrProxy,\n+\t\t\tURI targetURI) {\n+\t\tif (currentResource == null || source.eResource() != currentResource) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU4NjY3Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389586673", "bodyText": "Old generated code: if (((this.currentResource == null) || (source.eResource() != this.currentResource))) {\nHence: Yes, at least sure semantic has not changed.", "author": "ArneDeutsch", "createdAt": "2020-03-09T10:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4OTA4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389789085", "bodyText": "\ud83d\udc4d", "author": "szarnekow", "createdAt": "2020-03-09T16:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNTQwNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388925406", "bodyText": "Collections.emptyMap", "author": "tivervac", "createdAt": "2020-03-06T14:15:24Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"A slot with name \\'\" + outputConfiguration + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjIxNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926214", "bodyText": "I'd move this three lines lower", "author": "tivervac", "createdAt": "2020-03-06T14:16:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjUxNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926516", "bodyText": "This used to be an InterruptedException", "author": "tivervac", "createdAt": "2020-03-06T14:17:17Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjc2Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926766", "bodyText": "Redundant finals", "author": "tivervac", "createdAt": "2020-03-06T14:17:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessRequest implements Runnable {\n+\tprivate final URI uri;\n+\n+\tprivate final Runnable runMe;\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTE1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388931159", "bodyText": "file_1?", "author": "tivervac", "createdAt": "2020-03-06T14:25:35Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388931532", "bodyText": "Another it_1", "author": "tivervac", "createdAt": "2020-03-06T14:26:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU4OTczNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389589734", "bodyText": "Need to differentiate from \"it\" here ...", "author": "ArneDeutsch", "createdAt": "2020-03-09T10:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwMTYyNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r390301624", "bodyText": "You can just call it \"handle\"", "author": "tivervac", "createdAt": "2020-03-10T13:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjMwMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388932302", "bodyText": "No need for Integer.valueOf", "author": "tivervac", "createdAt": "2020-03-06T14:27:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU5MDIyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389590223", "bodyText": "In fact it is needed ... eclipse compiler does not complain, but maven build fails without. Guess there are subtable differences in compiler implementation.", "author": "ArneDeutsch", "createdAt": "2020-03-09T11:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDE1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388934159", "bodyText": "Static import this if there is no name collision", "author": "tivervac", "createdAt": "2020-03-06T14:30:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDI0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388934244", "bodyText": "Same", "author": "tivervac", "createdAt": "2020-03-06T14:30:53Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU5MTUxOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389591519", "bodyText": "In fact it is needed ... eclipse compiler does not complain, but maven build fails without. Guess there are subtable differences in compiler implementation.", "author": "ArneDeutsch", "createdAt": "2020-03-09T11:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNTU3NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388935575", "bodyText": "This used to be IllegalArgumentException", "author": "tivervac", "createdAt": "2020-03-06T14:33:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(absoluteURI.toString());\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2e39ad150fae434a096c502225e051ce459a4da", "url": "https://github.com/eclipse/xtext-core/commit/d2e39ad150fae434a096c502225e051ce459a4da", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-09T11:05:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NjQ3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389796479", "bodyText": "A toString would be awesome.", "author": "szarnekow", "createdAt": "2020-03-09T16:12:23Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessRequest implements Runnable {", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NzA0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389797049", "bodyText": "Cosmetics: Can be simplified to OutputConfigurationAdapter.class.equals(type)", "author": "szarnekow", "createdAt": "2020-03-09T16:13:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwMjAwMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389802000", "bodyText": "Could be come Preconditions.checkNotNull(..) and the subsequent hashCode and equals implementation could be simplified.", "author": "szarnekow", "createdAt": "2020-03-09T16:20:37Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389830655", "bodyText": "It would be really useful if these would declare throws IOException", "author": "szarnekow", "createdAt": "2020-03-09T17:05:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3MTA0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392071049", "bodyText": "Not sure here about API consequences ... and what about BeforeRead and BeforeDelete!?", "author": "ArneDeutsch", "createdAt": "2020-03-13T07:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MjAxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392082018", "bodyText": "I tried to include beforeRead and beforeDelete in these.\nDeclaring an exception on the signature would be binary compatible, but source incompatible. However, since some the callbacks will be implemented with Xtend, it wouldn't matter (sneakyThrow ...). @cdietrich What's your take?", "author": "szarnekow", "createdAt": "2020-03-13T08:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MjQ4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392082481", "bodyText": "is there anybody out there using (calling) this at all?", "author": "cdietrich", "createdAt": "2020-03-13T08:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4Mjk4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392082981", "bodyText": "maybe you can have a look at these", "author": "cdietrich", "createdAt": "2020-03-13T08:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTA0Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389831046", "bodyText": "There is only a single field. We could try to avoid the ToStringBuilder", "author": "szarnekow", "createdAt": "2020-03-09T17:06:09Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn new ToStringBuilder(this).addAllFields().toString();", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTM5Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389831396", "bodyText": "Severity is an enum - identity comparison could be used here.", "author": "szarnekow", "createdAt": "2020-03-09T17:06:42Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+@ImplementedBy(IShouldGenerate.OnlyWithoutErrors.class)\n+public interface IShouldGenerate {\n+\t@Beta\n+\t@Singleton\n+\tclass OnlyWithoutErrors implements IShouldGenerate {\n+\t\t@Inject\n+\t\tprivate IResourceValidator resourceValidator;\n+\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tif (!resource.getErrors().isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<Issue> issues = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, cancelIndicator);\n+\t\t\treturn !exists(issues, (Issue issue) -> Objects.equal(issue.getSeverity(), Severity.ERROR));", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "url": "https://github.com/eclipse/xtext-core/commit/9f4bf0fb16a8d36a8252a316db7602d7387a2697", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-13T07:46:15Z", "type": "commit"}, {"oid": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "url": "https://github.com/eclipse/xtext-core/commit/9f4bf0fb16a8d36a8252a316db7602d7387a2697", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-13T07:46:15Z", "type": "forcePushed"}]}