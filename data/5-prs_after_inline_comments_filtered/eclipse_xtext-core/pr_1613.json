{"pr_number": 1613, "pr_title": "Java based formatter2 API and Xtext formatter", "pr_createdAt": "2020-11-06T08:24:35Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1613", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyMTAzNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r518621035", "bodyText": "FormatterTestLanguageJavaFormatter?", "author": "cdietrich", "createdAt": "2020-11-06T09:20:35Z", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/formatting2/internal/JavaFormatter.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.formatting2.internal;\n+\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.internal.formattertestlanguage.IDList;\n+import org.eclipse.xtext.formatting2.internal.services.FormatterTestLanguageGrammarAccess;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Arne Deutsch - Initial contribution and API\n+ */\n+public class JavaFormatter extends AbstractJavaFormatter {", "originalCommit": "d7c9adaa595ff54bcc448efa2d40fa29a8f70120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxMTc0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r518811744", "bodyText": "Done.", "author": "ArneDeutsch", "createdAt": "2020-11-06T15:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyMTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyMTc0MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r518621741", "bodyText": "add @since 2.24 to class", "author": "cdietrich", "createdAt": "2020-11-06T09:21:52Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/formatting2/AbstractJavaFormatter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.formatting2;\n+\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.formatting2.regionaccess.IEObjectRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionFinder;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.Exceptions;\n+import org.eclipse.xtext.util.PolymorphicDispatcher;\n+import org.eclipse.xtext.util.PolymorphicDispatcher.ErrorHandler;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * <p>\n+ * This is an abstract base class for language-specific formatters, intended to be extended with a java class.\n+ * </p>\n+ * <p>\n+ * It is working very much like {@link AbstractFormatter2} but does support additional methods to simplify java\n+ * formatter code.\n+ * </p>\n+ * <p>\n+ * the \"_format\" methods are called by reflection. The name is important as well as there are exactly two arguments\n+ * whereas the first one is of the element type you like to format and the second one of type\n+ * {@link IFormattableDocument}. The methods should be protected.\n+ * </p>\n+ * <p>\n+ * Example code for a java formatter:\n+ * \n+ * <pre>\n+ * import static org.xtext.example.mydsl.myDsl.MyDslPackage.Literals.*;\n+ * \n+ * public class MyDslFormatter2 extends AbstractJavaFormatter {\n+ * \tprotected void _format(Model model, IFormattableDocument doc) {\n+ * \t\tfor (Parent parent : model.getParents())\n+ * \t\t\tdoc.format(parent);\n+ * \t}\n+ * \n+ * \tprotected void _format(Parent parent, IFormattableDocument doc) {\n+ * \t\tdoc.prepend(regionFor(parent).keyword(\"parent\"), it -> it.noSpace());\n+ * \t\tdoc.append(regionFor(parent).keyword(\"parent\"), it -> it.oneSpace());\n+ * \t\tdoc.append(regionFor(parent).feature(PARENT__NAME), it -> it.oneSpace());\n+ * \t\tdoc.prepend(regionFor(parent).keyword(\"{\"), it -> it.oneSpace());\n+ * \t\tdoc.append(regionFor(parent).keyword(\"{\"), it -> it.newLine());\n+ * \t\tdoc.interior(regionFor(parent).keyword(\"{\"), regionFor(parent).keyword(\"}\"), it -> it.indent());\n+ * \t\tdoc.append(regionFor(parent).keyword(\"}\"), it -> it.setNewLines(1, 1, 2));\n+ * \t\tfor (Child child : parent.getChildren())\n+ * \t\t\tdoc.format(child);\n+ * \t}\n+ * \n+ * \tprotected void _format(Child child, IFormattableDocument doc) {\n+ * \t\tdoc.append(regionFor(child).keyword(\"child\"), it -> it.oneSpace());\n+ * \t\tdoc.append(regionFor(child).feature(CHILD__NAME), it -> it.newLine());\n+ * \t}\n+ * }\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * This is suitable for the following grammar:\n+ * \n+ * <pre>\n+ * grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals\n+ * \n+ * generate myDsl \"http://www.xtext.org/example/mydsl/MyDsl\"\n+ * \n+ * Model: parents+=Parent*;\n+ * Parent: 'parent' name=ID '!' ('{' children+=Child* '}')?;\n+ * Child: 'child' name=ID;\n+ * </pre>\n+ * </p>\n+ */\n+@Beta", "originalCommit": "d7c9adaa595ff54bcc448efa2d40fa29a8f70120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxMTgwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r518811808", "bodyText": "Done.", "author": "ArneDeutsch", "createdAt": "2020-11-06T15:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyMTc0MQ=="}], "type": "inlineReview"}, {"oid": "a2c79c9da75c4d24b28561be8f53b93c63475432", "url": "https://github.com/eclipse/xtext-core/commit/a2c79c9da75c4d24b28561be8f53b93c63475432", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-06T15:25:06Z", "type": "forcePushed"}, {"oid": "15b7f0603b9b4a3c1fa9674e40d882d5d74adb4d", "url": "https://github.com/eclipse/xtext-core/commit/15b7f0603b9b4a3c1fa9674e40d882d5d74adb4d", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-06T15:32:56Z", "type": "forcePushed"}, {"oid": "cd6cff9c8b4d0260370c315ed5990bd158065a30", "url": "https://github.com/eclipse/xtext-core/commit/cd6cff9c8b4d0260370c315ed5990bd158065a30", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-06T15:42:05Z", "type": "forcePushed"}, {"oid": "f1cc75a192a65128aa66f1fa5865c18cb93ddb19", "url": "https://github.com/eclipse/xtext-core/commit/f1cc75a192a65128aa66f1fa5865c18cb93ddb19", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-06T16:16:49Z", "type": "forcePushed"}, {"oid": "8ef51221232d8954bf64f27b72e055034cc76bcd", "url": "https://github.com/eclipse/xtext-core/commit/8ef51221232d8954bf64f27b72e055034cc76bcd", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-06T16:26:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTg0Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521245842", "bodyText": "I know it's a test, but for documentation purpose it would be good to find a better name for it", "author": "szarnekow", "createdAt": "2020-11-11T10:01:13Z", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/formatting2/internal/FormatterTestLanguageJavaFormatter.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.formatting2.internal;\n+\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.internal.formattertestlanguage.IDList;\n+import org.eclipse.xtext.formatting2.internal.services.FormatterTestLanguageGrammarAccess;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Arne Deutsch - Initial contribution and API\n+ */\n+public class FormatterTestLanguageJavaFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tFormatterTestLanguageGrammarAccess grammar;\n+\n+\tprotected void format(IDList list, IFormattableDocument doc) {\n+\t\tdoc.prepend(regionFor(list).keyword(\"idlist\"), it -> it.noSpace());", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwNTExMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r522805111", "bodyText": "it -> it. is clutter that I can not get rid of. noSpace() only, as in Xtend, is much more nice. I can not make a nice name of it, just want to keep it short. This is why I stick to the \"default\" ... other than that I would choose a one-letter-name ...", "author": "ArneDeutsch", "createdAt": "2020-11-13T08:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxNTQyOA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r522815428", "bodyText": "f -> f is also nonsaying\nIHiddenRegionFormatter::noSpace\nis also lengthy", "author": "cdietrich", "createdAt": "2020-11-13T09:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NjYyNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521246625", "bodyText": "Can this become a reusable utility if we inject the interface of the formatter instead of the concrete type?", "author": "szarnekow", "createdAt": "2020-11-11T10:02:31Z", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/formatting2/internal/JavaFormatterTestHelper.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.formatting2.internal;\n+\n+import org.eclipse.xtext.formatting2.IFormatter2;\n+import org.eclipse.xtext.testing.formatter.FormatterTestHelper;\n+import org.eclipse.xtext.testing.formatter.FormatterTestRequest;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Arne Deutsch - Initial contribution and API\n+ */\n+public class JavaFormatterTestHelper extends FormatterTestHelper {\n+\n+\t@Inject\n+\tprivate FormatterTestLanguageJavaFormatter formatter;", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzOTE5Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r522839193", "bodyText": "Not sure. The paretn does the following:\n@Inject(optional = true)\nprivate Provider<IFormatter2> formatter;\n\nprotected IFormatter2 createFormatter(FormatterTestRequest request) {\n\tcheckNotNull(formatter, \"There is a Guice Binding missing for \" + IFormatter2.class.getName());\n\treturn formatter.get();\n}\n\nAnd the other sibling overrides with:\n@Override\nprotected IFormatter2 createFormatter(FormatterTestRequest req) {\n\treturn ((GenericFormatterTestRequest) req).getFormatter();\n}\n\nRight now it seems there is not much room for reusability here ...", "author": "ArneDeutsch", "createdAt": "2020-11-13T09:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NjYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0ODA5NA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521248094", "bodyText": "As far as I can tell, AbstractXtextTests was meant to be used for various test languages in this test bundle. Having a method load(URI) that expects the resource to point to an Xtext grammar file, appears to be wrong.", "author": "szarnekow", "createdAt": "2020-11-11T10:05:03Z", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/tests/AbstractXtextTests.java", "diffHunk": "@@ -390,6 +397,30 @@ protected String readFileIntoString(String filePath) throws IOException {\n \t\tthrow new IllegalStateException(\"May not happen, but helps to suppress false positives in eclipse' control flow analysis.\");\n \t}\n \n+\tprotected Grammar load(URI uri) {", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0ODM3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521248378", "bodyText": "Can this go to some of the various Serialization test utils?", "author": "szarnekow", "createdAt": "2020-11-11T10:05:29Z", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/tests/AbstractXtextTests.java", "diffHunk": "@@ -390,6 +397,30 @@ protected String readFileIntoString(String filePath) throws IOException {\n \t\tthrow new IllegalStateException(\"May not happen, but helps to suppress false positives in eclipse' control flow analysis.\");\n \t}\n \n+\tprotected Grammar load(URI uri) {\n+\t\tXtextResourceSet rs = new XtextResourceSet();\n+\t\treturn (Grammar) rs.getResource(uri, true).getContents().get(0);\n+\t}\n+\n+\tprotected List<Pair<EObject, ICompositeNode>> detachNodeModel(EObject eObject) {", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1MzIxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521253218", "bodyText": "please use a more descriptive name for it or replace by method reference TypeOfIt::noSpace", "author": "szarnekow", "createdAt": "2020-11-11T10:13:52Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/formatting2/AbstractJavaFormatter.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.formatting2;\n+\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.formatting2.regionaccess.IEObjectRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionFinder;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.Exceptions;\n+import org.eclipse.xtext.util.PolymorphicDispatcher;\n+import org.eclipse.xtext.util.PolymorphicDispatcher.ErrorHandler;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * <p>\n+ * This is an abstract base class for language-specific formatters, intended to be extended with a java class.\n+ * </p>\n+ * <p>\n+ * It is working very much like {@link AbstractFormatter2} but does support additional methods to simplify java\n+ * formatter code.\n+ * </p>\n+ * <p>\n+ * the \"_format\" methods are called by reflection. The name is important as well as there are exactly two arguments\n+ * whereas the first one is of the element type you like to format and the second one of type\n+ * {@link IFormattableDocument}. The methods should be protected.\n+ * </p>\n+ * <p>\n+ * Example code for a java formatter:\n+ * \n+ * <pre>\n+ * import static org.xtext.example.mydsl.myDsl.MyDslPackage.Literals.*;\n+ * \n+ * public class MyDslFormatter2 extends AbstractJavaFormatter {\n+ * \tprotected void _format(Model model, IFormattableDocument doc) {\n+ * \t\tfor (Parent parent : model.getParents())\n+ * \t\t\tdoc.format(parent);\n+ * \t}\n+ * \n+ * \tprotected void _format(Parent parent, IFormattableDocument doc) {\n+ * \t\tdoc.prepend(regionFor(parent).keyword(\"parent\"), it -> it.noSpace());", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1Mzc4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521253789", "bodyText": "Why not a JavaDoc comment?", "author": "szarnekow", "createdAt": "2020-11-11T10:14:53Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/formatting2/AbstractJavaFormatter.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.formatting2;\n+\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.formatting2.regionaccess.IEObjectRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionFinder;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.Exceptions;\n+import org.eclipse.xtext.util.PolymorphicDispatcher;\n+import org.eclipse.xtext.util.PolymorphicDispatcher.ErrorHandler;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * <p>\n+ * This is an abstract base class for language-specific formatters, intended to be extended with a java class.\n+ * </p>\n+ * <p>\n+ * It is working very much like {@link AbstractFormatter2} but does support additional methods to simplify java\n+ * formatter code.\n+ * </p>\n+ * <p>\n+ * the \"_format\" methods are called by reflection. The name is important as well as there are exactly two arguments\n+ * whereas the first one is of the element type you like to format and the second one of type\n+ * {@link IFormattableDocument}. The methods should be protected.\n+ * </p>\n+ * <p>\n+ * Example code for a java formatter:\n+ * \n+ * <pre>\n+ * import static org.xtext.example.mydsl.myDsl.MyDslPackage.Literals.*;\n+ * \n+ * public class MyDslFormatter2 extends AbstractJavaFormatter {\n+ * \tprotected void _format(Model model, IFormattableDocument doc) {\n+ * \t\tfor (Parent parent : model.getParents())\n+ * \t\t\tdoc.format(parent);\n+ * \t}\n+ * \n+ * \tprotected void _format(Parent parent, IFormattableDocument doc) {\n+ * \t\tdoc.prepend(regionFor(parent).keyword(\"parent\"), it -> it.noSpace());\n+ * \t\tdoc.append(regionFor(parent).keyword(\"parent\"), it -> it.oneSpace());\n+ * \t\tdoc.append(regionFor(parent).feature(PARENT__NAME), it -> it.oneSpace());\n+ * \t\tdoc.prepend(regionFor(parent).keyword(\"{\"), it -> it.oneSpace());\n+ * \t\tdoc.append(regionFor(parent).keyword(\"{\"), it -> it.newLine());\n+ * \t\tdoc.interior(regionFor(parent).keyword(\"{\"), regionFor(parent).keyword(\"}\"), it -> it.indent());\n+ * \t\tdoc.append(regionFor(parent).keyword(\"}\"), it -> it.setNewLines(1, 1, 2));\n+ * \t\tfor (Child child : parent.getChildren())\n+ * \t\t\tdoc.format(child);\n+ * \t}\n+ * \n+ * \tprotected void _format(Child child, IFormattableDocument doc) {\n+ * \t\tdoc.append(regionFor(child).keyword(\"child\"), it -> it.oneSpace());\n+ * \t\tdoc.append(regionFor(child).feature(CHILD__NAME), it -> it.newLine());\n+ * \t}\n+ * }\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * This is suitable for the following grammar:\n+ * \n+ * <pre>\n+ * grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals\n+ * \n+ * generate myDsl \"http://www.xtext.org/example/mydsl/MyDsl\"\n+ * \n+ * Model: parents+=Parent*;\n+ * Parent: 'parent' name=ID '!' ('{' children+=Child* '}')?;\n+ * Child: 'child' name=ID;\n+ * </pre>\n+ * </p>\n+ * \n+ * @author Arne Deutsch\n+ * @since 2.24\n+ */\n+@Beta\n+public abstract class AbstractJavaFormatter extends AbstractFormatter2 {\n+\n+\tprivate PolymorphicDispatcher<Void> dispatcher = createPolymorhicDispatcher();\n+\n+\t// Error handler dispatches to default method in case of a missing method in concrete formatter\n+\tprotected class EObjectErrorHandler implements ErrorHandler<Void> {\n+\t\t@Override\n+\t\tpublic Void handle(Object[] params, Throwable e) {\n+\t\t\tif (e instanceof NoSuchMethodException) {\n+\t\t\t\tif (params.length == 2 && params[0] instanceof EObject && params[1] instanceof IFormattableDocument) {\n+\t\t\t\t\t_format((EObject) params[0], (IFormattableDocument) params[1]);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Exceptions.throwUncheckedException(e);\n+\t\t}\n+\t}\n+\n+\t// reflective method that calls \"_format\" methods found in the implementing class.", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1NTQ4NA==", "url": "https://github.com/eclipse/xtext-core/pull/1613#discussion_r521255484", "bodyText": "Is regionFor(rule) a cheap call? Or should we store the region in a local var?", "author": "szarnekow", "createdAt": "2020-11-11T10:18:00Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/xtext/XtextFormatterJava.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.com) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.xtext;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractMetamodelDeclaration;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Action;\n+import org.eclipse.xtext.Alternatives;\n+import org.eclipse.xtext.Annotation;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.CharacterRange;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.EnumRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.Group;\n+import org.eclipse.xtext.Keyword;\n+import org.eclipse.xtext.NamedArgument;\n+import org.eclipse.xtext.NegatedToken;\n+import org.eclipse.xtext.Parameter;\n+import org.eclipse.xtext.ParserRule;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.UntilToken;\n+import org.eclipse.xtext.Wildcard;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+\n+/**\n+ * @author Arne Deutsch - Initial contribution and API\n+ */\n+public class XtextFormatterJava extends AbstractJavaFormatter {\n+\n+\tprotected void format(Grammar grammar, IFormattableDocument doc) {\n+\t\tdoc.prepend(regionFor(grammar).keyword(\"(\"), it -> it.noSpace());\n+\t\tformatParens(grammar, doc);\n+\t\tregionFor(grammar).keywords(\",\").forEach(s -> doc.prepend(s, it -> it.noSpace()));\n+\t\tregionFor(grammar).keywords(\",\").forEach(s -> doc.append(s, it -> it.oneSpace()));\n+\t\tboolean first = true;\n+\t\tfor (AbstractMetamodelDeclaration decl : grammar.getMetamodelDeclarations()) {\n+\t\t\tdoc.set(previousHiddenRegion(decl), first ? it -> it.setNewLines(2) : it -> it.setNewLines(1));\n+\t\t\tfirst = false;\n+\t\t\tdoc.format(decl);\n+\t\t}\n+\t\tfor (AbstractRule rule : grammar.getRules()) {\n+\t\t\tdoc.set(previousHiddenRegion(rule), it -> it.setNewLines(2));\n+\t\t\tdoc.format(rule);\n+\t\t}\n+\t\tdoc.set(nextHiddenRegion(grammar), it -> it.setNewLines(0, 0, 1));\n+\t}\n+\n+\tprotected void format(ParserRule rule, IFormattableDocument doc) {\n+\t\tdoc.prepend(regionFor(rule).keyword(\"<\"), it -> it.oneSpace());\n+\t\tdoc.append(regionFor(rule).keyword(\">\"), it -> it.noSpace());\n+\t\trule.getParameters().forEach(p -> doc.format(p));\n+\t\tformatRule(rule, doc);\n+\t\tformatParens(rule, doc);\n+\t}\n+\n+\tprotected void format(TerminalRule rule, IFormattableDocument doc) {\n+\t\tformatRule(rule, doc);\n+\t}\n+\n+\tprotected void format(EnumRule rule, IFormattableDocument doc) {\n+\t\tformatRule(rule, doc);\n+\t}\n+\n+\tprotected void format(Alternatives alternatives, IFormattableDocument doc) {\n+\t\tregionFor(alternatives).keywords(\"|\").forEach(r -> {\n+\t\t\tdoc.surround(r, it -> it.autowrap());\n+\t\t\tdoc.surround(r, it -> it.setNewLines(0, 0, 1));\n+\t\t\tdoc.surround(r, it -> it.oneSpace());\n+\t\t});\n+\t\tformatParens(alternatives, doc);\n+\t\tformatCardinality(alternatives, doc);\n+\t\tfor (AbstractElement element : alternatives.getElements())\n+\t\t\tdoc.format(element);\n+\t}\n+\n+\tprotected void format(Assignment assignment, IFormattableDocument doc) {\n+\t\tregionFor(assignment).keywords(\"=\", \"+=\", \"?=\").forEach(r -> doc.surround(r, it -> it.noSpace()));\n+\t\tformatCardinality(assignment, doc);\n+\t\tformatParens(assignment, doc);\n+\t\tdoc.format(assignment.getTerminal());\n+\t}\n+\n+\tprotected void format(Group group, IFormattableDocument doc) {\n+\t\tformatCardinality(group, doc);\n+\t\tformatParens(group, doc);\n+\t\tboolean first = true;\n+\t\tEList<AbstractElement> elements = group.getElements();\n+\t\tint size = elements.size();\n+\t\tint index = 0;\n+\t\tfor (AbstractElement element : elements) {\n+\t\t\tindex++;\n+\t\t\tboolean last = index == size;\n+\t\t\tif (!first && !last) {\n+\t\t\t\tdoc.prepend(element, it -> it.setNewLines(0, 0, 1));\n+\t\t\t\tif (!(element instanceof UntilToken) && !(element instanceof Group))\n+\t\t\t\t\tdoc.surround(element, it -> it.oneSpace());\n+\t\t\t} else if (!first && last) {\n+\t\t\t\tdoc.prepend(element, it -> it.setNewLines(0, 0, 1));\n+\t\t\t}\n+\t\t\tfirst = false;\n+\t\t\tdoc.format(element);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Wildcard wildcard, IFormattableDocument doc) {\n+\t\tdoc.surround(regionFor(wildcard).keyword(\":\"), it -> it.oneSpace());\n+\t}\n+\n+\tprotected void format(CharacterRange range, IFormattableDocument doc) {\n+\t\tdoc.surround(regionFor(range).keyword(\"..\"), it -> it.noSpace());\n+\t\tformatCardinality(range, doc);\n+\t\tdoc.format(range.getLeft());\n+\t\tdoc.format(range.getRight());\n+\t}\n+\n+\tprotected void format(RuleCall call, IFormattableDocument doc) {\n+\t\tdoc.append(call, it -> it.autowrap());\n+\t\tdoc.prepend(regionFor(call).keyword(\"<\"), it -> it.noSpace());\n+\t\tcall.getArguments().forEach(a -> doc.format(a));\n+\t}\n+\n+\tprotected void format(Keyword keyword, IFormattableDocument doc) {\n+\t\tdoc.surround(keyword, it -> it.autowrap());\n+\t\tformatCardinality(keyword, doc);\n+\t}\n+\n+\tprotected void format(NegatedToken token, IFormattableDocument doc) {\n+\t\tdoc.append(regionFor(token).keyword(\"!\"), it -> it.noSpace());\n+\t\tformatParens(token, doc);\n+\t\tformatCardinality(token, doc);\n+\t\tdoc.format(token.getTerminal());\n+\t}\n+\n+\tprotected void format(UntilToken token, IFormattableDocument doc) {\n+\t\tdoc.surround(regionFor(token).keyword(\"->\"), it -> it.noSpace());\n+\t\tdoc.format(token.getTerminal());\n+\t}\n+\n+\tprotected void format(Action action, IFormattableDocument doc) {\n+\t\tdoc.append(regionFor(action).keyword(\"{\"), it -> it.noSpace());\n+\t\tdoc.prepend(regionFor(action).keyword(\"}\"), it -> it.noSpace());\n+\t}\n+\n+\tprotected void format(CrossReference ref, IFormattableDocument doc) {\n+\t\tdoc.prepend(regionFor(ref).keyword(\"[\"), it -> it.autowrap());\n+\t\tdoc.append(regionFor(ref).keyword(\"[\"), it -> it.noSpace());\n+\t\tdoc.prepend(regionFor(ref).keyword(\"]\"), it -> it.noSpace());\n+\t\tdoc.append(regionFor(ref).keyword(\"]\"), it -> it.autowrap());\n+\t\tdoc.surround(regionFor(ref).keyword(\"|\"), it -> it.noSpace());\n+\t\tdoc.format(ref.getType());\n+\t}\n+\n+\tprotected void format(Parameter param, IFormattableDocument doc) {\n+\t\tdoc.surround(param, it -> it.noSpace());\n+\t}\n+\n+\tprotected void format(NamedArgument param, IFormattableDocument doc) {\n+\t\tdoc.surround(param, it -> it.noSpace());\n+\t\tregionFor(param).keywords(\"=\").forEach(k -> doc.surround(k, it -> it.noSpace()));\n+\t}\n+\n+\tprotected void format(TypeRef ref, IFormattableDocument doc) {\n+\t\tdoc.surround(regionFor(ref).keyword(\"::\"), it -> it.noSpace());\n+\t}\n+\n+\tprotected void format(Annotation annotation, IFormattableDocument doc) {\n+\t\tdoc.surround(regionFor(annotation).keyword(\"@\"), it -> it.noSpace());\n+\t\tdoc.append(annotation, it -> it.newLine());\n+\t}\n+\n+\tprivate void formatRule(AbstractRule rule, IFormattableDocument doc) {\n+\t\tdoc.surround(regionFor(rule).keyword(\"returns\"), it -> it.oneSpace());", "originalCommit": "8ef51221232d8954bf64f27b72e055034cc76bcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a331e173df064546ad87ebf3e6a24d9646ca08b7", "url": "https://github.com/eclipse/xtext-core/commit/a331e173df064546ad87ebf3e6a24d9646ca08b7", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-13T07:08:00Z", "type": "forcePushed"}, {"oid": "816273c7594f17c60dfd98cdfe639d82175d1efd", "url": "https://github.com/eclipse/xtext-core/commit/816273c7594f17c60dfd98cdfe639d82175d1efd", "message": "Review adaptions.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-16T08:21:55Z", "type": "forcePushed"}, {"oid": "ad62f8360439c62724289f78b1d2cdad1085fb60", "url": "https://github.com/eclipse/xtext-core/commit/ad62f8360439c62724289f78b1d2cdad1085fb60", "message": "[eclipse/xtext#1697] Abstract super class for java based formatters.\n[#1489] Java based Xtext formatter (formatter2 API).\n\nRemove API restrictions.\nTesting java based formatter.\nFormatter2 Java Fragment.", "committedDate": "2020-11-16T08:32:34Z", "type": "commit"}, {"oid": "ad62f8360439c62724289f78b1d2cdad1085fb60", "url": "https://github.com/eclipse/xtext-core/commit/ad62f8360439c62724289f78b1d2cdad1085fb60", "message": "[eclipse/xtext#1697] Abstract super class for java based formatters.\n[#1489] Java based Xtext formatter (formatter2 API).\n\nRemove API restrictions.\nTesting java based formatter.\nFormatter2 Java Fragment.", "committedDate": "2020-11-16T08:32:34Z", "type": "forcePushed"}]}