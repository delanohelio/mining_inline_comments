{"pr_number": 559, "pr_title": "[OC-1144] Adds parents to entity and forbides cycle in transitive ref\"", "pr_createdAt": "2020-11-02T15:30:44Z", "pr_url": "https://github.com/opfab/operatorfabric-core/pull/559", "timeline": [{"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "url": "https://github.com/opfab/operatorfabric-core/commit/33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "message": "[OC-1144] Adds parents to entity and forbides cycle in transitive ref\"\n\nSigned-off-by: LE-GALL Ronan Ext <43667786+rlg-rte@users.noreply.github.com>", "committedDate": "2020-11-02T15:26:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3MTQ1MQ==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516571451", "bodyText": "Put it in package org.lfenergy.operatorfabric.users.utils", "author": "freddidierRTE", "createdAt": "2020-11-03T10:40:40Z", "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3OTM3NA==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516579374", "bodyText": "You should sychronized this bock of code", "author": "freddidierRTE", "createdAt": "2020-11-03T10:54:07Z", "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntitiesController.java", "diffHunk": "@@ -81,9 +82,18 @@ public Entity createEntity(HttpServletRequest request, HttpServletResponse respo\n             response.addHeader(\"Location\", request.getContextPath() + \"/entities/\" + entity.getId());\n             response.setStatus(201);\n         }\n+        // let's do this quite mindlessly\n+        List<EntityData> entities = entityRepository.findAll();\n+        this.checkForCycleInEntityParenthood(entity, entities);\n         return entityRepository.save((EntityData) entity);", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzMjM4Mw==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516632383", "bodyText": "Why not just :\n.filter(entity -> { if (entity == null) return false; return !entity.getId().equals(currentEntity.getId(); }) ...", "author": "freddidierRTE", "createdAt": "2020-11-03T12:32:28Z", "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiError;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiErrorException;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.springframework.http.HttpStatus;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/*\n+This helper class presumes that stored Entities don't cycle (beware manual database updates)\n+ */\n+@Slf4j\n+public class EntityCycleDetector {\n+    final private List<String> visitedId;\n+    final private Map<String, List<String>> graph;\n+    final private String currentEntityId;\n+\n+    EntityCycleDetector(Entity currentEntity, List<? extends Entity> allEntities) {\n+        this.currentEntityId = currentEntity.getId();\n+        Set<Entity> allEntitiesPlusNewOne = allEntities.stream()\n+                // allow update of an entity by removing its former version from inspected entities\n+                .filter(entity -> {\n+                    if (entity == null) return false;\n+                    boolean idDifference = entity.getId().equals(currentEntity.getId());\n+                    boolean isNewEntity = entity.equals(currentEntity);\n+                    boolean isNotPreviousVersionOfTheUpdateEntity = !idDifference || isNewEntity;\n+                    return isNotPreviousVersionOfTheUpdateEntity;", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5ODI2OA==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516798268", "bodyText": "As this part of code is tricky, I thought that declaring variables would ease the comprehension of this part of the code.", "author": "rlg-pro", "createdAt": "2020-11-03T16:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzMjM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzMzUyMg==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516633522", "bodyText": "genuineAddition shoud always return true as the entity has been removed from the Set ?", "author": "freddidierRTE", "createdAt": "2020-11-03T12:34:38Z", "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiError;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiErrorException;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.springframework.http.HttpStatus;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/*\n+This helper class presumes that stored Entities don't cycle (beware manual database updates)\n+ */\n+@Slf4j\n+public class EntityCycleDetector {\n+    final private List<String> visitedId;\n+    final private Map<String, List<String>> graph;\n+    final private String currentEntityId;\n+\n+    EntityCycleDetector(Entity currentEntity, List<? extends Entity> allEntities) {\n+        this.currentEntityId = currentEntity.getId();\n+        Set<Entity> allEntitiesPlusNewOne = allEntities.stream()\n+                // allow update of an entity by removing its former version from inspected entities\n+                .filter(entity -> {\n+                    if (entity == null) return false;\n+                    boolean idDifference = entity.getId().equals(currentEntity.getId());\n+                    boolean isNewEntity = entity.equals(currentEntity);\n+                    boolean isNotPreviousVersionOfTheUpdateEntity = !idDifference || isNewEntity;\n+                    return isNotPreviousVersionOfTheUpdateEntity;\n+                })\n+                .collect(Collectors.toSet());\n+        boolean genuineAddition = allEntitiesPlusNewOne.add(currentEntity);\n+        if (genuineAddition) {\n+            this.graph = allEntitiesPlusNewOne.stream()\n+                    .collect(Collectors.toMap(Entity::getId, entity -> entity.getParents()));\n+        } else {\n+            // no detection needed has entity identical to stored one\n+            this.graph = Collections.emptyMap();\n+        }", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5OTc3Mg==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516799772", "bodyText": "In case the added entity is identical to the previous one the .add method of the Set return false thus the comment line 38.", "author": "rlg-pro", "createdAt": "2020-11-03T16:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzMzUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzNTUxMw==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516635513", "bodyText": "parentEntityId instead of childEntityId", "author": "freddidierRTE", "createdAt": "2020-11-03T12:38:21Z", "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiError;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiErrorException;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.springframework.http.HttpStatus;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/*\n+This helper class presumes that stored Entities don't cycle (beware manual database updates)\n+ */\n+@Slf4j\n+public class EntityCycleDetector {\n+    final private List<String> visitedId;\n+    final private Map<String, List<String>> graph;\n+    final private String currentEntityId;\n+\n+    EntityCycleDetector(Entity currentEntity, List<? extends Entity> allEntities) {\n+        this.currentEntityId = currentEntity.getId();\n+        Set<Entity> allEntitiesPlusNewOne = allEntities.stream()\n+                // allow update of an entity by removing its former version from inspected entities\n+                .filter(entity -> {\n+                    if (entity == null) return false;\n+                    boolean idDifference = entity.getId().equals(currentEntity.getId());\n+                    boolean isNewEntity = entity.equals(currentEntity);\n+                    boolean isNotPreviousVersionOfTheUpdateEntity = !idDifference || isNewEntity;\n+                    return isNotPreviousVersionOfTheUpdateEntity;\n+                })\n+                .collect(Collectors.toSet());\n+        boolean genuineAddition = allEntitiesPlusNewOne.add(currentEntity);\n+        if (genuineAddition) {\n+            this.graph = allEntitiesPlusNewOne.stream()\n+                    .collect(Collectors.toMap(Entity::getId, entity -> entity.getParents()));\n+        } else {\n+            // no detection needed has entity identical to stored one\n+            this.graph = Collections.emptyMap();\n+        }\n+        this.visitedId = new ArrayList<>(graph.size());\n+    }\n+\n+    void throwApiExceptionOnCycle() {\n+        if (hasCycle()) {\n+            String cycle = String.join(\"->\", visitedId);\n+            throw new ApiErrorException(\n+                    ApiError.builder()\n+                            .status(HttpStatus.BAD_REQUEST)\n+                            .message(EntitiesController.CYCLE_DETECTION + \": \" + cycle)\n+                            .build());\n+        }\n+    }\n+    // inspects only cycle introduce by new entity and stops on the first one detected\n+    boolean hasCycle() {\n+        if(graph.isEmpty()) return false;// false entity update, i.e. stored and new one are identical\n+        return hasCycle(this.currentEntityId, visitedId);\n+    }\n+\n+    private boolean hasCycle(String entityId, List<String> visited) {\n+        if (visited.contains(entityId)){\n+            visited.add(entityId); // for error message clarity\n+            return true;\n+        }\n+        visited.add(entityId);\n+        if (graph.containsKey(entityId)) {\n+            for (String childEntityId : graph.get(entityId)) {\n+                if (hasCycle(childEntityId, visited)) return true;", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzNzkyMw==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516637923", "bodyText": "the collection is not empty in this test", "author": "freddidierRTE", "createdAt": "2020-11-03T12:42:37Z", "path": "services/core/users/src/test/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetectorShould.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import org.junit.jupiter.api.Test;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.lfenergy.operatorfabric.users.model.EntityData;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class EntityCycleDetectorShould {\n+\n+    /*\n+    Method naming convention expected to ease comprehension of tests\n+    It's a mix of Serpent and Camel Case.\n+    Double '_' to separate \"Given statements\".\n+\n+    Begins with expected result:\n+    - OK -> no cycle detected (hasCycle() return false);\n+    - CYCLE -> a cycle detected within the entities (hasCycle() return true).\n+\n+    THe 3rd part describes the Added Entity (which is tested) and it's parent content.\n+\n+    The 5th part describes the entity collection itself.\n+\n+    Shorthands used:\n+     - 4 -> for;\n+     - 2 -> to.\n+\n+    All constants and helping methods are declared right after the first method using them and are declared in CamelCase.\n+\n+     */\n+\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParents__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final String testedEntity = \"entityFreshlyAdded\";\n+\n+    @Test\n+    void OK__4__AddedEntityWithUnknownParents__In__AnEmptyEntityCollection(){\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has unknown parents\")\n+                .parents(UNKNOWNPARENTS)\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final Set<String> UNKNOWNPARENTS = Stream.of(\"unknownParent0\", \"unknownParent1\", \"unknownParent2\").collect(Collectors.toSet());\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferring2Itself__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+        Entity entityWithUnknownParents = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity references itself\")\n+                .parents(this.buildSet(entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(entityWithUnknownParents, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> buildSet(String... parents) {\n+        return Arrays.asList(parents).stream().collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityWithUnknownParentsAndReferring2ItSelf__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+\n+        Entity withoutAnyParent_And_RefersItself = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity has unknown parents AND references itself\")\n+                .parents(this.mixeParentRef(UNKNOWNPARENTS, entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent_And_RefersItself, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> mixeParentRef(Set<String> idCollections, String ... ids){\n+        Set<String> collect = Arrays.stream(ids).collect(Collectors.toSet());\n+        collect.addAll(UNKNOWNPARENTS);\n+        return collect;\n+    }\n+\n+    private final EntityData entityWithNoParent = EntityData.builder()\n+            .id(\"entityWithNoParent\")\n+            .description(\"first entity\").build();\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferencingItSelf__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .parents(this.buildSet(testedEntity))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private final EntityData entityReferencingUnknownParents = EntityData.builder()\n+            .id(\"entityReferencingUnknownParent\")\n+            .description(\"this entity as unknown entity has parents\")\n+            .parents(UNKNOWNPARENTS)\n+            .build();\n+    private final EntityData entityReferencingEntityWithNoParents = EntityData.builder()\n+            .id(\"entityWithEntityWithNoParentAsParent\")\n+            .description(\"This entity has a single parent entity, the one with no Parents\")\n+            .parents(this.buildSet(entityWithNoParent))\n+            .build();\n+\n+    private Set<String> buildSet(Entity ... entities) {\n+        return Arrays.stream(entities).map(Entity::getId).collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEmptyEntityCollection () {", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzODIwNA==", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516638204", "bodyText": "the collection is not empty in this test", "author": "freddidierRTE", "createdAt": "2020-11-03T12:43:12Z", "path": "services/core/users/src/test/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetectorShould.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import org.junit.jupiter.api.Test;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.lfenergy.operatorfabric.users.model.EntityData;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class EntityCycleDetectorShould {\n+\n+    /*\n+    Method naming convention expected to ease comprehension of tests\n+    It's a mix of Serpent and Camel Case.\n+    Double '_' to separate \"Given statements\".\n+\n+    Begins with expected result:\n+    - OK -> no cycle detected (hasCycle() return false);\n+    - CYCLE -> a cycle detected within the entities (hasCycle() return true).\n+\n+    THe 3rd part describes the Added Entity (which is tested) and it's parent content.\n+\n+    The 5th part describes the entity collection itself.\n+\n+    Shorthands used:\n+     - 4 -> for;\n+     - 2 -> to.\n+\n+    All constants and helping methods are declared right after the first method using them and are declared in CamelCase.\n+\n+     */\n+\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParents__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final String testedEntity = \"entityFreshlyAdded\";\n+\n+    @Test\n+    void OK__4__AddedEntityWithUnknownParents__In__AnEmptyEntityCollection(){\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has unknown parents\")\n+                .parents(UNKNOWNPARENTS)\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final Set<String> UNKNOWNPARENTS = Stream.of(\"unknownParent0\", \"unknownParent1\", \"unknownParent2\").collect(Collectors.toSet());\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferring2Itself__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+        Entity entityWithUnknownParents = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity references itself\")\n+                .parents(this.buildSet(entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(entityWithUnknownParents, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> buildSet(String... parents) {\n+        return Arrays.asList(parents).stream().collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityWithUnknownParentsAndReferring2ItSelf__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+\n+        Entity withoutAnyParent_And_RefersItself = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity has unknown parents AND references itself\")\n+                .parents(this.mixeParentRef(UNKNOWNPARENTS, entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent_And_RefersItself, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> mixeParentRef(Set<String> idCollections, String ... ids){\n+        Set<String> collect = Arrays.stream(ids).collect(Collectors.toSet());\n+        collect.addAll(UNKNOWNPARENTS);\n+        return collect;\n+    }\n+\n+    private final EntityData entityWithNoParent = EntityData.builder()\n+            .id(\"entityWithNoParent\")\n+            .description(\"first entity\").build();\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferencingItSelf__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .parents(this.buildSet(testedEntity))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private final EntityData entityReferencingUnknownParents = EntityData.builder()\n+            .id(\"entityReferencingUnknownParent\")\n+            .description(\"this entity as unknown entity has parents\")\n+            .parents(UNKNOWNPARENTS)\n+            .build();\n+    private final EntityData entityReferencingEntityWithNoParents = EntityData.builder()\n+            .id(\"entityWithEntityWithNoParentAsParent\")\n+            .description(\"This entity has a single parent entity, the one with no Parents\")\n+            .parents(this.buildSet(entityWithNoParent))\n+            .build();\n+\n+    private Set<String> buildSet(Entity ... entities) {\n+        return Arrays.stream(entities).map(Entity::getId).collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEmptyEntityCollection () {\n+        List<Entity> entities = Arrays.asList(\n+                entityWithNoParent\n+                , entityReferencingUnknownParents\n+                , entityReferencingEntityWithNoParents);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    @Test\n+    void OK__4__AddedEntityReferringUnknownParent__In__AnEmptyCollection () {", "originalCommit": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fdacb04fb8ab81d60840b325c1707f62bda2b396", "url": "https://github.com/opfab/operatorfabric-core/commit/fdacb04fb8ab81d60840b325c1707f62bda2b396", "message": "[OC-1144] applyes suggested modifications\n\nSigned-off-by: LE-GALL Ronan Ext <43667786+rlg-rte@users.noreply.github.com>", "committedDate": "2020-11-04T17:44:53Z", "type": "commit"}, {"oid": "237aa0ab6a03ced0c620e9f7c836ccab778852ec", "url": "https://github.com/opfab/operatorfabric-core/commit/237aa0ab6a03ced0c620e9f7c836ccab778852ec", "message": "[OC-1144] Correct minor sonar warnings\n\nSigned-off-by: freddidierRTE <frederic-f.didier@rte-france.com>", "committedDate": "2020-11-05T11:04:50Z", "type": "commit"}]}