{"pr_number": 2134, "pr_title": "Refactor text assessment conflict tables", "pr_createdAt": "2020-09-29T09:33:47Z", "pr_url": "https://github.com/ls1intum/Artemis/pull/2134", "timeline": [{"oid": "d400c0685cdbf8c16dc98e693ddb7b3bd40c064d", "url": "https://github.com/ls1intum/Artemis/commit/d400c0685cdbf8c16dc98e693ddb7b3bd40c064d", "message": "rename table and Java files to be more generic\n\nthis way we can also handle modeling conflicts in the future", "committedDate": "2020-09-29T08:49:20Z", "type": "commit"}, {"oid": "893138b66baed663a92cc5f7eeed11887e689a2c", "url": "https://github.com/ls1intum/Artemis/commit/893138b66baed663a92cc5f7eeed11887e689a2c", "message": "check if the feedback text is null", "committedDate": "2020-09-29T09:17:00Z", "type": "commit"}, {"oid": "886ca03ff05e4017ed4b50d833bc17a7542877fa", "url": "https://github.com/ls1intum/Artemis/commit/886ca03ff05e4017ed4b50d833bc17a7542877fa", "message": "another rename :-)", "committedDate": "2020-09-29T09:21:18Z", "type": "commit"}, {"oid": "5cd8ee8eec51d4a79071a4a42d7122f233497593", "url": "https://github.com/ls1intum/Artemis/commit/5cd8ee8eec51d4a79071a4a42d7122f233497593", "message": "Merge branch 'bugfix/refactor-text-assessment-conflict' of https://github.com/ls1intum/Artemis into bugfix/refactor-text-assessment-conflict\n\n# Conflicts:\n#\tsrc/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "committedDate": "2020-09-29T09:22:35Z", "type": "commit"}, {"oid": "0331afe5392e22aa43fed769e10bd1a756c29467", "url": "https://github.com/ls1intum/Artemis/commit/0331afe5392e22aa43fed769e10bd1a756c29467", "message": "add TODO", "committedDate": "2020-09-29T09:23:11Z", "type": "commit"}, {"oid": "267cef6a5077a32da798f027cc06be22bf14ced2", "url": "https://github.com/ls1intum/Artemis/commit/267cef6a5077a32da798f027cc06be22bf14ced2", "message": "One last rename", "committedDate": "2020-09-29T09:42:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwODcwNg==", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496608706", "bodyText": "Actually, those references ensure the deletion of referenced conflicts when the feedback is deleted.", "author": "bigultekin", "createdAt": "2020-09-29T10:25:51Z", "path": "src/main/java/de/tum/in/www1/artemis/domain/Feedback.java", "diffHunk": "@@ -70,6 +70,7 @@\n     @ManyToOne\n     private GradingInstruction gradingInstruction;\n \n+    // TODO: JP remove these two references as they are not really needed", "originalCommit": "0331afe5392e22aa43fed769e10bd1a756c29467", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1Mzc2Nw==", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496653767", "bodyText": "We now, but we don't like the implementation, so we want to find a better way in the future", "author": "krusche", "createdAt": "2020-09-29T11:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwODcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNDQxOQ==", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496634419", "bodyText": "Maybe it would be a good idea to start using the text blocks @MaisiKoleni was referencing today in the meeting as this is a rather long query", "author": "anditurdiu", "createdAt": "2020-09-29T11:13:26Z", "path": "src/main/java/de/tum/in/www1/artemis/repository/FeedbackConflictRepository.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package de.tum.in.www1.artemis.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.stereotype.Repository;\n+\n+import de.tum.in.www1.artemis.domain.FeedbackConflict;\n+\n+/**\n+ * Spring Data JPA repository for the FeedbackConflict entity.\n+ */\n+@Repository\n+public interface FeedbackConflictRepository extends JpaRepository<FeedbackConflict, Long> {\n+\n+    @Query(\"select distinct conflict from FeedbackConflict conflict where conflict.conflict = true and (conflict.firstFeedback.id in (:feedbackIds) or conflict.secondFeedback.id in (:feedbackIds))\")\n+    List<FeedbackConflict> findAllByFeedbackList(@Param(\"feedbackIds\") List<Long> feedbackIds);\n+\n+    @Query(\"select distinct conflict from FeedbackConflict conflict where conflict.conflict = true and \"", "originalCommit": "267cef6a5077a32da798f027cc06be22bf14ced2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1Mzg4NQ==", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496653885", "bodyText": "in a follow up, yes", "author": "krusche", "createdAt": "2020-09-29T11:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNDQxOQ=="}], "type": "inlineReview"}, {"oid": "fc3e4e1f80c7f77bc59062d2d47cd6c2e9db96c1", "url": "https://github.com/ls1intum/Artemis/commit/fc3e4e1f80c7f77bc59062d2d47cd6c2e9db96c1", "message": "rename primary key name", "committedDate": "2020-09-29T12:33:34Z", "type": "commit"}, {"oid": "7ab53881b98639afb01b15b71a10b79020da8e44", "url": "https://github.com/ls1intum/Artemis/commit/7ab53881b98639afb01b15b71a10b79020da8e44", "message": "Merge branch 'develop' into bugfix/refactor-text-assessment-conflict", "committedDate": "2020-09-29T12:38:56Z", "type": "commit"}, {"oid": "441ba2b77de1130f77504b89fd79298171849323", "url": "https://github.com/ls1intum/Artemis/commit/441ba2b77de1130f77504b89fd79298171849323", "message": "Update 20200726015816_changelog.xml", "committedDate": "2020-09-29T12:52:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NTUxOQ==", "url": "https://github.com/ls1intum/Artemis/pull/2134#discussion_r496695519", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "artemis-bot", "createdAt": "2020-09-29T12:59:14Z", "path": "src/main/java/de/tum/in/www1/artemis/service/AutomaticTextAssessmentConflictService.java", "diffHunk": "@@ -61,82 +61,81 @@ public void asyncCheckFeedbackConsistency(List<TextBlock> textBlocks, List<Feedb\n         feedbackList.removeIf(f -> !f.hasReference());\n \n         // If text block doesn't have a cluster id don't create an object\n-        List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS = feedbackList.stream().flatMap(feedback -> {\n+        List<TextFeedbackConflictRequestDTO> textFeedbackConflictRequestDTOS = feedbackList.stream().flatMap(feedback -> {\n             Optional<TextBlock> textBlock = textBlockRepository\n                     .findById(textBlocks.stream().filter(block -> block.getId().equals(feedback.getReference())).findFirst().get().getId());\n-            if (textBlock.isPresent() && textBlock.get().getCluster() != null) {\n-                return Stream.of(new TextAssessmentConflictRequestDTO(textBlock.get().getId(), textBlock.get().getText(), textBlock.get().getCluster().getId(), feedback.getId(),\n+            if (textBlock.isPresent() && textBlock.get().getCluster() != null && feedback.getDetailText() != null) {\n+                return Stream.of(new TextFeedbackConflictRequestDTO(textBlock.get().getId(), textBlock.get().getText(), textBlock.get().getCluster().getId(), feedback.getId(),\n                         feedback.getDetailText(), feedback.getCredits()));\n             }\n             else {\n                 return Stream.empty();\n             }\n         }).collect(toList());\n \n-        if (textAssessmentConflictRequestDTOS.isEmpty()) {\n+        if (textFeedbackConflictRequestDTOS.isEmpty()) {\n             return;\n         }\n \n         // remote service call to athene\n-        final List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS;\n+        final List<FeedbackConflictResponseDTO> feedbackConflictResponseDTOS;\n         try {\n-            textAssessmentConflictResponseDTOS = textAssessmentConflictService.checkFeedbackConsistencies(textAssessmentConflictRequestDTOS, exerciseId, 0);\n+            feedbackConflictResponseDTOS = textAssessmentConflictService.checkFeedbackConsistencies(textFeedbackConflictRequestDTOS, exerciseId, 0);\n         }\n         catch (NetworkingError networkingError) {\n             log.error(networkingError.getMessage(), networkingError);\n             return;\n         }\n \n         // create an array to store conflicts\n-        List<TextAssessmentConflict> textAssessmentConflicts = new ArrayList<>();\n+        List<FeedbackConflict> feedbackConflicts = new ArrayList<>();\n \n         // look for new conflicts\n         // Athene may find conflicts with feedback ids that are not in the feedback repository any more. So check for them. (May happen if the feedback is deleted in Artemis but\n         // already stored in Athene)\n-        textAssessmentConflictResponseDTOS.forEach(conflict -> {\n+        feedbackConflictResponseDTOS.forEach(conflict -> {\n             Optional<Feedback> firstFeedback = feedbackRepository.findById(conflict.getFirstFeedbackId());\n             Optional<Feedback> secondFeedback = feedbackRepository.findById(conflict.getSecondFeedbackId());\n-            List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findByFirstAndSecondFeedback(conflict.getFirstFeedbackId(),\n-                    conflict.getSecondFeedbackId());\n+            List<FeedbackConflict> storedConflicts = this.feedbackConflictRepository.findByFirstAndSecondFeedback(conflict.getFirstFeedbackId(), conflict.getSecondFeedbackId());\n             // if the found conflict is present but its type has changed, update it\n             if (!storedConflicts.isEmpty() && !storedConflicts.get(0).getType().equals(conflict.getType())) {\n                 storedConflicts.get(0).setType(conflict.getType());\n-                textAssessmentConflicts.add(storedConflicts.get(0));\n+                feedbackConflicts.add(storedConflicts.get(0));\n             }\n \n             // new conflict\n             if (firstFeedback.isPresent() && secondFeedback.isPresent() && storedConflicts.isEmpty()) {\n-                TextAssessmentConflict textAssessmentConflict = new TextAssessmentConflict();\n-                textAssessmentConflict.setConflict(true);\n-                textAssessmentConflict.setFirstFeedback(firstFeedback.get());\n-                textAssessmentConflict.setSecondFeedback(secondFeedback.get());\n-                textAssessmentConflict.setType(conflict.getType());\n-                textAssessmentConflict.setCreatedAt(ZonedDateTime.now());\n-                textAssessmentConflicts.add(textAssessmentConflict);\n+                FeedbackConflict feedbackConflict = new FeedbackConflict();\n+                feedbackConflict.setConflict(true);\n+                feedbackConflict.setFirstFeedback(firstFeedback.get());\n+                feedbackConflict.setSecondFeedback(secondFeedback.get());\n+                feedbackConflict.setType(conflict.getType());\n+                feedbackConflict.setCreatedAt(ZonedDateTime.now());\n+                feedbackConflicts.add(feedbackConflict);\n             }\n         });\n \n         // find solved conflicts and add them to list\n-        textAssessmentConflicts.addAll(this.findSolvedConflicts(textAssessmentConflictRequestDTOS, textAssessmentConflictResponseDTOS));\n+        feedbackConflicts.addAll(this.findSolvedConflicts(textFeedbackConflictRequestDTOS, feedbackConflictResponseDTOS));\n \n-        textAssessmentConflictRepository.saveAll(textAssessmentConflicts);\n+        feedbackConflictRepository.saveAll(feedbackConflicts);\n     }\n \n     /**\n      * Searches if the feedback that are sent to Athene already have conflicts in the database(storedConflicts),\n      * If the stored conflicts are not returned from Athene after the consistency check, it means that they are solved and set as solved.\n      *\n-     * @param textAssessmentConflictRequestDTOS the list sent to Athene for check\n-     * @param textAssessmentConflictResponseDTOS returned list with found conflicts.\n+     * @param textFeedbackConflictRequestDTOS the list sent to Athene for check\n+     * @param feedbackConflictResponseDTOS returned list with found conflicts.\n      * @return solved conflicts\n      */\n-    private List<TextAssessmentConflict> findSolvedConflicts(List<TextAssessmentConflictRequestDTO> textAssessmentConflictRequestDTOS,\n-            List<TextAssessmentConflictResponseDTO> textAssessmentConflictResponseDTOS) {\n-        List<Long> feedbackIds = textAssessmentConflictRequestDTOS.stream().map(TextAssessmentConflictRequestDTO::getFeedbackId).collect(toList());\n-        List<TextAssessmentConflict> storedConflicts = this.textAssessmentConflictRepository.findAllByFeedbackList(feedbackIds);\n+    private List<FeedbackConflict> findSolvedConflicts(List<TextFeedbackConflictRequestDTO> textFeedbackConflictRequestDTOS,\n+            List<FeedbackConflictResponseDTO> feedbackConflictResponseDTOS) {\n+        List<Long> feedbackIds = textFeedbackConflictRequestDTOS.stream().map(TextFeedbackConflictRequestDTO::getFeedbackId).collect(toList());\n+        List<FeedbackConflict> storedConflicts = this.feedbackConflictRepository.findAllByFeedbackList(feedbackIds);\n \n         storedConflicts.forEach(conflict -> {\n-            boolean isPresent = textAssessmentConflictResponseDTOS.stream().anyMatch(newConflicts -> (newConflicts.getFirstFeedbackId() == conflict.getFirstFeedback().getId()\n+            boolean isPresent = feedbackConflictResponseDTOS.stream().anyMatch(newConflicts -> (newConflicts.getFirstFeedbackId() == conflict.getFirstFeedback().getId()", "originalCommit": "441ba2b77de1130f77504b89fd79298171849323", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}