{"pr_number": 1389, "pr_title": "Support ByteBuf writing in NettyResponseChannel", "pr_createdAt": "2020-02-18T20:53:19Z", "pr_url": "https://github.com/linkedin/ambry/pull/1389", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3ODIwMQ==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r382278201", "bodyText": "Maybe a typo here for j added before @param.", "author": "xuhao417347761", "createdAt": "2020-02-20T21:52:20Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyResponseChannel.java", "diffHunk": "@@ -443,7 +443,7 @@ private boolean maybeWriteResponseMetadata(HttpResponse responseMetadata,\n \n   /**\n    * Builds and sends an error response to the client based on {@code cause}.\n-   * @param exception the cause of the request handling failure.\n+   *j@param exception the cause of the request handling failure.", "originalCommit": "351ae76b4206d798aa8363743a4148c0d5587c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzcwNw==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r382953707", "bodyText": "private static final", "author": "cgtz", "createdAt": "2020-02-23T00:53:58Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyResponseChannel.java", "diffHunk": "@@ -86,7 +86,7 @@\n   private final ChunkedWriteHandler chunkedWriteHandler;\n   private final PerformanceConfig perfConfig;\n \n-  private final Logger logger = LoggerFactory.getLogger(getClass());\n+  private final static Logger logger = LoggerFactory.getLogger(NettyResponseChannel.class);", "originalCommit": "13777002348b108944d899ab0d7c441b90a97e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1Mzg0Ng==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r382953846", "bodyText": "this seems like it should be exception != null or result == null", "author": "cgtz", "createdAt": "2020-02-23T00:57:11Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyResponseChannel.java", "diffHunk": "@@ -127,6 +127,23 @@\n \n   @Override\n   public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    return write(Unpooled.wrappedBuffer(src), new Callback<Long>() {\n+      @Override\n+      public void onCompletion(Long result, Exception exception) {\n+        if (exception == null) {", "originalCommit": "13777002348b108944d899ab0d7c441b90a97e77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MjQ1OQ==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r383582459", "bodyText": "I suppose when result == null then the exception would be not null.", "author": "justinlin-linkedin", "createdAt": "2020-02-24T23:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1Mzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDQ1Nw==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r382954457", "bodyText": "i would recommend doing the thing that was done with in the default impl in AsyncWritableChannel where a second future is created and completed from the callback. This will ensure that the future returned is completed after the buffer position is changed.", "author": "cgtz", "createdAt": "2020-02-23T01:11:07Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyResponseChannel.java", "diffHunk": "@@ -127,6 +127,23 @@\n \n   @Override\n   public Future<Long> write(ByteBuffer src, Callback<Long> callback) {", "originalCommit": "13777002348b108944d899ab0d7c441b90a97e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NTIwOQ==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r382955209", "bodyText": "should these buffers be retained before sending as content? If the chunk callback called by operationProgressed releases the buffer and the content object is also released by downstream channel handlers (not sure if this part happens or not), it may get an IllegalReferenceCountException", "author": "cgtz", "createdAt": "2020-02-23T01:28:43Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyResponseChannel.java", "diffHunk": "@@ -877,14 +893,13 @@ public HttpContent readChunk(ByteBufAllocator allocator) throws Exception {\n       Chunk chunk = chunksToWrite.poll();\n       if (chunk != null) {\n         chunk.onDequeue();\n-        ByteBuf buf = Unpooled.wrappedBuffer(chunk.buffer);\n-        progress.addAndGet(chunk.buffer.remaining());\n+        progress.addAndGet(chunk.buffer.readableBytes());\n         chunksAwaitingCallback.add(chunk);\n         if (chunk.isLast) {\n-          content = new DefaultLastHttpContent(buf);\n+          content = new DefaultLastHttpContent(chunk.buffer);", "originalCommit": "13777002348b108944d899ab0d7c441b90a97e77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NjYwOQ==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r382956609", "bodyText": "Confirmed that the outgoing ByteBuf will be released once it reaches the end of the pipeline: https://netty.io/wiki/reference-counted-objects.html#outbound-messages", "author": "cgtz", "createdAt": "2020-02-23T01:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NTIwOQ=="}], "type": "inlineReview"}, {"oid": "ddd0eb34aa541d946d43afabfb420707a2c60daf", "url": "https://github.com/linkedin/ambry/commit/ddd0eb34aa541d946d43afabfb420707a2c60daf", "message": "Address casey comments", "committedDate": "2020-02-25T01:14:10Z", "type": "forcePushed"}, {"oid": "005d7b91e62d7231fb06332551f738542564a74b", "url": "https://github.com/linkedin/ambry/commit/005d7b91e62d7231fb06332551f738542564a74b", "message": "Address casey comments", "committedDate": "2020-02-25T07:28:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwNjYwMA==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r384706600", "bodyText": "Why 0 instead of previous src.position()?", "author": "zzmao", "createdAt": "2020-02-26T19:16:15Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyResponseChannel.java", "diffHunk": "@@ -127,6 +127,23 @@\n \n   @Override\n   public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    FutureResult<Long> futureResult = new FutureResult<>();\n+    write(Unpooled.wrappedBuffer(src), new Callback<Long>() {\n+      @Override\n+      public void onCompletion(Long result, Exception exception) {\n+        long r = result == null ? (long) 0 : result.longValue();\n+        src.position((int) r);", "originalCommit": "005d7b91e62d7231fb06332551f738542564a74b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxNjE4Nw==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r384716187", "bodyText": "not used.", "author": "zzmao", "createdAt": "2020-02-26T19:33:50Z", "path": "ambry-rest/src/test/java/com.github.ambry.rest/NettyResponseChannelTest.java", "diffHunk": "@@ -17,10 +17,12 @@\n import com.github.ambry.config.PerformanceConfig;\n import com.github.ambry.config.VerifiableProperties;\n import com.github.ambry.router.Callback;\n+import com.github.ambry.utils.NettyByteBufLeakHelper;\n import com.github.ambry.utils.TestUtils;\n import com.github.ambry.utils.Utils;\n import com.github.ambry.utils.UtilsTest;\n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;", "originalCommit": "005d7b91e62d7231fb06332551f738542564a74b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0a1c99e7c7bf852f986ebda67580c71fc629fbe6", "url": "https://github.com/linkedin/ambry/commit/0a1c99e7c7bf852f986ebda67580c71fc629fbe6", "message": "Addres comments", "committedDate": "2020-02-26T22:07:30Z", "type": "forcePushed"}, {"oid": "c730f019958c2da77bcb98226663a30f36ba3509", "url": "https://github.com/linkedin/ambry/commit/c730f019958c2da77bcb98226663a30f36ba3509", "message": "WIP", "committedDate": "2020-02-27T02:13:51Z", "type": "commit"}, {"oid": "a05c14cdc3a217d6be811c872506f7fec21974a4", "url": "https://github.com/linkedin/ambry/commit/a05c14cdc3a217d6be811c872506f7fec21974a4", "message": "Support ByteBuf writing in NettyResponseChannel", "committedDate": "2020-02-27T02:13:51Z", "type": "commit"}, {"oid": "5c3aca4b978db2a8203417d1337f86ad4c656a88", "url": "https://github.com/linkedin/ambry/commit/5c3aca4b978db2a8203417d1337f86ad4c656a88", "message": "Address casey comments", "committedDate": "2020-02-27T02:13:51Z", "type": "commit"}, {"oid": "3f5628bd627351f273a9ed5745ce9005084b6fb2", "url": "https://github.com/linkedin/ambry/commit/3f5628bd627351f273a9ed5745ce9005084b6fb2", "message": "Addres comments", "committedDate": "2020-02-27T21:51:54Z", "type": "commit"}, {"oid": "5249cc714fd81db29610fda5a765dd579d825854", "url": "https://github.com/linkedin/ambry/commit/5249cc714fd81db29610fda5a765dd579d825854", "message": "Fix a weird bug", "committedDate": "2020-02-28T01:12:11Z", "type": "commit"}, {"oid": "5249cc714fd81db29610fda5a765dd579d825854", "url": "https://github.com/linkedin/ambry/commit/5249cc714fd81db29610fda5a765dd579d825854", "message": "Fix a weird bug", "committedDate": "2020-02-28T01:12:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2MDY3Mw==", "url": "https://github.com/linkedin/ambry/pull/1389#discussion_r385460673", "bodyText": "I have seen a really weird bug, where a range request would somehow pollute the blob data here. I change the way we are dealing with range request data to copying it out. And it fixes the problem. This is weird, but I won't get into too much detail.", "author": "justinlin-linkedin", "createdAt": "2020-02-28T01:15:45Z", "path": "ambry-router/src/test/java/com.github.ambry.router/InMemoryRouter.java", "diffHunk": "@@ -157,7 +157,11 @@ public ByteBuffer getBlob(ByteRange range) throws RouterException {\n         } catch (IllegalArgumentException e) {\n           throw new RouterException(\"Invalid range for blob\", e, RouterErrorCode.RangeNotSatisfiable);\n         }\n-        buf = ByteBuffer.wrap(blob.array(), (int) resolvedRange.getStartOffset(), (int) resolvedRange.getRangeSize());\n+        byte[] bytes = new byte[(int) resolvedRange.getRangeSize()];\n+        ByteBuffer duplicate = blob.duplicate();\n+        duplicate.position((int) resolvedRange.getStartOffset());\n+        duplicate.get(bytes);\n+        buf = ByteBuffer.wrap(bytes);\n       }", "originalCommit": "5249cc714fd81db29610fda5a765dd579d825854", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}