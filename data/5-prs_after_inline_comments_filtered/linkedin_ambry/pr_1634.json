{"pr_number": 1634, "pr_title": "Add REST handler for accounts/updateContainers", "pr_createdAt": "2020-09-29T20:58:51Z", "pr_url": "https://github.com/linkedin/ambry/pull/1634", "timeline": [{"oid": "53d873b5098dccacb26ecaab47b418461704d397", "url": "https://github.com/linkedin/ambry/commit/53d873b5098dccacb26ecaab47b418461704d397", "message": "Add REST handler for accounts/updateContainers\nMove common logic from HelixAccountService to AbstractAccountService", "committedDate": "2020-09-29T20:54:19Z", "type": "commit"}, {"oid": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "url": "https://github.com/linkedin/ambry/commit/6ab5ade12a55b9ee08ae701b467e583722fdca48", "message": "Implement AccountService.updateContainers() as upsert operation, remove addContainers()\nRevert moving InMemoryUnknownAccountService to test project", "committedDate": "2020-09-29T22:45:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNDI3Ng==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497214276", "bodyText": "minor: format this file to clean up the unused imports.", "author": "jsjtzyy", "createdAt": "2020-09-30T02:54:57Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -13,19 +13,28 @@\n  */\n package com.github.ambry.account;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import java.util.*;\n+import com.github.ambry.config.AccountServiceConfig;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxODEzMg==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497218132", "bodyText": "minor: we can remove unused imports from this file.", "author": "jsjtzyy", "createdAt": "2020-09-30T03:11:17Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -259,73 +259,6 @@ public boolean updateAccounts(Collection<Account> accounts) {\n     return updateAccountsWithAccountMetadataStore(accounts, accountMetadataStore);\n   }\n \n-  /**", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMDI3OA==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497220278", "bodyText": "I know this else branch is for updating container but do we also need to check if this container exists? Looks like we assume it is present without checking existingContainersInAccount.containsKey(container.getName()).", "author": "jsjtzyy", "createdAt": "2020-09-30T03:20:19Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -68,6 +79,71 @@ public Account getAccountById(short id) {\n     return accountInfoMapRef.get().getAccounts();\n   }\n \n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    checkOpen();\n+    // input validation\n+    if (accountName == null || accountName.isEmpty() || containers == null || containers.isEmpty()) {\n+      throw new AccountServiceException(\"Account or container is null or empty\", AccountServiceErrorCode.BadRequest);\n+    }\n+    Account account = getAccountByName(accountName);\n+    if (account == null) {\n+      logger.error(\"Account {} is not found\", accountName);\n+      throw new AccountServiceException(\"Account \" + accountName + \" is not found\", AccountServiceErrorCode.NotFound);\n+    }\n+\n+    List<Container> resolvedContainers = new ArrayList<>();\n+    // create a hashmap to map the name to existing containers in account\n+    Map<String, Container> existingContainersInAccount = new HashMap<>();\n+    account.getAllContainers().forEach(c -> existingContainersInAccount.put(c.getName(), c));\n+\n+    // Generate container ids for new containers\n+    short nextContainerId = account.getAllContainers()\n+        .stream()\n+        .map(Container::getId)\n+        .max(Short::compareTo)\n+        .map(maxId -> (short) (maxId + 1))\n+        .orElse(config.containerIdStartNumber);\n+\n+    for (Container container : containers) {\n+      if (container.getId() == Container.UNKNOWN_CONTAINER_ID) {\n+        // new container\n+        // make sure there is no conflicting container (conflicting means a container with same name but different attributes already exists).\n+        Container existingContainer = existingContainersInAccount.get(container.getName());\n+        if (existingContainer != null) {\n+          if (existingContainer.isSameContainer(container)) {\n+            // If an exactly same container already exists, ignore it. Adding same container multiple times is no-op.\n+          } else {\n+            throw new AccountServiceException(\"There is a conflicting container in account \" + accountName,\n+                AccountServiceErrorCode.ResourceConflict);\n+          }\n+        } else {\n+          resolvedContainers.add(\n+              new ContainerBuilder(container).setId(nextContainerId).setParentAccountId(account.getId()).build());\n+          ++nextContainerId;\n+        }\n+      } else {\n+        // existing container\n+        resolvedContainers.add(container);", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwNjgxOA==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497706818", "bodyText": "Oh good point.  I was assuming that the ensuing call to updateAccounts() would check that, but it's better to do it here.", "author": "lightningrob", "createdAt": "2020-09-30T18:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMDI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMTI3Mw==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497221273", "bodyText": "Why this is protected?", "author": "jsjtzyy", "createdAt": "2020-09-30T03:24:39Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -40,22 +41,21 @@\n /**\n  * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n  */\n-public class MySqlAccountService implements AccountService {\n+public class MySqlAccountService extends AbstractAccountService {\n \n   private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n   static final String MYSQL_ACCOUNT_UPDATER_PREFIX = \"mysql-account-updater\";\n-  private final AccountServiceMetrics accountServiceMetrics;\n+  protected final AtomicBoolean open = new AtomicBoolean(true);", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwNzU2OA==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497707568", "bodyText": "Good question.  I copied the line from HelixAccountService.  I'll change it to private in both places.", "author": "lightningrob", "createdAt": "2020-09-30T18:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwOTAxNw==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497709017", "bodyText": "Or maybe move it to Abstract class and keep it protected?", "author": "lightningrob", "createdAt": "2020-09-30T18:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MjE2MQ==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497772161", "bodyText": "Yes, it seems more reasonable.", "author": "jsjtzyy", "createdAt": "2020-09-30T20:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MDM5OQ==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497980399", "bodyText": "Kept it private in both classes.", "author": "lightningrob", "createdAt": "2020-10-01T04:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMTI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMzk5Mw==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497223993", "bodyText": "Looks like these two methods are not really needed. Any specific reason to keep them?", "author": "jsjtzyy", "createdAt": "2020-09-30T03:35:42Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountCollectionSerde.java", "diffHunk": "@@ -57,4 +57,44 @@ public static JSONObject toJson(Collection<Account> accounts) {\n       return accounts;\n     }\n   }\n+\n+  public static Account accountFromJson(JSONObject json) {\n+    return Account.fromJson(json);\n+  }\n+\n+  public static JSONObject accountToJson(Account account, boolean excludeContainers) {\n+    JSONObject jsonObject = account.toJson(false);\n+    if (excludeContainers) {\n+      jsonObject.remove(Account.CONTAINERS_KEY);\n+    }\n+    return jsonObject;\n+  }\n+\n+  public static JSONObject containersToJson(Collection<Container> containers) {\n+    JSONArray containerArray = new JSONArray();\n+    containers.stream().map(container -> container.toJson()).forEach(containerArray::put);\n+    return new JSONObject().put(Account.CONTAINERS_KEY, containerArray);\n+  }\n+\n+  public static Collection<Container> containersFromJson(JSONObject json, short accountId) {\n+    JSONArray containerArray = json.optJSONArray(Account.CONTAINERS_KEY);\n+    if (containerArray == null) {\n+      return Collections.emptyList();\n+    } else {\n+      Collection<Container> containers = new ArrayList<>();\n+      for (int i = 0; i < containerArray.length(); i++) {\n+        JSONObject containerJson = containerArray.getJSONObject(i);\n+        containers.add(Container.fromJson(containerJson, accountId));\n+      }\n+      return containers;\n+    }\n+  }\n+\n+  public static Container containerFromJson(JSONObject json, short accountId) {\n+    return Container.fromJson(json, accountId);\n+  }\n+\n+  public static JSONObject containerToJson(Container container) {\n+    return container.toJson();\n+  }", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxMzcwMg==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497713702", "bodyText": "They are used by ContainerDao which is in a different package that can't access the package private methods toJson()/fromJson() in Container class.  We could make those methods public if no one objects.", "author": "lightningrob", "createdAt": "2020-09-30T18:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MTkyMg==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497771922", "bodyText": "Sure, making those methods in Container sounds good to me.", "author": "jsjtzyy", "createdAt": "2020-09-30T20:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyNTY0NQ==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497225645", "bodyText": "sorry, I didn't add java doc for this config in previous PR, could you please add one?", "author": "jsjtzyy", "createdAt": "2020-09-30T03:42:46Z", "path": "ambry-api/src/main/java/com/github/ambry/config/AccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Common config for {@link AccountServiceConfig}\n+ */\n+public class AccountServiceConfig {\n+  public static final String ACCOUNT_SERVICE_PREFIX = \"account.service.\";\n+  public static final String CONTAINER_ID_START_NUMBER = ACCOUNT_SERVICE_PREFIX + \"container.id.start.number\";\n+\n+  @Config(CONTAINER_ID_START_NUMBER)", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyOTgzMA==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497229830", "bodyText": "Can we use NotFound error code?", "author": "jsjtzyy", "createdAt": "2020-09-30T03:59:59Z", "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/PostAccountsHandler.java", "diffHunk": "@@ -135,11 +141,58 @@ private void start() {\n      */\n     private Callback<Long> fetchAccountUpdateBodyCallback(RetainingAsyncWritableChannel channel) {\n       return buildCallback(frontendMetrics.postAccountsReadRequestMetrics, bytesRead -> {\n-        updateAccounts(readJsonFromChannel(channel));\n+        JSONObject jsonPayload = readJsonFromChannel(channel);\n+        ReadableStreamChannel outputChannel;\n+        if (restRequest.getPath().startsWith(Operations.UPDATE_ACCOUNT_CONTAINERS)) {\n+          logger.debug(\"Got request for {} with payload {}\", Operations.UPDATE_ACCOUNT_CONTAINERS, jsonPayload);\n+          JSONObject outputPayload = updateContainers(jsonPayload);\n+          outputChannel = serializeJsonToChannel(outputPayload);\n+        } else {\n+          updateAccounts(jsonPayload);\n+          outputChannel = new ByteBufferReadableStreamChannel(ByteBuffer.allocate(0));\n+        }\n         restResponseChannel.setHeader(RestUtils.Headers.DATE, new GregorianCalendar().getTime());\n-        restResponseChannel.setHeader(RestUtils.Headers.CONTENT_LENGTH, 0);\n-        finalCallback.onCompletion(null, null);\n-      }, uri, LOGGER, finalCallback);\n+        restResponseChannel.setHeader(RestUtils.Headers.CONTENT_TYPE, RestUtils.JSON_CONTENT_TYPE);\n+        restResponseChannel.setHeader(RestUtils.Headers.CONTENT_LENGTH, outputChannel.getSize());\n+        finalCallback.onCompletion(outputChannel, null);\n+      }, uri, logger, finalCallback);\n+    }\n+\n+    /**\n+     * Process the request json and call {@link AccountService#updateContainers} to add or update containers.\n+     * @param containersPayload the request json containing the containers to update.\n+     * @throws RestServiceException\n+     */\n+    private JSONObject updateContainers(JSONObject containersPayload) throws RestServiceException {\n+      Short accountId = RestUtils.getNumericalHeader(restRequest.getArgs(), RestUtils.Headers.TARGET_ACCOUNT_ID, false,\n+          Short::parseShort);\n+      String accountName = RestUtils.getHeader(restRequest.getArgs(), RestUtils.Headers.TARGET_ACCOUNT_NAME, false);\n+      if (accountId == null && accountName == null) {\n+        throw new RestServiceException(\"Missing required header: \" + RestUtils.Headers.TARGET_ACCOUNT_NAME,\n+            RestServiceErrorCode.BadRequest);\n+      }\n+      Account account =\n+          accountName != null ? accountService.getAccountByName(accountName) : accountService.getAccountById(accountId);\n+      if (account == null) {\n+        throw new RestServiceException(\"Account not found: \" + accountName, RestServiceErrorCode.BadRequest);", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxNTY0OQ==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497715649", "bodyText": "Yes.  Good catch.", "author": "lightningrob", "createdAt": "2020-09-30T18:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyOTgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY4NjE1Nw==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497686157", "bodyText": "Would default and start value be 1 here (matching with at-default above)? Probably this is coming from previous PR.", "author": "Arun-LinkedIn", "createdAt": "2020-09-30T17:35:10Z", "path": "ambry-api/src/main/java/com/github/ambry/config/AccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Common config for {@link AccountServiceConfig}\n+ */\n+public class AccountServiceConfig {\n+  public static final String ACCOUNT_SERVICE_PREFIX = \"account.service.\";\n+  public static final String CONTAINER_ID_START_NUMBER = ACCOUNT_SERVICE_PREFIX + \"container.id.start.number\";\n+\n+  @Config(CONTAINER_ID_START_NUMBER)\n+  @Default(\"1\")\n+  public final short containerIdStartNumber;\n+\n+  public AccountServiceConfig(VerifiableProperties verifiableProperties) {\n+    containerIdStartNumber =\n+        verifiableProperties.getShortInRange(CONTAINER_ID_START_NUMBER, (short) 0, (short) 0, Short.MAX_VALUE);", "originalCommit": "6ab5ade12a55b9ee08ae701b467e583722fdca48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxNjYwOA==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r497716608", "bodyText": "I agree they should match, but should it actually be 1 and not 0?", "author": "lightningrob", "createdAt": "2020-09-30T18:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY4NjE1Nw=="}], "type": "inlineReview"}, {"oid": "d53a0f84cd9ae765474a1721ebcc767ba30c79cd", "url": "https://github.com/linkedin/ambry/commit/d53a0f84cd9ae765474a1721ebcc767ba30c79cd", "message": "Address review comments\nRoll add/update logic into AccountService.updateContainers()", "committedDate": "2020-10-01T04:40:48Z", "type": "commit"}, {"oid": "32e8764109b6009e3ded439fa1e3c74b924d724c", "url": "https://github.com/linkedin/ambry/commit/32e8764109b6009e3ded439fa1e3c74b924d724c", "message": "Fix compile error, address Arun review comment.", "committedDate": "2020-10-01T04:47:38Z", "type": "commit"}, {"oid": "815343d978a16a3f51c8d0db06d5da00da67fb0f", "url": "https://github.com/linkedin/ambry/commit/815343d978a16a3f51c8d0db06d5da00da67fb0f", "message": "Fix one test", "committedDate": "2020-10-01T05:05:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNzY2MQ==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r498507661", "bodyText": "In current logic, if an exactly same container exists, the passed in container won't be added to final result. I wonder if we can still return the existing container in final result because its id is useful for closed source container creation logic.\nFor example: container creation involves two steps:  1. create container in ambry account service.  2. set up ACLs for this container.\nIf previous request succeeded on step 1 but failed on step 2 (i.e. ACL service is unavailable), the whole operation is not successful. We should allow user to retry, to be more accurate, retry the step 2 (which requires container id). So I suggest returning the existing container in result even for same container case. Thus, the caller can get container id and retry on setting up ACLs.", "author": "jsjtzyy", "createdAt": "2020-10-01T20:54:28Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -68,6 +77,84 @@ public Account getAccountById(short id) {\n     return accountInfoMapRef.get().getAccounts();\n   }\n \n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    checkOpen();\n+    // input validation\n+    if (accountName == null || accountName.isEmpty() || containers == null || containers.isEmpty()) {\n+      throw new AccountServiceException(\"Account or container is null or empty\", AccountServiceErrorCode.BadRequest);\n+    }\n+    Account account = getAccountByName(accountName);\n+    if (account == null) {\n+      logger.error(\"Account {} is not found\", accountName);\n+      throw new AccountServiceException(\"Account \" + accountName + \" is not found\", AccountServiceErrorCode.NotFound);\n+    }\n+\n+    List<Container> resolvedContainers = new ArrayList<>();\n+    // create a hashmap to map the name to existing containers in account\n+    Map<String, Container> existingContainersInAccount = new HashMap<>();\n+    account.getAllContainers().forEach(c -> existingContainersInAccount.put(c.getName(), c));\n+\n+    // Generate container ids for new containers\n+    short nextContainerId = account.getAllContainers()\n+        .stream()\n+        .map(Container::getId)\n+        .max(Short::compareTo)\n+        .map(maxId -> (short) (maxId + 1))\n+        .orElse(config.containerIdStartNumber);\n+\n+    for (Container container : containers) {\n+      if (container.getId() == Container.UNKNOWN_CONTAINER_ID) {\n+        // new container\n+        // make sure there is no conflicting container (conflicting means a container with same name but different attributes already exists).\n+        Container existingContainer = existingContainersInAccount.get(container.getName());\n+        if (existingContainer != null) {\n+          if (existingContainer.isSameContainer(container)) {\n+            // If an exactly same container already exists, ignore it. Adding same container multiple times is no-op.", "originalCommit": "815343d978a16a3f51c8d0db06d5da00da67fb0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyODQzNg==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r498528436", "bodyText": "This makes sense.  Existing containers are not included in the return list.", "author": "lightningrob", "createdAt": "2020-10-01T21:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNzY2MQ=="}], "type": "inlineReview"}, {"oid": "66297761df4f5c6b5b2c72202aa3444f9379d649", "url": "https://github.com/linkedin/ambry/commit/66297761df4f5c6b5b2c72202aa3444f9379d649", "message": "Include unchanged containers in list returned by AccountService.updateContainers() to handle retry case", "committedDate": "2020-10-01T21:41:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTU2OA==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r498545568", "bodyText": "Not necessary to do in this PR, but I was wondering why this wasn't just added as a method in the Account class, like Account.toJson(boolean includeContainers).", "author": "cgtz", "createdAt": "2020-10-01T22:36:42Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountCollectionSerde.java", "diffHunk": "@@ -57,4 +57,46 @@ public static JSONObject toJson(Collection<Account> accounts) {\n       return accounts;\n     }\n   }\n+\n+  /**\n+   * Serialize an account to a json object, stripping out its containers.\n+   * @param account the {@link Account}s to serialize.\n+   * @return the {@link JSONObject}\n+   */\n+  public static JSONObject accountToJsonNoContainers(Account account) {", "originalCommit": "66297761df4f5c6b5b2c72202aa3444f9379d649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1NTM0Nw==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r498555347", "bodyText": "We could.  It seemed like a bit too much of a special case to include it there, maybe it's okay.", "author": "lightningrob", "createdAt": "2020-10-01T23:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTUyMg==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r498551522", "bodyText": "It may be better to use RestUtils.getRequestPath(restRequest).matchesOperation(UPDATE_ACCOUNT_CONTAINERS) here.\nThis will ensure that prefixes such as the cluster name or the CDN path prefixes are stripped of correctly (not that this specific API will necessarily encounter them since it is an internal, non-blob ID based API) and handles edge cases relating to leading/trailing slashes. Still, I think it's good to keep things consistent with how operations are dealt with in other places.", "author": "cgtz", "createdAt": "2020-10-01T22:57:39Z", "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/PostAccountsHandler.java", "diffHunk": "@@ -135,11 +141,57 @@ private void start() {\n      */\n     private Callback<Long> fetchAccountUpdateBodyCallback(RetainingAsyncWritableChannel channel) {\n       return buildCallback(frontendMetrics.postAccountsReadRequestMetrics, bytesRead -> {\n-        updateAccounts(readJsonFromChannel(channel));\n+        JSONObject jsonPayload = readJsonFromChannel(channel);\n+        ReadableStreamChannel outputChannel;\n+        if (restRequest.getPath().startsWith(Operations.UPDATE_ACCOUNT_CONTAINERS)) {", "originalCommit": "66297761df4f5c6b5b2c72202aa3444f9379d649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MzIwMg==", "url": "https://github.com/linkedin/ambry/pull/1634#discussion_r498553202", "bodyText": "hmm, I really should have put this blocking work in a thread pool instead of running it directly in the preceding callback. I guess we can do that at in the future.", "author": "cgtz", "createdAt": "2020-10-01T23:04:16Z", "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/PostAccountsHandler.java", "diffHunk": "@@ -135,11 +141,57 @@ private void start() {\n      */\n     private Callback<Long> fetchAccountUpdateBodyCallback(RetainingAsyncWritableChannel channel) {\n       return buildCallback(frontendMetrics.postAccountsReadRequestMetrics, bytesRead -> {\n-        updateAccounts(readJsonFromChannel(channel));\n+        JSONObject jsonPayload = readJsonFromChannel(channel);\n+        ReadableStreamChannel outputChannel;\n+        if (restRequest.getPath().startsWith(Operations.UPDATE_ACCOUNT_CONTAINERS)) {\n+          logger.debug(\"Got request for {} with payload {}\", Operations.UPDATE_ACCOUNT_CONTAINERS, jsonPayload);\n+          JSONObject outputPayload = updateContainers(jsonPayload);\n+          outputChannel = serializeJsonToChannel(outputPayload);\n+        } else {\n+          updateAccounts(jsonPayload);\n+          outputChannel = new ByteBufferReadableStreamChannel(ByteBuffer.allocate(0));\n+        }\n         restResponseChannel.setHeader(RestUtils.Headers.DATE, new GregorianCalendar().getTime());\n-        restResponseChannel.setHeader(RestUtils.Headers.CONTENT_LENGTH, 0);\n-        finalCallback.onCompletion(null, null);\n-      }, uri, LOGGER, finalCallback);\n+        restResponseChannel.setHeader(RestUtils.Headers.CONTENT_TYPE, RestUtils.JSON_CONTENT_TYPE);\n+        restResponseChannel.setHeader(RestUtils.Headers.CONTENT_LENGTH, outputChannel.getSize());\n+        finalCallback.onCompletion(outputChannel, null);\n+      }, uri, logger, finalCallback);\n+    }\n+\n+    /**\n+     * Process the request json and call {@link AccountService#updateContainers} to add or update containers.\n+     * @param containersPayload the request json containing the containers to update.\n+     * @throws RestServiceException\n+     */\n+    private JSONObject updateContainers(JSONObject containersPayload) throws RestServiceException {", "originalCommit": "66297761df4f5c6b5b2c72202aa3444f9379d649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24306f4d2f86353fc2d0a4e0411185b78cdceffd", "url": "https://github.com/linkedin/ambry/commit/24306f4d2f86353fc2d0a4e0411185b78cdceffd", "message": "Address Casey review comment about gettng request path", "committedDate": "2020-10-01T23:43:49Z", "type": "commit"}, {"oid": "60de9241b7f6ade823b73c7fe4f43b667ce11cdc", "url": "https://github.com/linkedin/ambry/commit/60de9241b7f6ade823b73c7fe4f43b667ce11cdc", "message": "Fix POST handler tests\nAdd sleep as temp fix for endToEndCloudBackupTest", "committedDate": "2020-10-02T02:45:02Z", "type": "commit"}]}