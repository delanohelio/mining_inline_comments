{"pr_number": 1471, "pr_title": "Check cache state before updating blobs including retries", "pr_createdAt": "2020-04-11T05:33:56Z", "pr_url": "https://github.com/linkedin/ambry/pull/1471", "timeline": [{"oid": "5c2c6ca1319cf890e2f39b4c37a7064d673d4c6a", "url": "https://github.com/linkedin/ambry/commit/5c2c6ca1319cf890e2f39b4c37a7064d673d4c6a", "message": "Check cache state before updating blobs including retries", "committedDate": "2020-04-11T05:37:24Z", "type": "commit"}, {"oid": "5c2c6ca1319cf890e2f39b4c37a7064d673d4c6a", "url": "https://github.com/linkedin/ambry/commit/5c2c6ca1319cf890e2f39b4c37a7064d673d4c6a", "message": "Check cache state before updating blobs including retries", "committedDate": "2020-04-11T05:37:24Z", "type": "forcePushed"}, {"oid": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "url": "https://github.com/linkedin/ambry/commit/774000368e1135ce2f29e0b32ffe8db011b9afa0", "message": "findMissingKeys query uses Cosmos even for one record\nRepair inconsistency when updating blob with no Cosmos record\nVarious code and logging cleanup", "committedDate": "2020-04-13T18:38:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NjE5Mw==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407646193", "bodyText": "I'll remove this comment", "author": "lightningrob", "createdAt": "2020-04-13T18:44:48Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -357,6 +358,8 @@ private boolean shouldUpload(MessageInfo messageInfo) {\n     }\n   }\n \n+  // TODO: delete and update should throw StoreErrorCodes.ID_Not_Found on 404", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0OTYxMQ==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407649611", "bodyText": "threat -> thread", "author": "cgtz", "createdAt": "2020-04-13T18:50:52Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -365,18 +368,36 @@ public void delete(List<MessageInfo> infos) throws StoreException {\n     try {\n       for (MessageInfo msgInfo : infos) {\n         BlobId blobId = (BlobId) msgInfo.getStoreKey();\n-        String blobKey = blobId.getID();\n-        if (!checkCacheState(blobKey, BlobState.DELETED)) {\n-          requestAgent.doWithRetries(() -> cloudDestination.deleteBlob(blobId, msgInfo.getOperationTimeMs()), \"Delete\",\n-              partitionId.toPathString());\n-          addToCache(blobKey, BlobState.DELETED);\n-        }\n+        // If the cache has been updated by another thread, retry may be avoided\n+        requestAgent.doWithRetries(() -> deleteIfNeeded(blobId, msgInfo.getOperationTimeMs()), \"Delete\",\n+            partitionId.toPathString());\n       }\n     } catch (CloudStorageException ex) {\n-      throw new StoreException(ex, StoreErrorCodes.IOError);\n+      StoreErrorCodes errorCode =\n+          (ex.getStatusCode() == STATUS_NOT_FOUND) ? StoreErrorCodes.ID_Not_Found : StoreErrorCodes.IOError;\n+      throw new StoreException(ex, errorCode);\n     }\n   }\n \n+  /**\n+   * Delete the specified blob if needed depending on the cache state.\n+   * @param blobId the blob to delete\n+   * @param deletionTime the deletion time\n+   * @return whether the deletion was performed\n+   * @throws CloudStorageException\n+   */\n+  private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudStorageException {\n+    String blobKey = blobId.getID();\n+    // Note: always check cache before operation attempt, since this could be a retry after a CONFLICT error,\n+    // in which case the cache may have been updated by another threat.", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTU1MA==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407665550", "bodyText": "nit: could you separate these two assignments onto separate lines? it looks a little confusing since one of the values is assigned/mutated but the other is not assigned until line 265", "author": "cgtz", "createdAt": "2020-04-13T19:20:19Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -248,22 +254,43 @@ private boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value\n     Objects.requireNonNull(fieldName, \"Field name cannot be null\");\n \n     // We update the blob metadata value in two places:\n-    // 1) the CosmosDB metadata collection\n-    // 2) the blob storage entry metadata (to enable rebuilding the database)\n-\n+    // 1) the blob storage entry metadata (so GET's can be served entirely from ABS)\n+    // 2) the CosmosDB metadata collection\n     try {\n-      if (!azureBlobDataAccessor.updateBlobMetadata(blobId, fieldName, value)) {\n-        // TODO: what if this is a retry where ABS has been updated but Cosmos has not?\n-        return false;\n+      boolean updatedStorage, updatedCosmos = false;", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MDI3Nw==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407670277", "bodyText": "Could you expand on why the cosmos query is needed for findMissingKeys in this comment?", "author": "cgtz", "createdAt": "2020-04-13T19:29:20Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -162,7 +167,8 @@ public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws C\n     }\n \n     // For single blob GET request, get metadata from ABS instead of Cosmos\n-    if (blobIds.size() == 1) {\n+    // Note: findMissingKeys needs to query Cosmos regardless", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MTA5Ng==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407671096", "bodyText": "This comment says that null will be returned if the document is not found. I assume this has been changed to throw an exception in this case?", "author": "cgtz", "createdAt": "2020-04-13T19:30:48Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -144,47 +141,37 @@ void testConnectivity() {\n   ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    options.setPartitionKey(new PartitionKey(blobMetadata.getPartitionId()));\n     return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n         azureMetrics.documentDeleteTime);\n   }\n \n   /**\n-   * Read the blob metadata document in the CosmosDB collection.\n-   * @param blobId the {@link BlobId} for which metadata is requested.\n-   * @return the {@link ResourceResponse} containing the metadata document.\n-   * @throws DocumentClientException if the operation failed.\n-   */\n-  ResourceResponse<Document> readMetadata(BlobId blobId) throws DocumentClientException {\n-    String docLink = getDocumentLink(blobId.getID());\n-    RequestOptions options = getRequestOptions(blobId.getPartition().toPathString());\n-    return executeCosmosAction(() -> asyncDocumentClient.readDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentReadTime);\n-  }\n-\n-  /**\n-   * Update the blob metadata document in the CosmosDB collection, retrying as necessary.\n+   * Update the blob metadata document in the CosmosDB collection.\n    * @param blobId the {@link BlobId} for which metadata is replaced.\n    * @param fieldName the metadata field to update.\n    * @param value the new value for the field.\n    * @return the {@link ResourceResponse} returned by the operation, if successful.\n    * Returns {@Null} if the document is not found or the field already has the specified value.", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MzE3NA==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407673174", "bodyText": "how is the doc == null case handled now?", "author": "cgtz", "createdAt": "2020-04-13T19:34:50Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -144,47 +141,37 @@ void testConnectivity() {\n   ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    options.setPartitionKey(new PartitionKey(blobMetadata.getPartitionId()));\n     return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n         azureMetrics.documentDeleteTime);\n   }\n \n   /**\n-   * Read the blob metadata document in the CosmosDB collection.\n-   * @param blobId the {@link BlobId} for which metadata is requested.\n-   * @return the {@link ResourceResponse} containing the metadata document.\n-   * @throws DocumentClientException if the operation failed.\n-   */\n-  ResourceResponse<Document> readMetadata(BlobId blobId) throws DocumentClientException {\n-    String docLink = getDocumentLink(blobId.getID());\n-    RequestOptions options = getRequestOptions(blobId.getPartition().toPathString());\n-    return executeCosmosAction(() -> asyncDocumentClient.readDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentReadTime);\n-  }\n-\n-  /**\n-   * Update the blob metadata document in the CosmosDB collection, retrying as necessary.\n+   * Update the blob metadata document in the CosmosDB collection.\n    * @param blobId the {@link BlobId} for which metadata is replaced.\n    * @param fieldName the metadata field to update.\n    * @param value the new value for the field.\n    * @return the {@link ResourceResponse} returned by the operation, if successful.\n    * Returns {@Null} if the document is not found or the field already has the specified value.\n-   * @throws DocumentClientException if the operation failed.\n+   * @throws DocumentClientException if the record was not found or if the operation failed.\n    */\n   ResourceResponse<Document> updateMetadata(BlobId blobId, String fieldName, Object value)\n       throws DocumentClientException {\n-    ResourceResponse<Document> response = readMetadata(blobId);\n-    Document doc = response.getResource();\n-    if (doc == null) {\n-      logger.warn(\"Blob metadata record not found: {}\", blobId.getID());\n-      return null;\n-    }\n+\n+    // Read the existing record\n+    String docLink = getDocumentLink(blobId.getID());\n+    RequestOptions options = getRequestOptions(blobId.getPartition().toPathString());\n+    ResourceResponse<Document> readResponse =\n+        executeCosmosAction(() -> asyncDocumentClient.readDocument(docLink, options).toBlocking().single(),\n+            azureMetrics.documentReadTime);\n+    Document doc = readResponse.getResource();", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc1MjA5MQ==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407752091", "bodyText": "Per Cosmos it can't happen.  It either returns a document response or throws exception.", "author": "lightningrob", "createdAt": "2020-04-13T22:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3NDk1NQ==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407674955", "bodyText": "I just want to check if there are any conditions where it may not be good to create a record. For example, what if compaction already cleaned up the record (or is that sequence of events impossible)?", "author": "cgtz", "createdAt": "2020-04-13T19:38:28Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -248,22 +254,43 @@ private boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value\n     Objects.requireNonNull(fieldName, \"Field name cannot be null\");\n \n     // We update the blob metadata value in two places:\n-    // 1) the CosmosDB metadata collection\n-    // 2) the blob storage entry metadata (to enable rebuilding the database)\n-\n+    // 1) the blob storage entry metadata (so GET's can be served entirely from ABS)\n+    // 2) the CosmosDB metadata collection\n     try {\n-      if (!azureBlobDataAccessor.updateBlobMetadata(blobId, fieldName, value)) {\n-        // TODO: what if this is a retry where ABS has been updated but Cosmos has not?\n-        return false;\n+      boolean updatedStorage, updatedCosmos = false;\n+      AzureBlobDataAccessor.UpdateResponse updateResponse =\n+          azureBlobDataAccessor.updateBlobMetadata(blobId, fieldName, value);\n+      // Note: if blob does not exist will throw exception with NOT_FOUND status\n+      Map<String, String> metadataMap = updateResponse.metadata;\n+      updatedStorage = updateResponse.wasUpdated;\n+\n+      // Note: even if nothing changed in blob storage, still attempt to update Cosmos since this could be a retry\n+      // of a request where ABS was updated but Cosmos update failed.\n+      try {\n+        ResourceResponse<Document> response = cosmosDataAccessor.updateMetadata(blobId, fieldName, value);\n+        updatedCosmos = response != null;\n+      } catch (DocumentClientException dex) {\n+        if (dex.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+          // blob exists in ABS but not Cosmos - inconsistent state\n+          // Recover by inserting the updated map into cosmos\n+          cosmosDataAccessor.upsertMetadata(CloudBlobMetadata.fromMap(metadataMap));", "originalCommit": "774000368e1135ce2f29e0b32ffe8db011b9afa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc1Mzg5NQ==", "url": "https://github.com/linkedin/ambry/pull/1471#discussion_r407753895", "bodyText": "Good question.  It is possible for a blob to be purged but the Cosmos record not yet purged.  In this case, is it even possible for a lifecycle event to be passed here?  I would think the ReplicaThread would cut it off earlier, but not sure if the undelete feature changes that.  In that specific case, either expirationTime or deletionTime should be older than the retention period.", "author": "lightningrob", "createdAt": "2020-04-13T22:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3NDk1NQ=="}], "type": "inlineReview"}, {"oid": "52df6aa8668ec912b9d5a3df677013d26b3cd3e1", "url": "https://github.com/linkedin/ambry/commit/52df6aa8668ec912b9d5a3df677013d26b3cd3e1", "message": "Address Casey's review comments.", "committedDate": "2020-04-13T22:22:25Z", "type": "commit"}, {"oid": "e493d3e309b4aa4df32405ec49b57d22ab9ecb04", "url": "https://github.com/linkedin/ambry/commit/e493d3e309b4aa4df32405ec49b57d22ab9ecb04", "message": "Merge branch 'master' of github.com:linkedin/ambry into cosmos-consistency", "committedDate": "2020-04-13T22:26:21Z", "type": "commit"}]}