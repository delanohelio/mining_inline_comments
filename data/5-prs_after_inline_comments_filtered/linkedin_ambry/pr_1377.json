{"pr_number": 1377, "pr_title": "Introduce RetainingAsyncWritableChannel", "pr_createdAt": "2020-02-08T01:21:55Z", "pr_url": "https://github.com/linkedin/ambry/pull/1377", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNzc1Mw==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377407753", "bodyText": "year should be 2020", "author": "justinlin-linkedin", "createdAt": "2020-02-11T01:12:58Z", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.", "originalCommit": "341f7388b54b93a80c0d7d9a265670e3a116dbf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNzk2MA==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377407960", "bodyText": "not used anywhere in this file.", "author": "justinlin-linkedin", "createdAt": "2020-02-11T01:13:29Z", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;", "originalCommit": "341f7388b54b93a80c0d7d9a265670e3a116dbf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODIwMQ==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377408201", "bodyText": "change the position of src, just like the write method below.", "author": "justinlin-linkedin", "createdAt": "2020-02-11T01:14:30Z", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\n+/**\n+ * An implementation of {@link AsyncWritableChannel} that will retain a reference to any {@link ByteBuf}s passed to it.\n+ * It will assemble these buffers into a {@link CompositeByteBuf} that can then be consumed by the user of the channel.\n+ * Meant for interacting with blocking content consumers that would otherwise require a background thread if they did\n+ * not have all of the content available.\n+ */\n+public class RetainingAsyncWritableChannel implements AsyncWritableChannel {\n+  private final long sizeLimitInBytes;\n+  private volatile boolean open = true;\n+  private final AtomicLong totalBytesWritten = new AtomicLong(0);\n+  // accesses/updates to the buffer under construction must be protected by the lock\n+  private final Object bufferLock = new Object();\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Construct a {@link RetainingAsyncWritableChannel} with the size limit set to {@link Long#MAX_VALUE}.\n+   */\n+  public RetainingAsyncWritableChannel() {\n+    this(Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * @param sizeLimitInBytes the maximum number of bytes that can be written to this channel. If this limit is exceeded,\n+   *                         a {@link RestServiceException} will be provided to the write callback.\n+   */\n+  public RetainingAsyncWritableChannel(int sizeLimitInBytes) {\n+    this.sizeLimitInBytes = sizeLimitInBytes;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   *\n+   * This method requires copying\n+   */\n+  @Override\n+  public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    // still need to copy the buffer since the writer may decide to reuse the buffer after the callback is called.\n+    return writeInternal(() -> {\n+      ByteBuf copy = src.isDirect() ? ByteBufAllocator.DEFAULT.directBuffer(src.remaining())\n+          : PooledByteBufAllocator.DEFAULT.heapBuffer(src.remaining());\n+      copy.writeBytes(src);", "originalCommit": "341f7388b54b93a80c0d7d9a265670e3a116dbf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODQzMA==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377408430", "bodyText": "why do we throw a RestServiceException in the common package? Can we throw some more generic exception here?", "author": "justinlin-linkedin", "createdAt": "2020-02-11T01:15:29Z", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\n+/**\n+ * An implementation of {@link AsyncWritableChannel} that will retain a reference to any {@link ByteBuf}s passed to it.\n+ * It will assemble these buffers into a {@link CompositeByteBuf} that can then be consumed by the user of the channel.\n+ * Meant for interacting with blocking content consumers that would otherwise require a background thread if they did\n+ * not have all of the content available.\n+ */\n+public class RetainingAsyncWritableChannel implements AsyncWritableChannel {\n+  private final long sizeLimitInBytes;\n+  private volatile boolean open = true;\n+  private final AtomicLong totalBytesWritten = new AtomicLong(0);\n+  // accesses/updates to the buffer under construction must be protected by the lock\n+  private final Object bufferLock = new Object();\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Construct a {@link RetainingAsyncWritableChannel} with the size limit set to {@link Long#MAX_VALUE}.\n+   */\n+  public RetainingAsyncWritableChannel() {\n+    this(Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * @param sizeLimitInBytes the maximum number of bytes that can be written to this channel. If this limit is exceeded,\n+   *                         a {@link RestServiceException} will be provided to the write callback.\n+   */\n+  public RetainingAsyncWritableChannel(int sizeLimitInBytes) {\n+    this.sizeLimitInBytes = sizeLimitInBytes;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   *\n+   * This method requires copying\n+   */\n+  @Override\n+  public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    // still need to copy the buffer since the writer may decide to reuse the buffer after the callback is called.\n+    return writeInternal(() -> {\n+      ByteBuf copy = src.isDirect() ? ByteBufAllocator.DEFAULT.directBuffer(src.remaining())\n+          : PooledByteBufAllocator.DEFAULT.heapBuffer(src.remaining());\n+      copy.writeBytes(src);\n+      return copy;\n+    }, callback);\n+  }\n+\n+  @Override\n+  public Future<Long> write(ByteBuf src, Callback<Long> callback) {\n+    return writeInternal(() -> {\n+      ByteBuf duplicate = src.retainedDuplicate();\n+      // mark all bytes as read.\n+      src.skipBytes(src.readableBytes());\n+      return duplicate;\n+    }, callback);\n+  }\n+\n+  private Future<Long> writeInternal(Supplier<ByteBuf> retainedBufSupplier, Callback<Long> callback) {\n+    FutureResult<Long> future = new FutureResult<>();\n+    ByteBuf buf = null;\n+    long bytesWritten = 0;\n+    Exception exception = null;\n+    try {\n+      if (!isOpen()) {\n+        throw new ClosedChannelException();\n+      } else if (totalBytesWritten.get() > sizeLimitInBytes) {\n+        throw new RestServiceException(\"Request is larger than allowed size: \" + sizeLimitInBytes,", "originalCommit": "341f7388b54b93a80c0d7d9a265670e3a116dbf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1ODc5Mg==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r380458792", "bodyText": "In terms of production code, this is mostly used by the rest/frontend package and throwing RestServiceException directly makes error handling cleaner (correct response code generated without try/catch).", "author": "cgtz", "createdAt": "2020-02-18T05:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ2MDA4Mg==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r380460082", "bodyText": "One other option would be to move it to ambry-rest, and get rid of InputStreamReadableStreamChannel, which has no usages (other than a unit test)", "author": "cgtz", "createdAt": "2020-02-18T05:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwOTkyNQ==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377409925", "bodyText": "Can we add nettyByteBufLeakHelper in this test file since we are using retaining async write channel.", "author": "justinlin-linkedin", "createdAt": "2020-02-11T01:21:56Z", "path": "ambry-commons/src/test/java/com.github.ambry.commons/InputStreamReadableStreamChannelTest.java", "diffHunk": "@@ -118,7 +118,7 @@ public void readIntoAWCFailureTest() throws Exception {\n     // Read after close.\n     channel = new InputStreamReadableStreamChannel(stream, EXECUTOR_SERVICE);\n     channel.close();\n-    CopyingAsyncWritableChannel writeChannel = new CopyingAsyncWritableChannel();\n+    RetainingAsyncWritableChannel writeChannel = new RetainingAsyncWritableChannel();", "originalCommit": "341f7388b54b93a80c0d7d9a265670e3a116dbf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQxMDQ0OA==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377410448", "bodyText": "this is not used anywhere.", "author": "justinlin-linkedin", "createdAt": "2020-02-11T01:24:32Z", "path": "ambry-utils/src/test/java/com.github.ambry.utils/NettyByteBufLeakHelper.java", "diffHunk": "@@ -16,6 +16,8 @@\n import io.netty.buffer.PoolArenaMetric;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.PooledByteBufAllocatorMetric;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import java.lang.reflect.Field;", "originalCommit": "341f7388b54b93a80c0d7d9a265670e3a116dbf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ad7a2fbd9ea0dac6282e56ce5c3a3270cc3a0a6", "url": "https://github.com/linkedin/ambry/commit/2ad7a2fbd9ea0dac6282e56ce5c3a3270cc3a0a6", "message": "Address Justin's comments", "committedDate": "2020-02-18T05:06:38Z", "type": "forcePushed"}, {"oid": "8a02435f1b2e051aad50fe4ea4b56a55dcffa7a0", "url": "https://github.com/linkedin/ambry/commit/8a02435f1b2e051aad50fe4ea4b56a55dcffa7a0", "message": "Add toString for ContainerBlobsResource", "committedDate": "2020-02-18T22:12:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjczNw==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r381486737", "bodyText": "Not used.", "author": "zzmao", "createdAt": "2020-02-19T19:13:27Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequest.java", "diffHunk": "@@ -15,23 +15,32 @@\n \n import com.github.ambry.rest.RestRequest;\n import com.github.ambry.rest.RestResponseChannel;\n+import com.github.ambry.utils.AbstractByteBufHolder;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n import com.github.ambry.utils.SystemTime;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;", "originalCommit": "8a02435f1b2e051aad50fe4ea4b56a55dcffa7a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjgxMw==", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r381486813", "bodyText": "not used.", "author": "zzmao", "createdAt": "2020-02-19T19:13:34Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequest.java", "diffHunk": "@@ -15,23 +15,32 @@\n \n import com.github.ambry.rest.RestRequest;\n import com.github.ambry.rest.RestResponseChannel;\n+import com.github.ambry.utils.AbstractByteBufHolder;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n import com.github.ambry.utils.SystemTime;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n import java.io.InputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * A wrapper class at the network layer for NettyRequest based RestRequest.\n  */\n-public class NettyServerRequest implements NetworkRequest {\n+public class NettyServerRequest extends AbstractByteBufHolder<NettyServerRequest> implements NetworkRequest {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyServerRequest.class);", "originalCommit": "8a02435f1b2e051aad50fe4ea4b56a55dcffa7a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f34cff6d3a75b5512c387d722e9b60233e73311b", "url": "https://github.com/linkedin/ambry/commit/f34cff6d3a75b5512c387d722e9b60233e73311b", "message": "Address Ze's comments; still looking into test failure", "committedDate": "2020-02-25T00:16:03Z", "type": "forcePushed"}, {"oid": "b2bd59b77dafc37918f024c27ed7c9a0fc6f09d2", "url": "https://github.com/linkedin/ambry/commit/b2bd59b77dafc37918f024c27ed7c9a0fc6f09d2", "message": "Introduce RetainingAsyncWritableChannel\n\nThis channel is a replacement for CopyingAsyncWritableChannel that does\nnot require copying input buffers if supplied a ByteBuf from\nthe caller. These buffer will just be retained by incrementing the ref\ncount and added to a CompositeByteBuf.", "committedDate": "2020-02-25T21:13:31Z", "type": "commit"}, {"oid": "71d207330bceae73a1228c55e94144dbbf20ee83", "url": "https://github.com/linkedin/ambry/commit/71d207330bceae73a1228c55e94144dbbf20ee83", "message": "Correct cacheEnabled default value", "committedDate": "2020-02-25T21:13:31Z", "type": "commit"}, {"oid": "c5c8699eba9501710a17d7836c5189e466046933", "url": "https://github.com/linkedin/ambry/commit/c5c8699eba9501710a17d7836c5189e466046933", "message": "Close InputStream after NettyServerRequest has been handled", "committedDate": "2020-02-25T21:13:31Z", "type": "commit"}, {"oid": "4436cc2bc134123d04691d254baf2e684eb723c4", "url": "https://github.com/linkedin/ambry/commit/4436cc2bc134123d04691d254baf2e684eb723c4", "message": "Address Justin's comments", "committedDate": "2020-02-25T21:13:31Z", "type": "commit"}, {"oid": "244b4b07688aa8d7f4b3985cd758d673f65a50a0", "url": "https://github.com/linkedin/ambry/commit/244b4b07688aa8d7f4b3985cd758d673f65a50a0", "message": "Add toString for ContainerBlobsResource", "committedDate": "2020-02-25T21:13:31Z", "type": "commit"}, {"oid": "25d1c370bf0aafdb65d8d6c334420ed1b2bfba96", "url": "https://github.com/linkedin/ambry/commit/25d1c370bf0aafdb65d8d6c334420ed1b2bfba96", "message": "Address Ze's comments; still looking into test failure", "committedDate": "2020-02-25T21:13:31Z", "type": "commit"}, {"oid": "25d1c370bf0aafdb65d8d6c334420ed1b2bfba96", "url": "https://github.com/linkedin/ambry/commit/25d1c370bf0aafdb65d8d6c334420ed1b2bfba96", "message": "Address Ze's comments; still looking into test failure", "committedDate": "2020-02-25T21:13:31Z", "type": "forcePushed"}]}