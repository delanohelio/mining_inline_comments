{"pr_number": 1590, "pr_title": "Add support for undelete in blobstorestats", "pr_createdAt": "2020-07-15T21:53:28Z", "pr_url": "https://github.com/linkedin/ambry/pull/1590", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyODIxMg==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456228212", "bodyText": "getting undeleted", "author": "jsjtzyy", "createdAt": "2020-07-17T05:36:51Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -383,10 +377,16 @@ void handleNewDeleteEntry(IndexValue deleteValue, IndexValue originalPutValue) {\n    * @param originalPutValue the {@link IndexValue} of the original PUT that is getting updated\n    */\n   void handleNewTtlUpdateEntry(IndexValue ttlUpdateValue, IndexValue originalPutValue) {\n-    if (recentEntryQueueEnabled) {\n-      recentEntryQueue.offer(new Pair<>(ttlUpdateValue, originalPutValue));\n-      metrics.statsRecentEntryQueueSize.update(queueEntryCount.incrementAndGet());\n-    }\n+    enqueueNewValue(ttlUpdateValue, originalPutValue);\n+  }\n+\n+  /**\n+   * Function that handles new UNDELETE after a scan to keep the current {@link ScanResults} relevant.\n+   * @param undeleteValue the {@link IndexValue} of the new UNDELETE\n+   * @param originalPutValue the {@link IndexValue} of the original PUT that is getting deleted", "originalCommit": "9453670890e99a2a1051e2c662e08ce441724e2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyODU4Mw==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456228583", "bodyText": "actually, do we really need originalPutValue parameter here?", "author": "jsjtzyy", "createdAt": "2020-07-17T05:38:18Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -383,10 +377,16 @@ void handleNewDeleteEntry(IndexValue deleteValue, IndexValue originalPutValue) {\n    * @param originalPutValue the {@link IndexValue} of the original PUT that is getting updated\n    */\n   void handleNewTtlUpdateEntry(IndexValue ttlUpdateValue, IndexValue originalPutValue) {\n-    if (recentEntryQueueEnabled) {\n-      recentEntryQueue.offer(new Pair<>(ttlUpdateValue, originalPutValue));\n-      metrics.statsRecentEntryQueueSize.update(queueEntryCount.incrementAndGet());\n-    }\n+    enqueueNewValue(ttlUpdateValue, originalPutValue);\n+  }\n+\n+  /**\n+   * Function that handles new UNDELETE after a scan to keep the current {@link ScanResults} relevant.\n+   * @param undeleteValue the {@link IndexValue} of the new UNDELETE\n+   * @param originalPutValue the {@link IndexValue} of the original PUT that is getting deleted\n+   */\n+  void handleNewUndeleteEntry(IndexValue undeleteValue, IndexValue originalPutValue) {", "originalCommit": "9453670890e99a2a1051e2c662e08ce441724e2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMTAzMw==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456231033", "bodyText": "Could you add comment for removeFromStates  ?", "author": "jsjtzyy", "createdAt": "2020-07-17T05:47:01Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +495,73 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)", "originalCommit": "9453670890e99a2a1051e2c662e08ce441724e2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMzQyMQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456233421", "bodyText": "I might need some clarification, this else means the delete is the last record for certain key in this log segment, how can we know it's final state of whole persistent index? (Is it because we iterate from the very last index segment?)", "author": "jsjtzyy", "createdAt": "2020-07-17T05:55:08Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +495,73 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 2. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));", "originalCommit": "9453670890e99a2a1051e2c662e08ce441724e2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzNzU4MA==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456237580", "bodyText": "that's right, we iterate through the index values in descending order, where we iterate from that last index segment to the first one. And within each index segment, we iterate from the latest IndexValue to the earliest one. So long as there is a value in the map, this value would be the final state.", "author": "justinlin-linkedin", "createdAt": "2020-07-17T06:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMzU3OA==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456233578", "bodyText": "minor: // 3. TTL_UPDATE", "author": "jsjtzyy", "createdAt": "2020-07-17T05:55:38Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +495,73 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 2. TTL_UPDATE", "originalCommit": "9453670890e99a2a1051e2c662e08ce441724e2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3MTIwOQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457571209", "bodyText": "nit:  put this if after line542", "author": "jsjtzyy", "createdAt": "2020-07-20T17:22:14Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +494,76 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n+   * @param removeFromStates if {@code True}, then remove the {@link IndexFinalState} from the given map {@code keyFinalStates}\n+   *                         when encountering PUT IndexValue. This method iterates through IndexValues from most recent one to\n+   *                         earliest one, so PUT IndexValue is the last IndexValue for the same key.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 3. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n         validIndexEntryAction.accept(indexEntry);\n-        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+      } else if (indexValue.isUndelete()) {\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isTtlUpdate()) {\n+            indexValue.setExpiresAtMs(Utils.Infinite_Time);\n+          }", "originalCommit": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3NTQyMA==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457575420", "bodyText": "Maybe I overlooked something but I feel like it doesn't check if final state is delete case when validating the current TtlUpdate, does it? Please point me to the logic if I missed anything.", "author": "jsjtzyy", "createdAt": "2020-07-20T17:29:32Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +494,76 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n+   * @param removeFromStates if {@code True}, then remove the {@link IndexFinalState} from the given map {@code keyFinalStates}\n+   *                         when encountering PUT IndexValue. This method iterates through IndexValues from most recent one to\n+   *                         earliest one, so PUT IndexValue is the last IndexValue for the same key.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 3. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n         validIndexEntryAction.accept(indexEntry);\n-        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+      } else if (indexValue.isUndelete()) {\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isTtlUpdate()) {\n+            indexValue.setExpiresAtMs(Utils.Infinite_Time);\n+          }\n+          if (state.isDelete() || (state.getLifeVersion() != indexValue.getLifeVersion())) {\n+            // This UNDELETE is not valid, when the final state of this storeKey is\n+            // 1. DELETE, or\n+            // 2. the current lifeVersion is not the same\n+            continue;\n+          }\n+        } else {\n           long operationTimeInMs =\n               indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n                   : indexValue.getOperationTimeInMs();\n-          deletedKeys.put(indexEntry.getKey(), operationTimeInMs);\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n+        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+          validIndexEntryAction.accept(indexEntry);\n         }\n       } else if (indexValue.isTtlUpdate()) {\n-        if (isTtlUpdateEntryValid(indexEntry.getKey(), indexValue, referenceTimeInMs, deletedKeys)) {\n+        if (isTtlUpdateEntryValid(key, indexValue, referenceTimeInMs, keyFinalStates)) {\n           validIndexEntryAction.accept(indexEntry);\n         }", "originalCommit": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMDM5MQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457730391", "bodyText": "it's in line 595. It checks if there is a put in the same log segment with ttl update, if so, check if this put is valid or not. if it's not, then the ttl update is not valid either.", "author": "justinlin-linkedin", "createdAt": "2020-07-20T22:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3NTQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNDAxNA==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457734014", "bodyText": "I see, what if put is not in the same log segment, how do we handle that?", "author": "jsjtzyy", "createdAt": "2020-07-20T22:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3NTQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMDI1NQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r458310255", "bodyText": "There is a comments regarding this case. As long as the PUT exists and not in the same log segment, TTL_UPDATE is considered as valid. I suppose this is because the stats is used to trigger compaction, and it's possible that in compaction we only compact log segment with TTL_UPDATE and not PUT. For instance, if PUT is in 0_0_log and TTL_UPDATE is in 1_0_log and in compaction, we only compaction 1_0_log, in this case, TTL_UPDATE would be considered as valid and will be kept after compaction. I suppose the logic here is trying to be as close to the compaction logic as possible.", "author": "justinlin-linkedin", "createdAt": "2020-07-21T18:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3NTQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MDIzNw==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457580237", "bodyText": "I don't understand why we need check inalState.getOperationTime() < referenceTimeInMs.  I think once final state is delete, this put is no longer valid.", "author": "jsjtzyy", "createdAt": "2020-07-20T17:37:52Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +494,76 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n+   * @param removeFromStates if {@code True}, then remove the {@link IndexFinalState} from the given map {@code keyFinalStates}\n+   *                         when encountering PUT IndexValue. This method iterates through IndexValues from most recent one to\n+   *                         earliest one, so PUT IndexValue is the last IndexValue for the same key.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 3. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n         validIndexEntryAction.accept(indexEntry);\n-        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+      } else if (indexValue.isUndelete()) {\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isTtlUpdate()) {\n+            indexValue.setExpiresAtMs(Utils.Infinite_Time);\n+          }\n+          if (state.isDelete() || (state.getLifeVersion() != indexValue.getLifeVersion())) {\n+            // This UNDELETE is not valid, when the final state of this storeKey is\n+            // 1. DELETE, or\n+            // 2. the current lifeVersion is not the same\n+            continue;\n+          }\n+        } else {\n           long operationTimeInMs =\n               indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n                   : indexValue.getOperationTimeInMs();\n-          deletedKeys.put(indexEntry.getKey(), operationTimeInMs);\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n+        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+          validIndexEntryAction.accept(indexEntry);\n         }\n       } else if (indexValue.isTtlUpdate()) {\n-        if (isTtlUpdateEntryValid(indexEntry.getKey(), indexValue, referenceTimeInMs, deletedKeys)) {\n+        if (isTtlUpdateEntryValid(key, indexValue, referenceTimeInMs, keyFinalStates)) {\n           validIndexEntryAction.accept(indexEntry);\n         }\n       } else {\n-        // This is a put record\n-        if (isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n-          // try to update the expiration time for this put if there is an ttl update\n-          IndexValue newValue = index.findKey(indexEntry.getKey());\n-          if (newValue != null) {\n-            indexValue.setExpiresAtMs(newValue.getExpiresAtMs());\n-          }\n+        IndexFinalState finalState = removeFromStates ? keyFinalStates.remove(key) : keyFinalStates.get(key);\n+        if (finalState != null && finalState.isDelete() && finalState.getOperationTime() < referenceTimeInMs) {\n+          // Put is deleted before reference time, it's not valid.", "originalCommit": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyOTk5OQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457729999", "bodyText": "it's not just that. when the final state is delete, but it's still within the retention duration, say it's deleted no more than 7 days ago, then the put is still a valid record. It's only after 7 days, the put would be invalid.", "author": "justinlin-linkedin", "createdAt": "2020-07-20T22:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MDIzNw=="}], "type": "inlineReview"}, {"oid": "c01f01b41461067b2f9c86c4383ed3abe8e109c1", "url": "https://github.com/linkedin/ambry/commit/c01f01b41461067b2f9c86c4383ed3abe8e109c1", "message": "Add support for undelete in blobstorestats", "committedDate": "2020-07-20T22:32:53Z", "type": "commit"}, {"oid": "44547bcd6f46ed90ca234ee6c7c98c93f91f5a01", "url": "https://github.com/linkedin/ambry/commit/44547bcd6f46ed90ca234ee6c7c98c93f91f5a01", "message": "typo", "committedDate": "2020-07-20T22:32:53Z", "type": "commit"}, {"oid": "4d1e9ddb15eec45c095250a0b6aa54e7c36d4858", "url": "https://github.com/linkedin/ambry/commit/4d1e9ddb15eec45c095250a0b6aa54e7c36d4858", "message": "Comments", "committedDate": "2020-07-20T22:32:53Z", "type": "commit"}, {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2", "url": "https://github.com/linkedin/ambry/commit/a2c3b086103c64493c8239316f6ed9f6c53165e2", "message": "comments", "committedDate": "2020-07-20T22:37:39Z", "type": "commit"}, {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2", "url": "https://github.com/linkedin/ambry/commit/a2c3b086103c64493c8239316f6ed9f6c53165e2", "message": "comments", "committedDate": "2020-07-20T22:37:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMzc5MQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457733791", "bodyText": "why this is not finalState.getOperationTime() > referenceTimeInMs?", "author": "jsjtzyy", "createdAt": "2020-07-20T22:46:22Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -550,26 +592,20 @@ private boolean isTtlUpdateEntryValid(StoreKey key, IndexValue ttlUpdateValue, l\n       valid = false;\n     } else if (putValue.getOffset().getName().equals(ttlUpdateValue.getOffset().getName())) {\n       // can be invalid if it is in the same log segment and the put is invalid\n-      valid = isPutEntryValid(key, putValue, referenceTimeInMs, deletedKeys);\n+      IndexFinalState finalState = keyFinalStates.get(key);\n+      if (finalState != null && finalState.isDelete() && finalState.getOperationTime() < referenceTimeInMs) {", "originalCommit": "a2c3b086103c64493c8239316f6ed9f6c53165e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMjA0NQ==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r458312045", "bodyText": "finalState is delete so the operation time is when this blob is deleted. when deletedAt is less than reference time, it means this PUT value is not valid. For example. the reference is now - 7days and the deletedAt is now - 10 days, it means the blob is deleted 10 days ago and we only have 7 days as retention duration. now -10 days < now - 7 days, the PUT is invalid, so as the TTL_UPDATE.", "author": "justinlin-linkedin", "createdAt": "2020-07-21T18:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMzc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxNzk4Mg==", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r458317982", "bodyText": "I see, make sense.", "author": "jsjtzyy", "createdAt": "2020-07-21T18:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMzc5MQ=="}], "type": "inlineReview"}]}