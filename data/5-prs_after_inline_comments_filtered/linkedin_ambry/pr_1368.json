{"pr_number": 1368, "pr_title": "Introduce clustermap change listener to propagate remote replica addition/removal events", "pr_createdAt": "2020-01-28T00:14:06Z", "pr_url": "https://github.com/linkedin/ambry/pull/1368", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzODAyOQ==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374238029", "bodyText": "Since we dont really support, do you think throwing an exception might work here?", "author": "ankagrawal", "createdAt": "2020-02-03T17:31:54Z", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/StaticClusterManager.java", "diffHunk": "@@ -153,6 +153,11 @@ public MetricRegistry getMetricRegistry() {\n     return metricRegistry;\n   }\n \n+  @Override\n+  public void registerClusterMapListener(ClusterMapChangeListener clusterMapChangeListener) {\n+    // no op for static cluster map.", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM0MzIzNA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374343234", "bodyText": "sure, will make the change", "author": "jsjtzyy", "createdAt": "2020-02-03T21:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzODAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMjY0Mg==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r377212642", "bodyText": "I think this isnt addressed yet.", "author": "ankagrawal", "createdAt": "2020-02-10T17:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzODAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0ODk1Mw==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374248953", "bodyText": "If startupLatch is interrupted, could we might miss a replica event?  If yes, then should we throw an exception?", "author": "ankagrawal", "createdAt": "2020-02-03T17:54:16Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxNjA2OQ==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r375616069", "bodyText": "Will throw an IllegalStateException here. Note that, it doesn't help catch up missed event because next time this method is invoked, the pass-in parameters have changed. (For replication manager this is not critical, we still allow whole server to serve traffic temporarily. Missed replica event eventually will generate some error logs and then we can restart this node)", "author": "jsjtzyy", "createdAt": "2020-02-06T02:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0ODk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MDI1OQ==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374250259", "bodyText": "Is it possible that we add a replica for a pre-existing store (maybe as a retry, or re-assignment of a partition)? In that case maybe we can read any existing replica token.", "author": "ankagrawal", "createdAt": "2020-02-03T17:56:56Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjExNzk1NA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376117954", "bodyText": "This is a good point. For now, let's start with creating a brand new replica token because dynamically adding/removing remote replicas should be infrequent. I will keep your point in mind when merging this with PR #1355 .", "author": "jsjtzyy", "createdAt": "2020-02-06T22:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MjgyMQ==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374252821", "bodyText": "Looks like this method will be called either for replicas being added or removed. We should use a boolean then (e.g, isRemove), instead of two lists.", "author": "ankagrawal", "createdAt": "2020-02-03T18:02:15Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMjc3OQ==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376122779", "bodyText": "I see your point but the method is invoked by InstanceConfig change and there could be both added and removed replica within a single InstanceConfig change. We pass in two lists (can be empty) and let replication manager handle both cases at the same time.", "author": "jsjtzyy", "createdAt": "2020-02-06T22:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1NTc2NA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374255764", "bodyText": "Also it looks like we have some duplicate code between this method and addReplica/removeReplica methods. Can we try to refactor?", "author": "ankagrawal", "createdAt": "2020-02-03T18:08:56Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMDM3NA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376120374", "bodyText": "addReplica(), removeReplica() are methods for changing replicas on local node. They create a new PartitionInfo along with all peer RemoteReplicaInfos. onReplicaAddedOrRemoved() basically modifies existing PartitionInfo by adding/removing certain RemoteReplicaInfo. Refactoring will be considered in a separate PR after we have verified functionality of this change.", "author": "jsjtzyy", "createdAt": "2020-02-06T22:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1NTc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4ODUxNA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374988514", "bodyText": "I suggest adding a private class to serve as the implementation of ClusterMapChangeListener, just like PartitionStateChangeListener.", "author": "justinlin-linkedin", "createdAt": "2020-02-04T23:47:06Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNzk1Mw==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376127953", "bodyText": "Any benefits we can get by doing so? One probably reason I come up with is: when unifying all existing replication managers into a general replication manager, it requires 2 clustermap change listeners taking actions against changes in VCR and regular Ambry cluster. Feel free to add more thoughts here.", "author": "jsjtzyy", "createdAt": "2020-02-06T22:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4ODUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5ODM2Ng==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374998366", "bodyText": "please lock getRemoveReplicaInfos method as well, this lock is protecting remoteReplicas list, we should lock it everywhere we use it.", "author": "justinlin-linkedin", "createdAt": "2020-02-05T00:21:36Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/PartitionInfo.java", "diffHunk": "@@ -50,6 +53,44 @@ public ReplicaId getLocalReplicaId() {\n     return this.localReplicaId;\n   }\n \n+  /**\n+   * Add {@link RemoteReplicaInfo} to this {@link PartitionInfo} if it is previously absent.\n+   * @param remoteReplicaInfo the {@link RemoteReplicaInfo} to add.\n+   * @return {@code true} if remote replica info is added. {@code false} if it is already present\n+   */\n+  boolean addReplicaInfoIfAbsent(RemoteReplicaInfo remoteReplicaInfo) {\n+    lock.lock();", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjIzNQ==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376126235", "bodyText": "make sense, i will use read-write lock instead", "author": "jsjtzyy", "createdAt": "2020-02-06T22:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5ODM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5OTg4NA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374999884", "bodyText": "we should only add remoteReplicaInfo to the \"toAdd\" list when it was successfully added to partitionInfo, so we should move this statement in the if-else statement above.", "author": "justinlin-linkedin", "createdAt": "2020-02-05T00:27:25Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();\n+          RemoteReplicaInfo remoteReplicaInfo =\n+              new RemoteReplicaInfo(remoteReplica, partitionInfo.getLocalReplicaId(), partitionInfo.getStore(),\n+                  findToken,\n+                  TimeUnit.SECONDS.toMillis(storeConfig.storeDataFlushIntervalSeconds) * Replication_Delay_Multiplier,\n+                  SystemTime.getInstance(), remoteReplica.getDataNodeId().getPortToConnectTo());\n+          logger.info(\"Adding remote replica {} on {} to partition info.\", remoteReplica.getReplicaPath(),\n+              remoteReplica.getDataNodeId());\n+          if (partitionInfo.addReplicaInfoIfAbsent(remoteReplicaInfo)) {\n+            replicationMetrics.addMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+          }\n+          replicaInfosToAdd.add(remoteReplicaInfo);", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NzY3MA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376147670", "bodyText": "Correct, will fix this.", "author": "jsjtzyy", "createdAt": "2020-02-06T23:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5OTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMjUwMg==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r375002502", "bodyText": "why do we need this? we can just change the PartitionInfo's remove method to take a replica id as parameter, and looping the list in PartitionInfo, it's more aligned with addReplicaInfo.", "author": "justinlin-linkedin", "createdAt": "2020-02-05T00:37:43Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();\n+          RemoteReplicaInfo remoteReplicaInfo =\n+              new RemoteReplicaInfo(remoteReplica, partitionInfo.getLocalReplicaId(), partitionInfo.getStore(),\n+                  findToken,\n+                  TimeUnit.SECONDS.toMillis(storeConfig.storeDataFlushIntervalSeconds) * Replication_Delay_Multiplier,\n+                  SystemTime.getInstance(), remoteReplica.getDataNodeId().getPortToConnectTo());\n+          logger.info(\"Adding remote replica {} on {} to partition info.\", remoteReplica.getReplicaPath(),\n+              remoteReplica.getDataNodeId());\n+          if (partitionInfo.addReplicaInfoIfAbsent(remoteReplicaInfo)) {\n+            replicationMetrics.addMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+          }\n+          replicaInfosToAdd.add(remoteReplicaInfo);\n+        }\n+        addRemoteReplicaInfoToReplicaThread(replicaInfosToAdd, true);\n+\n+        // 4. remove replicaInfo from existing partitionInfo and replica-threads\n+        List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();\n+        for (ReplicaId remoteReplica : removedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          List<RemoteReplicaInfo> remoteReplicaInfos = new ArrayList<>(partitionInfo.getRemoteReplicaInfos());\n+          for (RemoteReplicaInfo remoteReplicaInfo : remoteReplicaInfos) {\n+            if (remoteReplicaInfo.getReplicaId().getDataNodeId() == remoteReplica.getDataNodeId()) {\n+              logger.info(\"Removing remote replica {} on {} from replica threads.\", remoteReplica.getReplicaPath(),\n+                  remoteReplica.getDataNodeId());\n+              replicaInfosToRemove.add(remoteReplicaInfo);\n+              if (partitionInfo.removeRelicaInfoIfPresent(remoteReplicaInfo)) {\n+                replicationMetrics.removeMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+              }\n+              break;\n+            }\n+          }\n+        }", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1Njg2Mg==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376156862", "bodyText": "right, will change removeRelicaInfoIfPresent", "author": "jsjtzyy", "createdAt": "2020-02-07T00:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMjc0Mw==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r375002743", "bodyText": "And we should put this statement within if-else statement as well.", "author": "justinlin-linkedin", "createdAt": "2020-02-05T00:38:27Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();\n+          RemoteReplicaInfo remoteReplicaInfo =\n+              new RemoteReplicaInfo(remoteReplica, partitionInfo.getLocalReplicaId(), partitionInfo.getStore(),\n+                  findToken,\n+                  TimeUnit.SECONDS.toMillis(storeConfig.storeDataFlushIntervalSeconds) * Replication_Delay_Multiplier,\n+                  SystemTime.getInstance(), remoteReplica.getDataNodeId().getPortToConnectTo());\n+          logger.info(\"Adding remote replica {} on {} to partition info.\", remoteReplica.getReplicaPath(),\n+              remoteReplica.getDataNodeId());\n+          if (partitionInfo.addReplicaInfoIfAbsent(remoteReplicaInfo)) {\n+            replicationMetrics.addMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+          }\n+          replicaInfosToAdd.add(remoteReplicaInfo);\n+        }\n+        addRemoteReplicaInfoToReplicaThread(replicaInfosToAdd, true);\n+\n+        // 4. remove replicaInfo from existing partitionInfo and replica-threads\n+        List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();\n+        for (ReplicaId remoteReplica : removedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          List<RemoteReplicaInfo> remoteReplicaInfos = new ArrayList<>(partitionInfo.getRemoteReplicaInfos());\n+          for (RemoteReplicaInfo remoteReplicaInfo : remoteReplicaInfos) {\n+            if (remoteReplicaInfo.getReplicaId().getDataNodeId() == remoteReplica.getDataNodeId()) {\n+              logger.info(\"Removing remote replica {} on {} from replica threads.\", remoteReplica.getReplicaPath(),\n+                  remoteReplica.getDataNodeId());\n+              replicaInfosToRemove.add(remoteReplicaInfo);", "originalCommit": "eb970c85dffe8ec29ab97ceeac61368a13df65c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NzkzMA==", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r376147930", "bodyText": "will fix", "author": "jsjtzyy", "createdAt": "2020-02-06T23:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMjc0Mw=="}], "type": "inlineReview"}, {"oid": "51646d14277b1f3847e11976e3d229c3a72fa5ff", "url": "https://github.com/linkedin/ambry/commit/51646d14277b1f3847e11976e3d229c3a72fa5ff", "message": "Introduce clustermap change listener to notify replica addition/removal\nevents\n\nWith \"move replica\", Helix cluster manager should be able to dynamically\nadd/remove remote replica infos and therefore clustermap will be\ndynamically changed. External components like ReplicationManager needs\nto update thread assignment and some in-mem data structures in repsonse\nto such changes. This PR introduces clustermap change listener which\nallows ReplicationManager to listen to any change in clustermap and take\nactions accordingly. For now, there is only one method in clustermap\nchange listener: onReplicaAddedOrRemoved(), we could add more methods\nlike onReplicaLeadershipChange etc if needed.", "committedDate": "2020-02-07T01:44:15Z", "type": "commit"}, {"oid": "ccbe4921d57156f8ce6e53de36b6faeb1223d6bb", "url": "https://github.com/linkedin/ambry/commit/ccbe4921d57156f8ce6e53de36b6faeb1223d6bb", "message": "add some tests and remove replica from metrics", "committedDate": "2020-02-07T01:44:15Z", "type": "commit"}, {"oid": "daeceece1f483b5f7ed91cecb5368967990bed07", "url": "https://github.com/linkedin/ambry/commit/daeceece1f483b5f7ed91cecb5368967990bed07", "message": "add more test cases", "committedDate": "2020-02-07T01:44:15Z", "type": "commit"}, {"oid": "977da233aaa798ac1e1d2e809a0cd187633c8c60", "url": "https://github.com/linkedin/ambry/commit/977da233aaa798ac1e1d2e809a0cd187633c8c60", "message": "improve test coverage", "committedDate": "2020-02-07T01:44:15Z", "type": "commit"}, {"oid": "c4123b715e7c1fac2242581e3e2bc113cae2cb65", "url": "https://github.com/linkedin/ambry/commit/c4123b715e7c1fac2242581e3e2bc113cae2cb65", "message": "comments", "committedDate": "2020-02-07T01:44:15Z", "type": "commit"}, {"oid": "fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "url": "https://github.com/linkedin/ambry/commit/fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "message": "rebase and fix conflicts", "committedDate": "2020-02-07T01:54:20Z", "type": "commit"}, {"oid": "fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "url": "https://github.com/linkedin/ambry/commit/fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "message": "rebase and fix conflicts", "committedDate": "2020-02-07T01:54:20Z", "type": "forcePushed"}, {"oid": "e8c6f9d66c95c85c95292234f3798e1eb7c4aecf", "url": "https://github.com/linkedin/ambry/commit/e8c6f9d66c95c85c95292234f3798e1eb7c4aecf", "message": "one more test case", "committedDate": "2020-02-07T21:13:35Z", "type": "commit"}, {"oid": "73106457fc9cf11ae98dcd66d6b358b4d2f50dd3", "url": "https://github.com/linkedin/ambry/commit/73106457fc9cf11ae98dcd66d6b358b4d2f50dd3", "message": "minor comment", "committedDate": "2020-02-10T18:01:48Z", "type": "commit"}]}