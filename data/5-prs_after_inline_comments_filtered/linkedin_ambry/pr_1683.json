{"pr_number": 1683, "pr_title": "Mysl account service failover to non-primary endpoints", "pr_createdAt": "2020-11-04T23:02:58Z", "pr_url": "https://github.com/linkedin/ambry/pull/1683", "timeline": [{"oid": "cf08b572237b1cb2bfc2fae23ef36c52cb23e321", "url": "https://github.com/linkedin/ambry/commit/cf08b572237b1cb2bfc2fae23ef36c52cb23e321", "message": "Mysl account service failover to non-primary endpoints", "committedDate": "2020-11-04T22:54:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNDE0Mw==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r517704143", "bodyText": "I was gonna reuse getDbEndpointsPerDC in some code of mine too, but it does not really need to return a map in my case either.", "author": "cgtz", "createdAt": "2020-11-05T00:06:45Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlAccountStoreFactory.java", "diffHunk": "@@ -25,43 +27,42 @@\n \n \n /**\n- * Factory class to return an instance of {@link MySqlAccountStore} on {@link #getMySqlAccountStore(boolean)} call\n+ * Factory class to return an instance of {@link MySqlAccountStore} on {@link #getMySqlAccountStore()} call\n  */\n public class MySqlAccountStoreFactory {\n \n   private static final Logger logger = LoggerFactory.getLogger(MySqlAccountStoreFactory.class);\n+  private static final String UNKNOWN_DATACENTER = \"Unknown\";\n+\n   protected final MySqlAccountServiceConfig accountServiceConfig;\n+  protected final String localDatacenter;\n \n   /**\n    * Constructor.\n-   * @param  verifiableProperties The properties to get a {@link MySqlAccountStore} instance. Cannot be {@code null}.\n+   * @param verifiableProperties The properties to get a {@link MySqlAccountStore} instance. Cannot be {@code null}.\n    */\n   public MySqlAccountStoreFactory(VerifiableProperties verifiableProperties) {\n     this.accountServiceConfig = new MySqlAccountServiceConfig(verifiableProperties);\n+    // If datacenter is unknown, all endpoints will be considered remote\n+    this.localDatacenter =\n+        verifiableProperties.getString(ClusterMapConfig.CLUSTERMAP_DATACENTER_NAME, UNKNOWN_DATACENTER);\n   }\n \n   /**\n    * Returns an instance of the {@link MySqlAccountStore} that the factory generates.\n-   * @param writeable needs to be set to true if requesting a store that accepts writes.\n    * @return an instance of {@link MySqlAccountStore} generated by this factory.\n    * @throws SQLException\n    */\n-  public MySqlAccountStore getMySqlAccountStore(boolean writeable) throws SQLException {\n+  public MySqlAccountStore getMySqlAccountStore() throws SQLException {\n     Map<String, List<MySqlUtils.DbEndpoint>> dcToMySqlDBEndpoints = getDbEndpointsPerDC(accountServiceConfig.dbInfo);\n-    for (List<MySqlUtils.DbEndpoint> dbEndpoints : dcToMySqlDBEndpoints.values()) {\n-      // TODO: Can have logic to try mysql end point on local DC first\n-      for (MySqlUtils.DbEndpoint dbEndpoint : dbEndpoints) {\n-        if ((dbEndpoint.isWriteable() && writeable) || (!dbEndpoint.isWriteable() && !writeable)) {\n-          try {\n-            return new MySqlAccountStore(dbEndpoint);\n-          } catch (SQLException e) {\n-            logger.error(\"MySQL account store creation failed\", e);\n-            // TODO: Add logic to retry on different db end point based on type of exception.\n-            throw e;\n-          }\n-        }\n-      }\n+    // Flatten to List (TODO: does utility method need to return map?)", "originalCommit": "cf08b572237b1cb2bfc2fae23ef36c52cb23e321", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58c61f29e006a59ebe34822661a72cebe1e60b71", "url": "https://github.com/linkedin/ambry/commit/58c61f29e006a59ebe34822661a72cebe1e60b71", "message": "Add unit test class MySqlDataAccessorTest", "committedDate": "2020-11-05T07:32:31Z", "type": "commit"}, {"oid": "4c52063fe2eb54ce9cb2b07b2272ccb874c149fe", "url": "https://github.com/linkedin/ambry/commit/4c52063fe2eb54ce9cb2b07b2272ccb874c149fe", "message": "Merge branch 'master' of github.com:linkedin/ambry into mysql-failover", "committedDate": "2020-11-05T08:02:32Z", "type": "commit"}, {"oid": "c18efec9ce919b15caa3b1cdbf613c3117d4bc32", "url": "https://github.com/linkedin/ambry/commit/c18efec9ce919b15caa3b1cdbf613c3117d4bc32", "message": "Fix merge issues", "committedDate": "2020-11-05T08:15:58Z", "type": "commit"}, {"oid": "9fc6c94521339f6ab86816d23ccfa6de15010a69", "url": "https://github.com/linkedin/ambry/commit/9fc6c94521339f6ab86816d23ccfa6de15010a69", "message": "Fix compile errors", "committedDate": "2020-11-05T16:09:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM5NDkxNQ==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518394915", "bodyText": "Yeah, would reset() be needed to clear PreparedStatements in 'statementCache' associated with this connection being closed?", "author": "Arun-LinkedIn", "createdAt": "2020-11-05T21:58:57Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -54,49 +61,91 @@\n   }\n \n   /** Production constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, MySqlAccountStoreMetrics metrics) throws SQLException {\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, String localDatacenter, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.metrics = metrics;\n+    setup(inputEndpoints, localDatacenter);\n+  }\n+\n+  /** Test constructor */\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, Driver mysqlDriver, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.mysqlDriver = mysqlDriver;\n     this.metrics = metrics;\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    // Initialize driver\n-    mysqlDriver = DriverManager.getDriver(mysqlUrl);\n+    setup(inputEndpoints, inputEndpoints.get(0).getDatacenter());\n+  }\n+\n+  /**\n+   * Setup for data access.\n+   * @param inputEndpoints the {@link DbEndpoint}s to use.\n+   * @param localDatacenter the name of the local datacenter.\n+   * @throws SQLException if setup fails.\n+   */\n+  private void setup(List<DbEndpoint> inputEndpoints, String localDatacenter) throws SQLException {\n+    if (inputEndpoints == null || inputEndpoints.isEmpty()) {\n+      throw new IllegalArgumentException(\"No endpoints supplied\");\n+    }\n+    // Sort from best to worst\n+    endpointComparator = new EndpointComparator(localDatacenter);\n+    Collections.sort(inputEndpoints, endpointComparator);\n+    sortedDbEndpoints = inputEndpoints;\n+    if (!sortedDbEndpoints.get(0).isWriteable()) {\n+      throw new IllegalArgumentException(\"No endpoints are writable\");\n+    }\n+\n+    initializeDriver(sortedDbEndpoints.get(0).getUrl());\n+\n     // AccountService needs to work if mysql is down.  Mysql can also reboot.\n     try {\n-      getDatabaseConnection();\n+      getDatabaseConnection(true);\n     } catch (SQLException e) {\n       if (isCredentialError(e)) {\n         throw e;\n       } else {\n-        // try again later\n+        logger.error(\"No writable database available, will retry later.\");\n       }\n     }\n   }\n \n-  /** Test constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, Driver mysqlDriver, MySqlAccountStoreMetrics metrics) {\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    this.mysqlDriver = mysqlDriver;\n-    this.metrics = metrics;\n+  private void initializeDriver(String url) throws SQLException {\n+    if (mysqlDriver == null) {\n+      mysqlDriver = DriverManager.getDriver(url);\n+    }\n   }\n \n   /**\n-   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused.\n+   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused,\n+   * unless a connection to a better-ranked enpoint is available.\n+   * @param needWritable whether the database instance needs to be writeable.\n    * @throws SQLException\n    */\n-  public synchronized Connection getDatabaseConnection() throws SQLException {\n-    if (activeConnection != null && activeConnection.isValid(5)) {\n+  public synchronized Connection getDatabaseConnection(boolean needWritable) throws SQLException {\n+\n+    // Close active connection if no longer valid\n+    if (activeConnection != null && !activeConnection.isValid(5)) {\n+      reset();\n+      activeConnection = null;\n+      connectedEndpoint = null;\n+    }\n+\n+    // If the active connection is good and it's the best endpoint, keep it.\n+    if (activeConnection != null && !isBetterEndpoint(sortedDbEndpoints.get(0), connectedEndpoint)) {\n       return activeConnection;\n     }\n-    if (activeConnection != null) {\n-      activeConnection.close();\n+    // See if we can do better\n+    Pair<DbEndpoint, Connection> endpointConnectionPair = connectToBestAvailableEndpoint(needWritable);\n+    if (connectedEndpoint == endpointConnectionPair.getFirst()) {\n+      // No better endpoint  was available.\n+      logger.debug(\"Still connected to {}\", connectedEndpoint.getUrl());\n+    } else {\n+      // New connection established!\n+      // TODO: mysqlMetrics.connectionFixedCount.inc();\n+      connectedEndpoint = endpointConnectionPair.getFirst();\n+      String qualifier = connectedEndpoint.isWriteable() ? \"writable\" : \"read-only\";\n+      logger.info(\"Connected to {} enpoint: {}\", qualifier, connectedEndpoint.getUrl());\n+      closeQuietly(activeConnection); // TODO: reset?", "originalCommit": "9fc6c94521339f6ab86816d23ccfa6de15010a69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM5ODY3OQ==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518398679", "bodyText": "Would returning here be okay too? Since db end points are sorted by writable property, remaining ones might be read-only ones.", "author": "Arun-LinkedIn", "createdAt": "2020-11-05T22:06:46Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -182,24 +232,116 @@ void onSuccess(OperationType operationType, long operationTimeInMs) {\n   }\n \n   /**\n-   * Reset to initial state.\n+   * Close the active connection and clear the statement cache.\n    * This should be called after a failed database operation.\n    */\n   synchronized void reset() {\n     for (PreparedStatement statement : statementCache.values()) {\n-      try {\n-        statement.close();\n-      } catch (SQLException e) {\n-        logger.error(\"Closing prepared statement\", e);\n-      }\n+      closeQuietly(statement);\n     }\n     statementCache.clear();\n-    if (activeConnection != null) {\n+    closeQuietly(activeConnection);\n+  }\n+\n+  /**\n+   * Connect to the best available database instance that matches the specified criteria.\n+   * Order of preference for instances to connect to:\n+   *   1) writeable instance in local colo\n+   *   2) writable instance in any colo\n+   *   3) readonly instance in local colo (if needWritable is false)\n+   *   4) readonly instance in any colo (if needWritable is false)\n+   * @param needWritable whether the endpoint needs to be writable\n+   * @return a pair of {@link DbEndpoint} and corresponding {@link Connection}.\n+   * @throws SQLException if connection could not be made to a suitable endpoint.\n+   */\n+  private Pair<DbEndpoint, Connection> connectToBestAvailableEndpoint(boolean needWritable) throws SQLException {\n+    SQLException lastException = null;\n+    for (DbEndpoint dbEndpoint : sortedDbEndpoints) {\n+      if (!isBetterEndpoint(dbEndpoint, connectedEndpoint)) {\n+        // This is the best we can do\n+        if (needWritable && !connectedEndpoint.isWriteable()) {\n+          // TODO: throw lastException if any\n+          throw new SQLException(\"Could not connect to any writable database\");\n+        } else {\n+          return new Pair<>(connectedEndpoint, activeConnection);\n+        }\n+      }\n+      if (needWritable && !dbEndpoint.isWriteable()) {\n+        continue;", "originalCommit": "9fc6c94521339f6ab86816d23ccfa6de15010a69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5OTk0OQ==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518499949", "bodyText": "Changed to throw exception", "author": "lightningrob", "createdAt": "2020-11-06T03:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM5ODY3OQ=="}], "type": "inlineReview"}, {"oid": "e0713915109aa5d70aaf343bb8761867ce0cbb30", "url": "https://github.com/linkedin/ambry/commit/e0713915109aa5d70aaf343bb8761867ce0cbb30", "message": "Add metrics", "committedDate": "2020-11-06T03:12:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NDgxNw==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518984817", "bodyText": "You may want to use ofNullable here. of will throw an NPE if lastException is null.\nOr an old style lastException != null ? lastException : noWritableEndpointException", "author": "cgtz", "createdAt": "2020-11-06T20:18:45Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -54,63 +64,163 @@\n   }\n \n   /** Production constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, MySqlAccountStoreMetrics metrics) throws SQLException {\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, String localDatacenter, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.metrics = metrics;\n+    setup(inputEndpoints, localDatacenter);\n+  }\n+\n+  /** Test constructor */\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, Driver mysqlDriver, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.mysqlDriver = mysqlDriver;\n     this.metrics = metrics;\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    // Initialize driver\n-    mysqlDriver = DriverManager.getDriver(mysqlUrl);\n+    setup(inputEndpoints, inputEndpoints.get(0).getDatacenter());\n+  }\n+\n+  /**\n+   * @return the {@link MySqlAccountStoreMetrics} being used.\n+   */\n+  public MySqlAccountStoreMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  /**\n+   * Setup for data access.\n+   * @param inputEndpoints the {@link DbEndpoint}s to use.\n+   * @param localDatacenter the name of the local datacenter.\n+   * @throws SQLException if setup fails.\n+   */\n+  private void setup(List<DbEndpoint> inputEndpoints, String localDatacenter) throws SQLException {\n+    if (inputEndpoints == null || inputEndpoints.isEmpty()) {\n+      throw new IllegalArgumentException(\"No endpoints supplied\");\n+    }\n+    // Sort from best to worst\n+    endpointComparator = new EndpointComparator(localDatacenter);\n+    Collections.sort(inputEndpoints, endpointComparator);\n+    sortedDbEndpoints = inputEndpoints;\n+    if (!sortedDbEndpoints.get(0).isWriteable()) {\n+      throw new IllegalArgumentException(\"No endpoints are writable\");\n+    }\n+\n+    initializeDriver(sortedDbEndpoints.get(0).getUrl());\n+\n     // AccountService needs to work if mysql is down.  Mysql can also reboot.\n     try {\n-      getDatabaseConnection();\n+      getDatabaseConnection(true);\n     } catch (SQLException e) {\n       if (isCredentialError(e)) {\n         throw e;\n       } else {\n-        // try again later\n+        logger.error(\"No writable database available, will retry later.\");\n       }\n     }\n   }\n \n-  /** Test constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, Driver mysqlDriver, MySqlAccountStoreMetrics metrics) {\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    this.mysqlDriver = mysqlDriver;\n-    this.metrics = metrics;\n+  private void initializeDriver(String url) throws SQLException {\n+    if (mysqlDriver == null) {\n+      mysqlDriver = DriverManager.getDriver(url);\n+    }\n   }\n \n   /**\n-   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused.\n+   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused,\n+   * unless a connection to a better-ranked enpoint is available.\n+   * @param needWritable whether the database instance needs to be writeable.\n    * @throws SQLException\n    */\n-  public synchronized Connection getDatabaseConnection() throws SQLException {\n-    if (activeConnection != null && activeConnection.isValid(5)) {\n+  public synchronized Connection getDatabaseConnection(boolean needWritable) throws SQLException {\n+\n+    // Close active connection if no longer valid\n+    if (activeConnection != null && !activeConnection.isValid(5)) {\n+      closeActiveConnection();\n+      activeConnection = null;\n+      connectedEndpoint = null;\n+    }\n+\n+    // If the active connection is good and it's the best endpoint, keep it.\n+    if (activeConnection != null && !isBetterEndpoint(sortedDbEndpoints.get(0), connectedEndpoint)) {\n       return activeConnection;\n     }\n-    if (activeConnection != null) {\n-      activeConnection.close();\n+    // See if we can do better\n+    Pair<DbEndpoint, Connection> endpointConnectionPair = connectToBestAvailableEndpoint(needWritable);\n+    if (connectedEndpoint == endpointConnectionPair.getFirst()) {\n+      // No better endpoint  was available.\n+      logger.debug(\"Still connected to {}\", connectedEndpoint.getUrl());\n+    } else {\n+      // New connection established\n+      connectedEndpoint = endpointConnectionPair.getFirst();\n+      String qualifier = connectedEndpoint.isWriteable() ? \"writable\" : \"read-only\";\n+      logger.info(\"Connected to {} enpoint: {}\", qualifier, connectedEndpoint.getUrl());\n+      closeActiveConnection();\n+      activeConnection = endpointConnectionPair.getSecond();\n     }\n-    Properties credentials = new Properties();\n-    credentials.setProperty(\"user\", mysqlUser);\n-    credentials.setProperty(\"password\", mysqlPassword);\n-    activeConnection = mysqlDriver.connect(mysqlUrl, credentials);\n     return activeConnection;\n   }\n \n+  /**\n+   * Connect to the best available database instance that matches the specified criteria.<br/>\n+   * Order of preference for instances to connect to:\n+   * <OL>\n+   *    <LI/> Writeable instance in local colo\n+   *    <LI/> Writable instance in any colo\n+   *    <LI/> Read-only instance in local colo (if needWritable is false)\n+   *    <LI/> Read-only instance in any colo (if needWritable is false)\n+   *  </OL>\n+   * @param needWritable whether the endpoint needs to be writable\n+   * @return a pair of {@link DbEndpoint} and corresponding {@link Connection}.\n+   * @throws SQLException if connection could not be made to a suitable endpoint.\n+   */\n+  private Pair<DbEndpoint, Connection> connectToBestAvailableEndpoint(boolean needWritable) throws SQLException {\n+    SQLException lastException = null;\n+    for (DbEndpoint candidateEndpoint : sortedDbEndpoints) {\n+      if (!isBetterEndpoint(candidateEndpoint, connectedEndpoint)) {\n+        // What we have is the best we can do.  Is it good enough?\n+        if (needWritable && !connectedEndpoint.isWriteable()) {\n+          throw Optional.of(lastException).orElse(noWritableEndpointException);", "originalCommit": "e0713915109aa5d70aaf343bb8761867ce0cbb30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MjE1NA==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518992154", "bodyText": "Good catch.  Fixed.", "author": "lightningrob", "createdAt": "2020-11-06T20:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NDgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NjExNA==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518986114", "bodyText": "same here and line 209", "author": "cgtz", "createdAt": "2020-11-06T20:21:49Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -54,63 +64,163 @@\n   }\n \n   /** Production constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, MySqlAccountStoreMetrics metrics) throws SQLException {\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, String localDatacenter, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.metrics = metrics;\n+    setup(inputEndpoints, localDatacenter);\n+  }\n+\n+  /** Test constructor */\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, Driver mysqlDriver, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.mysqlDriver = mysqlDriver;\n     this.metrics = metrics;\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    // Initialize driver\n-    mysqlDriver = DriverManager.getDriver(mysqlUrl);\n+    setup(inputEndpoints, inputEndpoints.get(0).getDatacenter());\n+  }\n+\n+  /**\n+   * @return the {@link MySqlAccountStoreMetrics} being used.\n+   */\n+  public MySqlAccountStoreMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  /**\n+   * Setup for data access.\n+   * @param inputEndpoints the {@link DbEndpoint}s to use.\n+   * @param localDatacenter the name of the local datacenter.\n+   * @throws SQLException if setup fails.\n+   */\n+  private void setup(List<DbEndpoint> inputEndpoints, String localDatacenter) throws SQLException {\n+    if (inputEndpoints == null || inputEndpoints.isEmpty()) {\n+      throw new IllegalArgumentException(\"No endpoints supplied\");\n+    }\n+    // Sort from best to worst\n+    endpointComparator = new EndpointComparator(localDatacenter);\n+    Collections.sort(inputEndpoints, endpointComparator);\n+    sortedDbEndpoints = inputEndpoints;\n+    if (!sortedDbEndpoints.get(0).isWriteable()) {\n+      throw new IllegalArgumentException(\"No endpoints are writable\");\n+    }\n+\n+    initializeDriver(sortedDbEndpoints.get(0).getUrl());\n+\n     // AccountService needs to work if mysql is down.  Mysql can also reboot.\n     try {\n-      getDatabaseConnection();\n+      getDatabaseConnection(true);\n     } catch (SQLException e) {\n       if (isCredentialError(e)) {\n         throw e;\n       } else {\n-        // try again later\n+        logger.error(\"No writable database available, will retry later.\");\n       }\n     }\n   }\n \n-  /** Test constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, Driver mysqlDriver, MySqlAccountStoreMetrics metrics) {\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    this.mysqlDriver = mysqlDriver;\n-    this.metrics = metrics;\n+  private void initializeDriver(String url) throws SQLException {\n+    if (mysqlDriver == null) {\n+      mysqlDriver = DriverManager.getDriver(url);\n+    }\n   }\n \n   /**\n-   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused.\n+   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused,\n+   * unless a connection to a better-ranked enpoint is available.\n+   * @param needWritable whether the database instance needs to be writeable.\n    * @throws SQLException\n    */\n-  public synchronized Connection getDatabaseConnection() throws SQLException {\n-    if (activeConnection != null && activeConnection.isValid(5)) {\n+  public synchronized Connection getDatabaseConnection(boolean needWritable) throws SQLException {\n+\n+    // Close active connection if no longer valid\n+    if (activeConnection != null && !activeConnection.isValid(5)) {\n+      closeActiveConnection();\n+      activeConnection = null;\n+      connectedEndpoint = null;\n+    }\n+\n+    // If the active connection is good and it's the best endpoint, keep it.\n+    if (activeConnection != null && !isBetterEndpoint(sortedDbEndpoints.get(0), connectedEndpoint)) {\n       return activeConnection;\n     }\n-    if (activeConnection != null) {\n-      activeConnection.close();\n+    // See if we can do better\n+    Pair<DbEndpoint, Connection> endpointConnectionPair = connectToBestAvailableEndpoint(needWritable);\n+    if (connectedEndpoint == endpointConnectionPair.getFirst()) {\n+      // No better endpoint  was available.\n+      logger.debug(\"Still connected to {}\", connectedEndpoint.getUrl());\n+    } else {\n+      // New connection established\n+      connectedEndpoint = endpointConnectionPair.getFirst();\n+      String qualifier = connectedEndpoint.isWriteable() ? \"writable\" : \"read-only\";\n+      logger.info(\"Connected to {} enpoint: {}\", qualifier, connectedEndpoint.getUrl());\n+      closeActiveConnection();\n+      activeConnection = endpointConnectionPair.getSecond();\n     }\n-    Properties credentials = new Properties();\n-    credentials.setProperty(\"user\", mysqlUser);\n-    credentials.setProperty(\"password\", mysqlPassword);\n-    activeConnection = mysqlDriver.connect(mysqlUrl, credentials);\n     return activeConnection;\n   }\n \n+  /**\n+   * Connect to the best available database instance that matches the specified criteria.<br/>\n+   * Order of preference for instances to connect to:\n+   * <OL>\n+   *    <LI/> Writeable instance in local colo\n+   *    <LI/> Writable instance in any colo\n+   *    <LI/> Read-only instance in local colo (if needWritable is false)\n+   *    <LI/> Read-only instance in any colo (if needWritable is false)\n+   *  </OL>\n+   * @param needWritable whether the endpoint needs to be writable\n+   * @return a pair of {@link DbEndpoint} and corresponding {@link Connection}.\n+   * @throws SQLException if connection could not be made to a suitable endpoint.\n+   */\n+  private Pair<DbEndpoint, Connection> connectToBestAvailableEndpoint(boolean needWritable) throws SQLException {\n+    SQLException lastException = null;\n+    for (DbEndpoint candidateEndpoint : sortedDbEndpoints) {\n+      if (!isBetterEndpoint(candidateEndpoint, connectedEndpoint)) {\n+        // What we have is the best we can do.  Is it good enough?\n+        if (needWritable && !connectedEndpoint.isWriteable()) {\n+          throw Optional.of(lastException).orElse(noWritableEndpointException);\n+        } else {\n+          return new Pair<>(connectedEndpoint, activeConnection);\n+        }\n+      }\n+      if (needWritable && !candidateEndpoint.isWriteable()) {\n+        throw Optional.of(lastException).orElse(noWritableEndpointException);", "originalCommit": "e0713915109aa5d70aaf343bb8761867ce0cbb30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4ODA4NQ==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518988085", "bodyText": "I wonder if there are constants for the mysql driver properties anywhere.", "author": "cgtz", "createdAt": "2020-11-06T20:26:45Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -54,63 +64,163 @@\n   }\n \n   /** Production constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, MySqlAccountStoreMetrics metrics) throws SQLException {\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, String localDatacenter, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.metrics = metrics;\n+    setup(inputEndpoints, localDatacenter);\n+  }\n+\n+  /** Test constructor */\n+  public MySqlDataAccessor(List<DbEndpoint> inputEndpoints, Driver mysqlDriver, MySqlAccountStoreMetrics metrics)\n+      throws SQLException {\n+    this.mysqlDriver = mysqlDriver;\n     this.metrics = metrics;\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    // Initialize driver\n-    mysqlDriver = DriverManager.getDriver(mysqlUrl);\n+    setup(inputEndpoints, inputEndpoints.get(0).getDatacenter());\n+  }\n+\n+  /**\n+   * @return the {@link MySqlAccountStoreMetrics} being used.\n+   */\n+  public MySqlAccountStoreMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  /**\n+   * Setup for data access.\n+   * @param inputEndpoints the {@link DbEndpoint}s to use.\n+   * @param localDatacenter the name of the local datacenter.\n+   * @throws SQLException if setup fails.\n+   */\n+  private void setup(List<DbEndpoint> inputEndpoints, String localDatacenter) throws SQLException {\n+    if (inputEndpoints == null || inputEndpoints.isEmpty()) {\n+      throw new IllegalArgumentException(\"No endpoints supplied\");\n+    }\n+    // Sort from best to worst\n+    endpointComparator = new EndpointComparator(localDatacenter);\n+    Collections.sort(inputEndpoints, endpointComparator);\n+    sortedDbEndpoints = inputEndpoints;\n+    if (!sortedDbEndpoints.get(0).isWriteable()) {\n+      throw new IllegalArgumentException(\"No endpoints are writable\");\n+    }\n+\n+    initializeDriver(sortedDbEndpoints.get(0).getUrl());\n+\n     // AccountService needs to work if mysql is down.  Mysql can also reboot.\n     try {\n-      getDatabaseConnection();\n+      getDatabaseConnection(true);\n     } catch (SQLException e) {\n       if (isCredentialError(e)) {\n         throw e;\n       } else {\n-        // try again later\n+        logger.error(\"No writable database available, will retry later.\");\n       }\n     }\n   }\n \n-  /** Test constructor */\n-  public MySqlDataAccessor(MySqlUtils.DbEndpoint dbEndpoint, Driver mysqlDriver, MySqlAccountStoreMetrics metrics) {\n-    mysqlUrl = dbEndpoint.getUrl();\n-    mysqlUser = dbEndpoint.getUsername();\n-    mysqlPassword = dbEndpoint.getPassword();\n-    this.mysqlDriver = mysqlDriver;\n-    this.metrics = metrics;\n+  private void initializeDriver(String url) throws SQLException {\n+    if (mysqlDriver == null) {\n+      mysqlDriver = DriverManager.getDriver(url);\n+    }\n   }\n \n   /**\n-   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused.\n+   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused,\n+   * unless a connection to a better-ranked enpoint is available.\n+   * @param needWritable whether the database instance needs to be writeable.\n    * @throws SQLException\n    */\n-  public synchronized Connection getDatabaseConnection() throws SQLException {\n-    if (activeConnection != null && activeConnection.isValid(5)) {\n+  public synchronized Connection getDatabaseConnection(boolean needWritable) throws SQLException {\n+\n+    // Close active connection if no longer valid\n+    if (activeConnection != null && !activeConnection.isValid(5)) {\n+      closeActiveConnection();\n+      activeConnection = null;\n+      connectedEndpoint = null;\n+    }\n+\n+    // If the active connection is good and it's the best endpoint, keep it.\n+    if (activeConnection != null && !isBetterEndpoint(sortedDbEndpoints.get(0), connectedEndpoint)) {\n       return activeConnection;\n     }\n-    if (activeConnection != null) {\n-      activeConnection.close();\n+    // See if we can do better\n+    Pair<DbEndpoint, Connection> endpointConnectionPair = connectToBestAvailableEndpoint(needWritable);\n+    if (connectedEndpoint == endpointConnectionPair.getFirst()) {\n+      // No better endpoint  was available.\n+      logger.debug(\"Still connected to {}\", connectedEndpoint.getUrl());\n+    } else {\n+      // New connection established\n+      connectedEndpoint = endpointConnectionPair.getFirst();\n+      String qualifier = connectedEndpoint.isWriteable() ? \"writable\" : \"read-only\";\n+      logger.info(\"Connected to {} enpoint: {}\", qualifier, connectedEndpoint.getUrl());\n+      closeActiveConnection();\n+      activeConnection = endpointConnectionPair.getSecond();\n     }\n-    Properties credentials = new Properties();\n-    credentials.setProperty(\"user\", mysqlUser);\n-    credentials.setProperty(\"password\", mysqlPassword);\n-    activeConnection = mysqlDriver.connect(mysqlUrl, credentials);\n     return activeConnection;\n   }\n \n+  /**\n+   * Connect to the best available database instance that matches the specified criteria.<br/>\n+   * Order of preference for instances to connect to:\n+   * <OL>\n+   *    <LI/> Writeable instance in local colo\n+   *    <LI/> Writable instance in any colo\n+   *    <LI/> Read-only instance in local colo (if needWritable is false)\n+   *    <LI/> Read-only instance in any colo (if needWritable is false)\n+   *  </OL>\n+   * @param needWritable whether the endpoint needs to be writable\n+   * @return a pair of {@link DbEndpoint} and corresponding {@link Connection}.\n+   * @throws SQLException if connection could not be made to a suitable endpoint.\n+   */\n+  private Pair<DbEndpoint, Connection> connectToBestAvailableEndpoint(boolean needWritable) throws SQLException {\n+    SQLException lastException = null;\n+    for (DbEndpoint candidateEndpoint : sortedDbEndpoints) {\n+      if (!isBetterEndpoint(candidateEndpoint, connectedEndpoint)) {\n+        // What we have is the best we can do.  Is it good enough?\n+        if (needWritable && !connectedEndpoint.isWriteable()) {\n+          throw Optional.of(lastException).orElse(noWritableEndpointException);\n+        } else {\n+          return new Pair<>(connectedEndpoint, activeConnection);\n+        }\n+      }\n+      if (needWritable && !candidateEndpoint.isWriteable()) {\n+        throw Optional.of(lastException).orElse(noWritableEndpointException);\n+      }\n+\n+      // Attempt to connect to candidate endpoint\n+      Properties credentials = new Properties();\n+      credentials.setProperty(\"user\", candidateEndpoint.getUsername());", "originalCommit": "e0713915109aa5d70aaf343bb8761867ce0cbb30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MjA0NQ==", "url": "https://github.com/linkedin/ambry/pull/1683#discussion_r518992045", "bodyText": "I would think so but didn't see any.", "author": "lightningrob", "createdAt": "2020-11-06T20:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4ODA4NQ=="}], "type": "inlineReview"}, {"oid": "fab8dbf4f804095907b693839ea86e57b6734dc4", "url": "https://github.com/linkedin/ambry/commit/fab8dbf4f804095907b693839ea86e57b6734dc4", "message": "Address Casey review comment (fix Optional usage)", "committedDate": "2020-11-06T20:31:53Z", "type": "commit"}]}