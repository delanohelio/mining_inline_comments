{"pr_number": 1722, "pr_title": "MySql transaction changes for doing account updates atomically.", "pr_createdAt": "2020-12-09T05:40:18Z", "pr_url": "https://github.com/linkedin/ambry/pull/1722", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MDIwMA==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539760200", "bodyText": "Should we set it explicitly in case it got left in an incorrect state?", "author": "lightningrob", "createdAt": "2020-12-10T00:51:31Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MTA2OQ==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539761069", "bodyText": "Make private", "author": "lightningrob", "createdAt": "2020-12-10T00:53:48Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, container.toJson().toString());\n+      insertStatement.setInt(3, container.getSnapshotVersion());\n+      insertStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Add containers from a given account to the database in batches.\n+   * @param accountId the containers' parent account id.\n+   * @param containers the containers to insert.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void addContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        insertStatement.setInt(1, accountId);\n+        insertStatement.setString(2, container.toJson().toString());\n+        insertStatement.setInt(3, container.getSnapshotVersion());\n+        insertStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          insertStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        insertStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates container from a given account in the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to update.\n+   * @throws SQLException\n+   */\n+  public void updateContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      updateStatement.setString(1, container.toJson().toString());\n+      updateStatement.setInt(2, container.getSnapshotVersion());\n+      updateStatement.setInt(3, accountId);\n+      updateStatement.setInt(4, container.getId());\n+      updateStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates containers from a given account in the database in batches.\n+   * @param accountId the container's parent account id.\n+   * @param containers the container to update.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        updateStatement.setString(1, container.toJson().toString());\n+        updateStatement.setInt(2, container.getSnapshotVersion());\n+        updateStatement.setInt(3, accountId);\n+        updateStatement.setInt(4, container.getId());\n+        updateStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          updateStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        updateStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the parent account.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getContainersByAccountSql, false);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getContainersSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertContainersResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Container container = new ContainerBuilder(\n+          Container.fromJson(new JSONObject(containerJson), (short) accountId)).setLastModifiedTime(\n+          lastModifiedTime.getTime()).setSnapshotVersion(version).build();\n+      containers.add(container);\n+    }\n+    return containers;\n+  }\n+\n+  /**\n+   * Adds/Updates accounts and their containers to the database in batches atomically using transaction.\n+   * @param accountsInfo information of updated Accounts\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateAccountsAndContainers(List<AccountUtils.AccountUpdateInfo> accountsInfo, int batchSize)\n+      throws SQLException {\n+    Connection conn = dataAccessor.getDatabaseConnection(true);\n+    try {\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertAccountStatement = dataAccessor.getPreparedStatement(insertAccountsSql, true);\n+      PreparedStatement updateAccountStatement = dataAccessor.getPreparedStatement(updateAccountsSql, true);\n+      PreparedStatement insertContainerStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      PreparedStatement updateContainerStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+\n+      conn.setAutoCommit(false);\n+      int batchCount = 0, insertAccountCount = 0, updateAccountCount = 0, insertContainerCount = 0,\n+          updateContainerCount = 0;\n+      for (int i = 0; i < accountsInfo.size(); i++) {\n+        Account account = accountsInfo.get(i).getAccount();\n+        boolean isAccountModified = accountsInfo.get(i).isModified();\n+        List<Container> addedContainers = accountsInfo.get(i).getAddedContainers();\n+        List<Container> updatedContainers = accountsInfo.get(i).getModifiedContainers();\n+\n+        if (isAccountModified) {\n+          if (account.getSnapshotVersion() == 0) {\n+            insertAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            insertAccountStatement.setInt(2, account.getSnapshotVersion());\n+            insertAccountStatement.addBatch();\n+            ++insertAccountCount;\n+          } else {\n+            updateAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            updateAccountStatement.setInt(2, account.getSnapshotVersion());\n+            updateAccountStatement.setInt(3, account.getId());\n+            updateAccountStatement.addBatch();\n+            ++updateAccountCount;\n+          }\n+          ++batchCount;\n+        }\n+\n+        for (Container container : addedContainers) {\n+          insertContainerStatement.setInt(1, account.getId());\n+          insertContainerStatement.setString(2, container.toJson().toString());\n+          insertContainerStatement.setInt(3, container.getSnapshotVersion());\n+          insertContainerStatement.addBatch();\n+          ++insertContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }\n+        }\n+\n+        for (Container container : updatedContainers) {\n+          updateContainerStatement.setString(1, container.toJson().toString());\n+          updateContainerStatement.setInt(2, container.getSnapshotVersion());\n+          updateContainerStatement.setInt(3, account.getId());\n+          updateContainerStatement.setInt(4, container.getId());\n+          updateContainerStatement.addBatch();\n+          ++updateContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }\n+        }\n+\n+        // Commit transaction if one of the following is true. Else, we continue to add more #accounts/containers in current batch.\n+        // a) If this is the last account in the list.\n+        // b) If subsequent account (and its containers) cannot fit in remaining slots of current batch.\n+        if (batchCount > 0 && (i == accountsInfo.size() - 1 ||\n+            accountsInfo.get(i + 1).getAddedContainers().size() + accountsInfo.get(i + 1).getModifiedContainers().size()\n+                + 1 > (batchSize - batchCount))) {\n+          executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+              updateAccountCount > 0 ? updateAccountStatement : null,\n+              insertContainerCount > 0 ? insertContainerStatement : null,\n+              updateContainerCount > 0 ? updateContainerStatement : null);\n+          conn.commit();\n+          batchCount = 0;\n+          insertAccountCount = 0;\n+          updateAccountCount = 0;\n+          insertContainerCount = 0;\n+          updateContainerCount = 0;\n+        }\n+      }\n+\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      //rollback\n+      conn.rollback();\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+\n+    // reset auto commit to true\n+    conn.setAutoCommit(true);\n+  }\n+\n+  /**\n+   * Executes batch inserts and updates for input {@link PreparedStatement}s.\n+   * @param insertAccountStatement {@link PreparedStatement} for inserting {@link Account}s\n+   * @param updateAccountStatement {@link PreparedStatement} for updating {@link Account}s\n+   * @param insertContainerStatement {@link PreparedStatement} for inserting {@link Container}s\n+   * @param updateContainerStatement {@link PreparedStatement} for updating {@link Container}s\n+   * @throws SQLException\n+   */\n+  public void executeBatchUpdates(PreparedStatement insertAccountStatement, PreparedStatement updateAccountStatement,", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NzY2MA==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539767660", "bodyText": "Also, since the method doesn't distinguish between the statements, it could take a variable array like:\nprivate void executeBatchUpdates(PreparedStatement ... statement)", "author": "lightningrob", "createdAt": "2020-12-10T01:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MTE1MQ==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539761151", "bodyText": "missing newline", "author": "lightningrob", "createdAt": "2020-12-10T00:54:02Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, container.toJson().toString());\n+      insertStatement.setInt(3, container.getSnapshotVersion());\n+      insertStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Add containers from a given account to the database in batches.\n+   * @param accountId the containers' parent account id.\n+   * @param containers the containers to insert.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void addContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        insertStatement.setInt(1, accountId);\n+        insertStatement.setString(2, container.toJson().toString());\n+        insertStatement.setInt(3, container.getSnapshotVersion());\n+        insertStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          insertStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        insertStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates container from a given account in the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to update.\n+   * @throws SQLException\n+   */\n+  public void updateContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      updateStatement.setString(1, container.toJson().toString());\n+      updateStatement.setInt(2, container.getSnapshotVersion());\n+      updateStatement.setInt(3, accountId);\n+      updateStatement.setInt(4, container.getId());\n+      updateStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates containers from a given account in the database in batches.\n+   * @param accountId the container's parent account id.\n+   * @param containers the container to update.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        updateStatement.setString(1, container.toJson().toString());\n+        updateStatement.setInt(2, container.getSnapshotVersion());\n+        updateStatement.setInt(3, accountId);\n+        updateStatement.setInt(4, container.getId());\n+        updateStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          updateStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        updateStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the parent account.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getContainersByAccountSql, false);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getContainersSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertContainersResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Container container = new ContainerBuilder(\n+          Container.fromJson(new JSONObject(containerJson), (short) accountId)).setLastModifiedTime(\n+          lastModifiedTime.getTime()).setSnapshotVersion(version).build();\n+      containers.add(container);\n+    }\n+    return containers;\n+  }\n+\n+  /**\n+   * Adds/Updates accounts and their containers to the database in batches atomically using transaction.\n+   * @param accountsInfo information of updated Accounts\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateAccountsAndContainers(List<AccountUtils.AccountUpdateInfo> accountsInfo, int batchSize)\n+      throws SQLException {\n+    Connection conn = dataAccessor.getDatabaseConnection(true);\n+    try {\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertAccountStatement = dataAccessor.getPreparedStatement(insertAccountsSql, true);\n+      PreparedStatement updateAccountStatement = dataAccessor.getPreparedStatement(updateAccountsSql, true);\n+      PreparedStatement insertContainerStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      PreparedStatement updateContainerStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+\n+      conn.setAutoCommit(false);\n+      int batchCount = 0, insertAccountCount = 0, updateAccountCount = 0, insertContainerCount = 0,\n+          updateContainerCount = 0;\n+      for (int i = 0; i < accountsInfo.size(); i++) {\n+        Account account = accountsInfo.get(i).getAccount();\n+        boolean isAccountModified = accountsInfo.get(i).isModified();\n+        List<Container> addedContainers = accountsInfo.get(i).getAddedContainers();\n+        List<Container> updatedContainers = accountsInfo.get(i).getModifiedContainers();\n+\n+        if (isAccountModified) {\n+          if (account.getSnapshotVersion() == 0) {\n+            insertAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            insertAccountStatement.setInt(2, account.getSnapshotVersion());\n+            insertAccountStatement.addBatch();\n+            ++insertAccountCount;\n+          } else {\n+            updateAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            updateAccountStatement.setInt(2, account.getSnapshotVersion());\n+            updateAccountStatement.setInt(3, account.getId());\n+            updateAccountStatement.addBatch();\n+            ++updateAccountCount;\n+          }\n+          ++batchCount;\n+        }\n+\n+        for (Container container : addedContainers) {\n+          insertContainerStatement.setInt(1, account.getId());\n+          insertContainerStatement.setString(2, container.toJson().toString());\n+          insertContainerStatement.setInt(3, container.getSnapshotVersion());\n+          insertContainerStatement.addBatch();\n+          ++insertContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }\n+        }\n+\n+        for (Container container : updatedContainers) {\n+          updateContainerStatement.setString(1, container.toJson().toString());\n+          updateContainerStatement.setInt(2, container.getSnapshotVersion());\n+          updateContainerStatement.setInt(3, account.getId());\n+          updateContainerStatement.setInt(4, container.getId());\n+          updateContainerStatement.addBatch();\n+          ++updateContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }\n+        }\n+\n+        // Commit transaction if one of the following is true. Else, we continue to add more #accounts/containers in current batch.\n+        // a) If this is the last account in the list.\n+        // b) If subsequent account (and its containers) cannot fit in remaining slots of current batch.\n+        if (batchCount > 0 && (i == accountsInfo.size() - 1 ||\n+            accountsInfo.get(i + 1).getAddedContainers().size() + accountsInfo.get(i + 1).getModifiedContainers().size()\n+                + 1 > (batchSize - batchCount))) {\n+          executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+              updateAccountCount > 0 ? updateAccountStatement : null,\n+              insertContainerCount > 0 ? insertContainerStatement : null,\n+              updateContainerCount > 0 ? updateContainerStatement : null);\n+          conn.commit();\n+          batchCount = 0;\n+          insertAccountCount = 0;\n+          updateAccountCount = 0;\n+          insertContainerCount = 0;\n+          updateContainerCount = 0;\n+        }\n+      }\n+\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      //rollback\n+      conn.rollback();\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+\n+    // reset auto commit to true\n+    conn.setAutoCommit(true);\n+  }\n+\n+  /**\n+   * Executes batch inserts and updates for input {@link PreparedStatement}s.\n+   * @param insertAccountStatement {@link PreparedStatement} for inserting {@link Account}s\n+   * @param updateAccountStatement {@link PreparedStatement} for updating {@link Account}s\n+   * @param insertContainerStatement {@link PreparedStatement} for inserting {@link Container}s\n+   * @param updateContainerStatement {@link PreparedStatement} for updating {@link Container}s\n+   * @throws SQLException\n+   */\n+  public void executeBatchUpdates(PreparedStatement insertAccountStatement, PreparedStatement updateAccountStatement,\n+      PreparedStatement insertContainerStatement, PreparedStatement updateContainerStatement) throws SQLException {\n+    if (insertAccountStatement != null) {\n+      insertAccountStatement.executeBatch();\n+    }\n+    if (updateAccountStatement != null) {\n+      updateAccountStatement.executeBatch();\n+    }\n+    if (insertContainerStatement != null) {\n+      insertContainerStatement.executeBatch();\n+    }\n+    if (updateContainerStatement != null) {\n+      updateContainerStatement.executeBatch();\n+    }\n+  }\n+}", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MzgwNQ==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539763805", "bodyText": "Why are we doing an insert if isAccountModified is true?  Maybe I don't understand what that variable means.", "author": "lightningrob", "createdAt": "2020-12-10T01:01:02Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, container.toJson().toString());\n+      insertStatement.setInt(3, container.getSnapshotVersion());\n+      insertStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Add containers from a given account to the database in batches.\n+   * @param accountId the containers' parent account id.\n+   * @param containers the containers to insert.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void addContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        insertStatement.setInt(1, accountId);\n+        insertStatement.setString(2, container.toJson().toString());\n+        insertStatement.setInt(3, container.getSnapshotVersion());\n+        insertStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          insertStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        insertStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates container from a given account in the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to update.\n+   * @throws SQLException\n+   */\n+  public void updateContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      updateStatement.setString(1, container.toJson().toString());\n+      updateStatement.setInt(2, container.getSnapshotVersion());\n+      updateStatement.setInt(3, accountId);\n+      updateStatement.setInt(4, container.getId());\n+      updateStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates containers from a given account in the database in batches.\n+   * @param accountId the container's parent account id.\n+   * @param containers the container to update.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        updateStatement.setString(1, container.toJson().toString());\n+        updateStatement.setInt(2, container.getSnapshotVersion());\n+        updateStatement.setInt(3, accountId);\n+        updateStatement.setInt(4, container.getId());\n+        updateStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          updateStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        updateStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the parent account.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getContainersByAccountSql, false);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getContainersSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertContainersResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Container container = new ContainerBuilder(\n+          Container.fromJson(new JSONObject(containerJson), (short) accountId)).setLastModifiedTime(\n+          lastModifiedTime.getTime()).setSnapshotVersion(version).build();\n+      containers.add(container);\n+    }\n+    return containers;\n+  }\n+\n+  /**\n+   * Adds/Updates accounts and their containers to the database in batches atomically using transaction.\n+   * @param accountsInfo information of updated Accounts\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateAccountsAndContainers(List<AccountUtils.AccountUpdateInfo> accountsInfo, int batchSize)\n+      throws SQLException {\n+    Connection conn = dataAccessor.getDatabaseConnection(true);\n+    try {\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertAccountStatement = dataAccessor.getPreparedStatement(insertAccountsSql, true);\n+      PreparedStatement updateAccountStatement = dataAccessor.getPreparedStatement(updateAccountsSql, true);\n+      PreparedStatement insertContainerStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      PreparedStatement updateContainerStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+\n+      conn.setAutoCommit(false);\n+      int batchCount = 0, insertAccountCount = 0, updateAccountCount = 0, insertContainerCount = 0,\n+          updateContainerCount = 0;\n+      for (int i = 0; i < accountsInfo.size(); i++) {\n+        Account account = accountsInfo.get(i).getAccount();\n+        boolean isAccountModified = accountsInfo.get(i).isModified();\n+        List<Container> addedContainers = accountsInfo.get(i).getAddedContainers();\n+        List<Container> updatedContainers = accountsInfo.get(i).getModifiedContainers();\n+\n+        if (isAccountModified) {\n+          if (account.getSnapshotVersion() == 0) {\n+            insertAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NTg1MA==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539765850", "bodyText": "Needs to be in finally block.", "author": "lightningrob", "createdAt": "2020-12-10T01:06:50Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, container.toJson().toString());\n+      insertStatement.setInt(3, container.getSnapshotVersion());\n+      insertStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Add containers from a given account to the database in batches.\n+   * @param accountId the containers' parent account id.\n+   * @param containers the containers to insert.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void addContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        insertStatement.setInt(1, accountId);\n+        insertStatement.setString(2, container.toJson().toString());\n+        insertStatement.setInt(3, container.getSnapshotVersion());\n+        insertStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          insertStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        insertStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates container from a given account in the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to update.\n+   * @throws SQLException\n+   */\n+  public void updateContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      updateStatement.setString(1, container.toJson().toString());\n+      updateStatement.setInt(2, container.getSnapshotVersion());\n+      updateStatement.setInt(3, accountId);\n+      updateStatement.setInt(4, container.getId());\n+      updateStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates containers from a given account in the database in batches.\n+   * @param accountId the container's parent account id.\n+   * @param containers the container to update.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        updateStatement.setString(1, container.toJson().toString());\n+        updateStatement.setInt(2, container.getSnapshotVersion());\n+        updateStatement.setInt(3, accountId);\n+        updateStatement.setInt(4, container.getId());\n+        updateStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          updateStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        updateStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the parent account.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getContainersByAccountSql, false);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getContainersSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertContainersResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Container container = new ContainerBuilder(\n+          Container.fromJson(new JSONObject(containerJson), (short) accountId)).setLastModifiedTime(\n+          lastModifiedTime.getTime()).setSnapshotVersion(version).build();\n+      containers.add(container);\n+    }\n+    return containers;\n+  }\n+\n+  /**\n+   * Adds/Updates accounts and their containers to the database in batches atomically using transaction.\n+   * @param accountsInfo information of updated Accounts\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateAccountsAndContainers(List<AccountUtils.AccountUpdateInfo> accountsInfo, int batchSize)\n+      throws SQLException {\n+    Connection conn = dataAccessor.getDatabaseConnection(true);\n+    try {\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertAccountStatement = dataAccessor.getPreparedStatement(insertAccountsSql, true);\n+      PreparedStatement updateAccountStatement = dataAccessor.getPreparedStatement(updateAccountsSql, true);\n+      PreparedStatement insertContainerStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      PreparedStatement updateContainerStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+\n+      conn.setAutoCommit(false);\n+      int batchCount = 0, insertAccountCount = 0, updateAccountCount = 0, insertContainerCount = 0,\n+          updateContainerCount = 0;\n+      for (int i = 0; i < accountsInfo.size(); i++) {\n+        Account account = accountsInfo.get(i).getAccount();\n+        boolean isAccountModified = accountsInfo.get(i).isModified();\n+        List<Container> addedContainers = accountsInfo.get(i).getAddedContainers();\n+        List<Container> updatedContainers = accountsInfo.get(i).getModifiedContainers();\n+\n+        if (isAccountModified) {\n+          if (account.getSnapshotVersion() == 0) {\n+            insertAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            insertAccountStatement.setInt(2, account.getSnapshotVersion());\n+            insertAccountStatement.addBatch();\n+            ++insertAccountCount;\n+          } else {\n+            updateAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            updateAccountStatement.setInt(2, account.getSnapshotVersion());\n+            updateAccountStatement.setInt(3, account.getId());\n+            updateAccountStatement.addBatch();\n+            ++updateAccountCount;\n+          }\n+          ++batchCount;\n+        }\n+\n+        for (Container container : addedContainers) {\n+          insertContainerStatement.setInt(1, account.getId());\n+          insertContainerStatement.setString(2, container.toJson().toString());\n+          insertContainerStatement.setInt(3, container.getSnapshotVersion());\n+          insertContainerStatement.addBatch();\n+          ++insertContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }\n+        }\n+\n+        for (Container container : updatedContainers) {\n+          updateContainerStatement.setString(1, container.toJson().toString());\n+          updateContainerStatement.setInt(2, container.getSnapshotVersion());\n+          updateContainerStatement.setInt(3, account.getId());\n+          updateContainerStatement.setInt(4, container.getId());\n+          updateContainerStatement.addBatch();\n+          ++updateContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }\n+        }\n+\n+        // Commit transaction if one of the following is true. Else, we continue to add more #accounts/containers in current batch.\n+        // a) If this is the last account in the list.\n+        // b) If subsequent account (and its containers) cannot fit in remaining slots of current batch.\n+        if (batchCount > 0 && (i == accountsInfo.size() - 1 ||\n+            accountsInfo.get(i + 1).getAddedContainers().size() + accountsInfo.get(i + 1).getModifiedContainers().size()\n+                + 1 > (batchSize - batchCount))) {\n+          executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+              updateAccountCount > 0 ? updateAccountStatement : null,\n+              insertContainerCount > 0 ? insertContainerStatement : null,\n+              updateContainerCount > 0 ? updateContainerStatement : null);\n+          conn.commit();\n+          batchCount = 0;\n+          insertAccountCount = 0;\n+          updateAccountCount = 0;\n+          insertContainerCount = 0;\n+          updateContainerCount = 0;\n+        }\n+      }\n+\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      //rollback\n+      conn.rollback();\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+\n+    // reset auto commit to true\n+    conn.setAutoCommit(true);", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3MDYxOA==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539770618", "bodyText": "This logic is repeated a few times.  How about if we create an inner class like AccountUpdateBatch encapsulating the statements and counters.  And it can have a method like maybeExecuteBatch() with this block of code.", "author": "lightningrob", "createdAt": "2020-12-10T01:19:58Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, container.toJson().toString());\n+      insertStatement.setInt(3, container.getSnapshotVersion());\n+      insertStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Add containers from a given account to the database in batches.\n+   * @param accountId the containers' parent account id.\n+   * @param containers the containers to insert.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void addContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        insertStatement.setInt(1, accountId);\n+        insertStatement.setString(2, container.toJson().toString());\n+        insertStatement.setInt(3, container.getSnapshotVersion());\n+        insertStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          insertStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        insertStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates container from a given account in the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to update.\n+   * @throws SQLException\n+   */\n+  public void updateContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      updateStatement.setString(1, container.toJson().toString());\n+      updateStatement.setInt(2, container.getSnapshotVersion());\n+      updateStatement.setInt(3, accountId);\n+      updateStatement.setInt(4, container.getId());\n+      updateStatement.executeUpdate();\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Updates containers from a given account in the database in batches.\n+   * @param accountId the container's parent account id.\n+   * @param containers the container to update.\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateContainers(int accountId, Collection<Container> containers, int batchSize) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+      int count = 0;\n+      for (Container container : containers) {\n+        updateStatement.setString(1, container.toJson().toString());\n+        updateStatement.setInt(2, container.getSnapshotVersion());\n+        updateStatement.setInt(3, accountId);\n+        updateStatement.setInt(4, container.getId());\n+        updateStatement.addBatch();\n+        if (++count % batchSize == 0) {\n+          updateStatement.executeBatch();\n+        }\n+      }\n+      if (containers.size() % batchSize != 0) {\n+        updateStatement.executeBatch();\n+      }\n+      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Write);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the parent account.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getContainersByAccountSql, false);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getContainersSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n+    } catch (SQLException e) {\n+      dataAccessor.onException(e, Read);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertContainersResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Container container = new ContainerBuilder(\n+          Container.fromJson(new JSONObject(containerJson), (short) accountId)).setLastModifiedTime(\n+          lastModifiedTime.getTime()).setSnapshotVersion(version).build();\n+      containers.add(container);\n+    }\n+    return containers;\n+  }\n+\n+  /**\n+   * Adds/Updates accounts and their containers to the database in batches atomically using transaction.\n+   * @param accountsInfo information of updated Accounts\n+   * @param batchSize number of statements to be executed in one batch\n+   * @throws SQLException\n+   */\n+  public void updateAccountsAndContainers(List<AccountUtils.AccountUpdateInfo> accountsInfo, int batchSize)\n+      throws SQLException {\n+    Connection conn = dataAccessor.getDatabaseConnection(true);\n+    try {\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertAccountStatement = dataAccessor.getPreparedStatement(insertAccountsSql, true);\n+      PreparedStatement updateAccountStatement = dataAccessor.getPreparedStatement(updateAccountsSql, true);\n+      PreparedStatement insertContainerStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      PreparedStatement updateContainerStatement = dataAccessor.getPreparedStatement(updateContainersSql, true);\n+\n+      conn.setAutoCommit(false);\n+      int batchCount = 0, insertAccountCount = 0, updateAccountCount = 0, insertContainerCount = 0,\n+          updateContainerCount = 0;\n+      for (int i = 0; i < accountsInfo.size(); i++) {\n+        Account account = accountsInfo.get(i).getAccount();\n+        boolean isAccountModified = accountsInfo.get(i).isModified();\n+        List<Container> addedContainers = accountsInfo.get(i).getAddedContainers();\n+        List<Container> updatedContainers = accountsInfo.get(i).getModifiedContainers();\n+\n+        if (isAccountModified) {\n+          if (account.getSnapshotVersion() == 0) {\n+            insertAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            insertAccountStatement.setInt(2, account.getSnapshotVersion());\n+            insertAccountStatement.addBatch();\n+            ++insertAccountCount;\n+          } else {\n+            updateAccountStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n+            updateAccountStatement.setInt(2, account.getSnapshotVersion());\n+            updateAccountStatement.setInt(3, account.getId());\n+            updateAccountStatement.addBatch();\n+            ++updateAccountCount;\n+          }\n+          ++batchCount;\n+        }\n+\n+        for (Container container : addedContainers) {\n+          insertContainerStatement.setInt(1, account.getId());\n+          insertContainerStatement.setString(2, container.toJson().toString());\n+          insertContainerStatement.setInt(3, container.getSnapshotVersion());\n+          insertContainerStatement.addBatch();\n+          ++insertContainerCount;\n+          if (++batchCount >= batchSize) {\n+            executeBatchUpdates(insertAccountCount > 0 ? insertAccountStatement : null,\n+                updateAccountCount > 0 ? updateAccountStatement : null,\n+                insertContainerCount > 0 ? insertContainerStatement : null,\n+                updateContainerCount > 0 ? updateContainerStatement : null);\n+            conn.commit();\n+            batchCount = 0;\n+            insertAccountCount = 0;\n+            updateAccountCount = 0;\n+            insertContainerCount = 0;\n+            updateContainerCount = 0;\n+          }", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3NDczMg==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r539774732", "bodyText": "Let's also refactor these prepared statement-filling code blocks into reusable internal methods, like:\naddContainer(PreparedStatement statement, int accountId, Container container);\nupdateContainer(PreparedStatement statement, int accountId, Container container);\naddAccount(PreparedStatement statement, Account account);\nupdateAccount(PreparedStatement statement, Account account);", "author": "lightningrob", "createdAt": "2020-12-10T01:30:53Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -197,4 +225,313 @@ public void updateAccounts(Collection<Account> accounts, int batchSize) throws S\n     }\n     return accounts;\n   }\n-}\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      long startTimeMs = System.currentTimeMillis();\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertContainersSql, true);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, container.toJson().toString());\n+      insertStatement.setInt(3, container.getSnapshotVersion());", "originalCommit": "54c2f7981e93aec2e042a247e009644758278197", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f50bbe2259d2c58973338797b45aa563dfd13e9", "url": "https://github.com/linkedin/ambry/commit/9f50bbe2259d2c58973338797b45aa563dfd13e9", "message": "1. MySql transaction changes for doing account updates atomically.\n2. Address Rob's comments and refactor AccountDao class", "committedDate": "2020-12-14T02:44:43Z", "type": "commit"}, {"oid": "9f50bbe2259d2c58973338797b45aa563dfd13e9", "url": "https://github.com/linkedin/ambry/commit/9f50bbe2259d2c58973338797b45aa563dfd13e9", "message": "1. MySql transaction changes for doing account updates atomically.\n2. Address Rob's comments and refactor AccountDao class", "committedDate": "2020-12-14T02:44:43Z", "type": "forcePushed"}, {"oid": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "url": "https://github.com/linkedin/ambry/commit/6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "message": "Synchronize access to AccountDao.updateAccounts()", "committedDate": "2020-12-14T03:04:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAyOTU4Mw==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543029583", "bodyText": "Minor: I feel like line 136, 148 and 160 can be logger.warn", "author": "jsjtzyy", "createdAt": "2020-12-15T04:04:32Z", "path": "ambry-commons/src/main/java/com/github/ambry/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -123,6 +124,43 @@ private void initializeDriver(String url) throws SQLException {\n     }\n   }\n \n+  /**\n+   * Enables or disables auto commit on current active {@link Connection}.\n+   * @param enable {@code true} to enable auto commit and {@code false} to disable auto commit.\n+   * @throws SQLException\n+   */\n+  public synchronized void setAutoCommit(boolean enable) throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {\n+      activeConnection.setAutoCommit(enable);\n+    } else {\n+      logger.debug(\"Connection to MySql DB is not available\");\n+    }\n+  }\n+\n+  /**\n+   * Commits transaction changes on current active {@link Connection}. This should only be used with auto commit disabled.\n+   * @throws SQLException\n+   */\n+  public synchronized void commit() throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {\n+      activeConnection.commit();\n+    } else {\n+      logger.debug(\"Connection to MySql DB is not available\");\n+    }\n+  }\n+\n+  /**\n+   * Rollback transaction changes on current active {@link Connection}. This should only be used with auto commit disabled.\n+   * @throws SQLException\n+   */\n+  public synchronized void rollback() throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {\n+      activeConnection.rollback();\n+    } else {\n+      logger.debug(\"Connection to MySql DB is not available\");", "originalCommit": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNDIzMQ==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543124231", "bodyText": "We also should not call isValid() all the time.  There was a time limit in place to prevent that.  If the connection isn't valid, the connection methods will throw an exception and that should result in cleanup.", "author": "lightningrob", "createdAt": "2020-12-15T08:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAyOTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNzA1Nw==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543037057", "bodyText": "minor: change containerDao to accountDao", "author": "jsjtzyy", "createdAt": "2020-12-15T04:27:42Z", "path": "ambry-tools/src/main/java/com/github/ambry/account/DatabaseTest.java", "diffHunk": "@@ -58,7 +59,7 @@ private static void perfTest(VerifiableProperties verifiableProperties) throws E\n     MySqlDataAccessor dataAccessor =\n         new MySqlAccountStoreFactory(verifiableProperties, new MetricRegistry()).getMySqlAccountStore()\n             .getMySqlDataAccessor();\n-    ContainerDao containerDao = new ContainerDao(dataAccessor);\n+    AccountDao containerDao = new AccountDao(dataAccessor);", "originalCommit": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNDkyMA==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543124920", "bodyText": "Maybe check if batch update exception has nested SQLTransientConnectionException?", "author": "lightningrob", "createdAt": "2020-12-15T08:01:22Z", "path": "ambry-commons/src/main/java/com/github/ambry/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -245,7 +283,7 @@ public static boolean isCredentialError(SQLException e) {\n    * @param operationType type of mysql operation\n    */\n   public void onException(SQLException e, OperationType operationType) {\n-    if (e instanceof SQLTransientConnectionException) {\n+    if (e instanceof SQLTransientConnectionException || e instanceof BatchUpdateException) {", "originalCommit": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNjk0Nw==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543126947", "bodyText": "Please import static AccountUtils.AccountUpdateInfo", "author": "lightningrob", "createdAt": "2020-12-15T08:04:55Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -34,167 +36,380 @@\n  */\n public class AccountDao {\n \n+  private final MySqlDataAccessor dataAccessor;\n+\n+  // Account table fields\n   public static final String ACCOUNT_TABLE = \"Accounts\";\n   public static final String ACCOUNT_INFO = \"accountInfo\";\n+  public static final String ACCOUNT_ID = \"accountId\";\n+\n+  // Container table fields\n+  public static final String CONTAINER_TABLE = \"Containers\";\n+  public static final String CONTAINER_ID = \"containerId\";\n+  public static final String CONTAINER_INFO = \"containerInfo\";\n+\n+  // Common fields\n   public static final String VERSION = \"version\";\n   public static final String CREATION_TIME = \"creationTime\";\n   public static final String LAST_MODIFIED_TIME = \"lastModifiedTime\";\n-  public static final String ACCOUNT_ID = \"accountId\";\n \n-  private final MySqlDataAccessor dataAccessor;\n-  private final String insertSql;\n-  private final String getSinceSql;\n-  private final String updateSql;\n+  // Account table query strings\n+  private final String insertAccountsSql;\n+  private final String getAccountsSinceSql;\n+  private final String updateAccountsSql;\n+\n+  // Container table query strings\n+  private final String insertContainersSql;\n+  private final String getContainersSinceSql;\n+  private final String getContainersByAccountSql;\n+  private final String updateContainersSql;\n+\n+  /**\n+   * Types of MySql statements.\n+   */\n+  public enum StatementType {\n+    Select, Insert, Update, Delete\n+  }\n \n   public AccountDao(MySqlDataAccessor dataAccessor) {\n     this.dataAccessor = dataAccessor;\n-    insertSql =\n+    insertAccountsSql =\n         String.format(\"insert into %s (%s, %s, %s, %s) values (?, ?, now(3), now(3))\", ACCOUNT_TABLE, ACCOUNT_INFO,\n             VERSION, CREATION_TIME, LAST_MODIFIED_TIME);\n-    getSinceSql = String.format(\"select %s, %s, %s from %s where %s > ?\", ACCOUNT_INFO, VERSION, LAST_MODIFIED_TIME,\n-        ACCOUNT_TABLE, LAST_MODIFIED_TIME);\n-    updateSql =\n+    getAccountsSinceSql =\n+        String.format(\"select %s, %s, %s from %s where %s > ?\", ACCOUNT_INFO, VERSION, LAST_MODIFIED_TIME,\n+            ACCOUNT_TABLE, LAST_MODIFIED_TIME);\n+    updateAccountsSql =\n         String.format(\"update %s set %s = ?, %s = ?, %s = now(3) where %s = ? \", ACCOUNT_TABLE, ACCOUNT_INFO, VERSION,\n             LAST_MODIFIED_TIME, ACCOUNT_ID);\n+    insertContainersSql =\n+        String.format(\"insert into %s (%s, %s, %s, %s, %s) values (?, ?, ?, now(3), now(3))\", CONTAINER_TABLE,\n+            ACCOUNT_ID, CONTAINER_INFO, VERSION, CREATION_TIME, LAST_MODIFIED_TIME);\n+    getContainersSinceSql =\n+        String.format(\"select %s, %s, %s, %s from %s where %s > ?\", ACCOUNT_ID, CONTAINER_INFO, VERSION,\n+            LAST_MODIFIED_TIME, CONTAINER_TABLE, LAST_MODIFIED_TIME);\n+    getContainersByAccountSql =\n+        String.format(\"select %s, %s, %s, %s from %s where %s = ?\", ACCOUNT_ID, CONTAINER_INFO, VERSION,\n+            LAST_MODIFIED_TIME, CONTAINER_TABLE, ACCOUNT_ID);\n+    updateContainersSql =\n+        String.format(\"update %s set %s = ?, %s = ?, %s = now(3) where %s = ? AND %s = ? \", CONTAINER_TABLE,\n+            CONTAINER_INFO, VERSION, LAST_MODIFIED_TIME, ACCOUNT_ID, CONTAINER_ID);\n   }\n \n   /**\n-   * Add an account to the database.\n-   * @param account the account to insert.\n+   * Gets all accounts that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Account}s.\n    * @throws SQLException\n    */\n-  public void addAccount(Account account) throws SQLException {\n-    try {\n-      long startTimeMs = System.currentTimeMillis();\n-      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertSql, true);\n-      insertStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n-      insertStatement.setInt(2, account.getSnapshotVersion());\n-      insertStatement.executeUpdate();\n-      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+  public List<Account> getNewAccounts(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getAccountsSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Account> accounts = convertAccountsResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return accounts;\n     } catch (SQLException e) {\n-      dataAccessor.onException(e, Write);\n+      dataAccessor.onException(e, Read);\n       throw e;\n     }\n   }\n \n   /**\n-   * Add accounts to the database in batches.\n-   * @param accounts the account to insert.\n-   * @param batchSize number of statements to be executed in one batch\n+   * Convert a query result set to a list of accounts.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Account}s.\n    * @throws SQLException\n    */\n-  public void addAccounts(Collection<Account> accounts, int batchSize) throws SQLException {\n-    try {\n-      long startTimeMs = System.currentTimeMillis();\n-      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertSql, true);\n-      int count = 0;\n-      for (Account account : accounts) {\n-        insertStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n-        insertStatement.setInt(2, account.getSnapshotVersion());\n-        insertStatement.addBatch();\n-        if (++count % batchSize == 0) {\n-          insertStatement.executeBatch();\n-        }\n-      }\n-      if (accounts.size() % batchSize != 0) {\n-        insertStatement.executeBatch();\n-      }\n-      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+  private List<Account> convertAccountsResultSet(ResultSet resultSet) throws SQLException {\n+    List<Account> accounts = new ArrayList<>();\n+    while (resultSet.next()) {\n+      String accountJson = resultSet.getString(ACCOUNT_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Account account =\n+          new AccountBuilder(Account.fromJson(new JSONObject(accountJson))).lastModifiedTime(lastModifiedTime.getTime())\n+              .snapshotVersion(version)\n+              .build();\n+      accounts.add(account);\n+    }\n+    return accounts;\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the parent account.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getContainersByAccountSql, false);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n     } catch (SQLException e) {\n-      dataAccessor.onException(e, Write);\n+      dataAccessor.onException(e, Read);\n       throw e;\n     }\n   }\n \n   /**\n-   * Updates an existing account in the database.\n-   * @param account the account to update.\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}s.\n    * @throws SQLException\n    */\n-  public void updateAccount(Account account) throws SQLException {\n-    try {\n-      long startTimeMs = System.currentTimeMillis();\n-      PreparedStatement updateStatement = dataAccessor.getPreparedStatement(updateSql, true);\n-      updateStatement.setString(1, AccountCollectionSerde.accountToJsonNoContainers(account).toString());\n-      updateStatement.setInt(2, account.getSnapshotVersion());\n-      updateStatement.setInt(3, account.getId());\n-      updateStatement.executeUpdate();\n-      dataAccessor.onSuccess(Write, System.currentTimeMillis() - startTimeMs);\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    long startTimeMs = System.currentTimeMillis();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getContainersSinceSql, false);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      List<Container> containers = convertContainersResultSet(rs);\n+      dataAccessor.onSuccess(Read, System.currentTimeMillis() - startTimeMs);\n+      return containers;\n     } catch (SQLException e) {\n-      dataAccessor.onException(e, Write);\n+      dataAccessor.onException(e, Read);\n       throw e;\n     }\n   }\n \n   /**\n-   * Updates a collection of accounts in the database.\n-   * @param accounts the account to update.\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of {@link Container}s.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertContainersResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      int version = resultSet.getInt(VERSION);\n+      Container container = new ContainerBuilder(\n+          Container.fromJson(new JSONObject(containerJson), (short) accountId)).setLastModifiedTime(\n+          lastModifiedTime.getTime()).setSnapshotVersion(version).build();\n+      containers.add(container);\n+    }\n+    return containers;\n+  }\n+\n+  /**\n+   * Adds/Updates accounts and their containers to the database in batches atomically using transaction.\n+   * @param accountsInfo information of updated Accounts\n    * @param batchSize number of statements to be executed in one batch\n    * @throws SQLException\n    */\n-  public void updateAccounts(Collection<Account> accounts, int batchSize) throws SQLException {\n+  public synchronized void updateAccounts(List<AccountUtils.AccountUpdateInfo> accountsInfo, int batchSize)", "originalCommit": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MTAxNg==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543141016", "bodyText": "This method is called as the first step in a transaction.  I would expect it to establish a connection if one does not exist.", "author": "lightningrob", "createdAt": "2020-12-15T08:28:25Z", "path": "ambry-commons/src/main/java/com/github/ambry/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -123,6 +124,43 @@ private void initializeDriver(String url) throws SQLException {\n     }\n   }\n \n+  /**\n+   * Enables or disables auto commit on current active {@link Connection}.\n+   * @param enable {@code true} to enable auto commit and {@code false} to disable auto commit.\n+   * @throws SQLException\n+   */\n+  public synchronized void setAutoCommit(boolean enable) throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {\n+      activeConnection.setAutoCommit(enable);\n+    } else {\n+      logger.debug(\"Connection to MySql DB is not available\");", "originalCommit": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MTYzNw==", "url": "https://github.com/linkedin/ambry/pull/1722#discussion_r543141637", "bodyText": "I don't see how connection can be null when commit or rollback is called.", "author": "lightningrob", "createdAt": "2020-12-15T08:29:26Z", "path": "ambry-commons/src/main/java/com/github/ambry/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -123,6 +124,43 @@ private void initializeDriver(String url) throws SQLException {\n     }\n   }\n \n+  /**\n+   * Enables or disables auto commit on current active {@link Connection}.\n+   * @param enable {@code true} to enable auto commit and {@code false} to disable auto commit.\n+   * @throws SQLException\n+   */\n+  public synchronized void setAutoCommit(boolean enable) throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {\n+      activeConnection.setAutoCommit(enable);\n+    } else {\n+      logger.debug(\"Connection to MySql DB is not available\");\n+    }\n+  }\n+\n+  /**\n+   * Commits transaction changes on current active {@link Connection}. This should only be used with auto commit disabled.\n+   * @throws SQLException\n+   */\n+  public synchronized void commit() throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {", "originalCommit": "6d5b85886dc9c43638aeaf1993203a6e8dd442a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7500a52d3065bea467ce4992d3b7c23c200d3da2", "url": "https://github.com/linkedin/ambry/commit/7500a52d3065bea467ce4992d3b7c23c200d3da2", "message": "Address Rob and Yingyi's comments", "committedDate": "2020-12-15T22:24:53Z", "type": "commit"}]}