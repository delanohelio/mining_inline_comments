{"pr_number": 1631, "pr_title": "[DataNodeConfigSource] use dedicated HPS instance", "pr_createdAt": "2020-09-25T15:53:17Z", "pr_url": "https://github.com/linkedin/ambry/pull/1631", "timeline": [{"oid": "e13f8926b8971c087c56ac051f0aac7399eb344e", "url": "https://github.com/linkedin/ambry/commit/e13f8926b8971c087c56ac051f0aac7399eb344e", "message": "[DataNodeConfigSource] use dedicated HPS instance\n\nThe property store provided by the HelixManager.getPropertyStore()\nmethod does not support caching/subscribed paths. As a solution, we can\nmove the ownership/instantiation of the PropertyStore into the\nPropertyStoreToDataNodeConfigAdapter class.\n\nTo keep views of the property store consistent between HelixParticipant\nand HelixClusterManager, this commit also adds a shared pool of\nDataNodeConfigSources so that the same instance (and ZkClient) can be\nused by both classes.", "committedDate": "2020-09-25T15:39:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYyODY0OA==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r495628648", "bodyText": "nit: in the equals method, suggest comparing zkAddr and instanceName first.", "author": "jsjtzyy", "createdAt": "2020-09-27T23:04:42Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -69,10 +73,65 @@ public HelixManager getZkHelixManagerAndConnect(String clusterName, String insta\n     return manager;\n   }\n \n+  /**\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param zkAddr the ZooKeeper address to connect to. If a {@link HelixManager} is required and one is already in the\n+   *               pool with this address, it will be reused.\n+   * @param metrics the {@link DataNodeConfigSourceMetrics} to use.\n+   * @return either a new instance of {@link DataNodeConfigSource} with the supplied configuration, or one from the pool\n+   *         if there is already one created for this address.\n+   */\n+  public DataNodeConfigSource getDataNodeConfigSource(ClusterMapConfig clusterMapConfig, String zkAddr,\n+      DataNodeConfigSourceMetrics metrics) {\n+    return dataNodeConfigSources.computeIfAbsent(zkAddr, k -> buildSource(clusterMapConfig, zkAddr, metrics));\n+  }\n+\n+  /**\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param zkAddr the ZooKeeper address to connect to. If a {@link HelixManager} is required and one is already in the\n+   *               pool with this address, it will be reused.\n+   * @param metrics the {@link DataNodeConfigSourceMetrics} to use.\n+   * @return a new instance of {@link DataNodeConfigSource} with the supplied configuration.\n+   */\n+  private DataNodeConfigSource buildSource(ClusterMapConfig clusterMapConfig, String zkAddr,\n+      DataNodeConfigSourceMetrics metrics) {\n+    try {\n+      InstanceConfigToDataNodeConfigAdapter instanceConfigSource = null;\n+      if (clusterMapConfig.clusterMapDataNodeConfigSourceType.isInstanceConfigAware()) {\n+        instanceConfigSource = new InstanceConfigToDataNodeConfigAdapter(\n+            getZkHelixManagerAndConnect(clusterMapConfig.clusterMapClusterName,\n+                ClusterMapUtils.getInstanceName(clusterMapConfig.clusterMapHostName, clusterMapConfig.clusterMapPort),\n+                InstanceType.SPECTATOR, zkAddr), clusterMapConfig);\n+      }\n+      PropertyStoreToDataNodeConfigAdapter propertyStoreSource = null;\n+      if (clusterMapConfig.clusterMapDataNodeConfigSourceType.isPropertyStoreAware()) {\n+        propertyStoreSource = new PropertyStoreToDataNodeConfigAdapter(zkAddr, clusterMapConfig);\n+      }\n+\n+      switch (clusterMapConfig.clusterMapDataNodeConfigSourceType) {\n+        case INSTANCE_CONFIG:\n+          return instanceConfigSource;\n+        case PROPERTY_STORE:\n+          return propertyStoreSource;\n+        case COMPOSITE_INSTANCE_CONFIG_PRIMARY:\n+          return new CompositeDataNodeConfigSource(instanceConfigSource, propertyStoreSource, SystemTime.getInstance(),\n+              metrics);\n+        case COMPOSITE_PROPERTY_STORE_PRIMARY:\n+          return new CompositeDataNodeConfigSource(propertyStoreSource, instanceConfigSource, SystemTime.getInstance(),\n+              metrics);\n+        default:\n+          throw new IllegalArgumentException(\"Unknown type: \" + clusterMapConfig.clusterMapDataNodeConfigSourceType);\n+      }\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Exception while instantiating DataNodeConfigSource\", e);\n+    }\n+  }\n+\n   /**\n    * Hashable key used to cache instances of {@link HelixManager} that match desired parameters.\n+   * Exposed for use in testing.\n    */\n-  private static class ManagerKey {\n+  static class ManagerKey {", "originalCommit": "e13f8926b8971c087c56ac051f0aac7399eb344e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI4MTk0NQ==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r496281945", "bodyText": "Compared zkAddr and instanceType first since those are most likely to be different in a single process.", "author": "cgtz", "createdAt": "2020-09-28T23:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYyODY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNTE3Mg==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r495635172", "bodyText": "I see this map is only used by HelixClusterManagerTest.java. If so, can we move this map to MockHelixManagerFactory in that file?", "author": "jsjtzyy", "createdAt": "2020-09-27T23:56:48Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -28,7 +30,9 @@\n  */\n public class HelixFactory {\n   private static final Logger LOGGER = LoggerFactory.getLogger(HelixFactory.class);\n-  Map<ManagerKey, HelixManager> helixManagers = new ConcurrentHashMap<>();\n+  // exposed for use in testing\n+  final Map<ManagerKey, HelixManager> helixManagers = new ConcurrentHashMap<>();", "originalCommit": "e13f8926b8971c087c56ac051f0aac7399eb344e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI4MjM2MA==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r496282360", "bodyText": "It is actually accessed in the getZkHelixManager method, but I was able to make it private and add a method that can be overridden for the test impl, which seems to be cleaner.", "author": "cgtz", "createdAt": "2020-09-28T23:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNTE3Mg=="}], "type": "inlineReview"}, {"oid": "609cb2e82bf67b9e58ca9d367fedc7920294e0e1", "url": "https://github.com/linkedin/ambry/commit/609cb2e82bf67b9e58ca9d367fedc7920294e0e1", "message": "fix ambiguous method", "committedDate": "2020-09-28T21:33:19Z", "type": "commit"}, {"oid": "2ed195d5fdd72eafc19c0e3710f7771bbf2f1cbf", "url": "https://github.com/linkedin/ambry/commit/2ed195d5fdd72eafc19c0e3710f7771bbf2f1cbf", "message": "Address comments", "committedDate": "2020-09-28T23:03:58Z", "type": "commit"}, {"oid": "94b7a599b5bdf00b1e8c973f7162d11b006011f0", "url": "https://github.com/linkedin/ambry/commit/94b7a599b5bdf00b1e8c973f7162d11b006011f0", "message": "fix test case that depends on HelixFactory for getting DNCS", "committedDate": "2020-09-29T00:46:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEwNjE0Ng==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r497106146", "bodyText": "Can you please help to explain a little bit in which case we will chose COMPOSITE_INSTANCE_CONFIG_PRIMARY and COMPOSITE_PROPERTY_STORE_PRIMARY? I understand the composite config is for safe migration, but just curious how to define which one is primary.", "author": "SophieGuo410", "createdAt": "2020-09-29T22:45:35Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -69,10 +73,78 @@ public HelixManager getZkHelixManagerAndConnect(String clusterName, String insta\n     return manager;\n   }\n \n+  /**\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param zkAddr the ZooKeeper address to connect to. If a {@link HelixManager} is required and one is already in the\n+   *               pool with this address, it will be reused.\n+   * @param metrics the {@link DataNodeConfigSourceMetrics} to use.\n+   * @return either a new instance of {@link DataNodeConfigSource} with the supplied configuration, or one from the pool\n+   *         if there is already one created for this address.\n+   */\n+  public DataNodeConfigSource getDataNodeConfigSource(ClusterMapConfig clusterMapConfig, String zkAddr,\n+      DataNodeConfigSourceMetrics metrics) {\n+    return dataNodeConfigSources.computeIfAbsent(zkAddr,\n+        k -> buildDataNodeConfigSource(clusterMapConfig, zkAddr, metrics));\n+  }\n+\n+  /**\n+   * Construct a new instance of {@link HelixManager}. Exposed so that tests can override if needed.\n+   * @param clusterName the name of the cluster for the manager.\n+   * @param instanceName the name of the instance for the manager.\n+   * @param instanceType the {@link InstanceType} of the requester.\n+   * @param zkAddr the address identifying the zk service to which this request is to be made.\n+   * @return a new instance of {@link HelixManager}.\n+   */\n+  HelixManager buildZKHelixManager(String clusterName, String instanceName, InstanceType instanceType, String zkAddr) {\n+    return HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+  }\n+\n+  /**\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param zkAddr the ZooKeeper address to connect to. If a {@link HelixManager} is required and one is already in the\n+   *               pool with this address, it will be reused.\n+   * @param metrics the {@link DataNodeConfigSourceMetrics} to use.\n+   * @return a new instance of {@link DataNodeConfigSource} with the supplied configuration.\n+   */\n+  private DataNodeConfigSource buildDataNodeConfigSource(ClusterMapConfig clusterMapConfig, String zkAddr,\n+      DataNodeConfigSourceMetrics metrics) {\n+    try {\n+      InstanceConfigToDataNodeConfigAdapter instanceConfigSource = null;\n+      if (clusterMapConfig.clusterMapDataNodeConfigSourceType.isInstanceConfigAware()) {\n+        instanceConfigSource = new InstanceConfigToDataNodeConfigAdapter(\n+            getZkHelixManagerAndConnect(clusterMapConfig.clusterMapClusterName,\n+                ClusterMapUtils.getInstanceName(clusterMapConfig.clusterMapHostName, clusterMapConfig.clusterMapPort),\n+                InstanceType.SPECTATOR, zkAddr), clusterMapConfig);\n+      }\n+      PropertyStoreToDataNodeConfigAdapter propertyStoreSource = null;\n+      if (clusterMapConfig.clusterMapDataNodeConfigSourceType.isPropertyStoreAware()) {\n+        propertyStoreSource = new PropertyStoreToDataNodeConfigAdapter(zkAddr, clusterMapConfig);\n+      }\n+\n+      switch (clusterMapConfig.clusterMapDataNodeConfigSourceType) {\n+        case INSTANCE_CONFIG:\n+          return instanceConfigSource;\n+        case PROPERTY_STORE:\n+          return propertyStoreSource;\n+        case COMPOSITE_INSTANCE_CONFIG_PRIMARY:", "originalCommit": "94b7a599b5bdf00b1e8c973f7162d11b006011f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE0MjM2OQ==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r497142369", "bodyText": "Sure, I should publish a short doc on the migration steps actually.\nThese two both can be used as migration tools so that both property store and instance configs get updated.\nThe first step would be to switch to COMPOSITE_INSTANCE_CONFIG_PRIMARY, which would keep logic in ambry-server/ambry-frontend based on what the instance configs (legacy source) present, but also check for discrepancies and keep the property store up to date on updates to things like sealed partitions.\nAfter we are comfortable that we aren't seeing discrepancies, we can switch to COMPOSITE_PROPERTY_STORE_PRIMARY. This will use the new source for application logic/listeners but still keep the instanceconfigs up to date in case we need to do a rollback.\nFinally, one can switch to PROPERTY_STORE to complete the migration.", "author": "cgtz", "createdAt": "2020-09-29T23:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEwNjE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNzYyNg==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r497117626", "bodyText": "what's this close method for? Does the helixManager needs to be disconnected here?", "author": "SophieGuo410", "createdAt": "2020-09-29T23:00:46Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapter.java", "diffHunk": "@@ -75,6 +75,10 @@ public DataNodeConfig get(String instanceName) {\n     return instanceConfig != null ? converter.convert(instanceConfig) : null;\n   }\n \n+  @Override\n+  public void close() {\n+  }", "originalCommit": "94b7a599b5bdf00b1e8c973f7162d11b006011f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE0Mzk5Nw==", "url": "https://github.com/linkedin/ambry/pull/1631#discussion_r497143997", "bodyText": "This close method is just here since I added close() to the interface, but this specific impl shouldn't have to do anything. Unlike PropertyStore...Adapter, this one doesn't own the HelixManager's lifecycle, since it was passed into the constructor. HelixClusterManager will disconnect the HelixManager (this part is a little weird right now, since both this class and HelixClusterManager get a shared reference to HelixManager through HelixFactory).", "author": "cgtz", "createdAt": "2020-09-29T23:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNzYyNg=="}], "type": "inlineReview"}]}