{"pr_number": 1429, "pr_title": "Introduce CompositeNetworkClient and factory", "pr_createdAt": "2020-03-16T21:02:21Z", "pr_url": "https://github.com/linkedin/ambry/pull/1429", "timeline": [{"oid": "0ccbfaff4138b26b937d2a69e6b097d545fc60e8", "url": "https://github.com/linkedin/ambry/commit/0ccbfaff4138b26b937d2a69e6b097d545fc60e8", "message": "Introduce CompositeNetworkClient and factory\n\nThis will allow requests to be routed to either an ambry-server or cloud\ndestination based on replica type for hybrid deployments of Ambry. It\ntakes in a map from replica type to client factory and chooses which\nrequests to send to which client.", "committedDate": "2020-03-16T21:01:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMjg4OA==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r393312888", "bodyText": "will finish this test case", "author": "cgtz", "createdAt": "2020-03-16T21:11:39Z", "path": "ambry-network/src/test/java/com/github/ambry/network/CompositeNetworkClientTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockReplicaId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import io.netty.buffer.Unpooled;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Test {@link CompositeNetworkClient} and {@link CompositeNetworkClientFactory}.\n+ */\n+public class CompositeNetworkClientTest {\n+  int nextCorrelationId = 0;\n+\n+  @Test\n+  public void testDelegation() throws IOException {\n+    Map<ReplicaType, NetworkClientFactory> childFactories = new HashMap<>();\n+    Pair<NetworkClientFactory, NetworkClient> mockOne = getMocks();\n+    childFactories.put(ReplicaType.DISK_BACKED, mockOne.getFirst());\n+    Pair<NetworkClientFactory, NetworkClient> mockTwo = getMocks();\n+    childFactories.put(ReplicaType.CLOUD_BACKED, mockTwo.getFirst());\n+\n+    CompositeNetworkClientFactory factory = new CompositeNetworkClientFactory(childFactories);\n+    factory.getNetworkClient();\n+    // the second call should call the underlying factories again\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    verify(mockOne.getFirst(), times(2)).getNetworkClient();\n+    verify(mockTwo.getFirst(), times(2)).getNetworkClient();\n+\n+    // warmUpConnections", "originalCommit": "0ccbfaff4138b26b937d2a69e6b097d545fc60e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "url": "https://github.com/linkedin/ambry/commit/1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "message": "Fixed test cases", "committedDate": "2020-03-18T19:22:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNTgwMQ==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394835801", "bodyText": "Javadocs please.", "author": "lightningrob", "createdAt": "2020-03-19T07:35:53Z", "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClient.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+\n+public class CompositeNetworkClient implements NetworkClient {", "originalCommit": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNjgxMA==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394836810", "bodyText": "This seems pretty late in the method to throw an exception like this.  Could we catch it earlier?", "author": "lightningrob", "createdAt": "2020-03-19T07:38:24Z", "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClient.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+\n+public class CompositeNetworkClient implements NetworkClient {\n+  /**\n+   * Used to properly route requests to drop.\n+   */\n+  private final Map<Integer, ReplicaType> correlationIdToReplicaType = new HashMap<>();\n+  private final EnumMap<ReplicaType, NetworkClient> childNetworkClients;\n+\n+  CompositeNetworkClient(EnumMap<ReplicaType, NetworkClient> childNetworkClients) {\n+    this.childNetworkClients = childNetworkClients;\n+  }\n+\n+  @Override\n+  public List<ResponseInfo> sendAndPoll(List<RequestInfo> allRequestsToSend, Set<Integer> allRequestsToDrop,\n+      int pollTimeoutMs) {\n+    // the first item of the pair is requests to send, the second is correlation IDs to drop\n+    Function<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> pairBuilder =\n+        replicaType -> new Pair<>(new ArrayList<>(), new HashSet<>());\n+    EnumMap<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> requestsToSendAndDropByType =\n+        new EnumMap<>(ReplicaType.class);\n+    for (RequestInfo requestInfo : allRequestsToSend) {\n+      ReplicaType replicaType = requestInfo.getReplicaId().getReplicaType();\n+      requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getFirst().add(requestInfo);\n+      correlationIdToReplicaType.put(requestInfo.getRequest().getCorrelationId(), replicaType);\n+    }\n+    for (Integer correlationId : allRequestsToDrop) {\n+      ReplicaType replicaType = correlationIdToReplicaType.get(correlationId);\n+      if (replicaType != null) {\n+        requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getSecond().add(correlationId);\n+      }\n+    }\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    requestsToSendAndDropByType.forEach((replicaType, requestsToSendAndDrop) -> {\n+      NetworkClient client = childNetworkClients.get(replicaType);\n+      if (client == null) {\n+        throw new IllegalStateException(\"No NetworkClient configured for replica type: \" + replicaType);", "originalCommit": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxNzcxMA==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r395217710", "bodyText": "Changed it to throw in the computeIfAbsent call (the first time a request is found with a certain ReplicaType);", "author": "cgtz", "createdAt": "2020-03-19T17:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNjgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjA5MQ==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394842091", "bodyText": "This doesn't seem possible.  Can't we just call the method for all clients?  LocalNetworkClient returns 0 anyway.", "author": "lightningrob", "createdAt": "2020-03-19T07:51:17Z", "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClient.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+\n+public class CompositeNetworkClient implements NetworkClient {\n+  /**\n+   * Used to properly route requests to drop.\n+   */\n+  private final Map<Integer, ReplicaType> correlationIdToReplicaType = new HashMap<>();\n+  private final EnumMap<ReplicaType, NetworkClient> childNetworkClients;\n+\n+  CompositeNetworkClient(EnumMap<ReplicaType, NetworkClient> childNetworkClients) {\n+    this.childNetworkClients = childNetworkClients;\n+  }\n+\n+  @Override\n+  public List<ResponseInfo> sendAndPoll(List<RequestInfo> allRequestsToSend, Set<Integer> allRequestsToDrop,\n+      int pollTimeoutMs) {\n+    // the first item of the pair is requests to send, the second is correlation IDs to drop\n+    Function<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> pairBuilder =\n+        replicaType -> new Pair<>(new ArrayList<>(), new HashSet<>());\n+    EnumMap<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> requestsToSendAndDropByType =\n+        new EnumMap<>(ReplicaType.class);\n+    for (RequestInfo requestInfo : allRequestsToSend) {\n+      ReplicaType replicaType = requestInfo.getReplicaId().getReplicaType();\n+      requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getFirst().add(requestInfo);\n+      correlationIdToReplicaType.put(requestInfo.getRequest().getCorrelationId(), replicaType);\n+    }\n+    for (Integer correlationId : allRequestsToDrop) {\n+      ReplicaType replicaType = correlationIdToReplicaType.get(correlationId);\n+      if (replicaType != null) {\n+        requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getSecond().add(correlationId);\n+      }\n+    }\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    requestsToSendAndDropByType.forEach((replicaType, requestsToSendAndDrop) -> {\n+      NetworkClient client = childNetworkClients.get(replicaType);\n+      if (client == null) {\n+        throw new IllegalStateException(\"No NetworkClient configured for replica type: \" + replicaType);\n+      }\n+      responses.addAll(\n+          client.sendAndPoll(requestsToSendAndDrop.getFirst(), requestsToSendAndDrop.getSecond(), pollTimeoutMs));\n+    });\n+    // clean up correlation ids for completed requests\n+    responses.forEach(\n+        response -> correlationIdToReplicaType.remove(response.getRequestInfo().getRequest().getCorrelationId()));\n+    return responses;\n+  }\n+\n+  @Override\n+  public int warmUpConnections(List<DataNodeId> dataNodeIds, int connectionWarmUpPercentagePerDataNode,\n+      long timeForWarmUp, List<ResponseInfo> responseInfoList) {\n+    // currently warm-up is only supported for connections to ambry-server.\n+    NetworkClient client = childNetworkClients.get(ReplicaType.DISK_BACKED);\n+    if (client != null) {\n+      return client.warmUpConnections(dataNodeIds, connectionWarmUpPercentagePerDataNode, timeForWarmUp,\n+          responseInfoList);\n+    } else {\n+      return 0;", "originalCommit": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxMTUzOA==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r395211538", "bodyText": "Sure, I can do that. Since there is no current way of filtering by replicatype of datanode (although maybe that makes sense to add in the future), we can send the full list to both clients.", "author": "cgtz", "createdAt": "2020-03-19T17:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjE5OA==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394842198", "bodyText": "javadoc", "author": "lightningrob", "createdAt": "2020-03-19T07:51:36Z", "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClientFactory.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.ReplicaType;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.Map;\n+\n+\n+public class CompositeNetworkClientFactory implements NetworkClientFactory {", "originalCommit": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MzMwNg==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394843306", "bodyText": "new line", "author": "lightningrob", "createdAt": "2020-03-19T07:54:09Z", "path": "ambry-network/src/test/java/com/github/ambry/network/CompositeNetworkClientTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockReplicaId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import io.netty.buffer.Unpooled;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Test {@link CompositeNetworkClient} and {@link CompositeNetworkClientFactory}.\n+ */\n+public class CompositeNetworkClientTest {\n+  private final Mocks mockOne = new Mocks();\n+  private final Mocks mockTwo = new Mocks();\n+  private final CompositeNetworkClientFactory factory;\n+  private int nextCorrelationId = 0;\n+\n+  public CompositeNetworkClientTest() {\n+    Map<ReplicaType, NetworkClientFactory> childFactories = new HashMap<>();\n+    childFactories.put(ReplicaType.DISK_BACKED, mockOne.factory);\n+    childFactories.put(ReplicaType.CLOUD_BACKED, mockTwo.factory);\n+    factory = new CompositeNetworkClientFactory(childFactories);\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClientFactory}\n+   */\n+  @Test\n+  public void testFactory() throws IOException {\n+    CompositeNetworkClient compositeClientOne = (CompositeNetworkClient) factory.getNetworkClient();\n+    CompositeNetworkClient compositeClientTwo = (CompositeNetworkClient) factory.getNetworkClient();\n+    assertNotNull(\"Client is null\", compositeClientOne);\n+    assertNotNull(\"Client is null\", compositeClientTwo);\n+    verify(mockOne.factory, times(2)).getNetworkClient();\n+    verify(mockTwo.factory, times(2)).getNetworkClient();\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#warmUpConnections}\n+   */\n+  @Test\n+  public void testWarmUp() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    when(mockOne.client.warmUpConnections(any(), anyInt(), anyLong(), any())).thenReturn(25);\n+    List<DataNodeId> nodesToWarmUp = Collections.nCopies(3, mock(DataNodeId.class));\n+    assertEquals(\"Unexpected number of connections warmed up\", 25,\n+        compositeClient.warmUpConnections(nodesToWarmUp, 100, 1000, Collections.emptyList()));\n+    verify(mockOne.client).warmUpConnections(nodesToWarmUp, 100, 1000, Collections.emptyList());\n+    verifyZeroInteractions(mockTwo.client);\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#sendAndPoll}\n+   */\n+  @Test\n+  public void testSendAndPoll() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+\n+    // a couple for the first client and one request for the second client\n+    List<RequestInfo> requestsToSendOne =\n+        Arrays.asList(getRequestInfo(ReplicaType.DISK_BACKED), getRequestInfo(ReplicaType.CLOUD_BACKED),\n+            getRequestInfo(ReplicaType.DISK_BACKED));\n+    // try dropping unknown correlation ID, this should not cause issues\n+    Set<Integer> requestsToDrop = Collections.singleton(77);\n+    int pollTimeoutMs = 1000;\n+    List<ResponseInfo> responsesOne =\n+        Collections.singletonList(new ResponseInfo(requestsToSendOne.get(0), null, Unpooled.EMPTY_BUFFER));\n+    List<ResponseInfo> responsesTwo = Collections.emptyList();\n+    when(mockOne.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesOne);\n+    when(mockTwo.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesTwo);\n+    List<ResponseInfo> responses = compositeClient.sendAndPoll(requestsToSendOne, requestsToDrop, pollTimeoutMs);\n+    assertEquals(\"Unexpected response list\", responsesOne, responses);\n+    verify(mockOne.client).sendAndPoll(Arrays.asList(requestsToSendOne.get(0), requestsToSendOne.get(2)),\n+        Collections.emptySet(), pollTimeoutMs);\n+    verify(mockTwo.client).sendAndPoll(Collections.singletonList(requestsToSendOne.get(1)), Collections.emptySet(),\n+        pollTimeoutMs);\n+    verifyNoMoreInteractions(mockOne.client);\n+    verifyNoMoreInteractions(mockTwo.client);\n+\n+    mockOne.resetMocks();\n+    mockTwo.resetMocks();\n+    // two requests for the second client\n+    List<RequestInfo> requestsToSendTwo =\n+        Arrays.asList(getRequestInfo(ReplicaType.CLOUD_BACKED), getRequestInfo(ReplicaType.CLOUD_BACKED));\n+    // drop one request from the current iteration and one from the last\n+    requestsToDrop = Stream.of(requestsToSendOne.get(2), requestsToSendTwo.get(0))\n+        .map(r -> r.getRequest().getCorrelationId())\n+        .collect(Collectors.toSet());\n+    responsesOne = Collections.singletonList(new ResponseInfo(requestsToSendOne.get(2), null, Unpooled.EMPTY_BUFFER));\n+    responsesTwo = Collections.singletonList(new ResponseInfo(requestsToSendTwo.get(1), null, Unpooled.EMPTY_BUFFER));\n+    when(mockOne.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesOne);\n+    when(mockTwo.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesTwo);\n+    responses = compositeClient.sendAndPoll(requestsToSendTwo, requestsToDrop, pollTimeoutMs);\n+    assertEquals(\"Unexpected response list\",\n+        Stream.of(responsesOne, responsesTwo).flatMap(List::stream).collect(Collectors.toList()), responses);\n+    verify(mockOne.client).sendAndPoll(Collections.emptyList(),\n+        Collections.singleton(requestsToSendOne.get(2).getRequest().getCorrelationId()), pollTimeoutMs);\n+    verify(mockTwo.client).sendAndPoll(requestsToSendTwo,\n+        Collections.singleton(requestsToSendTwo.get(0).getRequest().getCorrelationId()), pollTimeoutMs);\n+    verifyNoMoreInteractions(mockOne.client);\n+    verifyNoMoreInteractions(mockTwo.client);\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#wakeup}\n+   */\n+  @Test\n+  public void testWakeup() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    compositeClient.wakeup();\n+    verify(mockOne.client).wakeup();\n+    verify(mockTwo.client).wakeup();\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#close}\n+   */\n+  @Test\n+  public void testClose() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    compositeClient.close();\n+    verify(mockOne.client).close();\n+    verify(mockTwo.client).close();\n+  }\n+\n+  /**\n+   * @param replicaType the {@link ReplicaType} for the request.\n+   * @return a new {@link RequestInfo} with a new correlation ID.\n+   */\n+  private RequestInfo getRequestInfo(ReplicaType replicaType) {\n+    return new RequestInfo(\"a\", new Port(1, PortType.SSL), new MockSend(nextCorrelationId++),\n+        new MockReplicaId(replicaType));\n+  }\n+\n+  private static class Mocks {\n+    private final NetworkClientFactory factory;\n+    private final NetworkClient client;\n+\n+    Mocks() {\n+      factory = mock(NetworkClientFactory.class);\n+      client = mock(NetworkClient.class);\n+      resetMocks();\n+    }\n+\n+    private void resetMocks() {\n+      try {\n+        reset(factory, client);\n+        when(factory.getNetworkClient()).thenReturn(client);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+}", "originalCommit": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0NDk5Ng==", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394844996", "bodyText": "I had trouble following the mock usage.  Could we rename them diskMock and cloudMock to make it clearer?", "author": "lightningrob", "createdAt": "2020-03-19T07:58:06Z", "path": "ambry-network/src/test/java/com/github/ambry/network/CompositeNetworkClientTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockReplicaId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import io.netty.buffer.Unpooled;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Test {@link CompositeNetworkClient} and {@link CompositeNetworkClientFactory}.\n+ */\n+public class CompositeNetworkClientTest {\n+  private final Mocks mockOne = new Mocks();\n+  private final Mocks mockTwo = new Mocks();", "originalCommit": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fadd0249ab481a828de1ee6ef8277c481688fdb8", "url": "https://github.com/linkedin/ambry/commit/fadd0249ab481a828de1ee6ef8277c481688fdb8", "message": "Address Rob's comments", "committedDate": "2020-03-19T17:59:09Z", "type": "commit"}, {"oid": "dee8560c49be1a0b21b7fc77392f1903a07bb121", "url": "https://github.com/linkedin/ambry/commit/dee8560c49be1a0b21b7fc77392f1903a07bb121", "message": "Add test for uncovered case", "committedDate": "2020-03-19T19:48:07Z", "type": "commit"}]}