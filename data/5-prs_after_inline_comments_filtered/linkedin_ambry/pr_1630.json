{"pr_number": 1630, "pr_title": "[StorageQuota] Add some quota interfaces and a helix storage usage implementation", "pr_createdAt": "2020-09-23T20:59:42Z", "pr_url": "https://github.com/linkedin/ambry/pull/1630", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1OTI1NQ==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494659255", "bodyText": "nit: add unit for quota, i.e. in bytes", "author": "jsjtzyy", "createdAt": "2020-09-24T23:11:05Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Config for {@link com.github.ambry.quota.StorageQuotaService}\n+ */\n+public class StorageQuotaConfig {\n+  public static final String STORAGE_QUOTA_PREFIX = \"storage.quota.\";\n+  public static final String ZK_CLIENT_CONNECT_ADDRESS = STORAGE_QUOTA_PREFIX + \"zk.client.connect.address\";\n+  public static final String REFRESHER_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"refresher.polling.interval.ms\";\n+  public static final String CONTAINER_STORAGE_QUOTA_IN_JSON = STORAGE_QUOTA_PREFIX + \"container.storage.quota.in.json\";\n+  public static final String SOURCE_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"source.polling.interval.ms\";\n+\n+  //////////////// Config for HelixStorageUsageRefresher ///////////////\n+\n+  /**\n+   * The ZooKeeper server address to connect to. This config is required.\n+   */\n+  @Config(ZK_CLIENT_CONNECT_ADDRESS)\n+  public final String zkClientConnectAddress;\n+\n+  /**\n+   * The interval in milliseconds for refresher to refresh storage usage from its source.\n+   */\n+  @Config(REFRESHER_POLLING_INTERVAL_MS)\n+  @Default(\"30 * 60 * 1000\") // 30 minutes\n+  public final int refresherPollingIntervalMs;\n+\n+  //////////////// Config for JSONStringStorageQuotaSource ///////////////\n+\n+  /**\n+   * A JSON string representing storage quota for all containers. eg:\n+   * {\n+   *   \"101\": {\n+   *     \"1\": 1024000000,\n+   *     \"2\": 258438456\n+   *   },\n+   *   \"102\": {\n+   *     \"1\": 10737418240\n+   *   }\n+   * }\n+   * The key of the top object is the acount id and the key of the inner object is the container id.\n+   * The value of the each container id is the storage quota for this container.", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTQ5Mg==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494661492", "bodyText": "minor: use getIntInRange instead of getInt here.", "author": "jsjtzyy", "createdAt": "2020-09-24T23:18:04Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Config for {@link com.github.ambry.quota.StorageQuotaService}\n+ */\n+public class StorageQuotaConfig {\n+  public static final String STORAGE_QUOTA_PREFIX = \"storage.quota.\";\n+  public static final String ZK_CLIENT_CONNECT_ADDRESS = STORAGE_QUOTA_PREFIX + \"zk.client.connect.address\";\n+  public static final String REFRESHER_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"refresher.polling.interval.ms\";\n+  public static final String CONTAINER_STORAGE_QUOTA_IN_JSON = STORAGE_QUOTA_PREFIX + \"container.storage.quota.in.json\";\n+  public static final String SOURCE_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"source.polling.interval.ms\";\n+\n+  //////////////// Config for HelixStorageUsageRefresher ///////////////\n+\n+  /**\n+   * The ZooKeeper server address to connect to. This config is required.\n+   */\n+  @Config(ZK_CLIENT_CONNECT_ADDRESS)\n+  public final String zkClientConnectAddress;\n+\n+  /**\n+   * The interval in milliseconds for refresher to refresh storage usage from its source.\n+   */\n+  @Config(REFRESHER_POLLING_INTERVAL_MS)\n+  @Default(\"30 * 60 * 1000\") // 30 minutes\n+  public final int refresherPollingIntervalMs;\n+\n+  //////////////// Config for JSONStringStorageQuotaSource ///////////////\n+\n+  /**\n+   * A JSON string representing storage quota for all containers. eg:\n+   * {\n+   *   \"101\": {\n+   *     \"1\": 1024000000,\n+   *     \"2\": 258438456\n+   *   },\n+   *   \"102\": {\n+   *     \"1\": 10737418240\n+   *   }\n+   * }\n+   * The key of the top object is the acount id and the key of the inner object is the container id.\n+   * The value of the each container id is the storage quota for this container.\n+   *\n+   * If the targeted container doesn't have a storage quota in this JSON string, it's up to StorageQuotaEnforcer\n+   * to decide whether to allow uploads or not.\n+   */\n+  @Config(CONTAINER_STORAGE_QUOTA_IN_JSON)\n+  @Default(\"\")\n+  public final String containerStorageQuotaInJson;\n+\n+  /**\n+   * The interval in milliseconds for quota source to refresh each container's storage quota.\n+   */\n+  @Config(SOURCE_POLLING_INTERVAL_MS)\n+  @Default(\"30 * 60 * 1000\")\n+  public final int sourcePollingIntervalMs;\n+\n+  /**\n+   * Constructor to create a {@link StorageQuotaConfig}.\n+   * @param verifiableProperties The {@link VerifiableProperties} that contains all the properties.\n+   */\n+  public StorageQuotaConfig(VerifiableProperties verifiableProperties) {\n+    zkClientConnectAddress = verifiableProperties.getString(ZK_CLIENT_CONNECT_ADDRESS);\n+    refresherPollingIntervalMs = verifiableProperties.getInt(REFRESHER_POLLING_INTERVAL_MS, 30 * 60 * 1000);\n+    containerStorageQuotaInJson = verifiableProperties.getString(CONTAINER_STORAGE_QUOTA_IN_JSON, \"\");\n+    sourcePollingIntervalMs = verifiableProperties.getInt(SOURCE_POLLING_INTERVAL_MS, 30 * 60 * 1000);", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTY3Mg==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494661672", "bodyText": "Add some java doc", "author": "jsjtzyy", "createdAt": "2020-09-24T23:18:33Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+public interface StorageQuotaEnforcer {", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTkzNQ==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494661935", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-09-24T23:19:25Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+public interface StorageQuotaService {", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3Mzc1OA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494773758", "bodyText": "Will add doc later when I add methods to this interface.", "author": "justinlin-linkedin", "createdAt": "2020-09-25T06:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNzA3MA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496207070", "bodyText": "Might be nitpicking here, so I will let you and @jsjtzyy take the final decision on this. But I am not sure why are you even adding the interfaces if there is no method in that now? They don't serve any purpose for now. I think you can keep the three new interfaces StorageQuotaService.java, StorageQuotaServiceFactory.java and StorageQuotaEnforcer.java in a separate PR where you have figured out their behavior and methods.", "author": "ankagrawal", "createdAt": "2020-09-28T20:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM1OTg4Mg==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496359882", "bodyText": "I will remove those interfaces then.", "author": "justinlin-linkedin", "createdAt": "2020-09-29T03:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MjMzNw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494662337", "bodyText": "same here, can you add the unit (in bytes) here?", "author": "jsjtzyy", "createdAt": "2020-09-24T23:20:30Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * The interface of the source of storage quota for each container.\n+ */\n+public interface StorageQuotaSource {\n+  /**\n+   * Return the storage quota of each container. The returned map should be structured as such:\n+   * The key of the map is the account id in string format and the value of the map is the storage quota of each\n+   * container under this account.\n+   * The container usage map's key is the container is in string format, and the value is storage quota of this container.", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3MDY4Mw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494670683", "bodyText": "Why not put these into StorageQuotaConfig as static fields?", "author": "jsjtzyy", "createdAt": "2020-09-24T23:49:08Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A Helix implementation of {@link StorageUsageRefresher}. A Helix aggregation task, created in ambry-server, would persist\n+ * current storage usage in ZooKeeper periodically. This implementation would fetch the storage usage from zookeeper using\n+ * {@link HelixPropertyStore} and subscribe to the change. This implementation also periodically refetch the storage usage\n+ * from ZooKeeper to keep it up-to-date.\n+ */\n+public class HelixStorageUsageRefresher implements StorageUsageRefresher {\n+  // These two constant fields are shared by other classes. TODO: reuse these two constant fields.\n+  public static final String AGGREGATED_CONTAINER_STORAGE_USAGE_PATH = \"Aggregated_AccountReport\";\n+  public static final String VALID_SIZE_FILED_NAME = \"valid_data_size\";", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3NDY5Mw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494774693", "bodyText": "This is not configurable. Whatever goes to config would be considered a configurable value. I am thinking about abstract some of the logic in this class out with aggregation task since they share the same znode path and the same format.", "author": "justinlin-linkedin", "createdAt": "2020-09-25T06:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3MDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NTMzMQ==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494675331", "bodyText": "Since this is the initial fetch, in what scenario there is already a container usage map in memory? Is it because subscribeToChange() comes first in ctor?", "author": "jsjtzyy", "createdAt": "2020-09-25T00:05:42Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A Helix implementation of {@link StorageUsageRefresher}. A Helix aggregation task, created in ambry-server, would persist\n+ * current storage usage in ZooKeeper periodically. This implementation would fetch the storage usage from zookeeper using\n+ * {@link HelixPropertyStore} and subscribe to the change. This implementation also periodically refetch the storage usage\n+ * from ZooKeeper to keep it up-to-date.\n+ */\n+public class HelixStorageUsageRefresher implements StorageUsageRefresher {\n+  // These two constant fields are shared by other classes. TODO: reuse these two constant fields.\n+  public static final String AGGREGATED_CONTAINER_STORAGE_USAGE_PATH = \"Aggregated_AccountReport\";\n+  public static final String VALID_SIZE_FILED_NAME = \"valid_data_size\";\n+\n+  private static final Logger logger = LoggerFactory.getLogger(HelixStorageUsageRefresher.class);\n+\n+  private final HelixPropertyStore<ZNRecord> helixStore;\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageRef = new AtomicReference<>(null);\n+  private final AtomicReference<Callback> callback = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+\n+  /**\n+   * Constructor to create a {@link HelixStorageUsageRefresher}.\n+   * @param helixStore The {@link HelixPropertyStore} used to fetch storage usage and subscribe to change.\n+   * @param scheduler The {@link ScheduledExecutorService} to schedule a task to periodically refresh the usage.\n+   * @param config The {@link StorageQuotaConfig}.\n+   */\n+  public HelixStorageUsageRefresher(HelixPropertyStore<ZNRecord> helixStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config) {\n+    this.helixStore = Objects.requireNonNull(helixStore, \"HelixPropertyStore can't be null\");\n+    this.scheduler = scheduler;\n+    this.config = config;\n+    subscribeToChange();\n+    initialFetchAndSchedule();\n+  }\n+\n+  /**\n+   * Fetch the storage usage and schedule a task to periodically refresh the storage usage.\n+   */\n+  private void initialFetchAndSchedule() {\n+    Runnable updater = () -> {\n+      try {\n+        Map<String, Map<String, Long>> initialValue =\n+            fetchContainerStorageUsageFromPath(AGGREGATED_CONTAINER_STORAGE_USAGE_PATH);\n+        containerStorageUsageRef.set(initialValue);\n+      } catch (Exception e) {\n+        logger.error(\"Failed to parse the container usage from znode \" + AGGREGATED_CONTAINER_STORAGE_USAGE_PATH, e);\n+        // If we already have a container usage map in memory, then don't replace it with empty map.\n+        containerStorageUsageRef.compareAndSet(null, Collections.EMPTY_MAP);", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3NTI2Nw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494775267", "bodyText": "that's right. I don't know whether helix would fetch the content of z path if we call helix.subscribe so here I just blindly make the assumption that in memory cache might not be null.", "author": "justinlin-linkedin", "createdAt": "2020-09-25T06:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MDYxNA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494680614", "bodyText": "Based on how it's used, it's more like a listener not callback.", "author": "jsjtzyy", "createdAt": "2020-09-25T00:25:04Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * An interface to initialize and refresh the storage usage for each container.\n+ */\n+public interface StorageUsageRefresher {\n+\n+  /**\n+   * Return the current storage usage for each container. The returned map should be structured as such:\n+   * The key of the map is the account id in string format and the value of the map is the storage usage of each\n+   * container under this account.\n+   * The container usage map's key is the container is in string format, and the value is storage usage of this container.\n+   * @return The current storage usage for each container.\n+   * @throws Exception\n+   */\n+  Map<String, Map<String, Long>> getContainerStorageUsage() throws Exception;\n+\n+  /**\n+   * A callback interface registered with {@link StorageUsageRefresher}. It will be invoked every time when there is a\n+   * change in the storage usage. The new storage usage will be passed as the parameter. Notice this is a unmodifiable\n+   * map.\n+   */\n+  interface Callback {\n+    void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage);", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3NTQwNg==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494775406", "bodyText": "Will change the name of the interface.", "author": "justinlin-linkedin", "createdAt": "2020-09-25T06:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MDYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MTA1OQ==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494681059", "bodyText": "complete the java doc", "author": "jsjtzyy", "createdAt": "2020-09-25T00:26:55Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A Helix implementation of {@link StorageUsageRefresher}. A Helix aggregation task, created in ambry-server, would persist\n+ * current storage usage in ZooKeeper periodically. This implementation would fetch the storage usage from zookeeper using\n+ * {@link HelixPropertyStore} and subscribe to the change. This implementation also periodically refetch the storage usage\n+ * from ZooKeeper to keep it up-to-date.\n+ */\n+public class HelixStorageUsageRefresher implements StorageUsageRefresher {\n+  // These two constant fields are shared by other classes. TODO: reuse these two constant fields.\n+  public static final String AGGREGATED_CONTAINER_STORAGE_USAGE_PATH = \"Aggregated_AccountReport\";\n+  public static final String VALID_SIZE_FILED_NAME = \"valid_data_size\";\n+\n+  private static final Logger logger = LoggerFactory.getLogger(HelixStorageUsageRefresher.class);\n+\n+  private final HelixPropertyStore<ZNRecord> helixStore;\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageRef = new AtomicReference<>(null);\n+  private final AtomicReference<Callback> callback = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+\n+  /**\n+   * Constructor to create a {@link HelixStorageUsageRefresher}.\n+   * @param helixStore The {@link HelixPropertyStore} used to fetch storage usage and subscribe to change.\n+   * @param scheduler The {@link ScheduledExecutorService} to schedule a task to periodically refresh the usage.\n+   * @param config The {@link StorageQuotaConfig}.\n+   */\n+  public HelixStorageUsageRefresher(HelixPropertyStore<ZNRecord> helixStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config) {\n+    this.helixStore = Objects.requireNonNull(helixStore, \"HelixPropertyStore can't be null\");\n+    this.scheduler = scheduler;\n+    this.config = config;\n+    subscribeToChange();\n+    initialFetchAndSchedule();\n+  }\n+\n+  /**\n+   * Fetch the storage usage and schedule a task to periodically refresh the storage usage.\n+   */\n+  private void initialFetchAndSchedule() {\n+    Runnable updater = () -> {\n+      try {\n+        Map<String, Map<String, Long>> initialValue =\n+            fetchContainerStorageUsageFromPath(AGGREGATED_CONTAINER_STORAGE_USAGE_PATH);\n+        containerStorageUsageRef.set(initialValue);\n+      } catch (Exception e) {\n+        logger.error(\"Failed to parse the container usage from znode \" + AGGREGATED_CONTAINER_STORAGE_USAGE_PATH, e);\n+        // If we already have a container usage map in memory, then don't replace it with empty map.\n+        containerStorageUsageRef.compareAndSet(null, Collections.EMPTY_MAP);\n+      }\n+    };\n+    updater.run();\n+\n+    if (scheduler != null) {\n+      int initialDelay = new Random().nextInt(config.refresherPollingIntervalMs + 1);\n+      scheduler.scheduleAtFixedRate(updater, initialDelay, config.refresherPollingIntervalMs, TimeUnit.MILLISECONDS);\n+      logger.info(\n+          \"Background storage usage updater will fetch storage usage from remote starting {} ms from now and repeat with interval={} ms\",\n+          initialDelay, config.refresherPollingIntervalMs);\n+    }\n+  }\n+\n+  /**\n+   * Subscribe to storage usage change via helix property store. It will update the in memory cache of the storage usage\n+   * and invoke the callback if present.\n+   */\n+  private void subscribeToChange() {\n+    helixStore.subscribe(AGGREGATED_CONTAINER_STORAGE_USAGE_PATH, new HelixPropertyListener() {\n+      @Override\n+      public void onDataChange(String path) {\n+        refreshOnUpdate(path);\n+      }\n+\n+      @Override\n+      public void onDataCreate(String path) {\n+        refreshOnUpdate(path);\n+      }\n+\n+      @Override\n+      public void onDataDelete(String path) {\n+        // This is a no-op when a ZNRecord for aggregated storage usage is deleted.\n+        logger.warn(\"StorageUsage is unexpectedly deleted for at path {}\", path);\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageRef.get());\n+  }\n+\n+  @Override\n+  public void registerCallback(Callback cb) {\n+    Objects.requireNonNull(cb, \"Callback has to be non-null\");\n+    if (!callback.compareAndSet(null, cb)) {\n+      throw new IllegalStateException(\"Callback already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container storage usage from the given ZooKeeper path and update the in memory cache. Invoke callback\n+   * if present.\n+   * @param path The ZooKeeper path to fetch the storage usage.\n+   */\n+  private void refreshOnUpdate(String path) {\n+    try {\n+      Map<String, Map<String, Long>> storageUsage = fetchContainerStorageUsageFromPath(path);\n+      containerStorageUsageRef.set(storageUsage);\n+      if (callback.get() != null) {\n+        callback.get().onNewContainerStorageUsage(Collections.unmodifiableMap(storageUsage));\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh storage usage on update of path = {}\", path, e);\n+      containerStorageUsageRef.compareAndSet(null, Collections.EMPTY_MAP);\n+    }\n+  }\n+\n+  /**\n+   * Fetch container storage usage from the given ZooKeeper path.\n+   * @param path The ZooKeeper path to fetch storage usage.\n+   * @return", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4ODE0MQ==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494688141", "bodyText": "I remember we plan to not set hard limit quota for each container and only track their usage growth rate (this probably is not easy to implement). Is that future work?", "author": "jsjtzyy", "createdAt": "2020-09-25T00:53:30Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/JSONStringStorageQuotaSource.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A JSON string implementation of {@link StorageQuotaSource} interface. The entire storage quota is encoded as json\n+ * string in {@link StorageQuotaConfig#containerStorageQuotaInJson}.\n+ */\n+public class JSONStringStorageQuotaSource implements StorageQuotaSource {\n+  private static final Logger logger = LoggerFactory.getLogger(JSONStringStorageQuotaSource.class);\n+\n+  private final Map<String, Map<String, Long>> containerStorageQuota;\n+  private final StorageQuotaConfig config;\n+\n+  /**\n+   * Constructor to create a {@link JSONStringStorageQuotaSource}.\n+   * @param config The {@link StorageQuotaSource}.\n+   * @throws IOException\n+   */\n+  public JSONStringStorageQuotaSource(StorageQuotaConfig config) throws IOException {\n+    this.config = config;\n+    Map<String, Map<String, Long>> quota = Collections.EMPTY_MAP;\n+    if (config.containerStorageQuotaInJson != null && !config.containerStorageQuotaInJson.trim().isEmpty()) {\n+      ObjectMapper mapper = new ObjectMapper();\n+      quota = mapper.readValue(config.containerStorageQuotaInJson, new TypeReference<Map<String, Map<String, Long>>>() {", "originalCommit": "02562ccf5450fe91327cfe3676f90eaa120a0437", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3NzYyNw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r494777627", "bodyText": "This is for open source implementation, the closed source would be implemented in ambryli.", "author": "justinlin-linkedin", "createdAt": "2020-09-25T06:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4ODE0MQ=="}], "type": "inlineReview"}, {"oid": "a06a36025d40a49788218458455e6dbc21b953e1", "url": "https://github.com/linkedin/ambry/commit/a06a36025d40a49788218458455e6dbc21b953e1", "message": "Address comments", "committedDate": "2020-09-25T06:38:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwOTg2NA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496209864", "bodyText": "Sorry about the nitpick again, but I am not sure what do we mean by refresh here? Does it mean refreshing a cache, or a backend. Or does it mean updating something with new information?", "author": "ankagrawal", "createdAt": "2020-09-28T20:22:25Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * An interface to initialize and refresh the storage usage for each container.", "originalCommit": "a06a36025d40a49788218458455e6dbc21b953e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2MTA1Ng==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496361056", "bodyText": "It means if the storage usage is changed, by any other outsider, the implementation should be able to re-fetch the storage usage and refresh the in memory cache.", "author": "justinlin-linkedin", "createdAt": "2020-09-29T03:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwOTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMDU0MA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496210540", "bodyText": "This is more like Account Storage Usage. Because you are basically getting quota usage for all containers of an account.", "author": "ankagrawal", "createdAt": "2020-09-28T20:23:52Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * An interface to initialize and refresh the storage usage for each container.\n+ */\n+public interface StorageUsageRefresher {\n+\n+  /**\n+   * Return the current storage usage for each container. The returned map should be structured as such:\n+   * The key of the map is the account id in string format and the value of the map is the storage usage of each\n+   * container under this account.\n+   * The container usage map's key is the container is in string format, and the value is storage usage of this container.\n+   * @return The current storage usage for each container.\n+   * @throws Exception\n+   */\n+  Map<String, Map<String, Long>> getContainerStorageUsage() throws Exception;", "originalCommit": "a06a36025d40a49788218458455e6dbc21b953e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2MTQ0OA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496361448", "bodyText": "It actually returns container storage usage for all accounts. The outer map's key is the account id, so it covers all the accounts and containers. The reason why this is \"getContainerStorageUsage\" not \"getAccountStorageUsage\" is to emphasize the storage usage is per container, not per account.", "author": "justinlin-linkedin", "createdAt": "2020-09-29T03:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMDU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMzgzMA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496213830", "bodyText": "If only one listener can ever be registered, can we pass it in the constructor?", "author": "ankagrawal", "createdAt": "2020-09-28T20:30:13Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A Helix implementation of {@link StorageUsageRefresher}. A Helix aggregation task, created in ambry-server, would persist\n+ * current storage usage in ZooKeeper periodically. This implementation would fetch the storage usage from zookeeper using\n+ * {@link HelixPropertyStore} and subscribe to the change. This implementation also periodically refetch the storage usage\n+ * from ZooKeeper to keep it up-to-date.\n+ */\n+public class HelixStorageUsageRefresher implements StorageUsageRefresher {\n+  // These two constant fields are shared by other classes. TODO: reuse these two constant fields.\n+  public static final String AGGREGATED_CONTAINER_STORAGE_USAGE_PATH = \"Aggregated_AccountReport\";\n+  public static final String VALID_SIZE_FILED_NAME = \"valid_data_size\";\n+\n+  private static final Logger logger = LoggerFactory.getLogger(HelixStorageUsageRefresher.class);\n+\n+  private final HelixPropertyStore<ZNRecord> helixStore;\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageRef = new AtomicReference<>(null);\n+  private final AtomicReference<Listener> callback = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+\n+  /**\n+   * Constructor to create a {@link HelixStorageUsageRefresher}.\n+   * @param helixStore The {@link HelixPropertyStore} used to fetch storage usage and subscribe to change.\n+   * @param scheduler The {@link ScheduledExecutorService} to schedule a task to periodically refresh the usage.\n+   * @param config The {@link StorageQuotaConfig}.\n+   */\n+  public HelixStorageUsageRefresher(HelixPropertyStore<ZNRecord> helixStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config) {\n+    this.helixStore = Objects.requireNonNull(helixStore, \"HelixPropertyStore can't be null\");\n+    this.scheduler = scheduler;\n+    this.config = config;\n+    subscribeToChange();\n+    initialFetchAndSchedule();\n+  }\n+\n+  /**\n+   * Fetch the storage usage and schedule a task to periodically refresh the storage usage.\n+   */\n+  private void initialFetchAndSchedule() {\n+    Runnable updater = () -> {\n+      try {\n+        Map<String, Map<String, Long>> initialValue =\n+            fetchContainerStorageUsageFromPath(AGGREGATED_CONTAINER_STORAGE_USAGE_PATH);\n+        containerStorageUsageRef.set(initialValue);\n+      } catch (Exception e) {\n+        logger.error(\"Failed to parse the container usage from znode \" + AGGREGATED_CONTAINER_STORAGE_USAGE_PATH, e);\n+        // If we already have a container usage map in memory, then don't replace it with empty map.\n+        containerStorageUsageRef.compareAndSet(null, Collections.EMPTY_MAP);\n+      }\n+    };\n+    updater.run();\n+\n+    if (scheduler != null) {\n+      int initialDelay = new Random().nextInt(config.refresherPollingIntervalMs + 1);\n+      scheduler.scheduleAtFixedRate(updater, initialDelay, config.refresherPollingIntervalMs, TimeUnit.MILLISECONDS);\n+      logger.info(\n+          \"Background storage usage updater will fetch storage usage from remote starting {} ms from now and repeat with interval={} ms\",\n+          initialDelay, config.refresherPollingIntervalMs);\n+    }\n+  }\n+\n+  /**\n+   * Subscribe to storage usage change via helix property store. It will update the in memory cache of the storage usage\n+   * and invoke the callback if present.\n+   */\n+  private void subscribeToChange() {\n+    helixStore.subscribe(AGGREGATED_CONTAINER_STORAGE_USAGE_PATH, new HelixPropertyListener() {\n+      @Override\n+      public void onDataChange(String path) {\n+        refreshOnUpdate(path);\n+      }\n+\n+      @Override\n+      public void onDataCreate(String path) {\n+        refreshOnUpdate(path);\n+      }\n+\n+      @Override\n+      public void onDataDelete(String path) {\n+        // This is a no-op when a ZNRecord for aggregated storage usage is deleted.\n+        logger.warn(\"StorageUsage is unexpectedly deleted for at path {}\", path);\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener cb) {\n+    Objects.requireNonNull(cb, \"Callback has to be non-null\");\n+    if (!callback.compareAndSet(null, cb)) {\n+      throw new IllegalStateException(\"Callback already registered\");", "originalCommit": "a06a36025d40a49788218458455e6dbc21b953e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2MTc1Nw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496361757", "bodyText": "It can be passed in the constructor. Basically the refresher interface will be used in StorageQuotaService, which will be implemented later. If passing to constructor makes more sense, i will change it later when implementing quota service.", "author": "justinlin-linkedin", "createdAt": "2020-09-29T03:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMDA4OA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496220088", "bodyText": "Are we not persisting the current storage usage in zookeeper now?", "author": "ankagrawal", "createdAt": "2020-09-28T20:42:16Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A Helix implementation of {@link StorageUsageRefresher}. A Helix aggregation task, created in ambry-server, would persist", "originalCommit": "a06a36025d40a49788218458455e6dbc21b953e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2MTg2NA==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r496361864", "bodyText": "They are in ZooKeeper. I am using Helix client to fetch storage usage from zookeeper.", "author": "justinlin-linkedin", "createdAt": "2020-09-29T03:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMDA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NDY5Mw==", "url": "https://github.com/linkedin/ambry/pull/1630#discussion_r497084693", "bodyText": "Ok. I was asking because in the comments here we are saying \"A Helix aggregation task, created in ambry-server, would persist current storage usage in ZooKeeper periodically.\" Should the persist part be removed from the comment?", "author": "ankagrawal", "createdAt": "2020-09-29T21:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMDA4OA=="}], "type": "inlineReview"}, {"oid": "c7418db82cb544bda84e425642a1b5ff96c852f8", "url": "https://github.com/linkedin/ambry/commit/c7418db82cb544bda84e425642a1b5ff96c852f8", "message": "Add some quota interfaces and a helix storage usage implenentation", "committedDate": "2020-09-29T01:02:53Z", "type": "commit"}, {"oid": "339e608b9ed01d6a6baf5304cf4fb35899102f84", "url": "https://github.com/linkedin/ambry/commit/339e608b9ed01d6a6baf5304cf4fb35899102f84", "message": "Address comments", "committedDate": "2020-09-29T01:02:53Z", "type": "commit"}, {"oid": "a0afdc51475cdc733c1510887927ce887b3803b0", "url": "https://github.com/linkedin/ambry/commit/a0afdc51475cdc733c1510887927ce887b3803b0", "message": "Address comments", "committedDate": "2020-09-29T03:50:57Z", "type": "commit"}, {"oid": "a0afdc51475cdc733c1510887927ce887b3803b0", "url": "https://github.com/linkedin/ambry/commit/a0afdc51475cdc733c1510887927ce887b3803b0", "message": "Address comments", "committedDate": "2020-09-29T03:50:57Z", "type": "forcePushed"}]}