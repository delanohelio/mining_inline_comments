{"pr_number": 1735, "pr_title": "[named_blobs] Avoid bad affected row count assumptions", "pr_createdAt": "2020-12-21T21:38:42Z", "pr_url": "https://github.com/linkedin/ambry/pull/1735", "timeline": [{"oid": "95f033bfc42fa923914e03fa341fe23d504d2a0b", "url": "https://github.com/linkedin/ambry/commit/95f033bfc42fa923914e03fa341fe23d504d2a0b", "message": "[named_blobs] Avoid bad affected row count assumptions\n\nPreviously, the put code used an \"insert on duplicate key\" expression\nwith conditional assignments. However, this required using the affected\nrows to count how many rows actually changed. If the DB is set up to use\ntriggers that assign other metadata columns, the row may change even if\nthe specific fields set in the update call did not.\n\nAs an alternative, we can switch to the default \"found rows\" jdbc\nbehavior and use an optimistic insert followed by a conditional update.", "committedDate": "2020-12-22T00:32:24Z", "type": "commit"}, {"oid": "95f033bfc42fa923914e03fa341fe23d504d2a0b", "url": "https://github.com/linkedin/ambry/commit/95f033bfc42fa923914e03fa341fe23d504d2a0b", "message": "[named_blobs] Avoid bad affected row count assumptions\n\nPreviously, the put code used an \"insert on duplicate key\" expression\nwith conditional assignments. However, this required using the affected\nrows to count how many rows actually changed. If the DB is set up to use\ntriggers that assign other metadata columns, the row may change even if\nthe specific fields set in the update call did not.\n\nAs an alternative, we can switch to the default \"found rows\" jdbc\nbehavior and use an optimistic insert followed by a conditional update.", "committedDate": "2020-12-22T00:32:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MTA3Mg==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r552251072", "bodyText": "Is there any logic change in this class or only refactoring?", "author": "lightningrob", "createdAt": "2021-01-05T23:04:09Z", "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/NamedBlobPutHandler.java", "diffHunk": "@@ -145,48 +145,6 @@ private void start() {\n       }\n     }\n \n-    /**", "originalCommit": "95f033bfc42fa923914e03fa341fe23d504d2a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MDUzOA==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r557690538", "bodyText": "Just refactoring", "author": "cgtz", "createdAt": "2021-01-14T20:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NjA0Mw==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r552256043", "bodyText": "Still need the indexes (4,5,6)?", "author": "lightningrob", "createdAt": "2021-01-05T23:18:07Z", "path": "ambry-named-mysql/src/main/java/com/github/ambry/named/MySqlNamedBlobDb.java", "diffHunk": "@@ -84,27 +83,32 @@\n       EXPIRES_TS, DELETED_TS, NAMED_BLOBS, ACCOUNT_ID, CONTAINER_ID);\n \n   /**\n-   * Create a blob name to blob ID mapping if a record for that blob name does not exist.\n-   * If there is an existing record but the existing blob was soft deleted or expired, allow it to be overwritten.\n-   * If there is an existing record and the existing blob is still valid (not expired or soft deleted), do not\n-   * overwrite it.\n-   * <p>\n-   * Eventually the put operation will support updates to the mapping in the third case above, but that requires other\n-   * work around concurrency control.\n+   * Attempt to insert a new mapping into the database.\n    */\n-  private static final String PUT_QUERY = String.format(\n-      \"INSERT INTO %1$s (%2$s, %3$s, %4$s, %5$s, %6$s) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE \"\n-          + \"%5$s = IF(%8$s, VALUES(%5$s), %5$s), %6$s = IF(%8$s, VALUES(%6$s), %6$s), %7$s = IF(%8$s, null, %7$s)\",\n-      NAMED_BLOBS, ACCOUNT_ID, CONTAINER_ID, BLOB_NAME, BLOB_ID, EXPIRES_TS, DELETED_TS, IS_DELETED_OR_EXPIRED);\n+  private static final String INSERT_QUERY =\n+      String.format(\"INSERT INTO %s (%s, %s, %4$s, %5$s, %6$s) VALUES (?, ?, ?, ?, ?)\", NAMED_BLOBS, ACCOUNT_ID,", "originalCommit": "95f033bfc42fa923914e03fa341fe23d504d2a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MjA0NA==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r557692044", "bodyText": "You are right that these aren't required. I will make sure to fix this in my next PR", "author": "cgtz", "createdAt": "2021-01-14T20:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1Njk2MQ==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r552256961", "bodyText": "Just curious, why are you updating the blobId column here?", "author": "lightningrob", "createdAt": "2021-01-05T23:20:43Z", "path": "ambry-named-mysql/src/main/java/com/github/ambry/named/MySqlNamedBlobDb.java", "diffHunk": "@@ -84,27 +83,32 @@\n       EXPIRES_TS, DELETED_TS, NAMED_BLOBS, ACCOUNT_ID, CONTAINER_ID);\n \n   /**\n-   * Create a blob name to blob ID mapping if a record for that blob name does not exist.\n-   * If there is an existing record but the existing blob was soft deleted or expired, allow it to be overwritten.\n-   * If there is an existing record and the existing blob is still valid (not expired or soft deleted), do not\n-   * overwrite it.\n-   * <p>\n-   * Eventually the put operation will support updates to the mapping in the third case above, but that requires other\n-   * work around concurrency control.\n+   * Attempt to insert a new mapping into the database.\n    */\n-  private static final String PUT_QUERY = String.format(\n-      \"INSERT INTO %1$s (%2$s, %3$s, %4$s, %5$s, %6$s) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE \"\n-          + \"%5$s = IF(%8$s, VALUES(%5$s), %5$s), %6$s = IF(%8$s, VALUES(%6$s), %6$s), %7$s = IF(%8$s, null, %7$s)\",\n-      NAMED_BLOBS, ACCOUNT_ID, CONTAINER_ID, BLOB_NAME, BLOB_ID, EXPIRES_TS, DELETED_TS, IS_DELETED_OR_EXPIRED);\n+  private static final String INSERT_QUERY =\n+      String.format(\"INSERT INTO %s (%s, %s, %4$s, %5$s, %6$s) VALUES (?, ?, ?, ?, ?)\", NAMED_BLOBS, ACCOUNT_ID,\n+          CONTAINER_ID, BLOB_NAME, BLOB_ID, EXPIRES_TS);\n \n-  private static final String SELECT_FOR_DELETE_QUERY =\n+  /**\n+   * If a record already exists for a named blob, attempt an update if the record in the DB represents an expired or\n+   * deleted blob.\n+   */\n+  private static final String UPDATE_IF_DELETED_OR_EXPIRED_QUERY =\n+      String.format(\"UPDATE %s SET %s = ?, %s = ?, %s = null WHERE %s AND %s\", NAMED_BLOBS, BLOB_ID, EXPIRES_TS,", "originalCommit": "95f033bfc42fa923914e03fa341fe23d504d2a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MjMwMQ==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r557692301", "bodyText": "This would allow one to replace a soft deleted record with a new blob.\nA put to the same key when a value was previously deleted is an allowed operation.", "author": "cgtz", "createdAt": "2021-01-14T20:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MDgyMQ==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r552260821", "bodyText": "What happens to the locked record if the update is not made?  In either case, when does it get unlocked (not sure if this whole thing is inside a transaction)?", "author": "lightningrob", "createdAt": "2021-01-05T23:32:07Z", "path": "ambry-named-mysql/src/main/java/com/github/ambry/named/MySqlNamedBlobDb.java", "diffHunk": "@@ -250,8 +276,8 @@\n       }\n       // only need to issue an update statement if the row was not already marked as deleted.", "originalCommit": "95f033bfc42fa923914e03fa341fe23d504d2a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MzE4Mw==", "url": "https://github.com/linkedin/ambry/pull/1735#discussion_r557693183", "bodyText": "Yep this whole thing is inside a transaction. In this case, the row is unlocked when the transaction is finished (executeTransactionAsync calls transaction.commit() or rollback())", "author": "cgtz", "createdAt": "2021-01-14T20:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MDgyMQ=="}], "type": "inlineReview"}]}