{"pr_number": 1444, "pr_title": "Change BlobStore so records can have a lifeVersion rather than -1", "pr_createdAt": "2020-03-28T00:27:05Z", "pr_url": "https://github.com/linkedin/ambry/pull/1444", "timeline": [{"oid": "2e96b748115a07cbbf83e8dabcd81ef8bff4da3e", "url": "https://github.com/linkedin/ambry/commit/2e96b748115a07cbbf83e8dabcd81ef8bff4da3e", "message": "Fix", "committedDate": "2020-04-01T20:03:28Z", "type": "forcePushed"}, {"oid": "a8eb308915b60225a55fbb9b8eb204880df5343a", "url": "https://github.com/linkedin/ambry/commit/a8eb308915b60225a55fbb9b8eb204880df5343a", "message": "Change BlobStore so records can have a lifeVersion rather than -1", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "1451543b9e79cd4ab783631a43af5a3dd51b56d8", "url": "https://github.com/linkedin/ambry/commit/1451543b9e79cd4ab783631a43af5a3dd51b56d8", "message": "Fix test", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "57e6bb055e2a8a542372fa7e991e247bf86966b7", "url": "https://github.com/linkedin/ambry/commit/57e6bb055e2a8a542372fa7e991e247bf86966b7", "message": "Fix the test failure again", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "3c3a7c428027fbc61567f9766eb917f7dd95ec90", "url": "https://github.com/linkedin/ambry/commit/3c3a7c428027fbc61567f9766eb917f7dd95ec90", "message": "Fix the test", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "url": "https://github.com/linkedin/ambry/commit/bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "message": "Fix", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "url": "https://github.com/linkedin/ambry/commit/bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "message": "Fix", "committedDate": "2020-04-01T20:40:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA1NzMwNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r401057307", "bodyText": "nit: is triggered", "author": "jsjtzyy", "createdAt": "2020-03-31T16:40:04Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageInfo.java", "diffHunk": "@@ -22,6 +22,8 @@\n  */\n public class MessageInfo {\n \n+  // The life version when the operation is trigger by the requests from frontend.", "originalCommit": "2f279b259571be0c1fd1d7590388d67b2ecdb1ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjE2OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402722168", "bodyText": "This can be INFO level. (I finally understand this after reading your comment in BlobIdTransformer)", "author": "jsjtzyy", "createdAt": "2020-04-03T03:50:26Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NDYyNg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402764626", "bodyText": "I will change this to trace. This doesn't seem like an important message to have. I set this to warn when testing.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402722917", "bodyText": "Any concern to use msgInfo.isUndeleted() instead of false here ? The reason I am asking is in the future we probably forget to update this hard coded value.", "author": "jsjtzyy", "createdAt": "2020-04-03T03:54:01Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }\n         encryptionKey = header.hasEncryptionKeyRecord() ? deserializeBlobEncryptionKey(msgStream) : null;\n         props = deserializeBlobProperties(msgStream);\n         metadata = deserializeUserMetadata(msgStream);\n         blobData = deserializeBlob(msgStream);\n       } else {\n-        throw new IllegalStateException(\"Message cannot be a deleted record \");\n+        throw new IllegalStateException(\"Message cannot be anything rather than put record \");\n       }\n       if (msgInfo.getStoreKey().equals(keyInStream)) {\n         // BlobIDTransformer only exists on ambry-server and replication between servers is relying on blocking channel\n         // which is still using java ByteBuffer. So, no need to consider releasing stuff.\n         // @todo, when netty Bytebuf is adopted for blocking channel on ambry-server, remember to release this ByteBuf.\n         PutMessageFormatInputStream transformedStream =\n             new PutMessageFormatInputStream(keyInStream, encryptionKey, props, metadata,\n-                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType());\n+                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType(),\n+                msgInfo.getLifeVersion());\n         MessageInfo transformedMsgInfo =\n             new MessageInfo(keyInStream, transformedStream.getSize(), msgInfo.isDeleted(), msgInfo.isTtlUpdated(),\n-                msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(), msgInfo.getContainerId(),\n-                msgInfo.getOperationTimeMs());\n+                false, msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(),", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNTYxMA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402725610", "bodyText": "Actually, after second thought, shouldn't this be false for all three boolean variables (deleted, ttlUpdated, undeleted)? Since this is PUT record only, hmm, probably isTtlUpdated() is still required. (Correct me if I am wrong)", "author": "jsjtzyy", "createdAt": "2020-04-03T04:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NTAwNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402765007", "bodyText": "you are right, this is a put, all the flags would e nullified anyway in the PersistentIndex anyway. But we still have to keep ttl update flag to be the same value as in the messageinfo since we will latter use it to apply a ttl update record.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyODMxOQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402728319", "bodyText": "Why do we need this log? Can it be debug level?", "author": "jsjtzyy", "createdAt": "2020-04-03T04:19:06Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java", "diffHunk": "@@ -182,6 +182,7 @@ public void handlePutRequest(NetworkRequest request) throws IOException, Interru\n         metrics.blobSizeInBytes.update(receivedRequest.getBlobSize());\n         metrics.blobUserMetadataSizeInBytes.update(receivedRequest.getUsermetadata().limit());\n         if (notification != null) {\n+          logger.info(\"AmbryRequests: write key \" + receivedRequest.getBlobId() + \" at port \" + currentNode.getPort());", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NTU1OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402765558", "bodyText": "sorry this is for testing, will remove it", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyODMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402729785", "bodyText": "Sorry, I forgot why we use this ctor of MessageInfo when handling undelete request, in which undeleted is false. Could you explain again?", "author": "jsjtzyy", "createdAt": "2020-04-03T04:26:04Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java", "diffHunk": "@@ -651,7 +654,7 @@ public void handleUndeleteRequest(NetworkRequest request) throws IOException, In\n         BlobId convertedBlobId = (BlobId) convertedStoreKey;\n         MessageInfo info =\n             new MessageInfo(convertedBlobId, -1, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n-                undeleteRequest.getOperationTimeMs());\n+                undeleteRequest.getOperationTimeMs(), MessageInfo.LIFE_VERSION_FROM_FRONTEND);", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NjkwMA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402766900", "bodyText": "The message info serves different purposes in different components. When transmitting it between server and server or between server and frontend, it carries the current state of the blob, so it has to has undelete/delete/ttl update flags. When passing it to blobstore method, it only carries the key, operation timestamp and the the lifeVersion. For example, then passing message info to blobstore.undelete, we know we have to undelete this blob so the undelete flag will be ignored.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyODI2Nw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403128267", "bodyText": "This makes sense, but it doesn't have any side effect if we explicitly specify undelete is true in the ctor, does it?", "author": "jsjtzyy", "createdAt": "2020-04-03T16:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1NzE2Nw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403157167", "bodyText": "it doesn't matter. I will update and add more comments.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T17:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMDczNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402730737", "bodyText": "can be INFO level", "author": "jsjtzyy", "createdAt": "2020-04-03T04:30:18Z", "path": "ambry-replication/src/main/java/com/github/ambry/replication/BlobIdTransformer.java", "diffHunk": "@@ -157,6 +160,12 @@ private Message newMessage(InputStream inputStream, StoreKey newKey, MessageInfo\n     BlobId newBlobId = (BlobId) newKey;\n \n     if (headerFormat.isPutRecord()) {\n+      if (headerFormat.hasLifeVersion() && headerFormat.getLifeVersion() != oldMessageInfo.getLifeVersion()) {\n+        // The original Put buffer might have lifeVersion as 0, but the message info might have a higher lifeVersion.\n+        logger.trace(", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NzM1OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402767358", "bodyText": "I will keep it as trace, this is not really important.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMDczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjUxNQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402732515", "bodyText": "Try to understand why we don't insert infoFound.getLifeVersion() into constructed new message info.", "author": "jsjtzyy", "createdAt": "2020-04-03T04:38:00Z", "path": "ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java", "diffHunk": "@@ -204,6 +204,11 @@ public void send(Send request) {\n                 infoFound = new MessageInfo(putMsgInfo.getStoreKey(), putMsgInfo.getSize(), true, false,\n                     putMsgInfo.getExpirationTimeInMs(), putMsgInfo.getAccountId(), putMsgInfo.getContainerId(),\n                     putMsgInfo.getOperationTimeMs());", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2ODY2MA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402768660", "bodyText": "oh, we should, will update.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjk5MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402732991", "bodyText": "I am curious how much difference it has with this minor change.", "author": "jsjtzyy", "createdAt": "2020-04-03T04:40:13Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java", "diffHunk": "@@ -488,7 +488,7 @@ void trackUpdate(String host, int port, UpdateType updateType) {\n    * @throws InterruptedException\n    */\n   boolean awaitBlobCreations() throws InterruptedException {\n-    return creationHelper.await(10, TimeUnit.SECONDS);\n+    return creationHelper.await(11, TimeUnit.SECONDS);", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2OTM5Mw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402769393", "bodyText": "typo", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQyNg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402733426", "bodyText": "if this is no longer valid, can we remove it?", "author": "jsjtzyy", "createdAt": "2020-04-03T04:42:15Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java", "diffHunk": "@@ -141,10 +141,11 @@ public void run() {\n                     System.out.println(exceptionMsg);\n                     throw new IllegalStateException(exceptionMsg);\n                   }\n-                  checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput));\n+                  // blob property doesn't have the correct expiration time after ttl update.\n+                  //checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput), \"blobproperty\");", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3MDU3MA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402770570", "bodyText": "yeap", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQ4OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402733488", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-04-03T04:42:30Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java", "diffHunk": "@@ -240,22 +241,27 @@ public void run() {\n                   if (ByteBuffer.wrap(blobout).compareTo(ByteBuffer.wrap(payload.blob)) != 0) {\n                     throw new IllegalStateException();\n                   }\n-                  checkExpiryTimeMatch(payload,\n-                      ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()));\n+                  //checkExpiryTimeMatch(payload,\n+                  //    ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()),\n+                  //    \"blobproperty in bloball\");", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDA2OQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402740069", "bodyText": "Is this for debug purpose? If it's really worth logging, how about using logger.trace ?", "author": "jsjtzyy", "createdAt": "2020-04-03T05:10:45Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -410,15 +409,21 @@ public void put(MessageWriteSet messageSetToWrite) throws StoreException {\n             ArrayList<IndexEntry> indexEntries = new ArrayList<>(messageInfo.size());\n             for (MessageInfo info : messageInfo) {\n               FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n-              IndexValue value = new IndexValue(info.getSize(), fileSpan.getStartOffset(), info.getExpirationTimeInMs(),\n-                  info.getOperationTimeMs(), info.getAccountId(), info.getContainerId());\n+              // Put from frontend should always use 0 as lifeVersion. (0 is the starting life version number for any data).\n+              // Put from replication or recovery should use liferVersion as it's.\n+              short lifeVersion = IndexValue.hasLifeVersion(info.getLifeVersion()) ? info.getLifeVersion() : (short) 0;\n+              IndexValue value =\n+                  new IndexValue(info.getSize(), fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE,\n+                      info.getExpirationTimeInMs(), info.getOperationTimeMs(), info.getAccountId(),\n+                      info.getContainerId(), lifeVersion);\n               IndexEntry entry = new IndexEntry(info.getStoreKey(), value, info.getCrc());\n               indexEntries.add(entry);\n               endOffsetOfLastMessage = fileSpan.getEndOffset();\n             }\n             FileSpan fileSpan = new FileSpan(indexEntries.get(0).getValue().getOffset(), endOffsetOfLastMessage);\n             index.addToIndex(indexEntries, fileSpan);\n             for (IndexEntry newEntry : indexEntries) {\n+              System.out.println(\"Handle new put Entry for key \" + newEntry.getKey());", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3MDcwNA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402770704", "bodyText": "will remove, for debug purpose.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDA2OQ=="}], "type": "inlineReview"}, {"oid": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "url": "https://github.com/linkedin/ambry/commit/a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "message": "Address comments", "committedDate": "2020-04-03T07:04:43Z", "type": "commit"}, {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "url": "https://github.com/linkedin/ambry/commit/664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "message": "Address comments", "committedDate": "2020-04-03T17:19:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403232649", "bodyText": "I raised the same question in the other PR:\nwhy not check storeValidateAuthorization here? assume replication always correct?", "author": "zzmao", "createdAt": "2020-04-03T18:38:06Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -470,23 +474,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTA2MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403269061", "bodyText": "I suppose so. Replication thread would replicating same blob record from different nodes, which means this record is already verified in different nodes.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3MDM5MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403270391", "bodyText": "I suppose I can verify it here again, there is no harm of doing it again.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMzMyOA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403233328", "bodyText": "minor: use isTtlUpdate() to make it consistent with other Ttl", "author": "zzmao", "createdAt": "2020-04-03T18:38:53Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -542,9 +542,11 @@ void addEntry(IndexEntry entry, Offset fileEndOffset) throws StoreException {\n       }\n       if (resetKey == null) {\n         PersistentIndex.IndexEntryType type = PersistentIndex.IndexEntryType.PUT;\n-        if (entry.getValue().isFlagSet(IndexValue.Flags.Delete_Index)) {\n+        if (entry.getValue().isDelete()) {\n           type = PersistentIndex.IndexEntryType.DELETE;\n-        } else if (entry.getValue().isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+        } else if (entry.getValue().isUndelete()) {\n+          type = PersistentIndex.IndexEntryType.UNDELETE;\n+        } else if (entry.getValue().isTTLUpdate()) {", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTE2MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403269161", "bodyText": "I will update.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMzMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODY1MA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403198650", "bodyText": "nit: (1) StoreKey (2) extra space between LifeVersion and should", "author": "jsjtzyy", "createdAt": "2020-04-03T17:58:06Z", "path": "ambry-api/src/main/java/com/github/ambry/store/Store.java", "diffHunk": "@@ -41,29 +41,37 @@\n   StoreInfo get(List<? extends StoreKey> ids, EnumSet<StoreGetOptions> storeGetOptions) throws StoreException;\n \n   /**\n-   * Puts a set of messages into the store\n+   * Puts a set of messages into the store. When the lifeVersion is {@link MessageInfo#LIFE_VERSION_FROM_FRONTEND}, this\n+   * method is invoked by the responding to the frontend request. Otherwise, it's invoked in the replication thread.\n    * @param messageSetToWrite The message set to write to the store\n+   *                          Only the Storekey, OperationTime, ExpirationTime, LifeVersion  should be used in this method.", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTI5OQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403225299", "bodyText": "When revisiting this piece of code, I find line 518 directly throws exception if it's deleted without checking the version. I feel like it may have edge case there. Could you double check if it needs to be updated?", "author": "jsjtzyy", "createdAt": "2020-04-03T18:29:14Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -470,23 +474,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()\n+              > info.getLifeVersion())) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.Life_Version_Conflict);\n+          }\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(info.getLifeVersion());\n         }\n-        indexValuesToDelete.add(value);\n-        lifeVersions.add(value.getLifeVersion());\n       }\n       synchronized (storeWriteLock) {\n         Offset currentIndexEndOffset = index.getCurrentEndOffset();", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3NzE2Ng==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403277166", "bodyText": "It could potentially be a edge case here, when the frontend deletes a blob and replication for this delete arrive at the same time. I will check the lifeVersion before throwing an exception.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MjczOQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403242739", "bodyText": "minor: line 847 in PersistentIndex, the java doc for lifeVersion should be delete record rather than undelete record", "author": "jsjtzyy", "createdAt": "2020-04-03T18:52:15Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -525,7 +545,8 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         int correspondingPutIndex = 0;\n         for (MessageInfo info : updatedInfos) {\n           FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n-          IndexValue deleteIndexValue = index.markAsDeleted(info.getStoreKey(), fileSpan, info.getOperationTimeMs());\n+          IndexValue deleteIndexValue =\n+              index.markAsDeleted(info.getStoreKey(), fileSpan, null, info.getOperationTimeMs(), info.getLifeVersion());", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3ODM3MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403278371", "bodyText": "will update.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTY4Mg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403249682", "bodyText": "In which case the value could be null ?", "author": "jsjtzyy", "createdAt": "2020-04-03T19:01:55Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -922,18 +921,18 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n-      short lifeVersion) throws StoreException {\n+  IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n+      throws StoreException {\n     validateFileSpan(fileSpan, true);\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3OTgzOQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403279839", "bodyText": "Honestly i don't know it was here for a while then.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTY5Mg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403251692", "bodyText": "In this PR, hasLifeVersion is always false, right? (because BlobStore.handleTtlUpate passes LIFE_VERSION_FROM_FRONTEND into this method)", "author": "jsjtzyy", "createdAt": "2020-04-03T19:04:40Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -922,18 +921,18 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n-      short lifeVersion) throws StoreException {\n+  IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n+      throws StoreException {\n     validateFileSpan(fileSpan, true);\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n-    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    if (value != null && value.isDelete()) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+    } else if (value != null && value.isTTLUpdate()) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n     } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI4MDMyMg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403280322", "bodyText": "that's right, TTL_UPDATE record will always follow a PUT or an UNDELETE.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403257597", "bodyText": "Could you explain why we pass info.getLifeVersion() rather than resolved lifeVersion to message info?", "author": "jsjtzyy", "createdAt": "2020-04-03T19:17:01Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -660,15 +686,16 @@ public short undelete(MessageInfo info) throws StoreException {\n       StoreKey id = info.getStoreKey();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n       List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n-      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      index.validateSanityForUndelete(id, values, info.getLifeVersion());\n       IndexValue latestValue = values.get(0);\n       short lifeVersion = (short) (latestValue.getLifeVersion() + 1);\n       MessageFormatInputStream stream =\n           new UndeleteMessageFormatInputStream(id, info.getAccountId(), info.getContainerId(),\n               info.getOperationTimeMs(), lifeVersion);\n       // Update info to add stream size;\n       info =\n-          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs());\n+          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs(),\n+              info.getLifeVersion());", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI4Mzc3Mg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403283772", "bodyText": "LifeVersion is used in two different places in undelete method. One is to construct an UndeleteMessageFormatInputStream, and we have to use a resolved lifeVersion, it can't be -1.\nThe other one is to verify the validity of a Undelete IndexEntry in PersistentIndex. when verifying undelete entry in persistent index (in method markAsUndelete), we need to pass lifeVersion as -1 if it's -1 in the message info so the persistentIndex knows it's from frontend.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3ODQ2Mw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403378463", "bodyText": "That's true.  I took a look at writeTo(log) method and found life version is not actually used when persisting to log. Then, it should be fine.", "author": "jsjtzyy", "createdAt": "2020-04-03T23:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw=="}], "type": "inlineReview"}, {"oid": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "url": "https://github.com/linkedin/ambry/commit/85d8ac616fb3f7734f9a3e265c583a5298c16365", "message": "Address comments", "committedDate": "2020-04-03T19:55:24Z", "type": "commit"}]}