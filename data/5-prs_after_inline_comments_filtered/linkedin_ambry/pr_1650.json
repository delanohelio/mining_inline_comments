{"pr_number": 1650, "pr_title": "[StorageQuota] Adding StorageQuotaEnforcer and StorageQuotaService", "pr_createdAt": "2020-10-07T22:04:59Z", "pr_url": "https://github.com/linkedin/ambry/pull/1650", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzNTAxNQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503435015", "bodyText": "Minor: since this is not in specific class, the name is too broad. Can we call it QuotaMode?", "author": "jsjtzyy", "createdAt": "2020-10-12T17:25:51Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/Mode.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * Quota service mode. If mode is tracking, it will not throttle traffics even if the quota is exceeded.\n+ */\n+public enum Mode {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzODU1Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503438553", "bodyText": "same here, maybe call it QuotaOperation?", "author": "jsjtzyy", "createdAt": "2020-10-12T17:33:18Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/Operation.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * Operations for quota service.\n+ */\n+public enum Operation {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzOTA3Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503439076", "bodyText": "Why we use Upload instead of Post? I think latter one is consistent with what we use in code base.", "author": "jsjtzyy", "createdAt": "2020-10-12T17:34:23Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/Operation.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * Operations for quota service.\n+ */\n+public enum Operation {\n+  Upload, Delete, TtlUpdate", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1ODc1OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503558759", "bodyText": "typo: ZooKeeper", "author": "jsjtzyy", "createdAt": "2020-10-12T22:08:45Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -18,13 +18,21 @@\n  */\n public class StorageQuotaConfig {\n   public static final String STORAGE_QUOTA_PREFIX = \"storage.quota.\";\n+  public static final String HELIX_PROPERTY_ROOT_PATH = STORAGE_QUOTA_PREFIX + \"helix.property.root.path\";\n   public static final String ZK_CLIENT_CONNECT_ADDRESS = STORAGE_QUOTA_PREFIX + \"zk.client.connect.address\";\n   public static final String REFRESHER_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"refresher.polling.interval.ms\";\n   public static final String CONTAINER_STORAGE_QUOTA_IN_JSON = STORAGE_QUOTA_PREFIX + \"container.storage.quota.in.json\";\n   public static final String SOURCE_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"source.polling.interval.ms\";\n \n   //////////////// Config for HelixStorageUsageRefresher ///////////////\n \n+  /**\n+   * The root path of helix property store in ZooKeepr for HelixStorageUsageRefresher. Must start with {@code /}, and", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1OTU4Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503559586", "bodyText": "Minor: Use getIntInRange for sourcePollingIntervalMs as well.", "author": "jsjtzyy", "createdAt": "2020-10-12T22:11:02Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -73,6 +81,7 @@\n    * @param verifiableProperties The {@link VerifiableProperties} that contains all the properties.\n    */\n   public StorageQuotaConfig(VerifiableProperties verifiableProperties) {\n+    helixPropertyRootPath = verifiableProperties.getString(HELIX_PROPERTY_ROOT_PATH);\n     zkClientConnectAddress = verifiableProperties.getString(ZK_CLIENT_CONNECT_ADDRESS);\n     refresherPollingIntervalMs =", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1OTg3OA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503559878", "bodyText": "typo: usage", "author": "jsjtzyy", "createdAt": "2020-10-12T22:11:54Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDg1OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503570859", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-10-12T22:46:19Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTQ5Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503571496", "bodyText": "btw, the quota change comes from Nuage, right?", "author": "jsjtzyy", "createdAt": "2020-10-12T22:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NDYyNw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503684627", "bodyText": "yes, it comes from nuage, but it's stored in a different service, called QuotaIn.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T05:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTMwNQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503571305", "bodyText": "if {@link StorageQuotaEnforcer} doesn't want to listen on the changes. does this mean there is no listener in StorageQuotaEnforcer?  (If so, can you tweak the comment?)", "author": "jsjtzyy", "createdAt": "2020-10-12T22:47:32Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NDA0NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505654045", "bodyText": "Why would getUsageRefresherListener() be called for an object that doesn't want to listen? When enforcer has to listen to the changes, it would just say StorageUsafeRefresher.addListener() or StorageQuotaRefresher.addListener(). If it doesn't want to listen, then it should not call addListener.", "author": "ankagrawal", "createdAt": "2020-10-15T15:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NTM1NA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503575354", "bodyText": "nit : @code -> @link", "author": "jsjtzyy", "createdAt": "2020-10-12T22:59:07Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * {@code StorageQuotaServiceFactory} is a factory to generate all the supporting cast required to instantiate an", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NzA3OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503577079", "bodyText": "typo in comment: The container usage map's key is the container id in string format", "author": "jsjtzyy", "createdAt": "2020-10-12T23:04:57Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java", "diffHunk": "@@ -29,4 +29,20 @@\n    * @return The storage quota for each container.\n    */\n   Map<String, Map<String, Long>> getContainerQuota();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDE1Nw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503580157", "bodyText": "Looks like the intellij complains about casting and unboxing. Try changing it following way:\n    long quota = storageQuota.getOrDefault(String.valueOf(accountId), new HashMap<>())\n        .getOrDefault(String.valueOf(containerId), Long.MAX_VALUE);", "author": "jsjtzyy", "createdAt": "2020-10-12T23:15:57Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MTQ5MA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503581490", "bodyText": "Looks like unboxing is not necessary. So v.longValue() -> v", "author": "jsjtzyy", "createdAt": "2020-10-12T23:20:59Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MjQ1NA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503582454", "bodyText": "return mode == Mode.Throttling ? exceedQuota.get() : false;", "author": "jsjtzyy", "createdAt": "2020-10-12T23:24:31Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDQ5MQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503584491", "bodyText": "Every time we call getUsageRefresherListener(), it instantiates a new StorageUsageRefresher.Listener, is this intended?", "author": "jsjtzyy", "createdAt": "2020-10-12T23:32:03Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjM5NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503686395", "bodyText": "we will only call it once.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDU5Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503584593", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-10-12T23:32:27Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return new StorageQuotaSource.Listener() {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjQ3NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503686475", "bodyText": "we will only call it once.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTk3NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503585975", "bodyText": "Maybe out of scope but we should consider precluding deleted container in both storageUsage and storageQuota maps.", "author": "jsjtzyy", "createdAt": "2020-10-12T23:37:35Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return new StorageQuotaSource.Listener() {\n+      @Override\n+      public void onNewContainerStorageQuota(Map<String, Map<String, Long>> containerStorageQuota) {\n+        Map<String, Map<String, Long>> newQuota = new HashMap<>();\n+        initMap(containerStorageQuota, newQuota, false);\n+        storageQuota = newQuota;\n+      }\n+    };\n+  }\n+\n+  private void initMap(Map<String, Map<String, Long>> mapWithValue, Map<String, Map<String, Long>> mapToInit,\n+      boolean concurrentMap) {\n+    for (Map.Entry<String, Map<String, Long>> mapEntry : mapWithValue.entrySet()) {\n+      Map<String, Long> innerMap = mapToInit.computeIfAbsent(mapEntry.getKey(),\n+          k -> concurrentMap ? new ConcurrentHashMap<>() : new HashMap<>());\n+      for (Map.Entry<String, Long> innerMapEntry : mapEntry.getValue().entrySet()) {\n+        // Replace the value in the map anyway.\n+        innerMap.put(innerMapEntry.getKey(), innerMapEntry.getValue());", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NzAxMg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503687012", "bodyText": "hmm, this would be complicated since storage has to know about the deleted container. I would have to expose another  method in StorageQuotaService for that. Will do this later. Thanks for bring this up, will do this later, by adding a TODO .", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NjU5Mg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503586592", "bodyText": "typo: storageQuotaEnforcer", "author": "jsjtzyy", "createdAt": "2020-10-12T23:40:03Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.utils.Utils;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * An implementation for {@link StorageQuotaService}.\n+ */\n+public class AmbryStorageQuotaService implements StorageQuotaService {\n+\n+  private final StorageUsageRefresher storageUsageRefresher;\n+  private final StorageQuotaSource storageQuotaSource;\n+  private final StorageQuotaEnforcer storageQuotaEnforer;", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MjA1Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503592056", "bodyText": "The scheduler will be used in future PR?", "author": "jsjtzyy", "createdAt": "2020-10-12T23:52:27Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.utils.Utils;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * An implementation for {@link StorageQuotaService}.\n+ */\n+public class AmbryStorageQuotaService implements StorageQuotaService {\n+\n+  private final StorageUsageRefresher storageUsageRefresher;\n+  private final StorageQuotaSource storageQuotaSource;\n+  private final StorageQuotaEnforcer storageQuotaEnforer;\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+\n+  public AmbryStorageQuotaService(StorageUsageRefresher storageUsageRefresher, StorageQuotaSource storageQuotaSource,\n+      StorageQuotaEnforcer storageQuotaEnforcer, ScheduledExecutorService scheduler, StorageQuotaConfig config) {\n+    this.storageUsageRefresher = Objects.requireNonNull(storageUsageRefresher, \"StorageUsageRefresher empty\");\n+    this.storageQuotaSource = Objects.requireNonNull(storageQuotaSource, \"StorageQuotaSource empty\");\n+    this.storageQuotaEnforer = Objects.requireNonNull(storageQuotaEnforcer, \"StorageQuotaEnforcer empty\");\n+    this.config = Objects.requireNonNull(config, \"StorageQuotaConfig empty\");\n+    this.scheduler = scheduler;", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4ODExNg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503688116", "bodyText": "it's already used in helixStorageUsageRefresher, passing it to storagequotaservice is to close it when shutting the service down.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwNjkwNg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r506706906", "bodyText": "I understand that. I guess I didn't make it clear previously. The comment is together with the comment in AmbryStorageQuotaServiceFactory class where I suggested moving scheduler, quotaSource etc into  AmbryStorageQuotaService ctor.  That comment was resolved but I didn't see the change. Did I miss anything?", "author": "jsjtzyy", "createdAt": "2020-10-16T20:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MjA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MzE0OA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503593148", "bodyText": "unused import", "author": "jsjtzyy", "createdAt": "2020-10-12T23:53:43Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5Mzk3OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503593979", "bodyText": "I guess you wanted to pass metrics into AmbryStorageQuotaService", "author": "jsjtzyy", "createdAt": "2020-10-12T23:55:12Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.Utils;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+\n+\n+/**\n+ * An factory implementation for {@link StorageQuotaService}. It uses {@link HelixStorageUsageRefresher}, {@link JSONStringStorageQuotaSource}\n+ * and {@link AmbryStorageQuotaEnforcer}.\n+ */\n+public class AmbryStorageQuotaServiceFactory implements StorageQuotaServiceFactory {\n+  private static final String STORAGE_QUOTA_SERVICE_PREFIX = \"storage-quota-service\";\n+  private final StorageQuotaService storageQuotaService;\n+\n+  public AmbryStorageQuotaServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry)", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4ODczNQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503688735", "bodyText": "oh, yes, i haven't figured out what metric to add, but just put metric registry here.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5Mzk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NTIyMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503595221", "bodyText": "I think all of this can be instantiated in AmbryStorageQuotaService class. Hence, the constructor of AmbryStorageQuotaService can be simplified to:\npublic AmbryStorageQuotaService(StorageQuotaConfig config, StorageQuotaMetrics metrics)", "author": "jsjtzyy", "createdAt": "2020-10-13T00:00:06Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.Utils;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+\n+\n+/**\n+ * An factory implementation for {@link StorageQuotaService}. It uses {@link HelixStorageUsageRefresher}, {@link JSONStringStorageQuotaSource}\n+ * and {@link AmbryStorageQuotaEnforcer}.\n+ */\n+public class AmbryStorageQuotaServiceFactory implements StorageQuotaServiceFactory {\n+  private static final String STORAGE_QUOTA_SERVICE_PREFIX = \"storage-quota-service\";\n+  private final StorageQuotaService storageQuotaService;\n+\n+  public AmbryStorageQuotaServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry)\n+      throws Exception {\n+    StorageQuotaConfig storageQuotaConfig = new StorageQuotaConfig(verifiableProperties);\n+\n+    HelixPropertyStore<ZNRecord> helixStore =\n+        CommonUtils.createHelixPropertyStore(storageQuotaConfig.zkClientConnectAddress,\n+            storageQuotaConfig.helixPropertyRootPath, null);\n+    ScheduledExecutorService scheduler = Utils.newScheduler(1, STORAGE_QUOTA_SERVICE_PREFIX, false);\n+    HelixStorageUsageRefresher storageUsageRefresher =\n+        new HelixStorageUsageRefresher(helixStore, scheduler, storageQuotaConfig);\n+    JSONStringStorageQuotaSource storageQuotaSource = new JSONStringStorageQuotaSource(storageQuotaConfig);\n+    AmbryStorageQuotaEnforcer storageQuotaEnforcer = new AmbryStorageQuotaEnforcer();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NTMzNA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503595334", "bodyText": "Remove this.", "author": "jsjtzyy", "createdAt": "2020-10-13T00:00:32Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -140,6 +140,7 @@ public void registerListener(Listener cb) {\n   private void refreshOnUpdate(String path) {\n     try {\n       Map<String, Map<String, Long>> storageUsage = fetchContainerStorageUsageFromPath(path);\n+      System.out.println(\"Getting this from update: \" + storageUsage);", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "url": "https://github.com/linkedin/ambry/commit/84a9064a2f1b62e3a5a6980ade79871ad903442f", "message": "Address comments", "committedDate": "2020-10-13T06:20:22Z", "type": "forcePushed"}, {"oid": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "url": "https://github.com/linkedin/ambry/commit/ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "message": "More typos", "committedDate": "2020-10-13T17:54:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDYyMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505640621", "bodyText": "The comments here are awesome. Thanks for adding detailed comments.", "author": "ankagrawal", "createdAt": "2020-10-15T15:33:57Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NTMyOA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505655328", "bodyText": "See comments for getUsageRefresherListener", "author": "ankagrawal", "createdAt": "2020-10-15T15:54:17Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener();", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMjE0MQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505922141", "bodyText": "Updated, added a registerListeners method in StorageQuotaEnforcer.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NTMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NTY4Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505655683", "bodyText": "typo: \"if\" the  given ....", "author": "ankagrawal", "createdAt": "2020-10-15T15:54:48Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener();\n+\n+  /**\n+   * Return true if the given {@link QuotaOperation} should be throttled.\n+   * @param accountId The accountId of this operation.\n+   * @param containerId The containerId of this operation.\n+   * @param op The {@link QuotaOperation}.\n+   * @param size The size of this operation. eg, if the op is {@link QuotaOperation#Post}, size if the size of the content.\n+   * @return True is the given {@link QuotaOperation} should be throttled.", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1ODYyOQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505658629", "bodyText": "Is StorageQuotaEnforcer going to be per container or for all containers. If it is going to be for all the containers, then is there a possibility that different containers might have different QuotaModes? If it is per container, then maybe we should remove containerId and accountId arguments from shouldThrottle.", "author": "ankagrawal", "createdAt": "2020-10-15T15:58:46Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener();\n+\n+  /**\n+   * Return true if the given {@link QuotaOperation} should be throttled.\n+   * @param accountId The accountId of this operation.\n+   * @param containerId The containerId of this operation.\n+   * @param op The {@link QuotaOperation}.\n+   * @param size The size of this operation. eg, if the op is {@link QuotaOperation#Post}, size if the size of the content.\n+   * @return True is the given {@link QuotaOperation} should be throttled.\n+   */\n+  boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size);\n+\n+  /**\n+   * Change the {@link StorageQuotaEnforcer}'s mode to the given value. If the mode is {@link QuotaMode#Tracking}, then {@link StorageQuotaEnforcer}\n+   * should never return true in {@link #shouldThrottle} method.\n+   * @param mode The new value for {@link QuotaMode}.\n+   */\n+  void setQuotaMode(QuotaMode mode);", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMzQxMg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505923412", "bodyText": "the quota is enforced per container. Different containers would have different quota, thus will be throttled at different time. QuotaMode now is a global setting. If we want to stop throttling per container. Then the current interface would have to be changed. I probably would have to revisit the interface when I start implementing for the closed source ambry.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1ODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg0MDEwNA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r507840104", "bodyText": "Nit: maybe name it setGlobalQuotaMode to make it explicit.", "author": "ankagrawal", "createdAt": "2020-10-19T15:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1ODYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2NDAxNg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505664016", "bodyText": "Its not clear to me whats the difference between StorageQuotaService and StorageQuotaEnforcer. This interface seems to have same methods as StorageQuotaEnforcer.", "author": "ankagrawal", "createdAt": "2020-10-15T16:06:23Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.Container;\n+\n+\n+/**", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyNDcwOA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505924708", "bodyText": "StorageQuotaService is more like a wrapper, it's responsibility is to 1) choose different implementation of StorageQuotaSource StorageUsageRefresher and StorageQuotaEnforcer 2) glue them together and make it work.\nBut mainly the reason why I have StorageQuotaService and StorageQuotaServiceFactory is to use different implementations of those components. In closed source ambry, I would create a QuotaInStorageQuotaSource, which will get the quota from QuotaIn service, a HelixBasedDataPlanStorageUsageRefresher, which will get the monthly storage usage instead of total usage from helix. And probably a different storage quota enforcer.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2NDAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3MTgxMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505671811", "bodyText": "It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.", "author": "ankagrawal", "createdAt": "2020-10-15T16:18:00Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link QuotaOperation#Post}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile QuotaMode mode = QuotaMode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size) {\n+    if (op != QuotaOperation.Post) {\n+      return false;\n+    }\n+    long quota = storageQuota.getOrDefault(String.valueOf(accountId), new HashMap<>())\n+        .getOrDefault(String.valueOf(containerId), Long.MAX_VALUE);\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v + size < quota) {\n+            return v + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v;\n+          }\n+        });\n+    return mode == QuotaMode.Throttling ? exceedQuota.get() : false;\n+  }\n+\n+  @Override\n+  public void setQuotaMode(QuotaMode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMjY5Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505922693", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3MTgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3MzExMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505673111", "bodyText": "javadocs?", "author": "ankagrawal", "createdAt": "2020-10-15T16:20:09Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link QuotaOperation#Post}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile QuotaMode mode = QuotaMode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size) {\n+    if (op != QuotaOperation.Post) {\n+      return false;\n+    }\n+    long quota = storageQuota.getOrDefault(String.valueOf(accountId), new HashMap<>())\n+        .getOrDefault(String.valueOf(containerId), Long.MAX_VALUE);\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v + size < quota) {\n+            return v + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v;\n+          }\n+        });\n+    return mode == QuotaMode.Throttling ? exceedQuota.get() : false;\n+  }\n+\n+  @Override\n+  public void setQuotaMode(QuotaMode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return new StorageQuotaSource.Listener() {\n+      @Override\n+      public void onNewContainerStorageQuota(Map<String, Map<String, Long>> containerStorageQuota) {\n+        Map<String, Map<String, Long>> newQuota = new HashMap<>();\n+        initMap(containerStorageQuota, newQuota, false);\n+        storageQuota = newQuota;\n+      }\n+    };\n+  }\n+\n+  private void initMap(Map<String, Map<String, Long>> mapWithValue, Map<String, Map<String, Long>> mapToInit,", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "url": "https://github.com/linkedin/ambry/commit/d1e212e204f2db17b34154b168c1cf7a99d5a80f", "message": "Address comments", "committedDate": "2020-10-16T00:06:45Z", "type": "forcePushed"}, {"oid": "0a4fb4b31058ade6baad5da88e787d9f8ab69651", "url": "https://github.com/linkedin/ambry/commit/0a4fb4b31058ade6baad5da88e787d9f8ab69651", "message": "[StorageQuota] Adding StorageQuotaEnforcer and StorageQuotaService", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "58d694fd1c2a4b20f3e957a1b87c350d11b903c1", "url": "https://github.com/linkedin/ambry/commit/58d694fd1c2a4b20f3e957a1b87c350d11b903c1", "message": "Add comments", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "d4e52b30001a2d5d62583ad7f71abdfad5235a11", "url": "https://github.com/linkedin/ambry/commit/d4e52b30001a2d5d62583ad7f71abdfad5235a11", "message": "Add more tests", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "d5ab3cc47c033047279c19bfe02347371b3a08d9", "url": "https://github.com/linkedin/ambry/commit/d5ab3cc47c033047279c19bfe02347371b3a08d9", "message": "Address comments", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "4cb78731cef19d328befa284b4819d1560f9c7a5", "url": "https://github.com/linkedin/ambry/commit/4cb78731cef19d328befa284b4819d1560f9c7a5", "message": "Fix typos", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "19ed3281d3b75cd1e54e14732d7386e911ba0e09", "url": "https://github.com/linkedin/ambry/commit/19ed3281d3b75cd1e54e14732d7386e911ba0e09", "message": "More typos", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "url": "https://github.com/linkedin/ambry/commit/daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "message": "Address comments", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "url": "https://github.com/linkedin/ambry/commit/daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "message": "Address comments", "committedDate": "2020-10-19T23:05:30Z", "type": "forcePushed"}, {"oid": "25c6496f806b941b80e40a7ff9e53edbcac07d21", "url": "https://github.com/linkedin/ambry/commit/25c6496f806b941b80e40a7ff9e53edbcac07d21", "message": "Address commments", "committedDate": "2020-10-20T21:19:50Z", "type": "commit"}]}