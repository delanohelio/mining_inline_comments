{"pr_number": 1712, "pr_title": "[StorageQuota] Add a storage usage refresher on top of mysql", "pr_createdAt": "2020-12-02T22:26:33Z", "pr_url": "https://github.com/linkedin/ambry/pull/1712", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc4OTExNg==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535789116", "bodyText": "nit: mysqlStoreRetryMax -> mysqlStoreRetryMaxCount", "author": "jsjtzyy", "createdAt": "2020-12-04T02:27:05Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -76,6 +81,34 @@\n   @Default(\"30 * 60 * 1000\")\n   public final int sourcePollingIntervalMs;\n \n+  /**\n+   * The directory to store quota related backup files. If empty, then backup files will be disabled.\n+   */\n+  @Config(BACKUP_FILE_DIR)\n+  @Default(\"\")\n+  public final String backupFileDir;\n+\n+  /**\n+   * Duration in milliseconds to backoff if the mysql database query failed.\n+   */\n+  @Config(MYSQL_STORE_RETRY_BACKOFF_MS)\n+  @Default(\"10*60*1000\")\n+  public final long mysqlStoreRetryBackoffMs;\n+\n+  /**\n+   * Maximum retry times to execute a mysql database query.\n+   */\n+  @Config(MYSQL_STORE_RETRY_MAX)\n+  @Default(\"1\")\n+  public final int mysqlStoreRetryMax;", "originalCommit": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDQ0Nw==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535864447", "bodyText": "Could you explain the logic here?  Looks like if retries exceeds max count, it resets retries , increments its value and  schedule another round of retry ?", "author": "jsjtzyy", "createdAt": "2020-12-04T06:23:35Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMax) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+      }\n+      retries++;\n+      if (config.mysqlStoreRetryBackoffMs != 0) {\n+        scheduler.schedule(this::fetchMonthlyStorageUsageAndMaybeRetry, config.mysqlStoreRetryBackoffMs,\n+            TimeUnit.MILLISECONDS);\n+      }", "originalCommit": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzODYxMA==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r536338610", "bodyText": "I have made a mistake. I should schedule for next fetch after resetting the retries back to 0 and return.\nThe logic goes like this, assume max retry count is 3. Then after starting to fetching the monthly base, we can try it for 3 times. If for all this 3 times, it failed, then we would just schedule for next fetch.", "author": "justinlin-linkedin", "createdAt": "2020-12-04T19:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDYyNg==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535864626", "bodyText": "return can be removed", "author": "jsjtzyy", "createdAt": "2020-12-04T06:24:01Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMax) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+      }\n+      retries++;\n+      if (config.mysqlStoreRetryBackoffMs != 0) {\n+        scheduler.schedule(this::fetchMonthlyStorageUsageAndMaybeRetry, config.mysqlStoreRetryBackoffMs,\n+            TimeUnit.MILLISECONDS);\n+      }\n+      return;", "originalCommit": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTAyMw==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535865023", "bodyText": "Why we need local variable base?", "author": "jsjtzyy", "createdAt": "2020-12-04T06:25:07Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;", "originalCommit": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2OTQ2Ng==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535869466", "bodyText": "In bootstrap case or containerStorageUsageMonthlyBase cannot be fetched from Mysql or local backup, shouldn't we give it an empty map at line 85?", "author": "jsjtzyy", "createdAt": "2020-12-04T06:37:09Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMax) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+      }\n+      retries++;\n+      if (config.mysqlStoreRetryBackoffMs != 0) {\n+        scheduler.schedule(this::fetchMonthlyStorageUsageAndMaybeRetry, config.mysqlStoreRetryBackoffMs,\n+            TimeUnit.MILLISECONDS);\n+      }\n+      return;\n+    } else {\n+      retries = 0;\n+      tryPersistMonthlyUsage();\n+      scheduleStorageUsageMonthlyBaseFetcher();\n+    }\n+  }\n+\n+  /**\n+   * Schedule the task to fetch storage usage monthly base for next month.\n+   */\n+  private void scheduleStorageUsageMonthlyBaseFetcher() {\n+    long sleepDurationInSecs = secondsToNextTick(currentMonth, config.mysqlMonthlyBaseFetchOffsetSec);\n+    logger.info(\"Schedule to fetch container storage monthly base after \" + sleepDurationInSecs + \" seconds\");\n+    scheduler.schedule(this::fetchStorageUsageMonthlyBase, sleepDurationInSecs, TimeUnit.SECONDS);\n+  }\n+\n+  /**\n+   * The task to fetch storage usage monthly base.\n+   */\n+  void fetchStorageUsageMonthlyBase() {\n+    currentMonth = getCurrentMonth();\n+    fetchMonthlyStorageUsageAndMaybeRetry();\n+  }\n+\n+  /**\n+   * Return {@link #containerStorageUsageMonthlyBase}. Only used in test.\n+   * @return the {@link #containerStorageUsageMonthlyBase}.\n+   */\n+  Map<String, Map<String, Long>> getContainerStorageUsageMonthlyBase() {\n+    return Collections.unmodifiableMap(containerStorageUsageMonthlyBase);\n+  }\n+\n+  /**\n+   * Return {@link BackupFileManager}. Only used in test.\n+   * @return {@link BackupFileManager}.\n+   */\n+  BackupFileManager getBackupFileManager() {\n+    return backupFileManager;\n+  }\n+\n+  /**\n+   * Fetch the storage usage and schedule a task to periodically refresh the storage usage.\n+   */\n+  private void initialFetchAndSchedule() {\n+    Runnable updater = () -> {\n+      try {\n+        Map<String, Map<String, Long>> base = containerStorageUsageMonthlyBase;", "originalCommit": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNzE4Nw==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r536337187", "bodyText": "It's kinda dangerous to do so. If initialing monthly base failed and we give it an empty map, and somehow fetching total storage usage succeeded, then the container usage for this month would highly likely to surpass the quota. For instance, if a container's total usage is 100GB and the monthly base is 95 GB and the quota is 10 GB. If everything works fine, then for this month, it already used 100 - 95 = 5GB, the quota is 10GB, it still has 5GB to use. But if we give monthly base an empty map, then for this month, we will consider this container using 100GB already.\nThis is a tricky one, I suppose we don't want to stop the process just because we can't get the monthly base for quota service, but we still want to have a correct logic going forward. That's why I come to this compromise. Monthly base would be highly likely fetched from backup files but we still fail the process if we can't initialize it from database. However, we don't fail the process if we can't get it later.", "author": "justinlin-linkedin", "createdAt": "2020-12-04T19:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2OTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0NjQ4NQ==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r538846485", "bodyText": "I see your point, but in the edge case aforementioned, is it possible that containerStorageUsageMonthlyBase is not initialized?  I have a minor concern the \"base\" might be null and there is no check before passing it to subtract method where NPE may occur.", "author": "jsjtzyy", "createdAt": "2020-12-08T22:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2OTQ2Ng=="}], "type": "inlineReview"}, {"oid": "b016b6ea4af87a4b94920a7b9e9b5e96b5b177f7", "url": "https://github.com/linkedin/ambry/commit/b016b6ea4af87a4b94920a7b9e9b5e96b5b177f7", "message": "[StorageQuota] Add a storage usage refresher on top of mysql", "committedDate": "2020-12-04T19:20:21Z", "type": "commit"}, {"oid": "d730ec7c06274e2300b41b76b5339c590a8792c2", "url": "https://github.com/linkedin/ambry/commit/d730ec7c06274e2300b41b76b5339c590a8792c2", "message": "comments", "committedDate": "2020-12-04T19:44:16Z", "type": "commit"}, {"oid": "d730ec7c06274e2300b41b76b5339c590a8792c2", "url": "https://github.com/linkedin/ambry/commit/d730ec7c06274e2300b41b76b5339c590a8792c2", "message": "comments", "committedDate": "2020-12-04T19:44:16Z", "type": "forcePushed"}, {"oid": "96e593a183bddda0ec76d839cf996712eaa22dbc", "url": "https://github.com/linkedin/ambry/commit/96e593a183bddda0ec76d839cf996712eaa22dbc", "message": "Fix", "committedDate": "2020-12-04T20:36:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MDc2Mg==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r538740762", "bodyText": "So in this case is the base value the last month's value? If yes, then can customers be penalized for our failure to get monthly base.\nI am worried about the following scenario:\nexample accountId: A, containerId: B, container quota: 12G\ncurrent date: Dec 2\nBase Value Nov = 85G\nBase Value Dec = 90G (this could not be fetched due to some reason), so containerStorageUsageMonthlyBase[\"A\"][\"B\"] = 85G\nCurrent Usage Value for container = 100G\nWhats our response in this case?", "author": "ankagrawal", "createdAt": "2020-12-08T19:20:04Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        containerStorageUsageMonthlyBase =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMaxCount) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+        scheduleStorageUsageMonthlyBaseFetcher();", "originalCommit": "96e593a183bddda0ec76d839cf996712eaa22dbc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MjQxNA==", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r538742414", "bodyText": "Nit: extra \"*\" in comment.", "author": "ankagrawal", "createdAt": "2020-12-08T19:22:30Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents", "originalCommit": "96e593a183bddda0ec76d839cf996712eaa22dbc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5bd1a9a8e35549b380991b2ae19fcac545f1c8fa", "url": "https://github.com/linkedin/ambry/commit/5bd1a9a8e35549b380991b2ae19fcac545f1c8fa", "message": "Comments", "committedDate": "2020-12-08T21:57:22Z", "type": "commit"}]}