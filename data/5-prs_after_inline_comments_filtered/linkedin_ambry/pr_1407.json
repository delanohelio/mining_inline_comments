{"pr_number": 1407, "pr_title": "Change blob type from java.nio.ByteBuffer to netty ByteBuf in PutRequest", "pr_createdAt": "2020-03-01T07:08:24Z", "pr_url": "https://github.com/linkedin/ambry/pull/1407", "timeline": [{"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "url": "https://github.com/linkedin/ambry/commit/99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "message": "Change blob type from java.nio.ByteBuffer to netty ByteBuf in PutRequest", "committedDate": "2020-03-01T07:06:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r386725607", "bodyText": "Is it possible to convert BlobProperties and userMeatadata to bytebuf first, and then use Bytebuf bufferToSend?", "author": "zzmao", "createdAt": "2020-03-03T00:04:39Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PutRequest.java", "diffHunk": "@@ -168,51 +171,80 @@ private int sizeExcludingBlobAndCrcSize() {\n     return sizeExcludingBlobAndCrc;\n   }\n \n+  private void prepareBuffer() {\n+    if (bufferToSend == null) {\n+      // this is the first time this method was called, prepare the buffer to send the header and other metadata\n+      // (everything except the blob content).\n+      bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+      writeHeader();\n+      int crcStart = bufferToSend.position();\n+      bufferToSend.put(blobId.toBytes());\n+      BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);", "originalCommit": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3MjE0Mw==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r386772143", "bodyText": "Use bytebuf as usermetadata's data type is currently in my plan, but I would do blob data first since blob data is usually much larger than the user metadata.", "author": "justinlin-linkedin", "createdAt": "2020-03-03T02:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwNzkzMA==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387207930", "bodyText": "Yes, but if you can make the change in one shot, you can eliminate ByteBuffer bufferToSend. Everything can be ByteBuf based in PutRequest.", "author": "zzmao", "createdAt": "2020-03-03T18:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2MzE0NQ==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387363145", "bodyText": "The problem is bufferToSend belongs to the it's parent class RequestOrResponse. To change the type of bufferToSend would trigger lots of changes for other classes as well.", "author": "justinlin-linkedin", "createdAt": "2020-03-03T23:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM4OTQyOA==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387389428", "bodyText": "Any plan to change it?", "author": "zzmao", "createdAt": "2020-03-04T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM5MDgyNg==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387390826", "bodyText": "We can change it later. I have a jira to change user metadata to use netty bytebuf. will do it with this jira.", "author": "justinlin-linkedin", "createdAt": "2020-03-04T01:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTg2NA==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r386725864", "bodyText": "Unpooled.wrappedBuffer(chunkUserMetadata)?", "author": "zzmao", "createdAt": "2020-03-03T00:05:33Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1346,8 +1347,8 @@ private void fetchRequests(RequestRegistrationCallback<PutOperation> requestRegi\n      */\n     protected PutRequest createPutRequest() {\n       return new PutRequest(NonBlockingRouter.correlationIdGenerator.incrementAndGet(), routerConfig.routerHostname,\n-          chunkBlobId, chunkBlobProperties, ByteBuffer.wrap(chunkUserMetadata), buf.duplicate(), buf.remaining(),\n-          BlobType.DataBlob, encryptedPerBlobKey != null ? encryptedPerBlobKey.duplicate() : null);\n+          chunkBlobId, chunkBlobProperties, ByteBuffer.wrap(chunkUserMetadata), Unpooled.wrappedBuffer(buf.duplicate()),", "originalCommit": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTUwMA==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387851500", "bodyText": "optional:  I would suggest renaming this method and moving the \"if\" statement out of method. Something like this:\nif (bufferToSend == null) {\n // this is the first time this method was called, prepare the buffer to send the header and other metadata\n   prepareBufferToSend();\n}", "author": "jsjtzyy", "createdAt": "2020-03-04T18:26:55Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PutRequest.java", "diffHunk": "@@ -168,51 +171,80 @@ private int sizeExcludingBlobAndCrcSize() {\n     return sizeExcludingBlobAndCrc;\n   }\n \n+  private void prepareBuffer() {\n+    if (bufferToSend == null) {\n+      // this is the first time this method was called, prepare the buffer to send the header and other metadata\n+      // (everything except the blob content).\n+      bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+      writeHeader();\n+      int crcStart = bufferToSend.position();\n+      bufferToSend.put(blobId.toBytes());\n+      BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n+      bufferToSend.putInt(usermetadata.capacity());\n+      bufferToSend.put(usermetadata);\n+      bufferToSend.putShort((short) blobType.ordinal());\n+      short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n+      bufferToSend.putShort(keyLength);\n+      if (keyLength > 0) {\n+        bufferToSend.put(blobEncryptionKey);\n+      }\n+      bufferToSend.putLong(blobSize);\n+      crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n+      nioBuffersFromBlob = blob.nioBuffers();\n+      for (ByteBuffer bb : nioBuffersFromBlob) {\n+        crc.update(bb);\n+        // change it back to 0 since we are going to write it to the channel later.\n+        bb.position(0);\n+      }\n+      crcBuf.putLong(crc.getValue());\n+      crcBuf.flip();\n+      bufferToSend.flip();\n+    }\n+  }\n+\n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (sentBytes < sizeInBytes()) {\n-      if (bufferToSend == null) {\n-        // this is the first time this method was called, prepare the buffer to send the header and other metadata\n-        // (everything except the blob content).\n-        bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n-        writeHeader();\n-        int crcStart = bufferToSend.position();\n-        bufferToSend.put(blobId.toBytes());\n-        BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-        bufferToSend.putInt(usermetadata.capacity());\n-        bufferToSend.put(usermetadata);\n-        bufferToSend.putShort((short) blobType.ordinal());\n-        short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-        bufferToSend.putShort(keyLength);\n-        if (keyLength > 0) {\n-          bufferToSend.put(blobEncryptionKey);\n+    try {\n+      if (sentBytes < sizeInBytes()) {\n+        prepareBuffer();", "originalCommit": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MTYwMg==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387871602", "bodyText": "sure", "author": "justinlin-linkedin", "createdAt": "2020-03-04T19:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NzE2MA==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387867160", "bodyText": "Could you rename n to something like oneTimeBytesWritten?  This indicates that, when current method is invoked, how many bytes have been written during this call. This may contain one or more nio buffers that are successfully written into channel.", "author": "jsjtzyy", "createdAt": "2020-03-04T18:55:58Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PutRequest.java", "diffHunk": "@@ -168,51 +171,80 @@ private int sizeExcludingBlobAndCrcSize() {\n     return sizeExcludingBlobAndCrc;\n   }\n \n+  private void prepareBuffer() {\n+    if (bufferToSend == null) {\n+      // this is the first time this method was called, prepare the buffer to send the header and other metadata\n+      // (everything except the blob content).\n+      bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+      writeHeader();\n+      int crcStart = bufferToSend.position();\n+      bufferToSend.put(blobId.toBytes());\n+      BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n+      bufferToSend.putInt(usermetadata.capacity());\n+      bufferToSend.put(usermetadata);\n+      bufferToSend.putShort((short) blobType.ordinal());\n+      short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n+      bufferToSend.putShort(keyLength);\n+      if (keyLength > 0) {\n+        bufferToSend.put(blobEncryptionKey);\n+      }\n+      bufferToSend.putLong(blobSize);\n+      crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n+      nioBuffersFromBlob = blob.nioBuffers();\n+      for (ByteBuffer bb : nioBuffersFromBlob) {\n+        crc.update(bb);\n+        // change it back to 0 since we are going to write it to the channel later.\n+        bb.position(0);\n+      }\n+      crcBuf.putLong(crc.getValue());\n+      crcBuf.flip();\n+      bufferToSend.flip();\n+    }\n+  }\n+\n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (sentBytes < sizeInBytes()) {\n-      if (bufferToSend == null) {\n-        // this is the first time this method was called, prepare the buffer to send the header and other metadata\n-        // (everything except the blob content).\n-        bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n-        writeHeader();\n-        int crcStart = bufferToSend.position();\n-        bufferToSend.put(blobId.toBytes());\n-        BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-        bufferToSend.putInt(usermetadata.capacity());\n-        bufferToSend.put(usermetadata);\n-        bufferToSend.putShort((short) blobType.ordinal());\n-        short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-        bufferToSend.putShort(keyLength);\n-        if (keyLength > 0) {\n-          bufferToSend.put(blobEncryptionKey);\n+    try {\n+      if (sentBytes < sizeInBytes()) {\n+        prepareBuffer();\n+        // If the header and metadata are not yet written out completely, try and write out as much of it now.\n+        if (bufferToSend.hasRemaining()) {\n+          written = channel.write(bufferToSend);\n         }\n-        bufferToSend.putLong(blobSize);\n-        crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-        crc.update(blob.array(), blob.arrayOffset(), blob.remaining());\n-        crcBuf.putLong(crc.getValue());\n-        crcBuf.flip();\n-        bufferToSend.flip();\n-      }\n \n-      // If the header and metadata are not yet written out completely, try and write out as much of it now.\n-      if (bufferToSend.hasRemaining()) {\n-        written = channel.write(bufferToSend);\n-      }\n+        // If the header and metadata were written out completely (in this call or a previous call),\n+        // try and write out as much of the blob now.\n+        if (!bufferToSend.hasRemaining() && blob != null) {\n+          int n = 0, currentWritten = -1;", "originalCommit": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MTczMA==", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387871730", "bodyText": "will update.", "author": "justinlin-linkedin", "createdAt": "2020-03-04T19:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NzE2MA=="}], "type": "inlineReview"}, {"oid": "866341e784af2152f4bedd125d2f9bf6d3f11b5a", "url": "https://github.com/linkedin/ambry/commit/866341e784af2152f4bedd125d2f9bf6d3f11b5a", "message": "Comments", "committedDate": "2020-03-04T19:09:29Z", "type": "commit"}]}