{"pr_number": 1366, "pr_title": "Adding undelete record to persistent index", "pr_createdAt": "2020-01-24T18:32:20Z", "pr_url": "https://github.com/linkedin/ambry/pull/1366", "timeline": [{"oid": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "url": "https://github.com/linkedin/ambry/commit/09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "message": "Fix", "committedDate": "2020-01-28T01:17:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwNzgzMw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372207833", "bodyText": "Do we still need ID_Deleted?", "author": "jsjtzyy", "createdAt": "2020-01-29T06:26:45Z", "path": "ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java", "diffHunk": "@@ -35,5 +35,9 @@\n   Already_Updated,\n   Update_Not_Allowed,\n   File_Not_Found,\n-  Channel_Closed\n+  Channel_Closed,\n+  Life_Version_Conflict,\n+  ID_Not_Deleted,\n+  ID_Undeleted,\n+  ID_Deleted_Permanently", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMTM4Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372701383", "bodyText": "we still need it, it will be returned when ambry-frontend requests to delete a already deleted blob.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwNzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MDQ4Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372640483", "bodyText": "Can you explain a little bit more about difference between life version from frontend and that is not?", "author": "jsjtzyy", "createdAt": "2020-01-29T21:30:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -55,6 +55,8 @@\n \n   final static byte FLAGS_DEFAULT_VALUE = (byte) 0;\n   final static long UNKNOWN_ORIGINAL_MESSAGE_OFFSET = -1;\n+  // The life version when the operation is trigger by the requests from frontend.\n+  final static short LIFE_VERSION_FROM_FRONTEND = -1;", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjQ1NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372702454", "bodyText": "frontend requests don't carry any lifeVersion information. This just indicates that markAsPermanent, markAsDeleted and markAsUndeleted is called by the requests from ambry frontend. When it's not from frontend, it should be from recovery and replication.\nIn the end, we will remove this variable. In the end, after we start to support lifeVersion, we will have to know lifeVersion for every frontend and replication requests.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MDQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MTU1Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372641557", "bodyText": "Replace isFlagSet(Flags.Undelete_Index) with isUndelete(). Same for DELETE and TTLUpdate.", "author": "jsjtzyy", "createdAt": "2020-01-29T21:32:57Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -386,11 +429,11 @@ ByteBuffer getBytes() {\n   @Override\n   public String toString() {\n     return \"Offset: \" + offset + \", Size: \" + getSize() + \", Deleted: \" + isFlagSet(Flags.Delete_Index)\n-        + \", TTL Updated: \" + isFlagSet(Flags.Ttl_Update_Index) + \", Undelete: \" + isFlagSet(\n-        Flags.Undelete_Index) + \", ExpiresAtMs: \" + getExpiresAtMs() + \", Original Message Offset: \"\n-        + getOriginalMessageOffset() + (formatVersion != PersistentIndex.VERSION_0 ? (\", OperationTimeAtSecs \"\n-        + getOperationTimeInMs() + \", AccountId \" + getAccountId() + \", ContainerId \" + getContainerId())\n-        : \"\") + (formatVersion > PersistentIndex.VERSION_2 ? \", Life Version:\" + lifeVersion : \"\");\n+        + \", TTL Updated: \" + isFlagSet(Flags.Ttl_Update_Index) + \", Undelete: \" + isFlagSet(Flags.Undelete_Index)\n+        + \", ExpiresAtMs: \" + getExpiresAtMs() + \", Original Message Offset: \" + getOriginalMessageOffset() + (", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0NjUyNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372646525", "bodyText": "If life version is not from frontend, dose it mean that the version comes from replication or compaction?", "author": "jsjtzyy", "createdAt": "2020-01-29T21:42:55Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -279,6 +313,15 @@ short getContainerId() {\n     return containerId;\n   }\n \n+  /**\n+   * True when the life version is not from frontend requests.\n+   * @param lifeVersion the given life version.\n+   * @return true when it's not from frontend requests.\n+   */\n+  static boolean hasLifeVersion(short lifeVersion) {\n+    return lifeVersion > LIFE_VERSION_FROM_FRONTEND;", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjgyNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372702824", "bodyText": "and recovery also", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0NjUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTQ2Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372661466", "bodyText": "Can this be simplified as flags == FLAGS_DEFAULT_VALUE ?", "author": "jsjtzyy", "createdAt": "2020-01-29T22:16:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -243,6 +245,38 @@ boolean isFlagSet(Flags flag) {\n     return ((getFlags() & (1 << flag.ordinal())) != 0);\n   }\n \n+  /**\n+   * Helper function for isFlagSet(Flags.Ttl_Update_Index).\n+   * @return true when the Ttl_Update_Index is set.\n+   */\n+  boolean isTTLUpdate() {\n+    return isFlagSet(Flags.Ttl_Update_Index);\n+  }\n+\n+  /**\n+   * Helper function for isFlagSet(Flags.Delete_Index).\n+   * @return true when the Delete_Index is set.\n+   */\n+  boolean isDelete() {\n+    return isFlagSet(Flags.Delete_Index);\n+  }\n+\n+  /**\n+   * Helper function for isFlagSet(Flags.Undelete_Index).\n+   * @return true when the Undelete_Index is set.\n+   */\n+  boolean isUndelete() {\n+    return isFlagSet(Flags.Undelete_Index);\n+  }\n+\n+  /**\n+   * Helper function to decide if this value is a put value or not.\n+   * @return true when it's not a put record.\n+   */\n+  boolean isPut() {\n+    return !(isTTLUpdate() || isDelete() || isUndelete());", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjg3Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372702876", "bodyText": "make sense.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDY1Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372710657", "bodyText": "+1", "author": "zzmao", "createdAt": "2020-01-30T00:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3Mjc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372672752", "bodyText": "If this is for testing purpose, I suggest removing this and either use mockito or extends PersisentIndex to override getVersion() method.", "author": "jsjtzyy", "createdAt": "2020-01-29T22:44:24Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -69,6 +70,30 @@\n   static final short CURRENT_VERSION = VERSION_2;\n   static final String CLEAN_SHUTDOWN_FILENAME = \"cleanshutdown\";\n \n+  // set by the setVersion method from test cases to test IndexValue at next version.\n+  private static Short externalSetVersion = null;", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3MzcwNg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372673706", "bodyText": "same here, we probably could remove this method", "author": "jsjtzyy", "createdAt": "2020-01-29T22:46:49Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -69,6 +70,30 @@\n   static final short CURRENT_VERSION = VERSION_2;\n   static final String CLEAN_SHUTDOWN_FILENAME = \"cleanshutdown\";\n \n+  // set by the setVersion method from test cases to test IndexValue at next version.\n+  private static Short externalSetVersion = null;\n+\n+  /**\n+   * Return the version. If {@link #setVersion(Short)} was invoked before, the version provided in the {@link #setVersion(Short)}\n+   * would be returned here.\n+   * @return The version of {@link PersistentIndex}.\n+   */\n+  static short getVersion() {\n+    if (externalSetVersion != null) {\n+      return externalSetVersion;\n+    }\n+    return CURRENT_VERSION;\n+  }\n+\n+  /**\n+   * Set the version for {@link PersistentIndex}. To resume the version to default one, pass a null to this method.\n+   * This method should only be used in the test cases.\n+   * @param external the version to set for {@link PersistentIndex}.\n+   */\n+  static void setVersion(Short external) {\n+    externalSetVersion = external;\n+  }", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MjU0MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372682541", "bodyText": "The info here comes from recovery.recover() but I don't see BlobStoreRecovery handles UNDELETE case. Are you planning to add that in future PR?", "author": "jsjtzyy", "createdAt": "2020-01-29T23:12:23Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -332,14 +357,24 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n+        } else if (info.isUndeleted()) {", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzgxOQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372707819", "bodyText": "It does, I have to rebase.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MjU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjA4Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372696082", "bodyText": "why we throw exception here?  If ttlUpdate doesn't have version, it is invalid?", "author": "jsjtzyy", "createdAt": "2020-01-29T23:57:47Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -712,37 +897,106 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {\n     validateFileSpan(fileSpan, true);\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    }\n+    short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n+    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n     } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n+    } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n+      throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n+          + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n+\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      // but the TTL update is going to still be placed?\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of ttlUpdate carries invalid lifeVersion\",\n+            StoreErrorCodes.Initialization_Error);", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzU4MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372707580", "bodyText": "If it doesn't have lifeVersion, it mean lifeVersion is -1. This will never happen, for 1 when the method is called in recovery or replication, we already the lifeVersion from MessageInfo 2 when the method is called in handling frontend requests, we will have a put record in the persistent index so the value == null will be false.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5Njc4MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372696780", "bodyText": "update the java doc of this method by adding lifeVersion", "author": "jsjtzyy", "createdAt": "2020-01-30T00:00:08Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -712,37 +897,106 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d4630e28a026a0cea4ec501b9002bde97a401073", "url": "https://github.com/linkedin/ambry/commit/d4630e28a026a0cea4ec501b9002bde97a401073", "message": "Address comments", "committedDate": "2020-01-30T01:02:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTQ1Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372711456", "bodyText": "logger.info add info.getLifeVersion()?", "author": "zzmao", "createdAt": "2020-01-30T00:55:02Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -315,15 +340,15 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n-          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n+          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n+              info.getLifeVersion());\n           logger.info(\"Index : {} updated message with key {} by inserting delete entry of size {} ttl {}\", dataDir,", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTY3OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372711678", "bodyText": "same for logs below.", "author": "zzmao", "createdAt": "2020-01-30T00:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyNjYwNg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373626606", "bodyText": "Minor: Life_Version_Invalid", "author": "zzmao", "createdAt": "2020-01-31T18:41:53Z", "path": "ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java", "diffHunk": "@@ -35,5 +35,9 @@\n   Already_Updated,\n   Update_Not_Allowed,\n   File_Not_Found,\n-  Channel_Closed\n+  Channel_Closed,\n+  Life_Version_Conflict,", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NzY4Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373657682", "bodyText": "Feel like conflict is better here, invalid seems to indicate the lifeVersion is not a valid number.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyNjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373628472", "bodyText": "Does U/D carry expiration time?", "author": "zzmao", "createdAt": "2020-01-31T18:45:57Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -518,17 +532,18 @@ private boolean needToRollOverIndex(IndexEntry entry) {\n   }\n \n   /**\n-   * Finds a key in the index and returns the blob index value associated with it. If not found,\n-   * returns null\n+   * Finds {@link IndexValue} that represents the latest state of the given {@code key} in the index and return it. If\n+   * not found, returns null.\n    * <br>\n-   * This method only returns PUT or DELETE index entries. It does not return TTL_UPDATE entries but accounts for\n-   * TTL updates by updating the flag and expiry time (if applicable).\n+   * This method returns the final state of the given {@code key}. The final state of a key can be a Put value, a Delete\n+   * value and a Undelete value. Ttl_update isn't considered as final state as it just update the expiration date.\n+   * {@link IndexValue} returned by this method would carry expiration date from Ttl_update if there is one.", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMjY1NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373632654", "bodyText": "Is it possible to embed TTL_UPDATE FLAG in D/U all the time?\nIf we support UNDELETE to DELETE after we release this feature, there won't be backward compatible  issue.", "author": "zzmao", "createdAt": "2020-01-31T18:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzNDg0NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373634844", "bodyText": "Or, can we set it permanent if a blob with TTL is undeleted?  To make TTL_UPDATE easier.", "author": "zzmao", "createdAt": "2020-01-31T19:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1Nzg1OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373657858", "bodyText": "talked offline.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyOTc5OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373629798", "bodyText": "The word reversed is confused.\nBecause the default order in our mind is latest to oldest. How about not use reverse in function name, just add some comments about what the order is.", "author": "zzmao", "createdAt": "2020-01-31T18:48:56Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKeyInReverseOrder(StoreKey key, FileSpan fileSpan,", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1ODE0Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373658146", "bodyText": "I can do that. Given that this is the only order we present the index values.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyOTc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1OTI0OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373659248", "bodyText": "yes.", "author": "zzmao", "createdAt": "2020-01-31T19:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyOTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzI0MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373633240", "bodyText": "Why getDeletedBlobReadOptions is so complicated?", "author": "zzmao", "createdAt": "2020-01-31T18:56:45Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -839,6 +1099,33 @@ private BlobReadOptions getDeletedBlobReadOptions(IndexValue value, StoreKey key\n     return readOptions;\n   }\n \n+  /**\n+   * Gets {@link BlobReadOptions} for a undeleted blob.\n+   * @param value the {@link IndexValue} of the delete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n+   * @throws StoreException\n+   */\n+  private BlobReadOptions getUndeletedBlobReadOptions(IndexValue value, StoreKey key,", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1ODIxNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373658214", "bodyText": "talked offline.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzYzNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373633635", "bodyText": "Why is size changed?", "author": "zzmao", "createdAt": "2020-01-31T18:57:38Z", "path": "ambry-store/src/test/java/com.github.ambry.store/CuratedLogIndexState.java", "diffHunk": "@@ -77,7 +77,10 @@\n   // deliberately do not divide the capacities perfectly.\n   static final long PUT_RECORD_SIZE = 53;\n   static final long DELETE_RECORD_SIZE = 29;\n-  static final long TTL_UPDATE_RECORD_SIZE = 37;\n+  static final long TTL_UPDATE_RECORD_SIZE = 29;", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1OTAyNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373659025", "bodyText": "That's minor change, size doesn't really matter, it seems like those are just random prime number greater than 24. I added some new records for undelete and the log segment is over flowed. I will change this back and change the log segment size instead.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzYzNQ=="}], "type": "inlineReview"}, {"oid": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "url": "https://github.com/linkedin/ambry/commit/0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "message": "Added behavioral changes for PersistentIndex for Undeletes\n\nAdded behavioral changes for PersistentIndex for Undeletes\n\nfix for IndexTest failure\n\nAdded test for bad undelete, test infra for undelete in CuratedLogIndexState\n\nAdded tests for index undelete\n\nthing to trigger change add\n\nthing to trigger build del\n\nthing to trigger change add\n\nthing to trigger build del\n\nthing to trigger change add\n\nthing to trigger build del\n\nfixed test\n\nadded undelete/lifeVersion awareness to findEntriesSince method", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "eafaf0ad50234f17f6f9464376790697285a89e5", "url": "https://github.com/linkedin/ambry/commit/eafaf0ad50234f17f6f9464376790697285a89e5", "message": "wip", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "eedf9524b48fae96f5d55e7f31d809d035a495f6", "url": "https://github.com/linkedin/ambry/commit/eedf9524b48fae96f5d55e7f31d809d035a495f6", "message": "Fix", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "f02fe7a6961288805c5861b1cdfcd70d900e5632", "url": "https://github.com/linkedin/ambry/commit/f02fe7a6961288805c5861b1cdfcd70d900e5632", "message": "Address comments", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "cf39281166bdcb85c404ba7aa69bd4cff5eadb9a", "url": "https://github.com/linkedin/ambry/commit/cf39281166bdcb85c404ba7aa69bd4cff5eadb9a", "message": "Updates", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "c73c0395656a5d0dfcb643b4e406831693ee995d", "url": "https://github.com/linkedin/ambry/commit/c73c0395656a5d0dfcb643b4e406831693ee995d", "message": "Comments", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "url": "https://github.com/linkedin/ambry/commit/cc0dd0855f4405b60609475b40e1f25f66c3e336", "message": "Comments", "committedDate": "2020-01-31T20:10:08Z", "type": "commit"}, {"oid": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "url": "https://github.com/linkedin/ambry/commit/cc0dd0855f4405b60609475b40e1f25f66c3e336", "message": "Comments", "committedDate": "2020-01-31T20:10:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwOTMzNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373709335", "bodyText": "nit: inserting undelete entry of size ...", "author": "jsjtzyy", "createdAt": "2020-01-31T22:14:54Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -315,31 +316,44 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n-          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting delete entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting delete entry of size {} ttl {} lifeVersion{}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n         } else if (info.isTtlUpdated()) {\n           markAsPermanent(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+              info.getOperationTimeMs(), info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           if (value == null) {\n             // this TTL update was forced even though there was no equivalent PUT record - this means that we MUST see\n             // a DELETE for this key (because the PUT record is gone, compaction must have cleaned it up because a\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n+        } else if (info.isUndeleted()) {\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting undelete update entry of size {} ttl {} lifeVersion {}\",", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMzUzMQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373713531", "bodyText": "minor: PUT or DELETE were expected, right?", "author": "jsjtzyy", "createdAt": "2020-01-31T22:28:25Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -315,31 +316,44 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n-          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting delete entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting delete entry of size {} ttl {} lifeVersion{}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n         } else if (info.isTtlUpdated()) {\n           markAsPermanent(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+              info.getOperationTimeMs(), info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           if (value == null) {\n             // this TTL update was forced even though there was no equivalent PUT record - this means that we MUST see\n             // a DELETE for this key (because the PUT record is gone, compaction must have cleaned it up because a\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n+        } else if (info.isUndeleted()) {\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting undelete update entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n+          if (value == null) {\n+            // Undelete record indicates that there might be a put and delete record before it.\n+            throw new StoreException(\"Put record were expected but were not encountered for key: \" + info.getStoreKey(),", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxNDc4Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373714786", "bodyText": "After a second thought, is it possible that Put record has been compacted. Just like value == null for TTL update? My point is, it may not need an exception here.", "author": "jsjtzyy", "createdAt": "2020-01-31T22:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzU2NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807564", "bodyText": "it's not possible, if a put is already compacted, then an undelete operation would be rejected since undelete doesn't do anything.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMzUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyMjg0NQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373722845", "bodyText": "Can you present a case where we do need to check !value.isDelete() && !value.isUndelete()? I know the piece of code comes from previous version, I just don't quite understand why we need such additional check.", "author": "jsjtzyy", "createdAt": "2020-01-31T23:01:36Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -590,15 +605,17 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n             }\n             logger.trace(\"Index : {} found value offset {} size {} ttl {}\", dataDir, value.getOffset(), value.getSize(),\n                 value.getExpiresAtMs());\n-            if (types.contains(IndexEntryType.DELETE) && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+            if (types.contains(IndexEntryType.DELETE) && value.isDelete()) {\n+              retCandidate = value;\n+              break;\n+            } else if (types.contains(IndexEntryType.UNDELETE) && value.isUndelete()) {\n               retCandidate = value;\n               break;\n-            } else if (types.contains(IndexEntryType.TTL_UPDATE) && !value.isFlagSet(IndexValue.Flags.Delete_Index)\n-                && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+            } else if (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete() && !value.isUndelete()\n+                && value.isTTLUpdate()) {", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzgwNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807804", "bodyText": "A delete or undelete entry will carry TTL_UPDATE_INDEX flag if there is a ttl_update record comes before it. So here if the search types only contain TTL_UPDATE_INDEX and we are seeing a delete record, then we have to make sure it doesn't get returned, therefore, we have to check !value.isDelete() && !value.isUndelete().", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyMjg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNTQzNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373725434", "bodyText": "can be private", "author": "jsjtzyy", "createdAt": "2020-01-31T23:12:26Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzg1Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807856", "bodyText": "I have to expose this method in package scope, since in later PR, blobstore will call this method to do a precheck before adding undelete record to persistent index.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNjEzMw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373726133", "bodyText": "minor: change to Searching all index values for to distinguish from findKey method", "author": "jsjtzyy", "createdAt": "2020-01-31T23:15:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNjQxMg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373726412", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-01-31T23:16:53Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNjYyMg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373726622", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-01-31T23:17:45Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNzQ0Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373727443", "bodyText": "types.contains(IndexEntryType.TTL_UPDATE logic doesn't consider !value.isUndelete() like that in findKey method. Any specific reason?", "author": "jsjtzyy", "createdAt": "2020-01-31T23:21:33Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzk1Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807952", "bodyText": "good catch, it's my bad, will update.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNzQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODAxNw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373728017", "bodyText": "Optional: probably worth adding a constructor for IndexValue that takes in another index value for deep copy purpose. (Pass in many parameters is error-prone)", "author": "jsjtzyy", "createdAt": "2020-01-31T23:24:19Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzk5Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807992", "bodyText": "make sense, will add a new constructor.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODI1Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373728257", "bodyText": "typo Returning", "author": "jsjtzyy", "createdAt": "2020-01-31T23:25:34Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373728996", "bodyText": "Looks like result may be null. Can you explicitly mention this in java doc?\nAlso, if null means not find index value related to given key. We can make result = new ArrayList<>() at the very beginning and in the end, return result.isEmpty() ? null : result;\nThen we can remove\n if (result == null) {\n            result = new LinkedList<>();\n  }", "author": "jsjtzyy", "createdAt": "2020-01-31T23:28:04Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyOTExMA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373729110", "bodyText": "Or probably we can accept an empty result as a return value.", "author": "jsjtzyy", "createdAt": "2020-01-31T23:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODM4Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808386", "bodyText": "I think returning a null is find here. I will comment it.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTk5MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373921991", "bodyText": "I see your comment. Also, like I said, we are able to remove\n if (result == null) {\n            result = new LinkedList<>();\n  }\n\nin the for loop.", "author": "jsjtzyy", "createdAt": "2020-02-03T04:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjQ4OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373732488", "bodyText": "I get you point here but I would suggest reverse values before hand which makes logic easier to understand and more consistent with your java docs of this method.", "author": "jsjtzyy", "createdAt": "2020-01-31T23:46:04Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODQ2MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808460", "bodyText": "I think the order in list is correct, i will change the variable name.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjk1Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373732952", "bodyText": "Why we didn't check last value type and expiration time of PUT in this method?", "author": "jsjtzyy", "createdAt": "2020-01-31T23:48:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);\n+    if (!firstValue.isPut()) {\n+      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    if (lastValue.getLifeVersion() >= lifeVersion) {\n+      throw new StoreException(\n+          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + lastValue.getLifeVersion()\n+              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+    }", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODYzNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808634", "bodyText": "you are right, we should check the the expiration date.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNDMxNw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373734317", "bodyText": "if target is already updated or expiration time = -1, in either case we can skip update", "author": "jsjtzyy", "createdAt": "2020-01-31T23:55:50Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);\n+    if (!firstValue.isPut()) {\n+      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    if (lastValue.getLifeVersion() >= lifeVersion) {\n+      throw new StoreException(\n+          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + lastValue.getLifeVersion()\n+              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+    }\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key} when there is\n+   * no lifeVersion provided.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   */\n+  void validateSanityForUndeleteWithoutLifeVersion(StoreKey key, List<IndexValue> values) throws StoreException {\n+    // When it's valid to undelete this key\n+    // P/T + D\n+    // P/T + D + U + D\n+    if (values.size() == 1) {\n+      IndexValue value = values.get(0);\n+      if (value.isDelete() || value.isTTLUpdate()) {\n+        throw new StoreException(\"Id \" + key + \" is compacted in index\" + dataDir,\n+            StoreErrorCodes.ID_Deleted_Permanently);\n+      } else if (value.isPut()) {\n+        throw new StoreException(\"Id \" + key + \" is not deleted yet in index \" + dataDir,\n+            StoreErrorCodes.ID_Not_Deleted);\n+      } else {\n+        throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir,\n+            StoreErrorCodes.ID_Undeleted);\n+      }\n+    }\n+    // First item has to be put and last item has to be a delete.\n+    // PutRecord can't expire and delete record can't be older than the delete retention time.\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);\n+    if (lastValue.isUndelete()) {\n+      throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir, StoreErrorCodes.ID_Undeleted);\n+    }\n+    if (!firstValue.isPut() || !lastValue.isDelete()) {\n+      throw new StoreException(\n+          \"Id \" + key + \" requires first value to be a put and last value to be a delete in index \" + dataDir,\n+          StoreErrorCodes.ID_Not_Deleted);\n+    }\n+    if (lastValue.getOperationTimeInMs() + TimeUnit.DAYS.toMillis(config.storeDeletedMessageRetentionDays)\n+        < time.milliseconds()) {\n+      throw new StoreException(\"Id \" + key + \" already permanently deleted in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    maybeChangeExpirationDate(firstValue, values);\n+    if (isExpired(firstValue)) {\n+      throw new StoreException(\"Id \" + key + \" already expired in index \" + dataDir, StoreErrorCodes.TTL_Expired);\n+    }\n+  }\n+\n+  /**\n+   * Change the target's expiration date and set the ttl_update_index to be true if there is a ttl index in given list.\n+   * @param target the {@link IndexValue} to change expiration date.\n+   * @param allValues the given list of {@link IndexValue}s.\n+   */\n+  void maybeChangeExpirationDate(IndexValue target, List<IndexValue> allValues) {\n+    if (target.isTTLUpdate()) {\n+      return;", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0ODExOA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373748118", "bodyText": "nit: carries", "author": "jsjtzyy", "createdAt": "2020-02-01T01:40:05Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -658,33 +834,55 @@ IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, long deletionTimeMs) th\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n    * @param deletionTimeMs deletion time of the blob. In-case of recovery, deletion time is obtained from {@code info}.\n+   * @param lifeVersion lifeVersion of this undelete record.\n    * @return the {@link IndexValue} of the delete record\n    * @throws StoreException\n    */\n-  private IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs)\n+  IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs, short lifeVersion)\n       throws StoreException {\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     validateFileSpan(fileSpan, true);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n-      throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+    } else if (value != null) {\n+      if (hasLifeVersion) {\n+        // When this method is invoked in either recovery or replication, delete can follow any index value.\n+        if ((value.isDelete() && value.getLifeVersion() >= lifeVersion) || (value.getLifeVersion() > lifeVersion)) {\n+          throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + value.getLifeVersion()\n+              + \" Delete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+        }\n+      } else {\n+        if (value.isDelete()) {\n+          throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+        }\n+      }\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of delete carry invalid lifeVersion\",", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0ODkxMA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373748910", "bodyText": "should we clear TTL Update flag as well?", "author": "jsjtzyy", "createdAt": "2020-02-01T01:49:48Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -658,33 +834,55 @@ IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, long deletionTimeMs) th\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n    * @param deletionTimeMs deletion time of the blob. In-case of recovery, deletion time is obtained from {@code info}.\n+   * @param lifeVersion lifeVersion of this undelete record.\n    * @return the {@link IndexValue} of the delete record\n    * @throws StoreException\n    */\n-  private IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs)\n+  IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs, short lifeVersion)\n       throws StoreException {\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     validateFileSpan(fileSpan, true);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n-      throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+    } else if (value != null) {\n+      if (hasLifeVersion) {\n+        // When this method is invoked in either recovery or replication, delete can follow any index value.\n+        if ((value.isDelete() && value.getLifeVersion() >= lifeVersion) || (value.getLifeVersion() > lifeVersion)) {\n+          throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + value.getLifeVersion()\n+              + \" Delete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+        }\n+      } else {\n+        if (value.isDelete()) {\n+          throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+        }\n+      }\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of delete carry invalid lifeVersion\",\n+            StoreErrorCodes.Initialization_Error);\n+      }\n       newValue =\n-          new IndexValue(size, fileSpan.getStartOffset(), info.getExpirationTimeInMs(), info.getOperationTimeMs(),\n-              info.getAccountId(), info.getContainerId());\n+          new IndexValue(size, fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE, info.getExpirationTimeInMs(),\n+              info.getOperationTimeMs(), info.getAccountId(), info.getContainerId(), lifeVersion);\n       newValue.clearOriginalMessageOffset();\n     } else {\n+      lifeVersion = hasLifeVersion ? lifeVersion : value.getLifeVersion();\n       newValue =\n           new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(), deletionTimeMs,\n-              value.getAccountId(), value.getContainerId(), (short) 0);\n+              value.getAccountId(), value.getContainerId(), lifeVersion);\n       newValue.setNewOffset(fileSpan.getStartOffset());\n+      // Only set the original message offset when the value is put\n+      if (!value.isPut()) {\n+        newValue.clearOriginalMessageOffset();\n+      }\n       newValue.setNewSize(size);\n     }\n+    newValue.clearFlag(IndexValue.Flags.Undelete_Index);", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODkyNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808925", "bodyText": "we don't, a delete or undelete can carry ttl_update_index flag and it's expiration date, since a delete and a undelete should represent the final state of a key. And expiration date is the final state of this key.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0ODkxMA=="}], "type": "inlineReview"}, {"oid": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "url": "https://github.com/linkedin/ambry/commit/ea2ba25eebd566b2d94119211b5f549a59fc2da3", "message": "More comments", "committedDate": "2020-02-01T23:45:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNjA2MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373926060", "bodyText": "Looks like firstValue/lastValue ordering is different from that in method validateSanityForUndelete().  I don't see any issue here but could we make them consistent?", "author": "jsjtzyy", "createdAt": "2020-02-03T05:22:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,167 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching all indexes for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching all indexes for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset()\n+                + \" to \" + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching all indexes with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && !value.isUndelete() && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT)\n+                && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              result.add(new IndexValue(value));\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returning values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    // This is from recovery or replication, make sure the last value is a put and the first value's lifeVersion is strictly\n+    // less than the given lifeVersion. We don't care about the first value's type, it can be a put, ttl_update or delete, it\n+    // can even be an undelete.\n+    IndexValue lastValue = values.get(values.size() - 1);\n+    IndexValue firstValue = values.get(0);\n+    if (!lastValue.isPut()) {\n+      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    if (firstValue.getLifeVersion() >= lifeVersion) {\n+      throw new StoreException(\n+          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + firstValue.getLifeVersion()\n+              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+    }\n+    maybeChangeExpirationDate(lastValue, values);\n+    if (isExpired(lastValue)) {\n+      throw new StoreException(\"Id \" + key + \" already expired in index \" + dataDir, StoreErrorCodes.TTL_Expired);\n+    }\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key} when there is\n+   * no lifeVersion provided.\n+   * <p/>\n+   * Undelete should be permitted only when the last value is a Put and first record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   */\n+  void validateSanityForUndeleteWithoutLifeVersion(StoreKey key, List<IndexValue> values) throws StoreException {\n+    // When it's valid to undelete this key\n+    // P/T + D\n+    // P/T + D + U + D\n+    if (values.size() == 1) {\n+      IndexValue value = values.get(0);\n+      if (value.isDelete() || value.isTTLUpdate()) {\n+        throw new StoreException(\"Id \" + key + \" is compacted in index\" + dataDir,\n+            StoreErrorCodes.ID_Deleted_Permanently);\n+      } else if (value.isPut()) {\n+        throw new StoreException(\"Id \" + key + \" is not deleted yet in index \" + dataDir,\n+            StoreErrorCodes.ID_Not_Deleted);\n+      } else {\n+        throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir,\n+            StoreErrorCodes.ID_Undeleted);\n+      }\n+    }\n+    // First item has to be put and last item has to be a delete.\n+    // PutRecord can't expire and delete record can't be older than the delete retention time.\n+    IndexValue firstValue = values.get(0);\n+    IndexValue lastValue = values.get(values.size() - 1);", "originalCommit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0NzQ5Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374247497", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-02-03T17:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNDc1MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373934751", "bodyText": "typo: as undelete", "author": "jsjtzyy", "createdAt": "2020-02-03T06:11:06Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -709,40 +909,100 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @param operationTimeMs the time of the update operation\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n+   * @param lifeVersion lifeVersion of this ttlUpdate record.\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {\n     validateFileSpan(fileSpan, true);\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    }\n+    short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n+    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n     } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n+    } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n+      throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n+          + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n+\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      // but the TTL update is going to still be placed?\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of ttlUpdate carries invalid lifeVersion\",\n+            StoreErrorCodes.Initialization_Error);\n+      }\n       newValue =\n-          new IndexValue(size, fileSpan.getStartOffset(), info.getExpirationTimeInMs(), info.getOperationTimeMs(),\n-              info.getAccountId(), info.getContainerId());\n+          new IndexValue(size, fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE, info.getExpirationTimeInMs(),\n+              info.getOperationTimeMs(), info.getAccountId(), info.getContainerId(), lifeVersion);\n       newValue.clearOriginalMessageOffset();\n     } else {\n+      lifeVersion = hasLifeVersion ? lifeVersion : value.getLifeVersion();\n       newValue =\n           new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), Utils.Infinite_Time, operationTimeMs,\n-              value.getAccountId(), value.getContainerId(), (short) 0);\n+              value.getAccountId(), value.getContainerId(), lifeVersion);\n       newValue.setNewOffset(fileSpan.getStartOffset());\n       newValue.setNewSize(size);\n     }\n+    newValue.clearFlag(IndexValue.Flags.Undelete_Index);\n     newValue.setFlag(IndexValue.Flags.Ttl_Update_Index);\n     addToIndex(new IndexEntry(id, newValue, null), fileSpan);\n     return newValue;\n   }\n \n+  /**\n+   * Marks a blob as permanent", "originalCommit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNTk3OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373935978", "bodyText": "I have same question here, do you have any idea why TTL update is placed even when PUT has been cleaned up?", "author": "jsjtzyy", "createdAt": "2020-02-03T06:16:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -709,40 +909,100 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @param operationTimeMs the time of the update operation\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n+   * @param lifeVersion lifeVersion of this ttlUpdate record.\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {\n     validateFileSpan(fileSpan, true);\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    }\n+    short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n+    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n     } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n+    } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n+      throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n+          + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n+\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      // but the TTL update is going to still be placed?", "originalCommit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MDQ3Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374250476", "bodyText": "i don't think it's possible. But I will take another look at later PR", "author": "justinlin-linkedin", "createdAt": "2020-02-03T17:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNTk3OA=="}], "type": "inlineReview"}, {"oid": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "url": "https://github.com/linkedin/ambry/commit/f65940cac1fe13b1d839c94d2ff81df94299c6fa", "message": "More comments", "committedDate": "2020-02-03T18:08:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2NzM4Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374267383", "bodyText": "please update comment for value and key parameters (change delete to undelete)", "author": "jsjtzyy", "createdAt": "2020-02-03T18:32:44Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -839,6 +1098,33 @@ private BlobReadOptions getDeletedBlobReadOptions(IndexValue value, StoreKey key\n     return readOptions;\n   }\n \n+  /**\n+   * Gets {@link BlobReadOptions} for a undeleted blob.\n+   * @param value the {@link IndexValue} of the delete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MDg4MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374270881", "bodyText": "nit: value.isTTLUpdate()", "author": "jsjtzyy", "createdAt": "2020-02-03T18:39:28Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -839,6 +1098,33 @@ private BlobReadOptions getDeletedBlobReadOptions(IndexValue value, StoreKey key\n     return readOptions;\n   }\n \n+  /**\n+   * Gets {@link BlobReadOptions} for a undeleted blob.\n+   * @param value the {@link IndexValue} of the delete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n+   * @throws StoreException\n+   */\n+  private BlobReadOptions getUndeletedBlobReadOptions(IndexValue value, StoreKey key,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    IndexValue putValue =\n+        findKey(key, new FileSpan(getStartOffset(indexSegments), value.getOffset()), EnumSet.of(IndexEntryType.PUT),\n+            indexSegments);\n+    if (putValue != null) {\n+      // use the expiration time from the original value because it may have been updated\n+      // since we are here dealing with undelete blob, we have to return the right life version\n+      return new BlobReadOptions(log, putValue.getOffset(),\n+          new MessageInfo(key, putValue.getSize(), false, value.isFlagSet(IndexValue.Flags.Ttl_Update_Index), true,", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MzgxNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374273814", "bodyText": "why here we filter delete entries again? Is this because messageInfo is updated in updateStateForMessages?", "author": "jsjtzyy", "createdAt": "2020-02-03T18:45:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -1555,6 +1839,10 @@ FindInfo findDeletedEntriesSince(FindToken token, long maxTotalSizeOfEntries, lo\n         }\n       }\n     }\n+    // Filter out all the messages that are not \"deleted\", then update state for remaining deleted message.\n+    filterDeleteEntries(messageEntries);\n+    updateStateForMessages(messageEntries);\n+\n     filterDeleteEntries(messageEntries);", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwMDQxOA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374300418", "bodyText": "talked offline", "author": "justinlin-linkedin", "createdAt": "2020-02-03T19:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MzgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3NDEzOA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374274138", "bodyText": "minor: please update java doc for this method.", "author": "jsjtzyy", "createdAt": "2020-02-03T18:46:11Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -1342,17 +1627,16 @@ private void updateStateForMessages(List<MessageInfo> messageEntries) throws Sto\n     ListIterator<MessageInfo> messageEntriesIterator = messageEntries.listIterator();\n     while (messageEntriesIterator.hasNext()) {\n       MessageInfo messageInfo = messageEntriesIterator.next();\n-      if (!messageInfo.isDeleted()) {\n-        // ok to use most recent ref\n-        IndexValue indexValue =\n-            findKey(messageInfo.getStoreKey(), null, EnumSet.of(IndexEntryType.TTL_UPDATE, IndexEntryType.DELETE));\n-        if (indexValue != null) {\n-          messageInfo = new MessageInfo(messageInfo.getStoreKey(), messageInfo.getSize(),\n-              indexValue.isFlagSet(IndexValue.Flags.Delete_Index),\n-              indexValue.isFlagSet(IndexValue.Flags.Ttl_Update_Index), indexValue.getExpiresAtMs(),\n-              indexValue.getAccountId(), indexValue.getContainerId(), indexValue.getOperationTimeInMs());\n-          messageEntriesIterator.set(messageInfo);\n-        }\n+      // for all the message info, we use most recent ref even for delete. since a deleted entry can be undeleted.\n+      // ok to use most recent ref\n+      IndexValue indexValue = findKey(messageInfo.getStoreKey(), null,\n+          EnumSet.of(IndexEntryType.TTL_UPDATE, IndexEntryType.DELETE, IndexEntryType.UNDELETE));\n+      if (indexValue != null) {\n+        messageInfo = new MessageInfo(messageInfo.getStoreKey(), indexValue.getSize(), indexValue.isDelete(),\n+            indexValue.isTTLUpdate(), indexValue.isUndelete(), indexValue.getExpiresAtMs(), null,\n+            indexValue.getAccountId(), indexValue.getContainerId(), indexValue.getOperationTimeInMs(),\n+            indexValue.getLifeVersion());\n+        messageEntriesIterator.set(messageInfo);", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "945473f79bdefb31c05038cd469914786c194241", "url": "https://github.com/linkedin/ambry/commit/945473f79bdefb31c05038cd469914786c194241", "message": "More comments", "committedDate": "2020-02-03T19:39:08Z", "type": "commit"}]}