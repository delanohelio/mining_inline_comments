{"pr_number": 1502, "pr_title": "Http2 exception handling and preparation for replication.", "pr_createdAt": "2020-05-04T19:41:59Z", "pr_url": "https://github.com/linkedin/ambry/pull/1502", "timeline": [{"oid": "f36a57c6621fcc60385a26794ca4e6d9186ee197", "url": "https://github.com/linkedin/ambry/commit/f36a57c6621fcc60385a26794ca4e6d9186ee197", "message": "Http2 preparation for replication.\n\nRefactor Http2BlockingChannel\nAdd Htt2BlockingChannelPool", "committedDate": "2020-05-05T17:52:31Z", "type": "forcePushed"}, {"oid": "aa39eb1521db66d947abf5eaaaed29784925dedb", "url": "https://github.com/linkedin/ambry/commit/aa39eb1521db66d947abf5eaaaed29784925dedb", "message": "refine", "committedDate": "2020-05-06T02:02:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwMTQwMg==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421101402", "bodyText": "nit: let's keep hostname and port so in the logger and exception we can print host and port out.", "author": "justinlin-linkedin", "createdAt": "2020-05-06T21:24:02Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0NTc5Ng==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421145796", "bodyText": "you could also use the getRemoteHost() and getRemotePort() methods in this class to construct log messages, which look it up from the channel pool", "author": "cgtz", "createdAt": "2020-05-06T23:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwMTQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwMTgxMg==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421101812", "bodyText": "nit: better to print out host and port.", "author": "justinlin-linkedin", "createdAt": "2020-05-06T21:24:50Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire().get(500, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      throw new IOException(\"Can't acquire stream channel: \", e);", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwOTY2Mw==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421109663", "bodyText": "nit: I am seeing this pr ignores some stats handlers from Http2NetworkClient, it would be nice to have those stats in place even for replication.", "author": "justinlin-linkedin", "createdAt": "2020-05-06T21:41:53Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire().get(500, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      throw new IOException(\"Can't acquire stream channel: \", e);\n     }\n-    byteBufferChannel.getBuffer().position(0);\n-    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n-    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n-    responsePromise = childChannel.eventLoop().newPromise();\n-    childChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n+    ChannelPipeline p = streamChannel.pipeline();\n+    p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n+    p.addLast(new HttpObjectAggregator(http2MultiplexedChannelPool.getMaxContentLength()));", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExOTE5Nw==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421119197", "bodyText": "nit: p.addLast(new AmbrySendToHttp2Adaptor());", "author": "justinlin-linkedin", "createdAt": "2020-05-06T22:04:06Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire().get(500, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      throw new IOException(\"Can't acquire stream channel: \", e);\n     }\n-    byteBufferChannel.getBuffer().position(0);\n-    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n-    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n-    responsePromise = childChannel.eventLoop().newPromise();\n-    childChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n+    ChannelPipeline p = streamChannel.pipeline();\n+    p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n+    p.addLast(new HttpObjectAggregator(http2MultiplexedChannelPool.getMaxContentLength()));\n+    p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n+      @Override\n+      protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n+        ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n+        // Stream channel can't be reused. Release it here.\n+        ctx.channel()\n+            .parent()\n+            .attr(Http2MultiplexedChannelPool.HTTP2_MULTIPLEXED_CHANNEL_POOL)\n+            .get()\n+            .release(ctx.channel());\n+      }\n+    });\n+    streamChannel.pipeline().addLast(new AmbrySendToHttp2Adaptor());", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzMzU5Nw==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421133597", "bodyText": "3 seconds seems a bit arbitrary, and awaitUninterruptibly returns a boolean indicating if the write succeeded or not. If the return value is false, we should throw out some exception so the caller would not proceeds to call receive method.", "author": "justinlin-linkedin", "createdAt": "2020-05-06T22:41:02Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire().get(500, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      throw new IOException(\"Can't acquire stream channel: \", e);\n     }\n-    byteBufferChannel.getBuffer().position(0);\n-    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n-    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n-    responsePromise = childChannel.eventLoop().newPromise();\n-    childChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n+    ChannelPipeline p = streamChannel.pipeline();\n+    p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n+    p.addLast(new HttpObjectAggregator(http2MultiplexedChannelPool.getMaxContentLength()));\n+    p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n+      @Override\n+      protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n+        ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n+        // Stream channel can't be reused. Release it here.\n+        ctx.channel()\n+            .parent()\n+            .attr(Http2MultiplexedChannelPool.HTTP2_MULTIPLEXED_CHANNEL_POOL)\n+            .get()\n+            .release(ctx.channel());\n+      }\n+    });\n+    streamChannel.pipeline().addLast(new AmbrySendToHttp2Adaptor());\n \n-    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n-    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n-    childChannel.write(headersFrame);\n-    childChannel.write(dataFrame);\n-    childChannel.flush();\n+    responsePromise = streamChannel.eventLoop().newPromise();\n+    streamChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n+    streamChannel.writeAndFlush(request).awaitUninterruptibly(3, TimeUnit.SECONDS);", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mzc2NA==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r423193764", "bodyText": "I would suggest making the send, receive and connection checkout timeouts configurable like in ConnectionPoolConfig.", "author": "cgtz", "createdAt": "2020-05-11T17:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzMzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzNDU1NQ==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421134555", "bodyText": "I think we should also override exceptionCaught method and set and error to the promise. So we don't have to wait for 3 seconds if something is wrong.", "author": "justinlin-linkedin", "createdAt": "2020-05-06T22:43:40Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire().get(500, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      throw new IOException(\"Can't acquire stream channel: \", e);\n     }\n-    byteBufferChannel.getBuffer().position(0);\n-    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n-    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n-    responsePromise = childChannel.eventLoop().newPromise();\n-    childChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n+    ChannelPipeline p = streamChannel.pipeline();\n+    p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n+    p.addLast(new HttpObjectAggregator(http2MultiplexedChannelPool.getMaxContentLength()));\n+    p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n+      @Override\n+      protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzNTQ2Nw==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421135467", "bodyText": "nit: might as well capture all the Exception.", "author": "justinlin-linkedin", "createdAt": "2020-05-06T22:45:58Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,118 +45,78 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n+  private Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n \n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire().get(500, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzNjM3Mw==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r421136373", "bodyText": "+final", "author": "justinlin-linkedin", "createdAt": "2020-05-06T22:48:28Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannelPool.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.Http2ClientConfig;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.ConnectionPool;\n+import com.github.ambry.network.ConnectionPoolTimeoutException;\n+import com.github.ambry.network.Port;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A connection pool that uses {@link Http2MultiplexedChannelPool} as the underlying channel for communication.\n+ * {@link Http2MultiplexedChannelPool} maintains physical connections to a host:port.\n+ * A stream channel represented by {@link Http2BlockingChannel} is checked out when checkOutConnection() is invoked.\n+ */\n+public class Http2BlockingChannelPool implements ConnectionPool {\n+  private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannelPool.class);\n+  private Map<InetSocketAddress, Http2MultiplexedChannelPool> http2ChannelPoolMap;\n+  private SSLFactory sslFactory;\n+  private EventLoopGroup eventLoopGroup;\n+  private Http2ClientConfig http2ClientConfig;\n+  private Http2ClientMetrics http2ClientMetrics;", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyMzUxNA==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r423223514", "bodyText": "Wait on future for shutdown to complete here?", "author": "cgtz", "createdAt": "2020-05-11T18:06:59Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannelPool.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.Http2ClientConfig;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.ConnectionPool;\n+import com.github.ambry.network.ConnectionPoolTimeoutException;\n+import com.github.ambry.network.Port;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A connection pool that uses {@link Http2MultiplexedChannelPool} as the underlying channel for communication.\n+ * {@link Http2MultiplexedChannelPool} maintains physical connections to a host:port.\n+ * A stream channel represented by {@link Http2BlockingChannel} is checked out when checkOutConnection() is invoked.\n+ */\n+public class Http2BlockingChannelPool implements ConnectionPool {\n+  private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannelPool.class);\n+  private Map<InetSocketAddress, Http2MultiplexedChannelPool> http2ChannelPoolMap;\n+  private SSLFactory sslFactory;\n+  private EventLoopGroup eventLoopGroup;\n+  private Http2ClientConfig http2ClientConfig;\n+  private Http2ClientMetrics http2ClientMetrics;\n+\n+  public Http2BlockingChannelPool(SSLFactory sslFactory, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    http2ChannelPoolMap = new ConcurrentHashMap<>();\n+    this.sslFactory = sslFactory;\n+    if (Epoll.isAvailable()) {\n+      logger.info(\"Using EpollEventLoopGroup in Http2BlockingChannelPool.\");\n+      this.eventLoopGroup = new EpollEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n+    } else {\n+      this.eventLoopGroup = new NioEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n+    }\n+    this.http2ClientConfig = http2ClientConfig;\n+    this.http2ClientMetrics = http2ClientMetrics;\n+  }\n+\n+  @Override\n+  public void start() {\n+    logger.info(\"Http2BlockingChannelPool started\");\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.info(\"Shutting down Http2BlockingChannelPool.\");\n+    eventLoopGroup.shutdownGracefully();", "originalCommit": "aa39eb1521db66d947abf5eaaaed29784925dedb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "013a18480914eb906db6bf948db0c8a181375955", "url": "https://github.com/linkedin/ambry/commit/013a18480914eb906db6bf948db0c8a181375955", "message": "address comments", "committedDate": "2020-05-18T17:32:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5NjgwNQ==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r426796805", "bodyText": "nit: after getAndSet() maybe check if the returned value is null.", "author": "justinlin-linkedin", "createdAt": "2020-05-18T17:50:16Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,139 +45,114 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n-\n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  private final Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n+  private final Http2ClientConfig http2ClientConfig;\n+  private final Http2ClientMetrics http2ClientMetrics;\n+\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+    this.http2ClientMetrics = http2MultiplexedChannelPool.getHttp2ClientMetrics();\n+    this.http2ClientConfig = http2MultiplexedChannelPool.getHttp2ClientConfig();\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2ClientConfig = http2ClientConfig;\n+    this.http2ClientMetrics = http2ClientMetrics;\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire()\n+          .get(http2ClientConfig.http2BlockingChannelAcquireTimeoutMs, TimeUnit.MILLISECONDS);\n+    } catch (Exception e) {\n+      throw new IOException(\"Can't acquire stream channel from \" + getRemoteHost() + \":\" + getRemotePort(), e);\n     }\n-    byteBufferChannel.getBuffer().position(0);\n-    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n-\n-    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n-    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n-    responsePromise = childChannel.eventLoop().newPromise();\n-    childChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n-\n-    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n-    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n-    childChannel.write(headersFrame);\n-    childChannel.write(dataFrame);\n-    childChannel.flush();\n+\n+    ChannelPipeline p = streamChannel.pipeline();\n+    p.addLast(new Http2ClientStreamStatsHandler(http2ClientMetrics));\n+    p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n+    p.addLast(new HttpObjectAggregator(http2ClientConfig.http2MaxContentLength));\n+    p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n+      @Override\n+      protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n+        ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n+        // Stream channel can't be reused. Release it here.\n+        ctx.channel()\n+            .parent()\n+            .attr(Http2MultiplexedChannelPool.HTTP2_MULTIPLEXED_CHANNEL_POOL)\n+            .get()\n+            .release(ctx.channel());\n+      }\n+\n+      @Override\n+      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setFailure(cause);", "originalCommit": "013a18480914eb906db6bf948db0c8a181375955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzNTc0Mg==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r426835742", "bodyText": "this should also have a null check in case exceptionCaught called getAndSet first", "author": "cgtz", "createdAt": "2020-05-18T19:05:36Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannel.java", "diffHunk": "@@ -68,139 +45,119 @@\n \n \n /**\n- * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n- * to support replication in the future.\n+ * A HTTP2 implementation of {@link ConnectedChannel} used in replication and test.\n+ * This implementation reuses connections maintained by {@link Http2MultiplexedChannelPool}(a pool for a single host:port) and creates a stream channel for each send.\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n   private final static AttributeKey<Promise<ByteBuf>> RESPONSE_PROMISE = AttributeKey.newInstance(\"ResponsePromise\");\n-  private final String hostName;\n-  private final int readBufferSize;\n-  private final int writeBufferSize;\n-  private final int http2InitialWindowSize;\n-  private final SSLFactory sslFactory;\n-  private final int port;\n-  private EventLoopGroup workerGroup;\n-  private Channel channel;\n   private Promise<ByteBuf> responsePromise;\n-  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n-\n-  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, int readBufferSize, int writeBufferSize,\n-      int http2InitialWindowSize) {\n-    this.hostName = hostName;\n-    this.port = port;\n-    this.readBufferSize = readBufferSize;\n-    this.writeBufferSize = writeBufferSize;\n-    this.http2InitialWindowSize = http2InitialWindowSize;\n+  private final Http2MultiplexedChannelPool http2MultiplexedChannelPool;\n+  private final Http2ClientConfig http2ClientConfig;\n+  private final Http2ClientMetrics http2ClientMetrics;\n+\n+  public Http2BlockingChannel(Http2MultiplexedChannelPool http2MultiplexedChannelPool) {\n+    this.http2MultiplexedChannelPool = http2MultiplexedChannelPool;\n+    this.http2ClientMetrics = http2MultiplexedChannelPool.getHttp2ClientMetrics();\n+    this.http2ClientConfig = http2MultiplexedChannelPool.getHttp2ClientConfig();\n+  }\n+\n+  /**\n+   * Constructor for test purpose.\n+   */\n+  public Http2BlockingChannel(String hostName, int port, SSLConfig sslConfig, Http2ClientConfig http2ClientConfig,\n+      Http2ClientMetrics http2ClientMetrics) {\n+    NettySslHttp2Factory nettySslHttp2Factory;\n     try {\n-      sslFactory = new NettySslHttp2Factory(sslConfig);\n+      nettySslHttp2Factory = new NettySslHttp2Factory(sslConfig);\n     } catch (GeneralSecurityException | IOException e) {\n-      throw new IllegalStateException(e);\n+      throw new IllegalStateException(\"Can't create NettySslHttp2Factory: \", e);\n     }\n+    this.http2ClientConfig = http2ClientConfig;\n+    this.http2ClientMetrics = http2ClientMetrics;\n+    this.http2MultiplexedChannelPool =\n+        new Http2MultiplexedChannelPool(new InetSocketAddress(hostName, port), nettySslHttp2Factory,\n+            Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup(), http2ClientConfig,\n+            http2ClientMetrics);\n   }\n \n   @Override\n   public void connect() throws IOException {\n-    workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n-    Bootstrap b = new Bootstrap();\n-    b.group(workerGroup);\n-    b.channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class);\n-    b.option(ChannelOption.SO_KEEPALIVE, true)\n-        // To honor http2 window size, WriteBufferWaterMark.high() should be greater or equal to http2 window size.\n-        // Also see: https://github.com/netty/netty/issues/10193\n-        .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n-            new WriteBufferWaterMark(http2InitialWindowSize, 2 * http2InitialWindowSize));\n-    if (readBufferSize != -1) {\n-      b.option(ChannelOption.SO_RCVBUF, readBufferSize);\n-    }\n-    if (writeBufferSize != -1) {\n-      b.option(ChannelOption.SO_SNDBUF, writeBufferSize);\n-    }\n-    b.remoteAddress(hostName, port);\n-    b.handler(new ChannelInitializer<SocketChannel>() {\n-      @Override\n-      protected void initChannel(SocketChannel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(hostName, port, SSLFactory.Mode.CLIENT));\n-        pipeline.addLast(sslHandler);\n-        pipeline.addLast(Http2FrameCodecBuilder.forClient()\n-            .initialSettings(Http2Settings.defaultSettings().initialWindowSize(http2InitialWindowSize))\n-            .build());\n-        pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n-      }\n-    });\n \n-    // Start the client.\n-    channel = b.connect().syncUninterruptibly().channel();\n-    logger.info(\"Connected to remote host\");\n-    http2StreamChannelBootstrap = new Http2StreamChannelBootstrap(channel).handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline p = ch.pipeline();\n-        p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n-        p.addLast(new HttpObjectAggregator(1024 * 1024));\n-        p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n-          @Override\n-          protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-            Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-            if (streamId == null) {\n-              logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-              return;\n-            }\n-            ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());\n-            logger.trace(\"Stream response received.\");\n-          }\n-        });\n-      }\n-    });\n   }\n \n   @Override\n   public void disconnect() throws IOException {\n-    channel.disconnect().syncUninterruptibly();\n-    workerGroup.shutdownGracefully();\n+\n   }\n \n+  /**\n+   * A new stream channel is created for each send.\n+   */\n   @Override\n   public void send(Send request) throws IOException {\n-    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n-    while (!request.isSendComplete()) {\n-      request.writeTo(byteBufferChannel);\n+    Channel streamChannel;\n+    try {\n+      streamChannel = http2MultiplexedChannelPool.acquire()\n+          .get(http2ClientConfig.http2BlockingChannelAcquireTimeoutMs, TimeUnit.MILLISECONDS);\n+    } catch (Exception e) {\n+      throw new IOException(\"Can't acquire stream channel from \" + getRemoteHost() + \":\" + getRemotePort(), e);\n     }\n-    byteBufferChannel.getBuffer().position(0);\n-    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n-\n-    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n-    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n-    responsePromise = childChannel.eventLoop().newPromise();\n-    childChannel.attr(RESPONSE_PROMISE).set(responsePromise);\n-\n-    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n-    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n-    childChannel.write(headersFrame);\n-    childChannel.write(dataFrame);\n-    childChannel.flush();\n+\n+    ChannelPipeline p = streamChannel.pipeline();\n+    p.addLast(new Http2ClientStreamStatsHandler(http2ClientMetrics));\n+    p.addLast(new Http2StreamFrameToHttpObjectCodec(false));\n+    p.addLast(new HttpObjectAggregator(http2ClientConfig.http2MaxContentLength));\n+    p.addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n+      @Override\n+      protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n+        ctx.channel().attr(RESPONSE_PROMISE).getAndSet(null).setSuccess(msg.content().retainedDuplicate());", "originalCommit": "8a84d0a81eddd3b7b0b4a8ff2c619de8a314801b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzNjc3OQ==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r426836779", "bodyText": "why does this class use ConcurrentHashMap instead of Http2ChannelPoolMap?", "author": "cgtz", "createdAt": "2020-05-18T19:07:36Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2BlockingChannelPool.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.Http2ClientConfig;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.ConnectionPool;\n+import com.github.ambry.network.ConnectionPoolTimeoutException;\n+import com.github.ambry.network.Port;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A connection pool that uses {@link Http2MultiplexedChannelPool} as the underlying channel for communication.\n+ * {@link Http2MultiplexedChannelPool} maintains physical connections to a host:port.\n+ * A stream channel represented by {@link Http2BlockingChannel} is checked out when checkOutConnection() is invoked.\n+ */\n+public class Http2BlockingChannelPool implements ConnectionPool {\n+  private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannelPool.class);\n+  private Map<InetSocketAddress, Http2MultiplexedChannelPool> http2ChannelPoolMap;", "originalCommit": "8a84d0a81eddd3b7b0b4a8ff2c619de8a314801b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzNzI5OA==", "url": "https://github.com/linkedin/ambry/pull/1502#discussion_r426837298", "bodyText": "final", "author": "cgtz", "createdAt": "2020-05-18T19:08:34Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ClientStreamStatsHandler.java", "diffHunk": "@@ -32,10 +32,10 @@\n @ChannelHandler.Sharable\n class Http2ClientStreamStatsHandler extends SimpleChannelInboundHandler<Http2Frame> {\n   private final Logger logger = LoggerFactory.getLogger(getClass());\n-  private Http2NetworkClient http2NetworkClient;\n+  private Http2ClientMetrics http2ClientMetrics;", "originalCommit": "8a84d0a81eddd3b7b0b4a8ff2c619de8a314801b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ef429f2928e4fde6e9be2a77150976fd4421212", "url": "https://github.com/linkedin/ambry/commit/6ef429f2928e4fde6e9be2a77150976fd4421212", "message": "final comments.", "committedDate": "2020-05-18T22:30:03Z", "type": "forcePushed"}, {"oid": "6497a6002270c55051e7a271e3e1ec7b05bc56a5", "url": "https://github.com/linkedin/ambry/commit/6497a6002270c55051e7a271e3e1ec7b05bc56a5", "message": "final comments.", "committedDate": "2020-05-19T16:52:57Z", "type": "forcePushed"}, {"oid": "801f965e1381ee7f5ecb5110ece2f531eec51b88", "url": "https://github.com/linkedin/ambry/commit/801f965e1381ee7f5ecb5110ece2f531eec51b88", "message": "Http2 preparation for replication.\n\nRefactor Http2BlockingChannel\nAdd Htt2BlockingChannelPool", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "935000bd2662dca79cdb6ce3d92bc9dfb3a0e166", "url": "https://github.com/linkedin/ambry/commit/935000bd2662dca79cdb6ce3d92bc9dfb3a0e166", "message": "refine", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "d07db77a2e6ea2ba4c1d95eca255ec42b95540c9", "url": "https://github.com/linkedin/ambry/commit/d07db77a2e6ea2ba4c1d95eca255ec42b95540c9", "message": "add exception handling", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "e2e8553cc273395318f4dca9d6c0bb21e58220c1", "url": "https://github.com/linkedin/ambry/commit/e2e8553cc273395318f4dca9d6c0bb21e58220c1", "message": "address comments", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "9efab5d78e90e50335c1b93769eb74cb5640f371", "url": "https://github.com/linkedin/ambry/commit/9efab5d78e90e50335c1b93769eb74cb5640f371", "message": "Also fix concurrent issue in Http2NetworkClient\\", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "63cbb0baa329101bc35f86aa8f55b5e16fda0396", "url": "https://github.com/linkedin/ambry/commit/63cbb0baa329101bc35f86aa8f55b5e16fda0396", "message": "fix test", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "5a3605fb0920654dca112d7b9b66d7db77cd8557", "url": "https://github.com/linkedin/ambry/commit/5a3605fb0920654dca112d7b9b66d7db77cd8557", "message": "final comments.", "committedDate": "2020-05-19T21:51:20Z", "type": "commit"}, {"oid": "5a3605fb0920654dca112d7b9b66d7db77cd8557", "url": "https://github.com/linkedin/ambry/commit/5a3605fb0920654dca112d7b9b66d7db77cd8557", "message": "final comments.", "committedDate": "2020-05-19T21:51:20Z", "type": "forcePushed"}, {"oid": "f55aab1dd65a174c4b6ebd847f37742b5a1110e6", "url": "https://github.com/linkedin/ambry/commit/f55aab1dd65a174c4b6ebd847f37742b5a1110e6", "message": "fix test failure.", "committedDate": "2020-05-20T16:31:52Z", "type": "commit"}, {"oid": "f55aab1dd65a174c4b6ebd847f37742b5a1110e6", "url": "https://github.com/linkedin/ambry/commit/f55aab1dd65a174c4b6ebd847f37742b5a1110e6", "message": "fix test failure.", "committedDate": "2020-05-20T16:31:52Z", "type": "forcePushed"}]}