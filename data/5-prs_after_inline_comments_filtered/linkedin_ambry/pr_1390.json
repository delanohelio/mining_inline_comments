{"pr_number": 1390, "pr_title": "Fix early close refcnt error", "pr_createdAt": "2020-02-18T20:59:15Z", "pr_url": "https://github.com/linkedin/ambry/pull/1390", "timeline": [{"oid": "06d079c2e4f6579cb9a4a932aaecabef3fcf0f91", "url": "https://github.com/linkedin/ambry/commit/06d079c2e4f6579cb9a4a932aaecabef3fcf0f91", "message": "Fix early close refcnt error", "committedDate": "2020-02-19T21:16:48Z", "type": "commit"}, {"oid": "7a6f54d8dcbd72d33b21695e8294311a74a3ad10", "url": "https://github.com/linkedin/ambry/commit/7a6f54d8dcbd72d33b21695e8294311a74a3ad10", "message": "Fix test", "committedDate": "2020-02-19T21:16:48Z", "type": "commit"}, {"oid": "9219b25acbcbd3a6b90fc5e418c9e56888a44c08", "url": "https://github.com/linkedin/ambry/commit/9219b25acbcbd3a6b90fc5e418c9e56888a44c08", "message": "Remove unused stuff", "committedDate": "2020-02-19T21:17:54Z", "type": "commit"}, {"oid": "9219b25acbcbd3a6b90fc5e418c9e56888a44c08", "url": "https://github.com/linkedin/ambry/commit/9219b25acbcbd3a6b90fc5e418c9e56888a44c08", "message": "Remove unused stuff", "committedDate": "2020-02-19T21:17:54Z", "type": "forcePushed"}, {"oid": "6358aa54bffc5ed37cd916d12a272869a13c426b", "url": "https://github.com/linkedin/ambry/commit/6358aa54bffc5ed37cd916d12a272869a13c426b", "message": "stuff", "committedDate": "2020-02-19T21:31:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NzY4MQ==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381567681", "bodyText": "should this call come before asyncWritableChannel.write in case write calls chunkAsyncWriteCallback before the buff is added to the map?", "author": "cgtz", "createdAt": "2020-02-19T21:54:35Z", "path": "ambry-router/src/main/java/com.github.ambry.router/GetBlobOperation.java", "diffHunk": "@@ -442,9 +449,12 @@ private void maybeWriteToChannel() {\n       // if there are chunks available to be written out, do now.\n       if (firstChunk.isComplete() && readCalled) {\n         while (operationException.get() == null && chunkIndexToBuf.containsKey(indexOfNextChunkToWriteOut)) {\n-          ByteBuf byteBuf = chunkIndexToBuf.get(indexOfNextChunkToWriteOut);\n-          asyncWritableChannel.write(byteBuf.nioBuffer(), chunkAsyncWriteCallback);\n-          indexOfNextChunkToWriteOut++;\n+          ByteBuf byteBuf = chunkIndexToBuf.remove(indexOfNextChunkToWriteOut);\n+          if (byteBuf != null) {\n+            asyncWritableChannel.write(byteBuf.nioBuffer(), chunkAsyncWriteCallback);\n+            chunkIndexToBufWaitingForRelease.put(indexOfNextChunkToWriteOut, byteBuf);", "originalCommit": "6358aa54bffc5ed37cd916d12a272869a13c426b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2OTM2MA==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381569360", "bodyText": "good catch.", "author": "justinlin-linkedin", "createdAt": "2020-02-19T21:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NzY4MQ=="}], "type": "inlineReview"}, {"oid": "8b1947e35d3cb5999b1dda2b258a0e0fcf2b3eb9", "url": "https://github.com/linkedin/ambry/commit/8b1947e35d3cb5999b1dda2b258a0e0fcf2b3eb9", "message": "Address casey comments", "committedDate": "2020-02-19T22:58:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMDg4OQ==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381600889", "bodyText": "Could you explain a little why we need wait for 1 sec here?", "author": "jsjtzyy", "createdAt": "2020-02-19T23:10:36Z", "path": "ambry-router/src/main/java/com.github.ambry.router/CryptoJobHandler.java", "diffHunk": "@@ -69,6 +70,11 @@ public void close() {\n           logger.error(\"Unknown type of job seen : \" + task.getClass());\n         }\n       }\n+      try {\n+        scheduler.awaitTermination(1000, TimeUnit.MILLISECONDS);", "originalCommit": "8b1947e35d3cb5999b1dda2b258a0e0fcf2b3eb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMzE3Ng==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381613176", "bodyText": "This is trying to fix the earlyCloseReadableChannel test method.\nIn that particular test, we would close the blobDataReadableChannel before we finish fetching data chunk from server and decrypting them. So there is a chance when the test method is finished, the decryption of some data chunks are still ongoing in the decryption thread. Since in the decrypt job, we still have a ByteBuf not released, we will run into ByteBuf leak error.\nSo here we wait for some time for all the decrypt jobs to finish and release all the ByteBufs they hold, and we won't have the leak error.", "author": "justinlin-linkedin", "createdAt": "2020-02-19T23:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwOTA0Mg==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381609042", "bodyText": "In which case, there might be a chunk left? I feel like chunks have been read in previous loop.", "author": "jsjtzyy", "createdAt": "2020-02-19T23:34:28Z", "path": "ambry-router/src/test/java/com.github.ambry.router/GetBlobOperationTest.java", "diffHunk": "@@ -1215,6 +1212,9 @@ public void run() {\n                   chunksLeftToRead--;\n                 }\n                 result.getBlobResult.getBlobDataChannel().close();\n+                while (writableChannel.getNextChunk(100) != null) {", "originalCommit": "8b1947e35d3cb5999b1dda2b258a0e0fcf2b3eb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMzkxNQ==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381613915", "bodyText": "They are not all read in the previous loop since this test case is to test when we close the ReadableChannel before we finishing read all the data from it, as you can see we close the channel before this line. But the AsyncWritableChannel's interface guarantees that whenever you pass a callback to the write method, this callback will be invoked in the same order they are passed to the channel. So this loop is doing exactly that. It loops over all the left  data chunk in the asyncWritableChannel and calls those callbacks.", "author": "justinlin-linkedin", "createdAt": "2020-02-19T23:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwOTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyMDc0NQ==", "url": "https://github.com/linkedin/ambry/pull/1390#discussion_r381620745", "bodyText": "I see. I thought chunksLeftToRead was the total number of chunks that written into the channel.", "author": "jsjtzyy", "createdAt": "2020-02-20T00:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwOTA0Mg=="}], "type": "inlineReview"}]}