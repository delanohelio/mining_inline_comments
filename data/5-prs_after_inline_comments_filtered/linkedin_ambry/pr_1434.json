{"pr_number": 1434, "pr_title": "Support undelete in replication", "pr_createdAt": "2020-03-24T00:34:06Z", "pr_url": "https://github.com/linkedin/ambry/pull/1434", "timeline": [{"oid": "e8b97899edae04cfea62840e7a4da424f1af26dc", "url": "https://github.com/linkedin/ambry/commit/e8b97899edae04cfea62840e7a4da424f1af26dc", "message": "Add more tests", "committedDate": "2020-03-24T18:33:59Z", "type": "forcePushed"}, {"oid": "ccea32482046fbfa45c69b322c87e4a5e3372d53", "url": "https://github.com/linkedin/ambry/commit/ccea32482046fbfa45c69b322c87e4a5e3372d53", "message": "Fixing test failures", "committedDate": "2020-03-25T01:33:26Z", "type": "forcePushed"}, {"oid": "4869ae7036ed67254b2954ea876a14650eb59b94", "url": "https://github.com/linkedin/ambry/commit/4869ae7036ed67254b2954ea876a14650eb59b94", "message": "Fix the test error", "committedDate": "2020-03-25T23:54:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4NDU2MA==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400384560", "bodyText": "Java Doc.", "author": "zzmao", "createdAt": "2020-03-30T17:56:09Z", "path": "ambry-api/src/main/java/com.github.ambry/store/Store.java", "diffHunk": "@@ -86,6 +86,8 @@\n    */\n   Set<StoreKey> findMissingKeys(List<StoreKey> keys) throws StoreException;\n \n+  MessageInfo findKey(StoreKey key) throws StoreException;", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4NTc1MA==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400385750", "bodyText": "workaround", "author": "zzmao", "createdAt": "2020-03-30T17:57:58Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobStore.java", "diffHunk": "@@ -482,6 +482,18 @@ private MessageInfo getMessageInfoFromMetadata(CloudBlobMetadata metadata) throw\n     }\n   }\n \n+  @Override\n+  public MessageInfo findKey(StoreKey key) throws StoreException {\n+    // This is a walkaround. This is only used in replication where replicaThread need to figure out if the blob", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NDY5NA==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400394694", "bodyText": "Not warn?", "author": "zzmao", "createdAt": "2020-03-30T18:12:29Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/BlobIdTransformer.java", "diffHunk": "@@ -156,6 +160,12 @@ private Message newMessage(InputStream inputStream, StoreKey newKey, MessageInfo\n     storeKeyFactory.getStoreKey(new DataInputStream(inputStream));\n     BlobId newBlobId = (BlobId) newKey;\n \n+    if (headerFormat.hasLifeVersion() && headerFormat.getLifeVersion() != oldMessageInfo.getLifeVersion()) {\n+      // The original Put buffer might have lifeVersion as 0, but the message info might have a higher lifeVersion.\n+      logger.trace(", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NTE1Ng==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r403395156", "bodyText": "this is really not important message, I used to use warn just for debugging purpose.", "author": "justinlin-linkedin", "createdAt": "2020-04-04T00:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMjUyMQ==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400402521", "bodyText": "What if U exists in local store?", "author": "zzmao", "createdAt": "2020-03-30T18:25:36Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicaThread.java", "diffHunk": "@@ -709,6 +673,69 @@ private void processReplicaMetadataResponse(Set<StoreKey> missingRemoteStoreKeys\n           logger.trace(\"Remote node: {} Thread name: {} Remote replica: {} Key in expired state remotely {}\",\n               remoteNode, threadName, remoteReplicaInfo.getReplicaId(), localKey);\n         }\n+      } else {\n+        // the key is present in the local store. Mark it for deletion if it is deleted in the remote store and not\n+        // deleted yet locally\n+        MessageInfo localMessageInfo = remoteReplicaInfo.getLocalStore().findKey(localKey);\n+        boolean deletedLocally = localMessageInfo.isDeleted();\n+        boolean ttlUpdatedLocally = localMessageInfo.isTtlUpdated();\n+        short localLifeVersion = localMessageInfo.getLifeVersion();\n+        short remoteLifeVersion = messageInfo.getLifeVersion();\n+        if (localLifeVersion > remoteLifeVersion) {\n+          // if the lifeVersion in local store is greater than the remote lifeVersion, then nothing needs to be done.\n+          continue;\n+        } else if (localLifeVersion == remoteLifeVersion) {\n+          // we are operating in the same version, in this case, delete would be the final state.\n+          if (!deletedLocally) {\n+            // Only adds record when it's not deleted yet. Since delete is the final state for this lifeVersion, if there\n+            // is a delete record for the current lifeVersion, then nothing needs to be done.\n+            MessageInfo info = new MessageInfo(localKey, 0, localKey.getAccountId(), localKey.getContainerId(),\n+                messageInfo.getOperationTimeMs());\n+            if (messageInfo.isTtlUpdated() && !ttlUpdatedLocally) {\n+              applyTtlUpdate(info, remoteReplicaInfo);\n+            }\n+            if (messageInfo.isDeleted()) {\n+              applyDelete(info, remoteReplicaInfo);\n+            }\n+          }\n+        } else {\n+          // if we are here, then the remote lifeVersion is greater than the local lifeVersion.\n+          // we need to reconcile the local state with the remote state.\n+          //\n+          // There are three states we have to reconcile: lifeVersion, ttl_update, is_deleted.\n+          // To reconcile lifeVersion and is_deleted, we have to add a Delete or Undelete record, based on what the final state is.\n+          // to reconcile ttl_update, if the final state is delete, then, we have to add ttl_update before delete, other, we can add ttl_update after undelete.\n+          MessageInfo info = new MessageInfo(localKey, 0, localKey.getAccountId(), localKey.getContainerId(),\n+              messageInfo.getOperationTimeMs(), remoteLifeVersion);\n+          boolean shouldInsertTtlUpdate = false;\n+          if (messageInfo.isTtlUpdated() && !ttlUpdatedLocally) {\n+            // make a patch for ttl update\n+            // if the remote state is delete, then we can't insert TTL_UPDATE after delete, we have to insert a ttl_update here\n+            if (messageInfo.isDeleted()) {\n+              // since ttl update can only follow Put or Undelete, make sure it's not locally deleted.\n+              // we can reuse the lifeVersion for undelete and ttl update, since the delete would be the final state of\n+              // this lifeVersion.\n+              if (deletedLocally) {\n+                applyUndelete(info, remoteReplicaInfo);", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NTY1Mw==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r403395653", "bodyText": "The latest value locally is a delete, and we can't apply ttl_update after a delete, so here I apply a undelete locally first. It doesn't matter if U exists in local store, as long as the latest value is a delete.", "author": "justinlin-linkedin", "createdAt": "2020-04-04T00:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMjUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwOTg2MA==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400409860", "bodyText": "Minor:  is shouldInsertTtlUpdate needed?  use messageInfo.isTtlUpdated() && !ttlUpdatedLocally && !messageInfo.isDeleted()?", "author": "zzmao", "createdAt": "2020-03-30T18:37:43Z", "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicaThread.java", "diffHunk": "@@ -709,6 +673,69 @@ private void processReplicaMetadataResponse(Set<StoreKey> missingRemoteStoreKeys\n           logger.trace(\"Remote node: {} Thread name: {} Remote replica: {} Key in expired state remotely {}\",\n               remoteNode, threadName, remoteReplicaInfo.getReplicaId(), localKey);\n         }\n+      } else {\n+        // the key is present in the local store. Mark it for deletion if it is deleted in the remote store and not\n+        // deleted yet locally\n+        MessageInfo localMessageInfo = remoteReplicaInfo.getLocalStore().findKey(localKey);\n+        boolean deletedLocally = localMessageInfo.isDeleted();\n+        boolean ttlUpdatedLocally = localMessageInfo.isTtlUpdated();\n+        short localLifeVersion = localMessageInfo.getLifeVersion();\n+        short remoteLifeVersion = messageInfo.getLifeVersion();\n+        if (localLifeVersion > remoteLifeVersion) {\n+          // if the lifeVersion in local store is greater than the remote lifeVersion, then nothing needs to be done.\n+          continue;\n+        } else if (localLifeVersion == remoteLifeVersion) {\n+          // we are operating in the same version, in this case, delete would be the final state.\n+          if (!deletedLocally) {\n+            // Only adds record when it's not deleted yet. Since delete is the final state for this lifeVersion, if there\n+            // is a delete record for the current lifeVersion, then nothing needs to be done.\n+            MessageInfo info = new MessageInfo(localKey, 0, localKey.getAccountId(), localKey.getContainerId(),\n+                messageInfo.getOperationTimeMs());\n+            if (messageInfo.isTtlUpdated() && !ttlUpdatedLocally) {\n+              applyTtlUpdate(info, remoteReplicaInfo);\n+            }\n+            if (messageInfo.isDeleted()) {\n+              applyDelete(info, remoteReplicaInfo);\n+            }\n+          }\n+        } else {\n+          // if we are here, then the remote lifeVersion is greater than the local lifeVersion.\n+          // we need to reconcile the local state with the remote state.\n+          //\n+          // There are three states we have to reconcile: lifeVersion, ttl_update, is_deleted.\n+          // To reconcile lifeVersion and is_deleted, we have to add a Delete or Undelete record, based on what the final state is.\n+          // to reconcile ttl_update, if the final state is delete, then, we have to add ttl_update before delete, other, we can add ttl_update after undelete.\n+          MessageInfo info = new MessageInfo(localKey, 0, localKey.getAccountId(), localKey.getContainerId(),\n+              messageInfo.getOperationTimeMs(), remoteLifeVersion);\n+          boolean shouldInsertTtlUpdate = false;\n+          if (messageInfo.isTtlUpdated() && !ttlUpdatedLocally) {\n+            // make a patch for ttl update\n+            // if the remote state is delete, then we can't insert TTL_UPDATE after delete, we have to insert a ttl_update here\n+            if (messageInfo.isDeleted()) {\n+              // since ttl update can only follow Put or Undelete, make sure it's not locally deleted.\n+              // we can reuse the lifeVersion for undelete and ttl update, since the delete would be the final state of\n+              // this lifeVersion.\n+              if (deletedLocally) {\n+                applyUndelete(info, remoteReplicaInfo);\n+              }\n+              applyTtlUpdate(info, remoteReplicaInfo);\n+            } else {\n+              // if final state is not delete, then to bump lifeVerion in local store to remote lifeVersion, we have to\n+              // add a undelete, and then add a ttl update.\n+              shouldInsertTtlUpdate = true;\n+            }\n+          }\n+\n+          // if we are here, then the ttl update is matched\n+          if (messageInfo.isDeleted()) {\n+            applyDelete(info, remoteReplicaInfo);\n+          } else {\n+            applyUndelete(info, remoteReplicaInfo);\n+            if (shouldInsertTtlUpdate) {", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NTgzNw==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r403395837", "bodyText": "you are right about the condition, but one boolean is more clear than three booleans.", "author": "justinlin-linkedin", "createdAt": "2020-04-04T00:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwOTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTg2Mg==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400415862", "bodyText": "Is there any version test?\nFor example:\nLocal: x x x x D2\nRemote: U2\nU2 should be denied.", "author": "zzmao", "createdAt": "2020-03-30T18:48:05Z", "path": "ambry-replication/src/test/java/com.github.ambry.replication/ReplicationTest.java", "diffHunk": "@@ -1994,8 +2014,614 @@ public void replicaTokenTest() throws InterruptedException {\n     remoteReplicaInfo.onTokenPersisted();\n   }\n \n+  /**\n+   * Tests when the local records has higher lifeVersion than remote records.\n+   */\n+  @Test\n+  public void replicaThreadLifeVersionLocalGreaterThanRemote() throws Exception {\n+    lifeVersionLocalGreaterThanRemote_Delete(false, false);\n+    lifeVersionLocalGreaterThanRemote_Delete(false, true);\n+    lifeVersionLocalGreaterThanRemote_Delete(true, false);\n+    lifeVersionLocalGreaterThanRemote_Delete(true, true);\n+  }\n+\n+  /**\n+   * Tests when the local store missing put records with lifeVersion greater than 0\n+   */\n+  @Test\n+  public void replicaThreadLifeVersionLocalLessThanRemote_MissingPuts() throws Exception {", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NjA5NA==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r403396094", "bodyText": "There is, it's in another test method. replicaThreadLifeVersionLocalLessThanRemote_FinalState_TtlUpdateDelete", "author": "justinlin-linkedin", "createdAt": "2020-04-04T00:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNzkzMQ==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r400417931", "bodyText": "Why not check Authorization_Failure in this case?", "author": "zzmao", "createdAt": "2020-03-30T18:51:29Z", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -470,23 +473,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()", "originalCommit": "506b6ef94cec4a11a6c24b6a32fc54357aae8c7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5bade049df52542e5e3cb7e2f2171e9ce365dc31", "url": "https://github.com/linkedin/ambry/commit/5bade049df52542e5e3cb7e2f2171e9ce365dc31", "message": "Add more tests", "committedDate": "2020-04-01T20:43:32Z", "type": "forcePushed"}, {"oid": "ce6ee834800dad052721cac14ef7e2bf2dac06e3", "url": "https://github.com/linkedin/ambry/commit/ce6ee834800dad052721cac14ef7e2bf2dac06e3", "message": "Rebase", "committedDate": "2020-04-03T23:36:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgzODc5Nw==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r405838797", "bodyText": "isKeyDeleted() is not currently reliable for this purpose.  If we need to get the accurate state, we would have to fetch the metadata from Azure.  For undelete operations which are rare, this should be okay, though for everyday checks it will be expensive.  Please add a TODO to fix it later.", "author": "lightningrob", "createdAt": "2020-04-08T21:57:07Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -516,6 +516,18 @@ private MessageInfo getMessageInfoFromMetadata(CloudBlobMetadata metadata) throw\n     }\n   }\n \n+  @Override\n+  public MessageInfo findKey(StoreKey key) throws StoreException {\n+    // This is a workaround. This is only used in replication where replicaThread need to figure out if the blob\n+    // is deleted and if the blob is ttlupdated, and also returns the lifeVersion.\n+    // Since we are not supporting lifeVersion in CloudBlobStore yet, for lifVersion, we will return 0 as default value.\n+    // For deleted, use return value from isKeyDeleted.\n+    // For ttl update, return false to trigger ttl update operation in replication. For an already ttl udpated blob\n+    // second ttl update would end up with an error, which replication will be able to silence.\n+    return new MessageInfo(key, 0, isKeyDeleted(key), false, false, Utils.Infinite_Time, null,", "originalCommit": "a581b0dcdfc206d24e3637abd950aeb1f07893aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgzOTM2NQ==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r405839365", "bodyText": "Duration is not a param so shouldn't be mentioned in javadoc.", "author": "lightningrob", "createdAt": "2020-04-08T21:58:25Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java", "diffHunk": "@@ -500,6 +500,16 @@ boolean awaitBlobDeletions() throws InterruptedException {\n     return deletionHelper.await(10, TimeUnit.SECONDS);\n   }\n \n+\n+  /**\n+   * Waits for blob undeletes on all replicas\n+   * @return {@code true} if undeletes were received in all replicas within the {@code duration} specified.", "originalCommit": "a581b0dcdfc206d24e3637abd950aeb1f07893aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NjU3Mw==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r405846573", "bodyText": "into an undelete", "author": "lightningrob", "createdAt": "2020-04-08T22:16:23Z", "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicaThread.java", "diffHunk": "@@ -968,6 +995,73 @@ private void applyTtlUpdate(MessageInfo messageInfo, RemoteReplicaInfo remoteRep\n     }\n   }\n \n+  /**\n+   * Applies an undelete to the blob described by {@code messageInfo}.\n+   * @param messageInfo the {@link MessageInfo} that will be transformed into a TTL update", "originalCommit": "a581b0dcdfc206d24e3637abd950aeb1f07893aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NjY3Ng==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r405846676", "bodyText": "into a delete", "author": "lightningrob", "createdAt": "2020-04-08T22:16:38Z", "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicaThread.java", "diffHunk": "@@ -968,6 +995,73 @@ private void applyTtlUpdate(MessageInfo messageInfo, RemoteReplicaInfo remoteRep\n     }\n   }\n \n+  /**\n+   * Applies an undelete to the blob described by {@code messageInfo}.\n+   * @param messageInfo the {@link MessageInfo} that will be transformed into a TTL update\n+   * @param remoteReplicaInfo The remote replica that is being replicated from\n+   * @throws StoreException\n+   */\n+  private void applyUndelete(MessageInfo messageInfo, RemoteReplicaInfo remoteReplicaInfo) throws StoreException {\n+    DataNodeId remoteNode = remoteReplicaInfo.getReplicaId().getDataNodeId();\n+    try {\n+      messageInfo = new MessageInfo(messageInfo.getStoreKey(), messageInfo.getSize(), messageInfo.isDeleted(),\n+          messageInfo.isTtlUpdated(), true, messageInfo.getExpirationTimeInMs(), messageInfo.getCrc(),\n+          messageInfo.getAccountId(), messageInfo.getContainerId(), messageInfo.getOperationTimeMs(),\n+          messageInfo.getLifeVersion());\n+      remoteReplicaInfo.getLocalStore().undelete(messageInfo);\n+      logger.trace(\"Remote node: {} Thread name: {} Remote replica: {} Key undelete id: {}\", remoteNode, threadName,\n+          remoteReplicaInfo.getReplicaId(), messageInfo.getStoreKey());\n+    } catch (StoreException e) {\n+      // The blob may be undeleted, which is alright\n+      if (e.getErrorCode() == StoreErrorCodes.Life_Version_Conflict\n+          || e.getErrorCode() == StoreErrorCodes.ID_Undeleted) {\n+        logger.trace(\"Remote node: {} Thread name: {} Remote replica: {} Key already undeleted: {}\", remoteNode,\n+            threadName, remoteReplicaInfo.getReplicaId(), messageInfo.getStoreKey());\n+      } else {\n+        throw e;\n+      }\n+    }\n+    // A Repair event for an undelete signifies that an undelete message was received from the remote and it is fired\n+    // as long as the undelete is guaranteed to have taken effect locally.\n+    if (notification != null) {\n+      notification.onBlobReplicaUndeleted(dataNodeId.getHostname(), dataNodeId.getPort(),\n+          messageInfo.getStoreKey().getID(), BlobReplicaSourceType.REPAIRED);\n+    }\n+  }\n+\n+  /**\n+   * Applies a delete to the blob described by {@code messageInfo}.\n+   * @param messageInfo the {@link MessageInfo} that will be transformed into a TTL update", "originalCommit": "a581b0dcdfc206d24e3637abd950aeb1f07893aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NzE2Ng==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r405847166", "bodyText": "Should the deleted flag be set to true here?", "author": "lightningrob", "createdAt": "2020-04-08T22:18:02Z", "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicaThread.java", "diffHunk": "@@ -968,6 +995,73 @@ private void applyTtlUpdate(MessageInfo messageInfo, RemoteReplicaInfo remoteRep\n     }\n   }\n \n+  /**\n+   * Applies an undelete to the blob described by {@code messageInfo}.\n+   * @param messageInfo the {@link MessageInfo} that will be transformed into a TTL update\n+   * @param remoteReplicaInfo The remote replica that is being replicated from\n+   * @throws StoreException\n+   */\n+  private void applyUndelete(MessageInfo messageInfo, RemoteReplicaInfo remoteReplicaInfo) throws StoreException {\n+    DataNodeId remoteNode = remoteReplicaInfo.getReplicaId().getDataNodeId();\n+    try {\n+      messageInfo = new MessageInfo(messageInfo.getStoreKey(), messageInfo.getSize(), messageInfo.isDeleted(),\n+          messageInfo.isTtlUpdated(), true, messageInfo.getExpirationTimeInMs(), messageInfo.getCrc(),\n+          messageInfo.getAccountId(), messageInfo.getContainerId(), messageInfo.getOperationTimeMs(),\n+          messageInfo.getLifeVersion());\n+      remoteReplicaInfo.getLocalStore().undelete(messageInfo);\n+      logger.trace(\"Remote node: {} Thread name: {} Remote replica: {} Key undelete id: {}\", remoteNode, threadName,\n+          remoteReplicaInfo.getReplicaId(), messageInfo.getStoreKey());\n+    } catch (StoreException e) {\n+      // The blob may be undeleted, which is alright\n+      if (e.getErrorCode() == StoreErrorCodes.Life_Version_Conflict\n+          || e.getErrorCode() == StoreErrorCodes.ID_Undeleted) {\n+        logger.trace(\"Remote node: {} Thread name: {} Remote replica: {} Key already undeleted: {}\", remoteNode,\n+            threadName, remoteReplicaInfo.getReplicaId(), messageInfo.getStoreKey());\n+      } else {\n+        throw e;\n+      }\n+    }\n+    // A Repair event for an undelete signifies that an undelete message was received from the remote and it is fired\n+    // as long as the undelete is guaranteed to have taken effect locally.\n+    if (notification != null) {\n+      notification.onBlobReplicaUndeleted(dataNodeId.getHostname(), dataNodeId.getPort(),\n+          messageInfo.getStoreKey().getID(), BlobReplicaSourceType.REPAIRED);\n+    }\n+  }\n+\n+  /**\n+   * Applies a delete to the blob described by {@code messageInfo}.\n+   * @param messageInfo the {@link MessageInfo} that will be transformed into a TTL update\n+   * @param remoteReplicaInfo The remote replica that is being replicated from\n+   * @throws StoreException\n+   */\n+  private void applyDelete(MessageInfo messageInfo, RemoteReplicaInfo remoteReplicaInfo) throws StoreException {\n+    DataNodeId remoteNode = remoteReplicaInfo.getReplicaId().getDataNodeId();\n+    try {\n+      messageInfo =\n+          new MessageInfo(messageInfo.getStoreKey(), messageInfo.getSize(), false, messageInfo.isTtlUpdated(), false,", "originalCommit": "a581b0dcdfc206d24e3637abd950aeb1f07893aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NzE0OQ==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r406487149", "bodyText": "+1", "author": "ankagrawal", "createdAt": "2020-04-09T21:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NzE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxOTkxMA==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r406919910", "bodyText": "good catch. Although those flags are not used in the delete method, this would definitely cause confusion. Thanks for pointing out.", "author": "justinlin-linkedin", "createdAt": "2020-04-10T20:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NzE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjc3NQ==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r406622775", "bodyText": "Strongly recommend to use getMissingRemoteStoreKeys() or original getMissingStoreKeys().\ngetRemoteMissingStoreKeys() sounds like get the keys that were missing on remote.", "author": "zzmao", "createdAt": "2020-04-10T06:30:19Z", "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicaThread.java", "diffHunk": "@@ -587,7 +587,7 @@ private ReplicaMetadataResponse getReplicaMetadataResponse(List<RemoteReplicaInf\n    * @return List of store keys that are missing from the local store\n    * @throws StoreException if store error (usually IOError) occurs when getting missing keys.\n    */\n-  private Set<StoreKey> getMissingStoreKeys(ReplicaMetadataResponseInfo replicaMetadataResponseInfo,\n+  private Set<StoreKey> getRemoteMissingStoreKeys(ReplicaMetadataResponseInfo replicaMetadataResponseInfo,", "originalCommit": "a581b0dcdfc206d24e3637abd950aeb1f07893aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxODU5MQ==", "url": "https://github.com/linkedin/ambry/pull/1434#discussion_r406918591", "bodyText": "I will keep it to original.", "author": "justinlin-linkedin", "createdAt": "2020-04-10T19:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjc3NQ=="}], "type": "inlineReview"}, {"oid": "f14e387f3ec2b93ffd98e4d016bc3ce5a7013928", "url": "https://github.com/linkedin/ambry/commit/f14e387f3ec2b93ffd98e4d016bc3ce5a7013928", "message": "Support undelete in replication", "committedDate": "2020-04-10T20:00:58Z", "type": "commit"}, {"oid": "42ae9495260bd0ce110529fc604e9cac2a64699c", "url": "https://github.com/linkedin/ambry/commit/42ae9495260bd0ce110529fc604e9cac2a64699c", "message": "Rebase", "committedDate": "2020-04-10T20:00:58Z", "type": "commit"}, {"oid": "47333340477f0250959cdb290390ab04cdcc2fe8", "url": "https://github.com/linkedin/ambry/commit/47333340477f0250959cdb290390ab04cdcc2fe8", "message": "Rebase", "committedDate": "2020-04-10T20:01:31Z", "type": "commit"}, {"oid": "3364697919578d8a145873aee562c2e9e0a50ac3", "url": "https://github.com/linkedin/ambry/commit/3364697919578d8a145873aee562c2e9e0a50ac3", "message": "Address comments", "committedDate": "2020-04-10T20:01:31Z", "type": "commit"}, {"oid": "8eb1a4a4403b931336edce9d478404ca9e582855", "url": "https://github.com/linkedin/ambry/commit/8eb1a4a4403b931336edce9d478404ca9e582855", "message": "Fix test failure", "committedDate": "2020-04-10T20:01:31Z", "type": "commit"}, {"oid": "5e0696ad74b78946e850557c1604858a426ef19d", "url": "https://github.com/linkedin/ambry/commit/5e0696ad74b78946e850557c1604858a426ef19d", "message": "Address comments", "committedDate": "2020-04-10T20:08:50Z", "type": "commit"}, {"oid": "5e0696ad74b78946e850557c1604858a426ef19d", "url": "https://github.com/linkedin/ambry/commit/5e0696ad74b78946e850557c1604858a426ef19d", "message": "Address comments", "committedDate": "2020-04-10T20:08:50Z", "type": "forcePushed"}]}