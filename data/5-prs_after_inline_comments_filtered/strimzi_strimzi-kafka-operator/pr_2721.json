{"pr_number": 2721, "pr_title": "Add automatic scaling of Zookeeper 3.5", "pr_createdAt": "2020-03-20T02:57:59Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721", "timeline": [{"oid": "e4d5e6f703f99c75207a9ca60d99f06d059e4c5c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e4d5e6f703f99c75207a9ca60d99f06d059e4c5c", "message": "Add automatic scaling of Zookeeper 3.5\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T02:49:00Z", "type": "commit"}, {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/85c321d7a2a2e18d8103073defb1a8f9111492c2", "message": "Remove methods which did not get used at the end\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T02:57:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2ODI2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395468269", "bodyText": "Can you javadoc which suffix the result is without?", "author": "tombentley", "createdAt": "2020-03-20T07:20:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperCluster.java", "diffHunk": "@@ -126,6 +125,13 @@ public static String podDnsName(String namespace, String cluster, int podId) {\n                 ModelUtils.KUBERNETES_SERVICE_DNS_DOMAIN);\n     }\n \n+    public static String podDnsNameWithoutSuffix(String namespace, String cluster, int podId) {", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2ODQ4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395468485", "bodyText": "Elsewhere we use zk as the abbreviation for ZooKeeper. I think we should be consistent.", "author": "tombentley", "createdAt": "2020-03-20T07:20:42Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -154,6 +158,7 @@\n     private final StorageClassOperator storageClassOperator;\n     private final NodeOperator nodeOperator;\n     private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> crdOperator;\n+    private final ZookeeperScalerProvider zooScalerProvider;", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2ODk0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395468948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * USed by the Zookeeper 3.5 Admin client for scaling\n          \n          \n            \n                     * Used by the Zookeeper 3.5 Admin client for scaling", "author": "tombentley", "createdAt": "2020-03-20T07:22:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTAzOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395469038", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param connectToReplicas     Number of replicas form the ZK STS which should be used\n          \n          \n            \n                     * @param connectToReplicas     Number of replicas from the ZK STS which should be used", "author": "tombentley", "createdAt": "2020-03-20T07:22:31Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling\n          *\n-         * For 3.5.x clusters scaling is limited to one server at a time (or an exception is thrown) and currently\n-         * requires user intervention to manually add/remove servers to/from the quorum.\n+         * @param connectToReplicas     Number of replicas form the ZK STS which should be used", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTMwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395469306", "bodyText": "Long line", "author": "tombentley", "createdAt": "2020-03-20T07:23:17Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling\n          *\n-         * For 3.5.x clusters scaling is limited to one server at a time (or an exception is thrown) and currently\n-         * requires user intervention to manually add/remove servers to/from the quorum.\n+         * @param connectToReplicas     Number of replicas form the ZK STS which should be used\n+         * @return                      The generated Zookeeper connection string\n          */\n-        Future<ReconciliationState> zkScalingSetup() {\n-            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .compose(sts -> {\n-                        if (sts != null) {\n-                            int currentReplicas = sts.getSpec().getReplicas();\n-                            int desiredReplicas = zkCluster.getReplicas();\n-                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n-                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n-\n-                            if (isZK35x && replicaDiff > 1) {\n-                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n-                                // then log the error and throw an exception halting the reconciliation.\n-                                String scaleErrorMessage = String.format(\n-                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n-                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n-                                                \"to one greater or lesser than the original value (%d).\",\n-                                        replicaDiff, currentReplicas);\n-\n-                                log.error(scaleErrorMessage);\n-\n-                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n-                            } else if (desiredReplicas > currentReplicas) {\n-                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n-                                // automatically. If it is 3.5 then it is limited to one at a time anyway by the check\n-                                // in the clause above.\n-                                zkCluster.setReplicas(currentReplicas + 1);\n-                                zkScalingUp = true;\n-                            } else if (desiredReplicas < currentReplicas) {\n-                                zkScalingDown = true;\n-                            }\n+        String zkConnectionString(int connectToReplicas)  {\n+            // Prepare Zoo connection string. We want to connect only to nodes which existed before\n+            // scaling and will exist after it is finished\n+            List<String> zooNodes = new ArrayList<>(connectToReplicas);\n \n-                            ConditionBuilder zkManualScalingCondition = null;\n-\n-                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n-                                // This is a scale up or down of a ZK 3.5.x cluster\n-                                String scaleMessage = String.format(\n-                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n-                                        \"update process defined in the documentation should be followed. When finished set \" +\n-                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"replicaChange\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n-                                zkManualScaling = true;\n-                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n-                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n-                                // only the user can set it to false.\n-                                String scaleMessage = String.format(\"Detected manual Zookeeper 3.5.x scaling operation in progress. \" +\n-                                                \"After following the manual process defined in the documentation, set %s annotation on the \" +\n-                                                \"Zookeeper stateful set to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"manualScaleAnnotationSet\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                zkManualScaling = true;\n-                            } else {\n-                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n-                                zkManualScaling = false;\n-                            }\n+            for (int i = 0; i < connectToReplicas; i++)   {\n+                zooNodes.add(String.format(\"%s.%s.%s.svc:%d\", zkCluster.getPodName(i), KafkaResources.zookeeperHeadlessServiceName(name), namespace, ZookeeperCluster.CLIENT_PORT));", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTU5MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395469591", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * for given cluster. The ZookeeperScaler instance created by this method should be clsoe dmanually after it is\n          \n          \n            \n                     * for the given cluster. The ZookeeperScaler instance created by this method should be closed manually after it is", "author": "tombentley", "createdAt": "2020-03-20T07:24:04Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling\n          *\n-         * For 3.5.x clusters scaling is limited to one server at a time (or an exception is thrown) and currently\n-         * requires user intervention to manually add/remove servers to/from the quorum.\n+         * @param connectToReplicas     Number of replicas form the ZK STS which should be used\n+         * @return                      The generated Zookeeper connection string\n          */\n-        Future<ReconciliationState> zkScalingSetup() {\n-            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .compose(sts -> {\n-                        if (sts != null) {\n-                            int currentReplicas = sts.getSpec().getReplicas();\n-                            int desiredReplicas = zkCluster.getReplicas();\n-                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n-                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n-\n-                            if (isZK35x && replicaDiff > 1) {\n-                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n-                                // then log the error and throw an exception halting the reconciliation.\n-                                String scaleErrorMessage = String.format(\n-                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n-                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n-                                                \"to one greater or lesser than the original value (%d).\",\n-                                        replicaDiff, currentReplicas);\n-\n-                                log.error(scaleErrorMessage);\n-\n-                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n-                            } else if (desiredReplicas > currentReplicas) {\n-                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n-                                // automatically. If it is 3.5 then it is limited to one at a time anyway by the check\n-                                // in the clause above.\n-                                zkCluster.setReplicas(currentReplicas + 1);\n-                                zkScalingUp = true;\n-                            } else if (desiredReplicas < currentReplicas) {\n-                                zkScalingDown = true;\n-                            }\n+        String zkConnectionString(int connectToReplicas)  {\n+            // Prepare Zoo connection string. We want to connect only to nodes which existed before\n+            // scaling and will exist after it is finished\n+            List<String> zooNodes = new ArrayList<>(connectToReplicas);\n \n-                            ConditionBuilder zkManualScalingCondition = null;\n-\n-                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n-                                // This is a scale up or down of a ZK 3.5.x cluster\n-                                String scaleMessage = String.format(\n-                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n-                                        \"update process defined in the documentation should be followed. When finished set \" +\n-                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"replicaChange\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n-                                zkManualScaling = true;\n-                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n-                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n-                                // only the user can set it to false.\n-                                String scaleMessage = String.format(\"Detected manual Zookeeper 3.5.x scaling operation in progress. \" +\n-                                                \"After following the manual process defined in the documentation, set %s annotation on the \" +\n-                                                \"Zookeeper stateful set to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"manualScaleAnnotationSet\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                zkManualScaling = true;\n-                            } else {\n-                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n-                                zkManualScaling = false;\n-                            }\n+            for (int i = 0; i < connectToReplicas; i++)   {\n+                zooNodes.add(String.format(\"%s.%s.%s.svc:%d\", zkCluster.getPodName(i), KafkaResources.zookeeperHeadlessServiceName(name), namespace, ZookeeperCluster.CLIENT_PORT));\n+            }\n \n-                            if (zkManualScalingCondition != null && isZK35x) {\n-                                this.kafkaStatus.addCondition(zkManualScalingCondition.build());\n-                            }\n+            return  String.join(\",\", zooNodes);\n+        }\n+\n+        /**\n+         * Helper method for getting the required secrets with certificates and creating the ZookeeperScaler instance\n+         * for given cluster. The ZookeeperScaler instance created by this method should be clsoe dmanually after it is", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MjI4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395472280", "bodyText": "Why currentServers and not currentConfiguration?", "author": "tombentley", "createdAt": "2020-03-20T07:33:26Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNzM0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395537341", "bodyText": "I fix the docs rather than renaming the parameter. It is only the servers part of the configuration which is passed to the reconfigure() method - withotu the version etc. So I thought this better distinguishes it.", "author": "scholzj", "createdAt": "2020-03-20T10:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MjI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3Mjk1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395472951", "bodyText": "Probably worth having a ZookeeperScalingException if these can end up in the status of the CR.", "author": "tombentley", "createdAt": "2020-03-20T07:35:49Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MzE0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395473149", "bodyText": "Timeout?", "author": "tombentley", "createdAt": "2020-03-20T07:36:26Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNjQ4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395536483", "bodyText": "The close call is immadiate without any timeout. It has a variant with timeout which I found not to be working when any problems happen to the connection so I decided to use this option.", "author": "scholzj", "createdAt": "2020-03-20T10:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MzE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3Mzc1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395473755", "bodyText": "I guess quoting is not necessary? Value can never contain and \\n, right? And I assume key can never contain =.", "author": "tombentley", "createdAt": "2020-03-20T07:38:14Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNjA1OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395536058", "bodyText": "The number of values here is very limited. We should not need any escaping.", "author": "scholzj", "createdAt": "2020-03-20T10:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3Mzc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NDEwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395474107", "bodyText": "It wasn't clear to me what \"During the parsing, only server configurations are used.\" meany until I read the code.", "author": "tombentley", "createdAt": "2020-03-20T07:39:22Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+        }\n+\n+        return serversList;\n+    }\n+\n+    /**\n+     * Parse the byte array we get from Zookeeper into a map we use internally. During the parsing, only server\n+     * configurations are used. The version field is ignored.", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NDc0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395474748", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param scale     Nubber of nodes which the Zookeeper cluster should have\n          \n          \n            \n                 * @param scale     Number of nodes which the Zookeeper cluster should have", "author": "tombentley", "createdAt": "2020-03-20T07:41:27Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+        }\n+\n+        return serversList;\n+    }\n+\n+    /**\n+     * Parse the byte array we get from Zookeeper into a map we use internally. During the parsing, only server\n+     * configurations are used. The version field is ignored.\n+     *\n+     * @param byteConfig    byte[] from Zookeeper client\n+     * @return              Map with Zookeeper configuration\n+     */\n+    /*test*/ static Map<String, String> parseConfig(byte[] byteConfig) {\n+        String config = new String(byteConfig, StandardCharsets.US_ASCII);\n+\n+        Map<String, String> configMap = Util.parseMap(config);\n+\n+        Map<String, String> serverMap = new HashMap<>(configMap.size() - 1);\n+\n+        for (Map.Entry<String, String> entry : configMap.entrySet())    {\n+            if (entry.getKey().startsWith(\"server.\"))   {\n+                serverMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+        return serverMap;\n+    }\n+\n+    /**\n+     * Checks whether two Zookeeper configurations are different or not. We will change the configuration only if it\n+     * differs to minimize the load.\n+     *\n+     * @param current   Map with current configuration\n+     * @param desired   Map with desired configuration\n+     * @return          True if the configurations differ and should be updated. False otherwise.\n+     */\n+    /*test*/ static boolean isDifferent(Map<String, String> current, Map<String, String> desired)    {\n+        return !current.equals(desired);\n+    }\n+\n+    /**\n+     * Generates a map with Zookeeper configuration\n+     *\n+     * @param scale     Nubber of nodes which the Zookeeper cluster should have", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NTA0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395475041", "bodyText": "Remove", "author": "tombentley", "createdAt": "2020-03-20T07:42:24Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/ResourceUtils.java", "diffHunk": "@@ -629,6 +632,20 @@ public Admin createAdminClient(String hostname, Secret clusterCaCertSecret, Secr\n         };\n     }\n \n+    public static ZookeeperScalerProvider zookeeperScalerProvider() {\n+        return new ZookeeperScalerProvider() {\n+            @Override\n+            public ZookeeperScaler createZookeeperScaler(Vertx vertx, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+                ZookeeperScaler mockZooScaler = mock(ZookeeperScaler.class);\n+\n+                when(mockZooScaler.scale(anyInt())).thenReturn(Future.succeededFuture());\n+                //when(mockZooScaler.close()).thenReturn(Future.succeededFuture());", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NTcwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395475702", "bodyText": "Timeouting isn't a word in English (though I quite like it)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testTimeoutingConnection(VertxTestContext context)  {\n          \n          \n            \n                public void testConnectionTimeout(VertxTestContext context)  {", "author": "tombentley", "createdAt": "2020-03-20T07:44:27Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScalerTest.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.SecretBuilder;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class ZookeeperScalerTest {\n+    private static Vertx vertx;\n+\n+    @BeforeAll\n+    public static void initVertx() {\n+        vertx = Vertx.vertx();\n+    }\n+\n+    @AfterAll\n+    public static void closeVertx() {\n+        vertx.close();\n+    }\n+\n+    @Test\n+    public void testIsNotDifferent()   {\n+        Map<String, String> current = new HashMap<>(3);\n+        current.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        current.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        current.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        Map<String, String> desired = new HashMap<>(3);\n+        desired.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        desired.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired), is(false));\n+\n+        Map<String, String> desired2 = new HashMap<>(3);\n+        desired2.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired2.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+        desired2.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired2), is(false));\n+    }\n+\n+    @Test\n+    public void testIsDifferent()   {\n+        Map<String, String> current = new HashMap<>(3);\n+        current.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        current.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        current.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        Map<String, String> desired = new HashMap<>(3);\n+        desired.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        desired.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+        desired.put(\"server.4\", \"127.0.0.1:28883:38883:participant;127.0.0.1:21813\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired), is(true));\n+\n+        Map<String, String> desired2 = new HashMap<>(3);\n+        desired2.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired2.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired2), is(true));\n+\n+        Map<String, String> desired3 = new HashMap<>(3);\n+        desired3.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        desired3.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired3), is(true));\n+    }\n+\n+    @Test\n+    public void testGenerateConfigOneNode() {\n+        Map<String, String> expected = new HashMap<>(3);\n+        expected.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+\n+        assertThat(ZookeeperScaler.generateConfig(1), is(expected));\n+    }\n+\n+    @Test\n+    public void testGenerateConfigThreeNodes() {\n+        Map<String, String> expected = new HashMap<>(3);\n+        expected.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        expected.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        expected.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.generateConfig(3), is(expected));\n+    }\n+\n+    @Test\n+    public void testParseConfig() {\n+        String config = \"server.1=127.0.0.1:28880:38880:participant;127.0.0.1:21810\\n\" +\n+                        \"server.2=127.0.0.1:28881:38881:participant;127.0.0.1:21811\\n\" +\n+                        \"server.3=127.0.0.1:28882:38882:participant;127.0.0.1:21812\\n\" +\n+                        \"version=100000000b\";\n+\n+        Map<String, String> expected = new HashMap<>(3);\n+        expected.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        expected.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        expected.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.parseConfig(config.getBytes(StandardCharsets.US_ASCII)), is(expected));\n+    }\n+\n+    @Test\n+    public void testMapToList() {\n+        Map<String, String> servers = new HashMap<>(3);\n+        servers.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        servers.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        servers.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        List<String> expected = new ArrayList<>(3);\n+        expected.add(\"server.1=127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        expected.add(\"server.2=127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        expected.add(\"server.3=127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.serversMapToList(servers), containsInAnyOrder(expected.toArray()));\n+    }\n+\n+    @Test\n+    public void testTimeoutingConnection(VertxTestContext context)  {", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NzgxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395477818", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Created file with Keystore or Truststore from the byte arrays passed as param.\n          \n          \n            \n                 * Create a file with Keystore or Truststore from the given {@code bytes}.", "author": "tombentley", "createdAt": "2020-03-20T07:51:08Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Util.java", "diffHunk": "@@ -123,4 +130,52 @@ public void handle(Long timerId) {\n             return Collections.emptyMap();\n         }\n     }\n+\n+    /**\n+     * Returns exception when secret is missing. This is used from several different methods to provide identical exception.\n+     *\n+     * @param namespace     Namespace of the Secret\n+     * @param secretName    Name of the Secret\n+     * @return              RuntimeException\n+     */\n+    public static RuntimeException missingSecretException(String namespace, String secretName) {\n+        return new RuntimeException(\"Secret \" + namespace + \"/\" + secretName + \" does not exist\");\n+    }\n+\n+    /**\n+     * Created file with Keystore or Truststore from the byte arrays passed as param.", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyNDcyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395524720", "bodyText": "The connection won't get closed in if there is a failed Future.", "author": "tombentley", "createdAt": "2020-03-20T09:38:23Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0Nzk4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395547980", "bodyText": "It is closed from KafkaAssemblyOperator in that case. But yeah, it is probably better to handle it already here.", "author": "scholzj", "createdAt": "2020-03-20T10:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyNDcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0ODI3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395548275", "bodyText": "I added assitional handling here as well.", "author": "scholzj", "createdAt": "2020-03-20T10:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyNDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyODAyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395528021", "bodyText": "Util.parseMap() was originally written for our own 'image map' syntax. Are you sure it's the right thing to use for ZK admin responses?", "author": "tombentley", "createdAt": "2020-03-20T09:45:07Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+        }\n+\n+        return serversList;\n+    }\n+\n+    /**\n+     * Parse the byte array we get from Zookeeper into a map we use internally. During the parsing, only server\n+     * configurations are used. The version field is ignored.\n+     *\n+     * @param byteConfig    byte[] from Zookeeper client\n+     * @return              Map with Zookeeper configuration\n+     */\n+    /*test*/ static Map<String, String> parseConfig(byte[] byteConfig) {\n+        String config = new String(byteConfig, StandardCharsets.US_ASCII);\n+\n+        Map<String, String> configMap = Util.parseMap(config);", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzOTAwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395539005", "bodyText": "Well, it was there and does exactly what we need. What do you think would be better?\nCopying the method into the ZookeeperScaler class and keeping it as a duplicate? Probably the only different thing is the , parsing which we do not need for Zookeeper (and strictly speaking we do not use it in the image maps either AFAIK - at least not in the main YAML).", "author": "scholzj", "createdAt": "2020-03-20T10:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyODAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0MDA5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395540094", "bodyText": "I'm fine with using Util.parseMap() if it happens to be compatible with the ZK output. I was just checking.", "author": "tombentley", "createdAt": "2020-03-20T10:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyODAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyOTU0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395529541", "bodyText": "Can we call this getCurrentConfig() or currentConfig()?", "author": "tombentley", "createdAt": "2020-03-20T09:48:10Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNDQ0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395534444", "bodyText": "This is accessed in various places by callbacks to vertx.executeBlocking(), i.e. potentially by different threads. Probably the correct thing to do is for connect() to return Future<ZooKeeperAdmin> and propagate the client through the compose chain in scale(), though that's a bit messy because getConfig() would need to return both the config and the client instance.", "author": "tombentley", "createdAt": "2020-03-20T09:57:56Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;", "originalCommit": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0OTQ3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395549477", "bodyText": "Yeah ... I was a bit strugling with how put it together. It seemed to be best this way also because of closing the connections in case of failures etc. Java makes this hard with not having any Tuples etc. We would probably need some custom class to pass both the results and the client along. The ZooKeeperAdmin client is also a bit weird mixture of synchronous and asynchronous methods which makes it harder to structure it. Connection is async, getConfig or reconfigure are sync.", "author": "scholzj", "createdAt": "2020-03-20T10:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MjMyNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395552327", "bodyText": "Yeah, this was one of the issues which led me to ultimately change the KafkaRoller to be single threaded. I think a custom class would be fine, it only needs two final fields and a constructor (roll on Java 14 with records).", "author": "tombentley", "createdAt": "2020-03-20T10:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNDQ0NA=="}], "type": "inlineReview"}, {"oid": "302f7b86a99a14df7b059c5f306138e2c8170790", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/302f7b86a99a14df7b059c5f306138e2c8170790", "message": "Review comments I\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T10:02:29Z", "type": "commit"}, {"oid": "975d9552b4258f844f6323bbd567331708858974", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/975d9552b4258f844f6323bbd567331708858974", "message": "Review comments II\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T10:26:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDU3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395570574", "bodyText": "We change Kafka version by env variable ST_KAFKA_VERSION. If a specific version of kafka is needed, we should have a different test for it, because this one should be general for ZK scaleup/Scaledown", "author": "Frawless", "createdAt": "2020-03-20T11:14:19Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/RollingUpdateST.java", "diffHunk": "@@ -342,14 +341,18 @@ void testKafkaWontRollUpBecauseTopic() {\n     }\n \n     @Test\n-    @Disabled(\"Zookeeper scaleUp/scaleDown is currently covered by manual procedure for Kafka 2.4.x. \" +\n-            \"This should be removed after implementation of Zookeeper Dynamic configuration\")\n     void testZookeeperScaleUpScaleDown() {\n         int messageCount = 50;\n         String topicName = \"test-topic-\" + new Random().nextInt(Integer.MAX_VALUE);\n \n         timeMeasuringSystem.setOperationID(timeMeasuringSystem.startTimeMeasuring(Operation.CLUSTER_RECOVERY));\n-        KafkaResource.kafkaPersistent(CLUSTER_NAME, 3).done();\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(\"2.3.1\")", "originalCommit": "975d9552b4258f844f6323bbd567331708858974", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MTM0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395571346", "bodyText": "That was actually commited by mistake.", "author": "scholzj", "createdAt": "2020-03-20T11:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDU3NA=="}], "type": "inlineReview"}, {"oid": "aee909f9164840f58944f02f3cb59b76d4c4d49b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/aee909f9164840f58944f02f3cb59b76d4c4d49b", "message": "Fix ST commited by mistake\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T11:15:52Z", "type": "commit"}, {"oid": "b77944076870b8157f21da73b62d64848c6e2347", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b77944076870b8157f21da73b62d64848c6e2347", "message": "Review Comments III\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T14:39:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MTM3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395691370", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n          \n          \n            \n                 * Close the ZookeeperScaler instance. This deletes", "author": "tombentley", "createdAt": "2020-03-20T14:55:10Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    //private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(zkAdmin -> {\n+                    Promise<Void> scalePromise = Promise.promise();\n+\n+                    getCurrentConfig(zkAdmin)\n+                            .compose(servers -> scaleTo(zkAdmin, servers, scaleTo))\n+                            .setHandler(res -> {\n+                                closeConnection(zkAdmin);\n+\n+                                if (res.succeeded())    {\n+                                    scalePromise.complete();\n+                                } else {\n+                                    scalePromise.fail(res.cause());\n+                                }\n+                            });\n+\n+                    return scalePromise.future();\n+                });\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes", "originalCommit": "b77944076870b8157f21da73b62d64848c6e2347", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MjM5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395692390", "bodyText": "Can you delete this?", "author": "tombentley", "createdAt": "2020-03-20T14:56:38Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    //private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(zkAdmin -> {\n+                    Promise<Void> scalePromise = Promise.promise();\n+\n+                    getCurrentConfig(zkAdmin)\n+                            .compose(servers -> scaleTo(zkAdmin, servers, scaleTo))\n+                            .setHandler(res -> {\n+                                closeConnection(zkAdmin);\n+\n+                                if (res.succeeded())    {\n+                                    scalePromise.complete();\n+                                } else {\n+                                    scalePromise.fail(res.cause());\n+                                }\n+                            });\n+\n+                    return scalePromise.future();\n+                });\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<ZooKeeperAdmin> connect()    {\n+        Promise<ZooKeeperAdmin> connected = Promise.promise();\n+\n+        try {\n+            ZooKeeperAdmin zkAdmin = zooAdminProvider.createZookeeperAdmin(\n+                this.zookeeperConnectionString,\n+                10_000,\n+                watchedEvent -> log.debug(\"Received event {} from ZooKeeperAdmin client connected to {}\", watchedEvent, zookeeperConnectionString),\n+                getClientConfig());\n+\n+            Util.waitFor(vertx,\n+                String.format(\"ZooKeeperAdmin connection to %s\", zookeeperConnectionString),\n+                1_000,\n+                operationTimeoutMs,\n+                () -> zkAdmin.getState().isAlive() && zkAdmin.getState().isConnected())\n+                .setHandler(res -> {\n+                    if (res.succeeded())  {\n+                        connected.complete(zkAdmin);\n+                    } else {\n+                        closeConnection(zkAdmin);\n+                        log.warn(\"Failed to connect to Zookeeper {}. Connection was not ready in {} ms.\", zookeeperConnectionString, operationTimeoutMs);\n+                        connected.fail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \". Connection was not ready in \" + operationTimeoutMs + \" ms.\", res.cause()));\n+                    }\n+                });\n+\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.fail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    /*private Future<ZooKeeperAdmin> connect()    {\n+        Promise<ZooKeeperAdmin> connected = Promise.promise();\n+\n+        ZooKeeperAdmin zkAdmin = null;\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnection(zkAdmin);\n+                    connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete(zkAdmin);\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnection(zkAdmin);\n+                            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }*/\n+\n+    /*private Watcher connectionWatch(ZooKeeperAdmin zkAdmin, Promise connected)   {\n+        return new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                switch (event.getState()) {\n+                    case SyncConnected:\n+                        event.getWrapper().\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete(zkAdmin);\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnection(zkAdmin);\n+                            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+            }\n+        };\n+    }*/\n+\n+    /*private void connectionTimoutTimer(ZooKeeperAdmin zkAdmin, Promise connected) {\n+        if (!connected.future().isComplete()) {\n+            log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+            closeConnection(zkAdmin);\n+            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+        }\n+    }*/", "originalCommit": "b77944076870b8157f21da73b62d64848c6e2347", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "212192c199f40225364bf6e038e4885ee6a8e718", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/212192c199f40225364bf6e038e4885ee6a8e718", "message": "Remove old code\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T15:10:27Z", "type": "commit"}, {"oid": "31fad9788e52bdbdcef31f4e957065b5bb7f2f29", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/31fad9788e52bdbdcef31f4e957065b5bb7f2f29", "message": "Deal with final classes differently -> using Mockito-Inline breaks other tests by being too slow?\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-03-20T16:49:27Z", "type": "commit"}]}