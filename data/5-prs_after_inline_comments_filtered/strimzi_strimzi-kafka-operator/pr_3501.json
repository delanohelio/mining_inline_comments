{"pr_number": 3501, "pr_title": "Dynamic logging for connect", "pr_createdAt": "2020-08-12T13:19:34Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501", "timeline": [{"oid": "1be594f8b4cd626a793418a35819e60e2a08fb6f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1be594f8b4cd626a793418a35819e60e2a08fb6f", "message": "Dynamic logging for connect\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-12T13:10:46Z", "type": "commit"}, {"oid": "f1c3c8145ef4d7c267d1f7f8fd882a500be6b05e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f1c3c8145ef4d7c267d1f7f8fd882a500be6b05e", "message": "chnglg\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-12T13:18:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1ODcwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r469258700", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CountDownLatch latch2 = new CountDownLatch(1);\n          \n          \n            \n                    client.updateConnectorLoggers(\"localhost\", PORT, desired)\n          \n          \n            \n                            .onComplete(connectorLoggers -> context.verify(() -> {\n          \n          \n            \n                                client.listConnectorLoggers(\"localhost\", PORT).onComplete(map -> {\n          \n          \n            \n                                    context.verify(() -> {\n          \n          \n            \n                                        assertThat(map.result().get(\"org.reflections\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"org.apache.zookeeper\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"root\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"unknown\"), is(notNullValue()));\n          \n          \n            \n                                        assertThat(map.result().get(\"unknown\").get(\"level\"), is(\"DEBUG\"));\n          \n          \n            \n                                        async.flag();\n          \n          \n            \n                                        latch2.countDown();\n          \n          \n            \n                                    });\n          \n          \n            \n                                });\n          \n          \n            \n                            }));\n          \n          \n            \n                    latch2.await(30, TimeUnit.SECONDS);\n          \n          \n            \n                    Checkpoint async = context.checkpoint();\n          \n          \n            \n                    client.updateConnectorLoggers(\"localhost\", PORT, desired)\n          \n          \n            \n                            .onComplete(context.succeeding())\n          \n          \n            \n                            .compose(connectorLoggers -> client.listConnectorLoggers(\"localhost\", PORT))\n          \n          \n            \n                            .onComplete(map -> context.verify(() -> {\n          \n          \n            \n                                        assertThat(map.result().get(\"org.reflections\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"org.apache.zookeeper\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"root\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.result().get(\"unknown\"), is(notNullValue()));\n          \n          \n            \n                                        assertThat(map.result().get(\"unknown\").get(\"level\"), is(\"DEBUG\"));\n          \n          \n            \n                                        async.flag();\n          \n          \n            \n                                    });\n          \n          \n            \n                                });\n          \n          \n            \n                            }));\n          \n      \n    \n    \n  \n\nonComplete should verify some state and then the next call should be made in a compose, and then followed by an onComplete and so on..", "author": "samuel-hawker", "createdAt": "2020-08-12T13:27:59Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiTest.java", "diffHunk": "@@ -249,4 +252,58 @@ public void handle(Long timerId) {\n                 async.flag();\n             }));\n     }\n+\n+    @Test\n+    public void testChangeLoggers(VertxTestContext context) throws InterruptedException {\n+        String desired = \"log4j.rootLogger=INFO, CONSOLE\\n\" +\n+                \"log4j.logger.org.apache.zookeeper=WARN\\n\" +\n+                \"log4j.logger.org.I0Itec.zkclient=WARN\\n\" +\n+                \"log4j.logger.org.reflections=WARN\";\n+\n+        KafkaConnectApi client = new KafkaConnectApiImpl(vertx);\n+        Checkpoint async = context.checkpoint(2);\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+        client.updateConnectorLoggers(\"localhost\", PORT, desired)\n+                .onComplete(connectorLoggers -> context.verify(() -> {\n+                    client.listConnectorLoggers(\"localhost\", PORT)\n+                        .onComplete(map -> {\n+                            context.verify(() -> {\n+                                assertThat(map.result().get(\"org.apache.zookeeper\").get(\"level\"), is(\"WARN\"));\n+                                assertThat(map.result().get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"WARN\"));\n+                                assertThat(map.result().get(\"org.reflections\").get(\"level\"), is(\"WARN\"));\n+                                assertThat(map.result().get(\"root\").get(\"level\"), is(\"INFO\"));\n+                                assertThat(map.result().get(\"io.debezium\").get(\"level\"), is(\"ERROR\"));\n+                                assertThat(map.result().get(\"unknown\"), is(nullValue()));\n+                                async.flag();\n+                                latch.countDown();\n+                            });\n+                        });\n+                }));\n+        latch.await(30, TimeUnit.SECONDS);\n+\n+        desired = \"log4j.rootLogger=INFO, CONSOLE\\n\" +\n+                \"log4j.logger.org.apache.zookeeper=FATAL\\n\" +\n+                \"log4j.logger.org.I0Itec.zkclient=FATAL\\n\" +\n+                \"log4j.logger.unknown=DEBUG\\n\" +\n+                \"log4j.logger.org.reflections=FATAL\";\n+\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        client.updateConnectorLoggers(\"localhost\", PORT, desired)\n+                .onComplete(connectorLoggers -> context.verify(() -> {\n+                    client.listConnectorLoggers(\"localhost\", PORT).onComplete(map -> {\n+                        context.verify(() -> {\n+                            assertThat(map.result().get(\"org.reflections\").get(\"level\"), is(\"FATAL\"));\n+                            assertThat(map.result().get(\"org.apache.zookeeper\").get(\"level\"), is(\"FATAL\"));\n+                            assertThat(map.result().get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"FATAL\"));\n+                            assertThat(map.result().get(\"root\").get(\"level\"), is(\"INFO\"));\n+                            assertThat(map.result().get(\"unknown\"), is(notNullValue()));\n+                            assertThat(map.result().get(\"unknown\").get(\"level\"), is(\"DEBUG\"));\n+                            async.flag();\n+                            latch2.countDown();\n+                        });\n+                    });\n+                }));\n+        latch2.await(30, TimeUnit.SECONDS);", "originalCommit": "f1c3c8145ef4d7c267d1f7f8fd882a500be6b05e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5NTUyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r469295525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .compose(a -> client.listConnectorLoggers(\"localhost\", PORT)\n          \n          \n            \n                                    .onComplete(context.succeeding(map -> context.verify(() -> {\n          \n          \n            \n                                        assertThat(map.get(\"org.apache.zookeeper\").get(\"level\"), is(\"WARN\"));\n          \n          \n            \n                                        assertThat(map.get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.get(\"org.reflections\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.get(\"org.reflections.Reflection\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.get(\"root\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.get(\"io.debezium\").get(\"level\"), is(\"ERROR\"));\n          \n          \n            \n                                        assertThat(map.get(\"unknown\"), is(nullValue()));\n          \n          \n            \n                                        async.flag();\n          \n          \n            \n                                    }))))\n          \n          \n            \n                            .onComplete(context.succeeding());\n          \n          \n            \n                            .compose(a -> client.listConnectorLoggers(\"localhost\", PORT))\n          \n          \n            \n                            .onComplete(context.succeeding(map -> context.verify(() -> {\n          \n          \n            \n                                        assertThat(map.get(\"org.apache.zookeeper\").get(\"level\"), is(\"WARN\"));\n          \n          \n            \n                                        assertThat(map.get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.get(\"org.reflections\").get(\"level\"), is(\"FATAL\"));\n          \n          \n            \n                                        assertThat(map.get(\"org.reflections.Reflection\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.get(\"root\").get(\"level\"), is(\"INFO\"));\n          \n          \n            \n                                        assertThat(map.get(\"io.debezium\").get(\"level\"), is(\"ERROR\"));\n          \n          \n            \n                                        assertThat(map.get(\"unknown\"), is(nullValue()));\n          \n          \n            \n                                        async.flag();\n          \n          \n            \n                                    }))))", "author": "samuel-hawker", "createdAt": "2020-08-12T14:20:09Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiTest.java", "diffHunk": "@@ -249,4 +250,32 @@ public void handle(Long timerId) {\n                 async.flag();\n             }));\n     }\n+\n+    @Test\n+    public void testChangeLoggers(VertxTestContext context) throws InterruptedException {\n+        String desired = \"log4j.rootLogger=INFO, CONSOLE\\n\" +\n+                \"log4j.logger.org.apache.zookeeper=WARN\\n\" +\n+                \"log4j.logger.org.I0Itec.zkclient=INFO\\n\" +\n+                \"log4j.logger.org.reflections.Reflection=INFO\\n\" +\n+                \"log4j.logger.org.reflections=FATAL\";\n+\n+        KafkaConnectApi client = new KafkaConnectApiImpl(vertx);\n+        Checkpoint async = context.checkpoint();\n+\n+        client.updateConnectorLoggers(\"localhost\", PORT, desired)\n+                .onComplete(context.succeeding())\n+                .compose(a -> client.listConnectorLoggers(\"localhost\", PORT)\n+                        .onComplete(context.succeeding(map -> context.verify(() -> {\n+                            assertThat(map.get(\"org.apache.zookeeper\").get(\"level\"), is(\"WARN\"));\n+                            assertThat(map.get(\"org.I0Itec.zkclient\").get(\"level\"), is(\"INFO\"));\n+                            assertThat(map.get(\"org.reflections\").get(\"level\"), is(\"FATAL\"));\n+                            assertThat(map.get(\"org.reflections.Reflection\").get(\"level\"), is(\"INFO\"));\n+                            assertThat(map.get(\"root\").get(\"level\"), is(\"INFO\"));\n+                            assertThat(map.get(\"io.debezium\").get(\"level\"), is(\"ERROR\"));\n+                            assertThat(map.get(\"unknown\"), is(nullValue()));\n+                            async.flag();\n+                        }))))\n+                .onComplete(context.succeeding());", "originalCommit": "4a0e9246f9cbdf29741eaddd339079f5b1e8b825", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5NjI5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r469296298", "bodyText": "is loggingAppenders intended to be a common interface across all operators?\nWhat about applications that don't use log4j?", "author": "samuel-hawker", "createdAt": "2020-08-12T14:21:12Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -339,4 +341,16 @@ public Counter getPeriodicReconciliationsCounter() {\n     public AtomicInteger getResourceCounter() {\n         return resourceCounter;\n     }\n+\n+    public String getLoggingAppenders(String loggingConfiguration) {", "originalCommit": "4a0e9246f9cbdf29741eaddd339079f5b1e8b825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5Nzc2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r469297761", "bodyText": "It is just common method to get appenders from the log4j configuration.", "author": "sknot-rh", "createdAt": "2020-08-12T14:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5NjI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMDM3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472920372", "bodyText": "Does it really need to be in AbstractOperator though? It seems like a utility method to me.", "author": "tombentley", "createdAt": "2020-08-19T10:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5NjI5OA=="}], "type": "inlineReview"}, {"oid": "65738cb8ef3551dc7b91388df31573cce127d9a8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/65738cb8ef3551dc7b91388df31573cce127d9a8", "message": "tests fix\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-12T14:23:26Z", "type": "forcePushed"}, {"oid": "5788e7831bacf4e18d0749a58a01ae10ae80c8fd", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5788e7831bacf4e18d0749a58a01ae10ae80c8fd", "message": "tests fix\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-12T14:54:15Z", "type": "commit"}, {"oid": "5788e7831bacf4e18d0749a58a01ae10ae80c8fd", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5788e7831bacf4e18d0749a58a01ae10ae80c8fd", "message": "tests fix\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-12T14:54:15Z", "type": "forcePushed"}, {"oid": "096e17e78bd2e468be5f3454944f781403ad1a43", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/096e17e78bd2e468be5f3454944f781403ad1a43", "message": "doc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-13T07:41:16Z", "type": "commit"}, {"oid": "9d5a317bc846c88d29f4db619887cab83dfcecf5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9d5a317bc846c88d29f4db619887cab83dfcecf5", "message": "rc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-13T08:08:07Z", "type": "commit"}, {"oid": "9d5a317bc846c88d29f4db619887cab83dfcecf5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9d5a317bc846c88d29f4db619887cab83dfcecf5", "message": "rc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-13T08:08:07Z", "type": "forcePushed"}, {"oid": "5cb63538781466fcd7c2d20d657145c240bd0c92", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5cb63538781466fcd7c2d20d657145c240bd0c92", "message": "compare\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-17T06:31:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwOTE1NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472509154", "bodyText": "What exactly are we suppressing? Any way to avoid it? Maybe we could start adding comments to explain.", "author": "scholzj", "createdAt": "2020-08-18T21:40:43Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -469,4 +484,135 @@ void rescheduleOrComplete(Long tid) {\n                 .end();\n         return result.future();\n     }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "5cb63538781466fcd7c2d20d657145c240bd0c92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwOTY3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472509678", "bodyText": "Might be worth adding Javadoc. The input parameters are obvious, but what to expect inside the map isn't. Especially since this is. public method.", "author": "scholzj", "createdAt": "2020-08-18T21:41:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -469,4 +484,135 @@ void rescheduleOrComplete(Long tid) {\n                 .end();\n         return result.future();\n     }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {", "originalCommit": "5cb63538781466fcd7c2d20d657145c240bd0c92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMDI0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472510246", "bodyText": "For this and all the other functions ... are these really Connector loggers? I assumed they are configure for the whole connect and not per connector in which case they would be Connect loggers.", "author": "scholzj", "createdAt": "2020-08-18T21:43:19Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -133,6 +136,18 @@\n      * this returns the list of connector plugins.\n      */\n     Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port);\n+\n+    /**\n+     * Make a {@code GET} request to {@code /admin/loggers}.\n+     * @param host The host to make the request to.\n+     * @param port The port to make the request to.\n+     * @param desiredLogging Desired logging.\n+     * @return A Future which completes with the result of the request. If the request was successful,\n+     * this returns the list of connector loggers.\n+     */\n+    Future<Void> updateConnectorLoggers(String host, int port, String desiredLogging);", "originalCommit": "5cb63538781466fcd7c2d20d657145c240bd0c92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMjA1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472512053", "bodyText": "Same as above ... do we really need this?", "author": "scholzj", "createdAt": "2020-08-18T21:47:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -469,4 +484,135 @@ void rescheduleOrComplete(Long tid) {\n                 .end();\n         return result.future();\n     }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), Map.class);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e)  {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n+                updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());\n+            }\n+        });\n+\n+        LinkedHashMap<String, String> updateSortedLoggers = sortLoggers(updateLoggers);\n+        Future<Void> result = Future.succeededFuture();\n+        for (Map.Entry<String, String> logger: updateSortedLoggers.entrySet()) {\n+            result = result.compose(previous -> updateConnectorLogger(host, port, logger.getKey(), logger.getValue().split(\",\")[0].replaceAll(\"\\\\s\", \"\")));\n+        }\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "5cb63538781466fcd7c2d20d657145c240bd0c92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMzk0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472513946", "bodyText": "How does this differ from ANNO_STRIMZI_LOGGING_APPENDERS_HASH from #3469 ? Is it really different annotation - i.e. not hash? If yes, why are we using hash there and not here? I guess we need to keep the old values and be able to recover them?", "author": "scholzj", "createdAt": "2020-08-18T21:51:29Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n     public static final String STRIMZI_DOMAIN = \"strimzi.io/\";\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n+    public static final String STRIMZI_LOGGING_APPENDERS_ANNOTATION = STRIMZI_DOMAIN + \"logging-appenders\";", "originalCommit": "5cb63538781466fcd7c2d20d657145c240bd0c92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNTkxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472515918", "bodyText": "This makes it sound like there are only appenders which need rolling update and loggers which can be set dynamically. Is there nothing else in the Log4j files? Would it be better to filter out here what you can set dynamically and keep the rest for the rolling update? I guess the same applies to #3469?", "author": "scholzj", "createdAt": "2020-08-18T21:56:06Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -339,4 +341,16 @@ public Counter getPeriodicReconciliationsCounter() {\n     public AtomicInteger getResourceCounter() {\n         return resourceCounter;\n     }\n+\n+    public String getLoggingAppenders(String loggingConfiguration) {\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(loggingConfiguration);\n+        StringBuilder result = new StringBuilder();\n+        for (Map.Entry<String, String> entry: ops.asMap().entrySet()) {\n+            if (entry.getKey().startsWith(\"log4j.appender\")) {\n+                result.append(entry.getKey()).append(\"=\").append(entry.getValue());\n+            }\n+        }\n+        return result.toString();", "originalCommit": "5cb63538781466fcd7c2d20d657145c240bd0c92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc1NjUwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472756507", "bodyText": "You are right", "author": "sknot-rh", "createdAt": "2020-08-19T06:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNTkxOA=="}], "type": "inlineReview"}, {"oid": "5932217501782177ebdc5c7482094596c2f2cc37", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5932217501782177ebdc5c7482094596c2f2cc37", "message": "Jakub's rc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-19T06:59:58Z", "type": "commit"}, {"oid": "5932217501782177ebdc5c7482094596c2f2cc37", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5932217501782177ebdc5c7482094596c2f2cc37", "message": "Jakub's rc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-19T06:59:58Z", "type": "forcePushed"}, {"oid": "876bf24968bf7e017e6854f9188bb34c0c4fdbc1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/876bf24968bf7e017e6854f9188bb34c0c4fdbc1", "message": "remove unchecked suppressions\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-19T07:59:38Z", "type": "commit"}, {"oid": "35d94b6dec854650feebbc98333c72bd6db29bb3", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/35d94b6dec854650feebbc98333c72bd6db29bb3", "message": "spotbugs refactor\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-19T08:18:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkwOTY4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472909686", "bodyText": "Can we factor ObjectMapper into a constant, since it's thread safe it should be OK to reuse the same instance across all methods in this class.", "author": "tombentley", "createdAt": "2020-08-19T09:57:43Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMTAwMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472911001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n          \n          \n            \n                        } else if (!entry.getKey().startsWith(\"log4j.appender.\")) {", "author": "tombentley", "createdAt": "2020-08-19T10:00:06Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), MAP_OF_MAP_OF_STRINGS);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMTc2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472911765", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());\n          \n          \n            \n                            updateLoggers.put(entry.getKey().substring(\"log4j.logger.\".length()), entry.getValue());", "author": "tombentley", "createdAt": "2020-08-19T10:01:32Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), MAP_OF_MAP_OF_STRINGS);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n+                updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMjc5Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472912796", "bodyText": "I think you should refactor the .split(\",\")[0].replaceAll(\"\\\\s\", \"\")  into a method and provide a comment explaining it.", "author": "tombentley", "createdAt": "2020-08-19T10:03:32Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), MAP_OF_MAP_OF_STRINGS);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n+                updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());\n+            }\n+        });\n+\n+        LinkedHashMap<String, String> updateSortedLoggers = sortLoggers(updateLoggers);\n+        Future<Void> result = Future.succeededFuture();\n+        for (Map.Entry<String, String> logger : updateSortedLoggers.entrySet()) {\n+            result = result.compose(previous -> updateConnectorLogger(host, port, logger.getKey(), logger.getValue().split(\",\")[0].replaceAll(\"\\\\s\", \"\")));", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxNDkwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472914902", "bodyText": "That's horribly inefficient. Replace all needs to compile a Pattern, and you allocate a new String just to compute its length. for (int i = 0; i < tested.length(); i++) { if (tested.charAt(i) == '.') count++ }.", "author": "tombentley", "createdAt": "2020-08-19T10:07:17Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), MAP_OF_MAP_OF_STRINGS);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n+                updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());\n+            }\n+        });\n+\n+        LinkedHashMap<String, String> updateSortedLoggers = sortLoggers(updateLoggers);\n+        Future<Void> result = Future.succeededFuture();\n+        for (Map.Entry<String, String> logger : updateSortedLoggers.entrySet()) {\n+            result = result.compose(previous -> updateConnectorLogger(host, port, logger.getKey(), logger.getValue().split(\",\")[0].replaceAll(\"\\\\s\", \"\")));\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Future<Void> updateConnectLoggers(String host, int port, String desiredLogging) {\n+        return listConnectorLoggers(host, port).compose(fetchedLoggers -> updateLoggers(host, port, desiredLogging, fetchedLoggers));\n+    }\n+\n+    private int numberOfDotsInString(String tested) {\n+        return tested.length() - tested.replaceAll(\"\\\\.\", \"\").length();", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxNjM4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472916385", "bodyText": "Why not k1.compareTo(k2)? Because a prefix is < every string of which it is a prefix.", "author": "tombentley", "createdAt": "2020-08-19T10:09:49Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), MAP_OF_MAP_OF_STRINGS);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n+                updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());\n+            }\n+        });\n+\n+        LinkedHashMap<String, String> updateSortedLoggers = sortLoggers(updateLoggers);\n+        Future<Void> result = Future.succeededFuture();\n+        for (Map.Entry<String, String> logger : updateSortedLoggers.entrySet()) {\n+            result = result.compose(previous -> updateConnectorLogger(host, port, logger.getKey(), logger.getValue().split(\",\")[0].replaceAll(\"\\\\s\", \"\")));\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Future<Void> updateConnectLoggers(String host, int port, String desiredLogging) {\n+        return listConnectorLoggers(host, port).compose(fetchedLoggers -> updateLoggers(host, port, desiredLogging, fetchedLoggers));\n+    }\n+\n+    private int numberOfDotsInString(String tested) {\n+        return tested.length() - tested.replaceAll(\"\\\\.\", \"\").length();\n+    }\n+\n+    /**\n+     * To apply loggers correctly, we need to sort them. The sorting is performed on base of logger generality.\n+     * Logger \"abc.company\" is more general than \"abc.company.name\"\n+     * @param loggers map of loggers to be sorted\n+     * @return map of sorted loggers\n+     */\n+    private LinkedHashMap<String, String> sortLoggers(Map<String, String> loggers) {\n+        Comparator<Map.Entry<String, String>> loggerComparator = (e1, e2) -> {\n+            String k1 = e1.getKey();\n+            String k2 = e2.getKey();\n+            if (k1.equals(\"root\")) {\n+                // we need root logger always to be the first logger to be set via REST API\n+                return Integer.MIN_VALUE;\n+            }\n+            if (k2.equals(\"root\")) {\n+                return Integer.MAX_VALUE;\n+            }\n+            return numberOfDotsInString(k1) - numberOfDotsInString(k2);", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxODc4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472918788", "bodyText": "I think you could replace this whole method with:\nString root = loggers.get(\"root\");\nList<Map.Entry<String, String>> listOfEntries = new ArrayList<>(loggers.entrySet());\nsort(listOfEntries, Comparator.comparing(e -> e.getKey()));\nLinkedHashMap<String, String> sortedLoggers = new LinkedHashMap<>(listOfEntries);\nif (root != null) {\n    sortedLoggers.put(\"root\", root);\n}\nreturn sortedLoggers;", "author": "tombentley", "createdAt": "2020-08-19T10:14:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApiImpl.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.strimzi.api.kafka.model.connect.ConnectorPlugin;\n+import io.strimzi.operator.common.BackOff;\n+import io.strimzi.operator.common.model.OrderedProperties;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings({\"deprecation\"})\n+class KafkaConnectApiImpl implements KafkaConnectApi {\n+    private static final Logger log = LogManager.getLogger(KafkaConnectApiImpl.class);\n+    public static final TypeReference<Map<String, Object>> TREE_TYPE = new TypeReference<Map<String, Object>>() {\n+    };\n+    public static final TypeReference<Map<String, String>> MAP_OF_STRINGS = new TypeReference<Map<String, String>>() {\n+    };\n+\n+    public static final TypeReference<Map<String, Map<String, String>>> MAP_OF_MAP_OF_STRINGS = new TypeReference<Map<String, Map<String, String>>>() {\n+\n+    };\n+    private final Vertx vertx;\n+\n+    public KafkaConnectApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Future<Map<String, Object>> createOrUpdatePutRequest(\n+            String host, int port,\n+            String connectorName, JsonObject configJson) {\n+        Promise<Map<String, Object>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        Buffer data = configJson.toBuffer();\n+        String path = \"/connectors/\" + connectorName + \"/config\";\n+        log.debug(\"Making PUT request to {} with body {}\", path, configJson);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.debug(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to PUT request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(data.length()))\n+                .write(data)\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> getConnector(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                TREE_TYPE);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> Future<T> doGet(String host, int port, String path, Set<Integer> okStatusCodes, TypeReference<T> type) {\n+        Promise<T> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        log.debug(\"Making GET request to {}\", path);\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (okStatusCodes.contains(response.statusCode())) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+                            try {\n+                                T t = mapper.readValue(buffer.getBytes(), type);\n+                                log.debug(\"Got {} response to GET request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n+                            } catch (IOException e) {\n+                                result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n+                            }\n+                        });\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.debug(\"Got {} response to GET request to {}\", response.statusCode(), path);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(\n+            String host, int port,\n+            String connectorName) {\n+        return doGet(host, port, String.format(\"/connectors/%s/config\", connectorName),\n+                new HashSet<>(asList(200, 201)),\n+                MAP_OF_STRINGS);\n+    }\n+\n+    @Override\n+    public Future<Map<String, String>> getConnectorConfig(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(409),\n+            () -> getConnectorConfig(host, port, connectorName), \"config\");\n+    }\n+\n+    @Override\n+    public Future<Void> delete(String host, int port, String connectorName) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connectors/\" + connectorName;\n+        vertx.createHttpClient(options)\n+                .delete(port, host, path, response -> {\n+                    if (response.statusCode() == 204) {\n+                        result.complete();\n+                    } else {\n+                        // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject x = buffer.toJsonObject();\n+                            result.fail(new ConnectRestException(response, x.getString(\"message\")));\n+                        });\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> statusWithBackOff(BackOff backOff, String host, int port, String connectorName) {\n+        return withBackoff(backOff, connectorName, Collections.singleton(404),\n+            () -> status(host, port, connectorName), \"status\");\n+    }\n+\n+    private <T> Future<T> withBackoff(BackOff backOff, String connectorName,\n+                                      Set<Integer> retriableStatusCodes,\n+                                      Supplier<Future<T>> supplier,\n+                                      String attribute) {\n+        Promise<T> result = Promise.promise();\n+\n+        Handler<Long> handler = new Handler<Long>() {\n+            @Override\n+            public void handle(Long tid) {\n+                supplier.get().onComplete(connectorStatus -> {\n+                    if (connectorStatus.succeeded()) {\n+                        result.complete(connectorStatus.result());\n+                    } else {\n+                        Throwable cause = connectorStatus.cause();\n+                        if (cause != null\n+                                && cause instanceof ConnectRestException\n+                                && retriableStatusCodes.contains(((ConnectRestException) cause).getStatusCode())) {\n+                            if (backOff.done()) {\n+                                log.debug(\"Connector {} {} returned HTTP {} and we run out of back off time\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                result.fail(cause);\n+                            } else {\n+                                log.debug(\"Connector {} {} returned HTTP {} - backing off\", connectorName, attribute, ((ConnectRestException) cause).getStatusCode());\n+                                rescheduleOrComplete(tid);\n+                            }\n+                        } else {\n+                            result.fail(cause);\n+                        }\n+                    }\n+                });\n+            }\n+\n+            void rescheduleOrComplete(Long tid) {\n+                if (backOff.done()) {\n+                    log.warn(\"Giving up waiting for status of connector {} after {} attempts taking {}ms\",\n+                            connectorName, backOff.maxAttempts(), backOff.totalDelayMs());\n+                } else {\n+                    // Schedule ourselves to run again\n+                    long delay = backOff.delayMs();\n+                    log.debug(\"Status for connector {} not found; \" +\n+                                    \"backing off for {}ms (cumulative {}ms)\",\n+                            connectorName, delay, backOff.cumulativeDelayMs());\n+                    if (delay < 1) {\n+                        this.handle(tid);\n+                    } else {\n+                        vertx.setTimer(delay, this);\n+                    }\n+                }\n+            }\n+        };\n+\n+        handler.handle(null);\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Object>> status(String host, int port, String connectorName) {\n+        String path = \"/connectors/\" + connectorName + \"/status\";\n+        return doGet(host, port, path, Collections.singleton(200), TREE_TYPE);\n+    }\n+\n+    @Override\n+    public Future<Void> pause(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/pause\");\n+    }\n+\n+    @Override\n+    public Future<Void> resume(String host, int port, String connectorName) {\n+        return pauseResume(host, port, \"/connectors/\" + connectorName + \"/resume\");\n+    }\n+\n+    private Future<Void> pauseResume(String host, int port, String path) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 202) {\n+                        result.complete();\n+                    } else {\n+                        result.fail(\"Unexpected status code \" + response.statusCode()\n+                                + \" for GET request to \" + host + \":\" + port + path);\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<String>> list(String host, int port) {\n+        String path = \"/connectors\";\n+        Promise<List<String>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            JsonArray objects = buffer.toJsonArray();\n+                            List<String> list = new ArrayList<>(objects.size());\n+                            for (Object o : objects) {\n+                                if (o instanceof String) {\n+                                    list.add((String) o);\n+                                } else {\n+                                    result.fail(o == null ? \"null\" : o.getClass().getName());\n+                                }\n+                            }\n+                            result.complete(list);\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<List<ConnectorPlugin>> listConnectorPlugins(String host, int port) {\n+        Promise<List<ConnectorPlugin>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/connector-plugins\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                result.complete(asList(mapper.readValue(buffer.getBytes(), ConnectorPlugin[].class)));\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to parse list of connector plugins\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to parse list of connector plugins\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateConnectorLogger(String host, int port, String logger, String level) {\n+        Promise<Void> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\" + logger;\n+        JsonObject levelJO = new JsonObject();\n+        levelJO.put(\"level\", level);\n+        log.debug(\"Making PUT request to {} with body {}\", path, levelJO);\n+        vertx.createHttpClient(options)\n+                .put(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    response.bodyHandler(body -> {\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        log.debug(\"Logger {} updated to level {}\", logger, level);\n+                        result.complete();\n+                    } else {\n+                        log.debug(\"Logger {} did not update to level {} (http code {})\", logger, level, response.statusCode());\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .putHeader(\"Content-Type\", \"application/json\")\n+                .putHeader(\"Content-Length\", String.valueOf(levelJO.toBuffer().length()))\n+                .setFollowRedirects(true)\n+                .write(levelJO.toBuffer())\n+                .end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    public Future<Map<String, Map<String, String>>> listConnectorLoggers(String host, int port) {\n+        Promise<Map<String, Map<String, String>>> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(true);\n+        String path = \"/admin/loggers/\";\n+        vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(error -> {\n+                        result.fail(error);\n+                    });\n+                    if (response.statusCode() == 200) {\n+                        response.bodyHandler(buffer -> {\n+                            ObjectMapper mapper = new ObjectMapper();\n+\n+                            try {\n+                                Map<String, Map<String, String>> fetchedLoggers = mapper.readValue(buffer.getBytes(), MAP_OF_MAP_OF_STRINGS);\n+                                result.complete(fetchedLoggers);\n+                            } catch (IOException e) {\n+                                log.warn(\"Failed to get list of connector loggers\", e);\n+                                result.fail(new ConnectRestException(response, \"Failed to get connector loggers\", e));\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new ConnectRestException(response, \"Unexpected status code\"));\n+                    }\n+                })\n+                .exceptionHandler(result::fail)\n+                .setFollowRedirects(true)\n+                .putHeader(\"Accept\", \"application/json\")\n+                .end();\n+        return result.future();\n+    }\n+\n+    private Future<Void> updateLoggers(String host, int port, String desiredLogging, Map<String, Map<String, String>> fetchedLoggers) {\n+        Map<String, String> updateLoggers = new LinkedHashMap<>();\n+        fetchedLoggers.entrySet().forEach(entry -> {\n+            // set all logger levels to OFF\n+            updateLoggers.put(entry.getKey(), \"OFF\");\n+        });\n+\n+        OrderedProperties ops = new OrderedProperties();\n+        ops.addStringPairs(desiredLogging);\n+        ops.asMap().entrySet().forEach(entry -> {\n+            // set desired loggers to desired levels\n+            if (entry.getKey().equals(\"log4j.rootLogger\")) {\n+                updateLoggers.put(\"root\", entry.getValue());\n+            } else if (!entry.getKey().startsWith(\"log4j.appender\")) {\n+                updateLoggers.put(entry.getKey().replace(\"log4j.logger.\", \"\"), entry.getValue());\n+            }\n+        });\n+\n+        LinkedHashMap<String, String> updateSortedLoggers = sortLoggers(updateLoggers);\n+        Future<Void> result = Future.succeededFuture();\n+        for (Map.Entry<String, String> logger : updateSortedLoggers.entrySet()) {\n+            result = result.compose(previous -> updateConnectorLogger(host, port, logger.getKey(), logger.getValue().split(\",\")[0].replaceAll(\"\\\\s\", \"\")));\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Future<Void> updateConnectLoggers(String host, int port, String desiredLogging) {\n+        return listConnectorLoggers(host, port).compose(fetchedLoggers -> updateLoggers(host, port, desiredLogging, fetchedLoggers));\n+    }\n+\n+    private int numberOfDotsInString(String tested) {\n+        return tested.length() - tested.replaceAll(\"\\\\.\", \"\").length();\n+    }\n+\n+    /**\n+     * To apply loggers correctly, we need to sort them. The sorting is performed on base of logger generality.\n+     * Logger \"abc.company\" is more general than \"abc.company.name\"\n+     * @param loggers map of loggers to be sorted\n+     * @return map of sorted loggers\n+     */\n+    private LinkedHashMap<String, String> sortLoggers(Map<String, String> loggers) {\n+        Comparator<Map.Entry<String, String>> loggerComparator = (e1, e2) -> {\n+            String k1 = e1.getKey();\n+            String k2 = e2.getKey();\n+            if (k1.equals(\"root\")) {\n+                // we need root logger always to be the first logger to be set via REST API\n+                return Integer.MIN_VALUE;\n+            }\n+            if (k2.equals(\"root\")) {\n+                return Integer.MAX_VALUE;\n+            }\n+            return numberOfDotsInString(k1) - numberOfDotsInString(k2);\n+        };\n+        List<Map.Entry<String, String>> listOfEntries = new ArrayList<>(loggers.entrySet());\n+        Collections.sort(listOfEntries, loggerComparator);", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMzU3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472923574", "bodyText": "512 bit hash => 64 bytes => 128 chars in the string. I don't think we need to be so resilient to a collision that we need to spend that much effort. 64 bits would be more than enough IMHO.", "author": "tombentley", "createdAt": "2020-08-19T10:22:16Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Util.java", "diffHunk": "@@ -369,4 +371,24 @@ public static ConfigResource getBrokersConfig(int podId) {\n     public static ConfigResource getBrokersConfig(String podId) {\n         return new ConfigResource(ConfigResource.Type.BROKER, podId);\n     }\n+\n+    public static String getStringHash(String toBeHashed)  {\n+        try {\n+            MessageDigest hashFunc = MessageDigest.getInstance(\"SHA-512\");", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMzYwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r472923600", "bodyText": "This should be just called stringHash(). Why the fetish with prefixing every method which returns something with get?\nAlso some Java doc would not go amiss.", "author": "tombentley", "createdAt": "2020-08-19T10:22:18Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Util.java", "diffHunk": "@@ -369,4 +371,24 @@ public static ConfigResource getBrokersConfig(int podId) {\n     public static ConfigResource getBrokersConfig(String podId) {\n         return new ConfigResource(ConfigResource.Type.BROKER, podId);\n     }\n+\n+    public static String getStringHash(String toBeHashed)  {", "originalCommit": "35d94b6dec854650feebbc98333c72bd6db29bb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "22427ce085f0fb67aa05b6b6945694a01a60dc20", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/22427ce085f0fb67aa05b6b6945694a01a60dc20", "message": "Tom's comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-20T06:39:57Z", "type": "commit"}, {"oid": "22427ce085f0fb67aa05b6b6945694a01a60dc20", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/22427ce085f0fb67aa05b6b6945694a01a60dc20", "message": "Tom's comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-20T06:39:57Z", "type": "forcePushed"}, {"oid": "2681b5eb405737e79ce796529ba2152e38b552c8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2681b5eb405737e79ce796529ba2152e38b552c8", "message": "comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-21T07:15:39Z", "type": "commit"}, {"oid": "06c9b0364b50a03b02e9728f73b23e3963329922", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/06c9b0364b50a03b02e9728f73b23e3963329922", "message": "fix\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-21T12:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc0Nzg0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r474747847", "bodyText": "Javadoc", "author": "tombentley", "createdAt": "2020-08-21T14:51:21Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Util.java", "diffHunk": "@@ -369,4 +372,36 @@ public static ConfigResource getBrokersConfig(int podId) {\n     public static ConfigResource getBrokersConfig(String podId) {\n         return new ConfigResource(ConfigResource.Type.BROKER, podId);\n     }\n+\n+    public static String stringHash(String toBeHashed)  {", "originalCommit": "06c9b0364b50a03b02e9728f73b23e3963329922", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc0ODIyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3501#discussion_r474748224", "bodyText": "Javadoc", "author": "tombentley", "createdAt": "2020-08-21T14:51:58Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Util.java", "diffHunk": "@@ -369,4 +372,36 @@ public static ConfigResource getBrokersConfig(int podId) {\n     public static ConfigResource getBrokersConfig(String podId) {\n         return new ConfigResource(ConfigResource.Type.BROKER, podId);\n     }\n+\n+    public static String stringHash(String toBeHashed)  {\n+        try {\n+            MessageDigest hashFunc = MessageDigest.getInstance(\"SHA\");\n+\n+            byte[] hash = hashFunc.digest(toBeHashed.getBytes(StandardCharsets.UTF_8));\n+\n+            StringBuffer stringHash = new StringBuffer();\n+\n+            for (int i = 0; i < hash.length; i++) {\n+                String hex = Integer.toHexString(0xff & hash[i]);\n+                if (hex.length() == 1) stringHash.append('0');\n+                stringHash.append(hex);\n+            }\n+\n+            return stringHash.toString();\n+        } catch (NoSuchAlgorithmException e)    {\n+            throw new RuntimeException(\"Failed to create SHA MessageDigest instance\");\n+        }\n+    }\n+\n+    public static String getLoggingDynamicallyUnmodifiableEntries(String loggingConfiguration) {", "originalCommit": "06c9b0364b50a03b02e9728f73b23e3963329922", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "29576fac1be3f0b6093b475f8dab74836ca7b6a4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/29576fac1be3f0b6093b475f8dab74836ca7b6a4", "message": "fix + STg\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-24T09:55:03Z", "type": "commit"}, {"oid": "b793e11d4775b8dd63c96f78934a604fc1e4640d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b793e11d4775b8dd63c96f78934a604fc1e4640d", "message": "doc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-24T10:17:00Z", "type": "commit"}, {"oid": "b793e11d4775b8dd63c96f78934a604fc1e4640d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b793e11d4775b8dd63c96f78934a604fc1e4640d", "message": "doc\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-08-24T10:17:00Z", "type": "forcePushed"}]}