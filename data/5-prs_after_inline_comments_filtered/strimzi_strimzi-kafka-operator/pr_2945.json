{"pr_number": 2945, "pr_title": "KafkaClusterRebalance CRD and rebalance operator", "pr_createdAt": "2020-05-04T16:37:02Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419642800", "bodyText": "I find this a bit weird. Since the CR which deploys Kafka cluster is just Kafka, should this be just KafkaRebalance?", "author": "scholzj", "createdAt": "2020-05-04T18:33:59Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxNjc0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419916741", "bodyText": "I thought about it for a long time, leaving it as it is but yes I would agree.", "author": "ppatierno", "createdAt": "2020-05-05T07:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxNzk4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419917986", "bodyText": "There is no going back ... so I think you should either agree and change it or disagree and leave it as it is :-o", "author": "scholzj", "createdAt": "2020-05-05T07:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxODkzNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419918935", "bodyText": "What I meant is that I agree, just asking to myself why I didn't do that before opening the PR. So, I will change!", "author": "ppatierno", "createdAt": "2020-05-05T07:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyMDUxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419920519", "bodyText": "Ahh, ok ... understood ... thanks.", "author": "scholzj", "createdAt": "2020-05-05T07:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1ODQ0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420058442", "bodyText": "Done", "author": "ppatierno", "createdAt": "2020-05-05T12:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzY3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419643674", "bodyText": "We don't seem to override toString in other APi classes. Why do we need it here?", "author": "scholzj", "createdAt": "2020-05-04T18:35:34Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaClusterRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")\n+    public List<String> getGoals() {\n+        return goals;\n+    }\n+\n+    public void setGoals(List<String> goals) {\n+        this.goals = goals;\n+    }\n+\n+    @Description(\"Whether to allow hard goals to be skipped in rebalance proposal generation. Default is false.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public boolean isSkipHardGoalCheck() {\n+        return skipHardGoalCheck;\n+    }\n+\n+    public void setSkipHardGoalCheck(boolean skipHardGoalCheck) {\n+        this.skipHardGoalCheck = skipHardGoalCheck;\n+    }\n+\n+    @Override\n+    public Map<String, Object> getAdditionalProperties() {\n+        return this.additionalProperties;\n+    }\n+\n+    @Override\n+    public void setAdditionalProperty(String name, Object value) {\n+        this.additionalProperties.put(name, value);\n+    }\n+\n+    @Override\n+    public String toString() {", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxNzQ1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419917452", "bodyText": "I see it in KafkaBridge, KafkaUser, KafkaMirrorMaker ... just for naming a few of them.", "author": "ppatierno", "createdAt": "2020-05-05T07:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyMDMzOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419920339", "bodyText": "But matching classes for this class are KafkaUserSpec, KafkaBridgeSpec and KafkaMirrorMakerSpec. And I do not see it in any of those.", "author": "scholzj", "createdAt": "2020-05-05T07:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzNDczMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419934731", "bodyText": "Right", "author": "ppatierno", "createdAt": "2020-05-05T08:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDI2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419644265", "bodyText": "Is this something the user can use in any way? My understanding was that we do not allow access to the CC API.", "author": "scholzj", "createdAt": "2020-05-04T18:36:27Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaClusterRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getOptimizationResult() {\n+        return optimizationResult;\n+    }\n+\n+    public void setOptimizationResult(Map<String, Object> optimizationResult) {\n+        this.optimizationResult = optimizationResult;\n+    }\n+\n+    @Description(\"The session identifier for requests to Cruise Control pertaining to this KafkaClusterRebalance resource.\")", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxODExOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419918119", "bodyText": "No, we are using the session in the status as a way to store this information that the operator needs for tracking the state of the rebalance.", "author": "ppatierno", "createdAt": "2020-05-05T07:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyMDkxNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419920915", "bodyText": "Should that be somehow clarified in the description?", "author": "scholzj", "createdAt": "2020-05-05T07:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIwNTEyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420205125", "bodyText": "I added a clarification about it use.", "author": "tomncooper", "createdAt": "2020-05-05T15:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NjM1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419646359", "bodyText": "Could we have some comment what is this be used for?", "author": "scholzj", "createdAt": "2020-05-04T18:39:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419647250", "bodyText": "This looks like asking for a trouble .get(0).getType() ... should it instead properly find the right type?", "author": "scholzj", "createdAt": "2020-05-04T18:41:21Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEyMjg0NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420122845", "bodyText": "What do you mean? We want to print in which status is the rebalance operator state machine for printing a log.", "author": "ppatierno", "createdAt": "2020-05-05T13:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI1NTIxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420255219", "bodyText": "Well, right now you are printing which ever condition is in the position 0. But you probably want to print status of some specific condition?", "author": "scholzj", "createdAt": "2020-05-05T16:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM1MDQ4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420350481", "bodyText": "Our conditions collection is always made by just one condition. Isn't it the case in every status field for all the resources we are handling today?", "author": "ppatierno", "createdAt": "2020-05-05T19:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM1MTg4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420351887", "bodyText": "Some resources have more conditions - the Kafka one for example ... at least in some cases. That is why this looks a bit fragile - you have one condition now ... until you add more in some future and forget to change this.", "author": "scholzj", "createdAt": "2020-05-05T19:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM2MjMwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420362300", "bodyText": "Anyway, there is not a type I should search for as you mentioned in the first comment. We need the only one condition we have and the corresponding type in order to log it.", "author": "ppatierno", "createdAt": "2020-05-05T19:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MjczMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419652731", "bodyText": "I tink this would better fit into io.strimzi.operator.cluster.operator.resource.cruisecontrol", "author": "scholzj", "createdAt": "2020-05-04T18:50:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlApi.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU3ODI0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420578242", "bodyText": "I agree but at this point, we should move the KafkaConnectApi class as well under the resource. Of course, it's not related to the current PR.", "author": "ppatierno", "createdAt": "2020-05-06T06:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MjczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419656683", "bodyText": "Shoult this be offloaded somethere to api? It looks like it would be better fit there.", "author": "scholzj", "createdAt": "2020-05-04T18:57:31Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMjk2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420012963", "bodyText": "I think I disagree. If we put this in api then there would be the reasonable expectation that the current enum values are exhaustive, which would mean we couldn't add a new value (should we need to) without breaking compatibility. If this is just a String from the PoV of the public API then there isn't (or shouldn't be) that expectation.", "author": "tombentley", "createdAt": "2020-05-05T10:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEyNDAxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420124014", "bodyText": "but arent't the api supposed to be used somehow by users as well? we provide them even on Maven right? so a user can develop its own application interacting with Strimzi using this API. In this case we are talking about internal stuff related to the rebalance operator state machine.", "author": "ppatierno", "createdAt": "2020-05-05T13:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MTA3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420151075", "bodyText": "Yes, but the nature of the contract is different. If, in the api and also in the CRD JSON Schema it's an enum then users are entitled to conclude that items won't be added to the enumeration (e.g. users of the api module can write a switch over the enum with cases for each value). If we later need to add a value we're breaking that code. If it's just a String then they shouldn't be making those kinds of assumptions.", "author": "tombentley", "createdAt": "2020-05-05T14:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIwMTk2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420201963", "bodyText": "So I am confused, I was suggesting to leave this enum here. It seems you are on the same page @tombentley ?", "author": "ppatierno", "createdAt": "2020-05-05T15:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIwNTY3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420205675", "bodyText": "I think it's OK here, yes.", "author": "tombentley", "createdAt": "2020-05-05T15:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2MzU3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420263579", "bodyText": "So if this state is internal only, it is not used in the custom resources then? My understanding was that this is in the Status of the CR and I expected that users are interested in this information -> E.g. the proposal is pending, I should wait more, the proposal is ready, I should review it. That seems like exactly the thing which the user wants to do using the api. If we pretend that the status in the CR is just opaque String, it will force the user to write their own Enum and they will have to for every release dig the possible states out of the docs and they will have no build level checks that the old states still exist. So if this is part of the status, it should be AFAIC part of the api.", "author": "scholzj", "createdAt": "2020-05-05T16:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3NTE3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420275171", "bodyText": "The states should be public and documented, but we shouldn't imply that the ones which exist today will be the only ones. It's the exhaustivity which is the problem, not the visibility.", "author": "tombentley", "createdAt": "2020-05-05T17:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4Njc1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420286757", "bodyText": "I'm not sure I really understand it ... it is public APi, users need to understand them and use them, but we make their life miserable by forcing the to dig it out of the docs and double check it every release?\nOn a practical level, the list of the states in docs is as exhaustive and final as Enum would be. It is just much harder to use.", "author": "scholzj", "createdAt": "2020-05-05T17:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419656750", "bodyText": "Shoult this be offloaded somethere to api? It looks like it would be better fit there.", "author": "scholzj", "createdAt": "2020-05-04T18:57:37Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNjMzNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420236335", "bodyText": "I guess that the @tombentley 's comment on State is valid here as well. I would leave it here.", "author": "ppatierno", "createdAt": "2020-05-05T16:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2NDIwMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420264201", "bodyText": "Same as above. Isn't this the value to which the user should set the annotation to tell CC what to do?", "author": "scholzj", "createdAt": "2020-05-05T16:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM1NzAyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420357022", "bodyText": "Well, it's something like the \"strimzi.io/delete-pod-and-pvc\" and it's not in the api package, or?", "author": "ppatierno", "createdAt": "2020-05-05T19:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM2NDU0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420364547", "bodyText": "Isn't the only valid value in strimzi.io/delete-pod-and-pvc always true?\nI leave it up to you guys, not a fight worth fighting. But I don't understand the difference this makes from the API perspective? If adding a new value is breaking, we should avoid regardless of Enum or docs. And if someone actually uses the API the Enum would be useful.", "author": "scholzj", "createdAt": "2020-05-05T19:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3NTI5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420375293", "bodyText": "it's always true but it's not in the api, it's just documented. To be honest from my point of view what is in the API is something usable from a user from code, not something used to interact with the custom resources.", "author": "ppatierno", "createdAt": "2020-05-05T20:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3NjIwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420376205", "bodyText": "The hole API is about custom resources and working with them from Java. So reading the status, processing it, triggering actions etc. is IMHO part of it.", "author": "scholzj", "createdAt": "2020-05-05T20:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MTMzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420381333", "bodyText": "If we are saying that some user could write a Java application and interacting with the rebalance operator from there, then yes now I can see your point.\nAnyway again, even if the delete pod and pvc is true, it should be there helping the user to know that it exists and not putting a raw string in his Java code.", "author": "ppatierno", "createdAt": "2020-05-05T20:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMzIxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420403217", "bodyText": "For me that is something what makes sense ... for example writting an applicaiton which would create the KafkaRebalance resource with some goals, wait until the proposal is ready, check the proposal and trigger its application in the cluster. TBH, not sure how many users does the api have. Maybe its wasted effort.", "author": "scholzj", "createdAt": "2020-05-05T21:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1OTgyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419659829", "bodyText": "It looks like you execute this logic here only when event is triggered. Maybe I missed something, but this looks wrong. You have your own reconcileAll loop and you need to test this everytime in the loop, or?", "author": "scholzj", "createdAt": "2020-05-04T19:02:39Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY2NTMzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420665333", "bodyText": "good catch!", "author": "ppatierno", "createdAt": "2020-05-06T09:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1OTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MjIxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419662218", "bodyText": "Some Javadocs would not hurt ... you have getRebalanceAnnotation, rebalanceAnnotation, hasRebalanceAnnotation` ... not exactly clear what the difference is between those.", "author": "scholzj", "createdAt": "2020-05-04T19:06:37Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);\n+                                                // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                //       We can then update the status at this point.\n+                                                break;\n+                                            case ACTIVE: // Rebalance proposal is still being calculated\n+                                                // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                log.info(\"Rebalance ({}) optimization proposal is still being prepared\", sessionId);\n+                                                ccAPIErrorCount.set(0);\n+                                                break;\n+                                            default:\n+                                                log.error(\"Unexpected state {}\", taskStatus);\n+                                                vertx.cancelTimer(t);\n+                                                p.fail(\"Unexpected state \" + taskStatus);\n+                                                break;\n+                                        }\n+                                    } else {\n+                                        log.error(\"Cruise Control getting rebalance task status failed\", userTaskResult.cause());\n+                                        // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                        // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                        ccAPIErrorCount.getAndIncrement();\n+                                    }\n+                                });\n+                            }\n+                        } else {\n+                            p.complete(freshClusterRebalance.getStatus());\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       RebalanceAnnotation rebalanceAnnotation,\n+                                                       RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaClusterRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileClusterRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance) {\n+        if (clusterRebalance == null) {\n+            log.info(\"{}: rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            return clusterRebalanceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName())\n+                    .compose(fetchedClusterRebalance -> {\n+                        KafkaClusterRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                        // cluster rebalance is new or it is in one of others states\n+                        State currentState = clusterRebalanceStatus == null ? State.New :\n+                                State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                        // check annotation\n+                        RebalanceAnnotation rebalanceAnnotation = getRebalanceAnnotation(fetchedClusterRebalance);\n+                        return reconcile(reconciliation, host, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                    }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                                 String host, CruiseControlApi apiClient,\n+                                                                 boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+        boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaClusterRebalanceStatusBuilder()\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    private RebalanceAnnotation getRebalanceAnnotation(KafkaClusterRebalance clusterRebalance) {", "originalCommit": "7f47772bd80f692d74c18bc37c1d2f8a312983b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420004404", "bodyText": "Given the issue we've just had for Kafka Connect where we were passing back some json from its API which had a different ordering between reconciliations, how do we know this doesn't have the same issue?", "author": "tombentley", "createdAt": "2020-05-05T10:18:15Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaClusterRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getOptimizationResult() {\n+        return optimizationResult;", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEzMDI4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420130281", "bodyText": "There is no JSON that is passing back from the operator to the API, if I understood correctly your concern.", "author": "ppatierno", "createdAt": "2020-05-05T13:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MTY1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420151650", "bodyText": "So what are the Objects in this Map<String, Object>?", "author": "tombentley", "createdAt": "2020-05-05T14:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIyNDk2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420224962", "bodyText": "The optimisationResults are a JsonObject of String keys to String, double, int and lists of Strings. Hence the use of Object.", "author": "tomncooper", "createdAt": "2020-05-05T16:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNDM5Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420234396", "bodyText": "So you're saying that the lists of Strings are always going to be in the same order?", "author": "tombentley", "createdAt": "2020-05-05T16:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NzIyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420287226", "bodyText": "No, but the order does not matter. The map is just given as is to the Status to shown to the user.", "author": "tomncooper", "createdAt": "2020-05-05T17:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5ODU2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420298564", "bodyText": "That turned out to be a bit more complicated in Mirror Maker 2. I wonder if it would end up the same here :-o.", "author": "scholzj", "createdAt": "2020-05-05T17:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNzMwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420007308", "bodyText": "Does this comment belong here? I don't understand how it does, when this bit of code is now about anomaly goals.", "author": "tombentley", "createdAt": "2020-05-05T10:24:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzMzk0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420233943", "bodyText": "This is explaining the result of the code above, we could probably move it up there", "author": "kyguy", "createdAt": "2020-05-05T16:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNzg4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420007886", "bodyText": "getConfigOption can take a 2nd argument which provides a default.", "author": "tombentley", "createdAt": "2020-05-05T10:25:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list\n+        String anomalyGoalsString;\n+        if (configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY) != null) {\n+            // The user has defined some anomaly detection goals\n+            anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY);\n+        } else {\n+            // No anomaly detection goals have been defined by the user, therefore the defaults defined in Cruise Control\n+            // will be used.\n+            anomalyGoalsString = CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS;\n+        }", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwODEyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420008121", "bodyText": "How do you know defaultGoalsString is not null?", "author": "tombentley", "createdAt": "2020-05-05T10:25:40Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list\n+        String anomalyGoalsString;\n+        if (configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY) != null) {\n+            // The user has defined some anomaly detection goals\n+            anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY);\n+        } else {\n+            // No anomaly detection goals have been defined by the user, therefore the defaults defined in Cruise Control\n+            // will be used.\n+            anomalyGoalsString = CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS;\n+        }\n+\n+        Set<String> anomalyDetectionGoals = new HashSet<>(Arrays.asList(anomalyGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        String defaultGoalsString = configuration.getConfigOption(CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY);\n+        Set<String> defaultGoals = new HashSet<>(Arrays.asList(defaultGoalsString.split(\"\\\\s*,\\\\s*\")));", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIyODY4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420228680", "bodyText": "We set it to this [1] here [2] if default.goals is set to null\n[1] https://github.com/strimzi/strimzi-kafka-operator/blob/master/cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java#L26-L41\n[2] \n  \n    \n      strimzi-kafka-operator/cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java\n    \n    \n        Lines 242 to 244\n      in\n      e1cad47\n    \n    \n    \n    \n\n        \n          \n           if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) { \n        \n\n        \n          \n               userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue()); \n        \n\n        \n          \n           }", "author": "kyguy", "createdAt": "2020-05-05T16:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwODEyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MjUxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421352511", "bodyText": "Which is great and true today, but there's no harm in adding a null check in case it's not true tomorrow. Remember, the more distant the place where you know the value is always set then the more fragile it is to a future change violating the non-nullness.", "author": "tombentley", "createdAt": "2020-05-07T09:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwODEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwOTMyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420009326", "bodyText": "The user can override goals and default.goals, so why is GOALS a better name?", "author": "tombentley", "createdAt": "2020-05-05T10:28:06Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -23,7 +23,7 @@\n      * A list of case insensitive goals that Cruise Control supports in the order of priority.\n      * The high priority goals will be executed first.\n      */\n-    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+    private static final String GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNTE2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420235169", "bodyText": "In the deployment PR the default goals list was built from the default default.goals list. This was the wrong way round so this PR swaps them.", "author": "tomncooper", "createdAt": "2020-05-05T16:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwOTMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNzI3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420237275", "bodyText": "default.goals must be a subset of goals so we thought it would be more intuitive sense", "author": "kyguy", "createdAt": "2020-05-05T16:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwOTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMTEyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420011120", "bodyText": "Probably these status updates should also execute within withLock().", "author": "tombentley", "createdAt": "2020-05-05T10:31:36Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMTUxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420011512", "bodyText": "If its public we should probably add some Javadoc.", "author": "tombentley", "createdAt": "2020-05-05T10:32:22Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM2ODg5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420368894", "bodyText": "No it doesn't need to be public, changed to private.", "author": "ppatierno", "createdAt": "2020-05-05T19:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNTE5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420015195", "bodyText": "I think we need a bit more detail here about how this operator works (e.g. mention that we're using a state machine and give an example flow).", "author": "tombentley", "createdAt": "2020-05-05T10:39:51Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNjQ3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420016477", "bodyText": "It's weird that the one method has no get prefix in the name, but the other has a get prefix. Can we make the consistent (preferably without the get prefix, since it's not a getter).", "author": "tombentley", "createdAt": "2020-05-05T10:42:11Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNjg5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420016895", "bodyText": "Include the reconciliation in all these debugging stmts.", "author": "tombentley", "createdAt": "2020-05-05T10:43:00Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMDg3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420020870", "bodyText": "Note that this will result in a Future<KafkaClusterRebalanceStatus> with a null result. Is updateStatus() etc null-safe?", "author": "tombentley", "createdAt": "2020-05-05T10:50:33Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc3Njk2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420776965", "bodyText": "In this specific case it's not called because the caller check that the resource is not there anymore so there is no status to update but you are right, I need to check null status in the updateStatus for another case, or in general. thanks.", "author": "ppatierno", "createdAt": "2020-05-06T13:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMjA3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420022074", "bodyText": "I wonder if this is really the best exception type for this. It feels like we ought to have a common one used whenever an operator cannot connect to a managed resource. It could be used for the Kafka Connect stuff, and the Kafka Admin client connections too.", "author": "tombentley", "createdAt": "2020-05-05T10:53:05Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzODQ3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420638470", "bodyText": "Agree that would be a good idea. This could be a good thing to do when we switch from the deprecated vertx httpclient post and get methods we are using and switch to the webclient for the Connect and CC clients.", "author": "tomncooper", "createdAt": "2020-05-06T08:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMjA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NzgzNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420647835", "bodyText": "Last time I looked, I felt the WebClient was a little more than we really needed for Kafka Connect. OTOH, we're our needs there have grown a bit over time, so maybe we should switch. But whether we switch or not is secondary to the refactoring to having a consistent way of doing this, imho.", "author": "tombentley", "createdAt": "2020-05-06T09:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMjA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMzQxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420023412", "bodyText": "Is this still a TODO? Do we need to fix it?", "author": "tombentley", "createdAt": "2020-05-05T10:55:46Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNjIzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420236236", "bodyText": "This has actually been fixed now by the onNotReady method. So you can remove this @ppatierno", "author": "tomncooper", "createdAt": "2020-05-05T16:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMzQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NzI0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420397246", "bodyText": "Yep.", "author": "ppatierno", "createdAt": "2020-05-05T20:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMzQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDQzNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420024435", "bodyText": "I think this deserves a comment.", "author": "tombentley", "createdAt": "2020-05-05T10:57:52Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNzQwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420237403", "bodyText": "I did have one originally then thought it might be redundant. That count is for unsuccessful attempts to contact that CC server. If we have got here then we have successfully communicated and count can be reset.", "author": "tomncooper", "createdAt": "2020-05-05T16:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDg5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420024894", "bodyText": "Again the logging in this method should include the reconciliation, right?", "author": "tombentley", "createdAt": "2020-05-05T10:58:49Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);\n+                                                // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                //       We can then update the status at this point.\n+                                                break;\n+                                            case ACTIVE: // Rebalance proposal is still being calculated\n+                                                // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                log.info(\"Rebalance ({}) optimization proposal is still being prepared\", sessionId);\n+                                                ccAPIErrorCount.set(0);\n+                                                break;\n+                                            default:\n+                                                log.error(\"Unexpected state {}\", taskStatus);", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNTUzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420025537", "bodyText": "ccApiErrorCount would be more consistent with most of the rest of the project, I think. (Or have I lost this battle?)", "author": "tombentley", "createdAt": "2020-05-05T11:00:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNjUzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420026533", "bodyText": "Do we really need this one?", "author": "tombentley", "createdAt": "2020-05-05T11:02:20Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);\n+                                                // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                //       We can then update the status at this point.\n+                                                break;\n+                                            case ACTIVE: // Rebalance proposal is still being calculated\n+                                                // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                log.info(\"Rebalance ({}) optimization proposal is still being prepared\", sessionId);\n+                                                ccAPIErrorCount.set(0);\n+                                                break;\n+                                            default:\n+                                                log.error(\"Unexpected state {}\", taskStatus);\n+                                                vertx.cancelTimer(t);\n+                                                p.fail(\"Unexpected state \" + taskStatus);\n+                                                break;\n+                                        }\n+                                    } else {\n+                                        log.error(\"Cruise Control getting rebalance task status failed\", userTaskResult.cause());\n+                                        // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                        // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                        ccAPIErrorCount.getAndIncrement();\n+                                    }\n+                                });\n+                            }\n+                        } else {\n+                            p.complete(freshClusterRebalance.getStatus());\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       RebalanceAnnotation rebalanceAnnotation,\n+                                                       RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaClusterRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileClusterRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance) {\n+        if (clusterRebalance == null) {\n+            log.info(\"{}: rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            return clusterRebalanceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName())\n+                    .compose(fetchedClusterRebalance -> {\n+                        KafkaClusterRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                        // cluster rebalance is new or it is in one of others states\n+                        State currentState = clusterRebalanceStatus == null ? State.New :\n+                                State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                        // check annotation\n+                        RebalanceAnnotation rebalanceAnnotation = getRebalanceAnnotation(fetchedClusterRebalance);\n+                        return reconcile(reconciliation, host, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                    }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                                 String host, CruiseControlApi apiClient,\n+                                                                 boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+        boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaClusterRebalanceStatusBuilder()\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    private RebalanceAnnotation getRebalanceAnnotation(KafkaClusterRebalance clusterRebalance) {\n+        String rebalanceAnnotationValue = rebalanceAnnotation(clusterRebalance);\n+        RebalanceAnnotation rebalanceAnnotation;\n+        try {\n+            rebalanceAnnotation = rebalanceAnnotationValue == null ?\n+                    RebalanceAnnotation.none : RebalanceAnnotation.valueOf(rebalanceAnnotationValue);\n+        } catch (IllegalArgumentException e) {\n+            rebalanceAnnotation = RebalanceAnnotation.unknown;\n+            log.warn(\"Wrong annotation value {}={} on {}/{}\",\n+                    ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotationValue,\n+                    clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName());\n+        }\n+        return rebalanceAnnotation;\n+    }\n+\n+    private String rebalanceAnnotation(KafkaClusterRebalance clusterRebalance) {\n+        return clusterRebalance.getMetadata().getAnnotations() == null ?\n+                null : clusterRebalance.getMetadata().getAnnotations().get(ANNO_STRIMZI_IO_REBALANCE);\n+    }", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NjQyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420396422", "bodyText": "This takes the raw string value for the annotation which could even be a not valid value (i.e. strimzi.io/rebalance=foo). The other method maps to the corresponding annotation to unknown in this case (or none if no annotation is present). I renamed and added a few Javadoc on all of them.", "author": "ppatierno", "createdAt": "2020-05-05T20:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNjUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNjk0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420026946", "bodyText": "Please can we document all of these?", "author": "tombentley", "createdAt": "2020-05-05T11:03:14Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlApi.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+\n+/**\n+ * Cruise Control REST API interface definition\n+ */\n+public interface CruiseControlApi {\n+\n+    String CC_REST_API_ERROR_KEY = \"errorMessage\";\n+    String CC_REST_API_PROGRESS_KEY = \"progress\";\n+    String CC_REST_API_USER_ID_HEADER = \"User-Task-ID\";\n+    String CC_REST_API_SUMMARY = \"summary\";\n+\n+    Future<CruiseControlResponse> getCruiseControlState(String host, int port, boolean verbose);\n+    Future<CruiseControlRebalanceResponse> rebalance(String host, int port, RebalanceOptions options, String userTaskID);\n+    Future<CruiseControlResponse> getUserTaskStatus(String host, int port, String userTaskId);\n+    Future<CruiseControlResponse> stopExecution(String host, int port);", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyODMyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420028326", "bodyText": "I think you should include the statusMessage. I also see scope here for some common error handling with the Kafka Connect client, but not for this PR. This comment applies to other similar places in this class.", "author": "tombentley", "createdAt": "2020-05-05T11:06:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.json.Json;\n+import io.vertx.core.json.JsonObject;\n+\n+public class CruiseControlApiImpl implements CruiseControlApi {\n+\n+    private static final boolean HTTP_CLIENT_ACTIVITY_LOGGING = false;\n+\n+    private final Vertx vertx;\n+\n+    public CruiseControlApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    public Future<CruiseControlResponse> getCruiseControlState(String host, int port, boolean verbose) {\n+        return getCruiseControlState(host, port, verbose, null);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public Future<CruiseControlResponse> getCruiseControlState(String host, int port, boolean verbose, String userTaskId) {\n+\n+        Promise<CruiseControlResponse> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(HTTP_CLIENT_ACTIVITY_LOGGING);\n+\n+        String path = new PathBuilder(CruiseControlEndpoints.STATE)\n+                .addParameter(CruiseControlParameters.JSON, \"true\")\n+                .addParameter(CruiseControlParameters.VERBOSE, String.valueOf(verbose))\n+                .build();\n+\n+        HttpClientRequest request = vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(result::fail);\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject json = buffer.toJsonObject();\n+                            if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n+                                result.fail(json.getString(CC_REST_API_ERROR_KEY));\n+                            } else {\n+                                CruiseControlResponse ccResponse = new CruiseControlResponse(userTaskID, json);\n+                                result.complete(ccResponse);\n+                            }\n+                        });\n+\n+                    } else {\n+                        result.fail(new CruiseControlRestException(\n+                                \"Unexpected status code \" + response.statusCode() + \" for GET request to \" +\n+                                host + \":\" + port + path));\n+                    }\n+                })\n+                .exceptionHandler(result::fail);\n+\n+        if (userTaskId != null) {\n+            request.putHeader(CC_REST_API_USER_ID_HEADER, userTaskId);\n+        }\n+\n+        request.end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public Future<CruiseControlRebalanceResponse> rebalance(String host, int port, RebalanceOptions rbOptions, String userTaskId) {\n+\n+        if (rbOptions == null && userTaskId == null) {\n+            return Future.factory.failedFuture(\n+                    new IllegalArgumentException(\"Either rebalance options or user task ID should be supplied, both were null\"));\n+        }\n+\n+        Promise<CruiseControlRebalanceResponse> result = Promise.promise();\n+        HttpClientOptions httpOptions = new HttpClientOptions().setLogActivity(HTTP_CLIENT_ACTIVITY_LOGGING);\n+\n+        String path = new PathBuilder(CruiseControlEndpoints.REBALANCE)\n+                .addParameter(CruiseControlParameters.JSON, \"true\")\n+                .addRebalanceParameters(rbOptions)\n+                .build();\n+\n+\n+        HttpClientRequest request = vertx.createHttpClient(httpOptions)\n+                .post(port, host, path, response -> {\n+                    response.exceptionHandler(result::fail);\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                            JsonObject json = buffer.toJsonObject();\n+                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n+                            result.complete(ccResponse);\n+                        });\n+                    } else if (response.statusCode() == 202) {\n+                        response.bodyHandler(buffer -> {\n+                            String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                            JsonObject json = buffer.toJsonObject();\n+                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n+                            if (json.containsKey(CC_REST_API_PROGRESS_KEY)) {\n+                                // If the response contains a \"progress\" key then the rebalance proposal has not yet completed processing\n+                                ccResponse.setProposalIsStillCalculating(true);\n+                            } else {\n+                                result.fail(new CruiseControlRestException(\"202 Status code did not contain progress key. Response was: \" +\n+                                        ccResponse.getJson().toString()));\n+                            }\n+                            result.complete(ccResponse);\n+                        });\n+                    } else if (response.statusCode() == 500) {\n+                        response.bodyHandler(buffer -> {\n+                            String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                            JsonObject json = buffer.toJsonObject();\n+                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n+                            if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n+                                // If there was a client side error, check whether it was due to not enough data being available\n+                                if (json.getString(CC_REST_API_ERROR_KEY).contains(\"NotEnoughValidWindowsException\")) {\n+                                    ccResponse.setNotEnoughDataForProposal(true);\n+                                    result.complete(ccResponse);\n+                                } else {\n+                                    // If there was any other kind of error propagate this to the operator\n+                                    result.fail(json.getString(CC_REST_API_ERROR_KEY));\n+                                }\n+                            } else {\n+                                result.complete(ccResponse);\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new CruiseControlRestException(\n+                                \"Unexpected status code \" + response.statusCode() + \" for POST request to \" +\n+                                host + \":\" + port + path));", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyOTY0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420029648", "bodyText": "Just a point to note about this pattern: an enum like this works fine when all your paths are static (as here), but not when the path contains some parameters, e.g. /foo/${name}.", "author": "tombentley", "createdAt": "2020-05-05T11:08:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlEndpoints.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+enum CruiseControlEndpoints {", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMDkyOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420030928", "bodyText": "Shouldn't you URL encode the value?", "author": "tombentley", "createdAt": "2020-05-05T11:11:35Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/PathBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import java.util.List;\n+\n+public class PathBuilder {\n+\n+    String constructedPath;\n+    boolean firstParam;\n+\n+    public PathBuilder(CruiseControlEndpoints endpoint) {\n+        constructedPath = endpoint.path + \"?\";\n+        firstParam = true;\n+    }\n+\n+    public PathBuilder addParameter(String parameter) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += parameter;", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMTAyOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420031028", "bodyText": "Shouldn't you URL encode the value?", "author": "tombentley", "createdAt": "2020-05-05T11:11:45Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/PathBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import java.util.List;\n+\n+public class PathBuilder {\n+\n+    String constructedPath;\n+    boolean firstParam;\n+\n+    public PathBuilder(CruiseControlEndpoints endpoint) {\n+        constructedPath = endpoint.path + \"?\";\n+        firstParam = true;\n+    }\n+\n+    public PathBuilder addParameter(String parameter) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += parameter;\n+        return this;\n+    }\n+\n+    public PathBuilder addParameter(CruiseControlParameters param, String value) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += param.asPair(value);", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMTA4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420031086", "bodyText": "Shouldn't you URL encode the values?", "author": "tombentley", "createdAt": "2020-05-05T11:11:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/PathBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import java.util.List;\n+\n+public class PathBuilder {\n+\n+    String constructedPath;\n+    boolean firstParam;\n+\n+    public PathBuilder(CruiseControlEndpoints endpoint) {\n+        constructedPath = endpoint.path + \"?\";\n+        firstParam = true;\n+    }\n+\n+    public PathBuilder addParameter(String parameter) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += parameter;\n+        return this;\n+    }\n+\n+    public PathBuilder addParameter(CruiseControlParameters param, String value) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += param.asPair(value);\n+        return this;\n+    }\n+\n+    public PathBuilder addParameter(CruiseControlParameters param, List<String> values) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += param.asList(values);", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzc2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420033769", "bodyText": "Did we mean to change the status here?", "author": "tombentley", "createdAt": "2020-05-05T11:17:32Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/operator/resource/StatusUtils.java", "diffHunk": "@@ -29,18 +29,22 @@ public static String iso8601Now() {\n     }\n \n     public static Condition buildConditionFromException(Throwable error) {\n+        return buildCondition(error == null ? \"Ready\" : \"NotReady\", error);\n+    }\n+\n+    public static Condition buildCondition(String type, Throwable error) {\n         Condition readyCondition;\n         if (error == null) {\n             readyCondition = new ConditionBuilder()\n                     .withLastTransitionTime(iso8601Now())\n-                    .withType(\"Ready\")\n-                    .withStatus(\"True\")\n+                    .withType(type)\n+                    .withStatus(\"Ready\")", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2MTc1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420061756", "bodyText": "You are absolutely right. It should be just \"True\" as it is today.", "author": "ppatierno", "createdAt": "2020-05-05T12:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNTk2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420035961", "bodyText": "Please use the resource group defined in Constants", "author": "samuel-hawker", "createdAt": "2020-05-05T11:22:27Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = \"kafka.strimzi.io\";", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjA5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036097", "bodyText": "when you change to KafkaRebalance ensure this is changed to kr", "author": "samuel-hawker", "createdAt": "2020-05-05T11:22:48Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = \"kafka.strimzi.io\";\n+    public static final String RESOURCE_PLURAL = \"kafkaclusterrebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkaclusterrebalance\";\n+    public static final String CRD_API_VERSION = \"apiextensions.k8s.io/v1beta1\";\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kcr\";", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjI3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036278", "bodyText": "you're missing status from the order", "author": "samuel-hawker", "createdAt": "2020-05-05T11:23:10Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjYzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036633", "bodyText": "Ensure this string, as well as the class names are modified also.", "author": "samuel-hawker", "createdAt": "2020-05-05T11:23:55Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = \"kafka.strimzi.io\";\n+    public static final String RESOURCE_PLURAL = \"kafkaclusterrebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkaclusterrebalance\";\n+    public static final String CRD_API_VERSION = \"apiextensions.k8s.io/v1beta1\";\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kcr\";\n+    public static final List<String> RESOURCE_SHORTNAMES = singletonList(SHORT_NAME);\n+\n+    private String apiVersion;\n+    private ObjectMeta metadata;\n+    private KafkaClusterRebalanceSpec spec;\n+    private KafkaClusterRebalanceStatus status;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonProperty(\"kind\")\n+    @Override\n+    public String getKind() {\n+        return RESOURCE_KIND;\n+    }\n+\n+    @Override\n+    public String getApiVersion() {\n+        return apiVersion;\n+    }\n+\n+    @Override\n+    public void setApiVersion(String apiVersion) {\n+        this.apiVersion = apiVersion;\n+    }\n+\n+    @Override\n+    public ObjectMeta getMetadata() {\n+        return super.getMetadata();\n+    }\n+\n+    @Override\n+    public void setMetadata(ObjectMeta metadata) {\n+        super.setMetadata(metadata);\n+    }\n+\n+    @Description(\"The specification of the Kafka Cluster Rebalance.\")\n+    public KafkaClusterRebalanceSpec getSpec() {\n+        return spec;\n+    }\n+\n+    public void setSpec(KafkaClusterRebalanceSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    @Override\n+    @Description(\"The status of the Kafka Cluster Rebalance.\")", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjc5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036793", "bodyText": "Again, use the Constants static string", "author": "samuel-hawker", "createdAt": "2020-05-05T11:24:15Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzOTM2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420039369", "bodyText": "ditto this string change", "author": "samuel-hawker", "createdAt": "2020-05-05T11:29:43Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzOTQ0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420039441", "bodyText": "ditto", "author": "samuel-hawker", "createdAt": "2020-05-05T11:29:51Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MzgwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420053807", "bodyText": "Do we want to log.info this, seems a little noisy?", "author": "samuel-hawker", "createdAt": "2020-05-05T11:58:23Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzI4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420057280", "bodyText": "I generally prefer calling context.checkpoint() outside of the sync call and calling flag() inside this handler", "author": "samuel-hawker", "createdAt": "2020-05-05T12:05:13Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"proposals\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadBeforeOptimization\"), is(true)));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(result -> {\n+                    if (result.succeeded()) {\n+                        assertThat(result.result().thereIsNotEnoughDataForProposal(), is(true));\n+                        context.completeNow();\n+                    } else {\n+                        context.failNow(result.cause());\n+                    }\n+                });\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID;\n+\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceVerboseUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID;\n+\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            context.completeNow();", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzYzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420057636", "bodyText": "Similarly can we use checkpoints here", "author": "samuel-hawker", "createdAt": "2020-05-05T12:05:48Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/MockCruiseControlTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@ExtendWith(VertxExtension.class)\n+public class MockCruiseControlTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void startUp() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @AfterAll\n+    public static void stop() {\n+        ccServer.stop();\n+    }\n+\n+    private void runTest(Vertx vertx, VertxTestContext context, String userTaskID, int pendingCalls) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Future<CruiseControlResponse> statusFuture = client.getUserTaskStatus(HOST, PORT, userTaskID);\n+\n+        if (pendingCalls > 0) {\n+            for (int i = 1; i <= pendingCalls; i++) {\n+                statusFuture = statusFuture.compose(response -> {\n+                    context.verify(() -> assertThat(\n+                            response.getJson().getString(\"Status\"),\n+                            is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                    );\n+                    return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+                });\n+            }\n+        }\n+\n+        statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        }).setHandler(context.succeeding(result -> {\n+            context.completeNow();", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1ODE0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420058141", "bodyText": "ditto", "author": "samuel-hawker", "createdAt": "2020-05-05T12:06:49Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/MockCruiseControlTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@ExtendWith(VertxExtension.class)\n+public class MockCruiseControlTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void startUp() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @AfterAll\n+    public static void stop() {\n+        ccServer.stop();\n+    }\n+\n+    private void runTest(Vertx vertx, VertxTestContext context, String userTaskID, int pendingCalls) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Future<CruiseControlResponse> statusFuture = client.getUserTaskStatus(HOST, PORT, userTaskID);\n+\n+        if (pendingCalls > 0) {\n+            for (int i = 1; i <= pendingCalls; i++) {\n+                statusFuture = statusFuture.compose(response -> {\n+                    context.verify(() -> assertThat(\n+                            response.getJson().getString(\"Status\"),\n+                            is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                    );\n+                    return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+                });\n+            }\n+        }\n+\n+        statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        }).setHandler(context.succeeding(result -> {\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCUserTaskNoDelay(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID, 0);\n+    }\n+\n+    @Test\n+    public void testCCUserTaskNoDelayVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID, 0);\n+    }\n+\n+    @Test\n+    public void testCCUserTaskDelay(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID, 3);\n+    }\n+\n+    @Test\n+    public void testCCUserTaskDelayVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID, 3);\n+    }\n+\n+    @Test\n+    public void testMockCCServerPendingCallsOverride(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID;\n+\n+        int pendingCalls1 = 2;\n+        Checkpoint firstPending = context.checkpoint(pendingCalls1);\n+        int pendingCalls2 = 4;\n+        Checkpoint secondPending = context.checkpoint(pendingCalls2);\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls1);\n+\n+        Future<CruiseControlResponse> statusFuture = client.getUserTaskStatus(HOST, PORT, userTaskID);\n+\n+        for (int i = 1; i <= pendingCalls1; i++) {\n+            statusFuture = statusFuture.compose(response -> {\n+                context.verify(() -> assertThat(\n+                        response.getJson().getString(\"Status\"),\n+                        is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                );\n+                firstPending.flag();\n+                return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+            });\n+        }\n+\n+        statusFuture = statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        });\n+\n+        statusFuture = statusFuture.compose(response -> {\n+            try {\n+                ccServer.reset();\n+                MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls2);\n+            } catch (IOException e) {\n+                return Future.failedFuture(e);\n+            } catch (URISyntaxException e) {\n+                return Future.failedFuture(e);\n+            }\n+            return Future.succeededFuture();\n+        });\n+\n+        statusFuture = statusFuture.compose(ignore -> client.getUserTaskStatus(HOST, PORT, userTaskID));\n+\n+        for (int i = 1; i <= pendingCalls2; i++) {\n+            statusFuture = statusFuture.compose(response -> {\n+                context.verify(() -> assertThat(\n+                        response.getJson().getString(\"Status\"),\n+                        is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                );\n+                secondPending.flag();\n+                return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+            });\n+        }\n+\n+        statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getJsonArray(\"userTasks\").getJsonObject(0).getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        }).setHandler(context.succeeding(result -> {\n+            context.completeNow();", "originalCommit": "e1cad47d1a4f70a812e14895e8d1eb09a3964095", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dc9fc8bd0e0a8feb92dbbb5fb1301842be2afa53", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dc9fc8bd0e0a8feb92dbbb5fb1301842be2afa53", "message": "Refactor checkGoals() in CruiseControl class (#55)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-06T05:40:55Z", "type": "forcePushed"}, {"oid": "b3ffdd492f81358e6e0728ed36c322bf73968b1f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b3ffdd492f81358e6e0728ed36c322bf73968b1f", "message": "Moved cruisecontrol package with API client\nMoved Kafka Cruise Control example YAML\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-06T07:26:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTE0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421051146", "bodyText": "I think you are missing spaces at the end of the lines? They will be joined without a space between the sentences, or?", "author": "scholzj", "createdAt": "2020-05-06T19:51:11Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421051860", "bodyText": "This is a bit wierd. Wouldn't it be better to say if goals is not specified, the default goals will be used? Are you 100% sure there will be never any usecase for an actual empty list of goals?", "author": "scholzj", "createdAt": "2020-05-06T19:52:26Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI4Nzk5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421287994", "bodyText": "Are you 100% sure there will be never any use case for an actual empty list of goals?\n\nWhy are you asking this? I didn't say that, or I misunderstood what you mean :-)", "author": "ppatierno", "createdAt": "2020-05-07T07:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMzE5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421333193", "bodyText": "It is a question if you are sure abotu it. The API implies so. You say that empty list does actually not mean empty list but list of default goals. I can live with it, but I'm saying that there is no going back from that. So you need to be sure that there will never be any reason why you would need the empty list to mean empty list.", "author": "scholzj", "createdAt": "2020-05-07T08:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDA5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421350090", "bodyText": "Yeah, there is potentially a difference between not specifying the goals at all vs. specifying an empty list. If you're wanting to treat them as the same thing that's fine, but it's not a decision you can change later. From my understanding it wouldn't make sense to ask for a rebalance with no goals, so I think it's fine to conflate the two.", "author": "tombentley", "createdAt": "2020-05-07T09:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxMzA0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421413046", "bodyText": "Tbh no goals field and empty goals field sound to be the same to me. In both cases, I am not specifying goals. We should be just clear that \"no goals\" means using the default ones which is already described. Maybe just adding \"If no goals or an empty goals list .... \" . Is it what you mean?", "author": "ppatierno", "createdAt": "2020-05-07T10:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMzExNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423033117", "bodyText": "I think there is a big difference between when something doesn't exist and when it exists and it is empty. As I said, if you are sure that you will never need another meaning for empty list it should be fine.", "author": "scholzj", "createdAt": "2020-05-11T13:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0MTIzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423041230", "bodyText": "In this case, specifying no goal and an empty goals list is semantically the same.", "author": "ppatierno", "createdAt": "2020-05-11T13:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MjY4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421052681", "bodyText": "Space at the end of the sentence again?", "author": "scholzj", "createdAt": "2020-05-06T19:53:53Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getOptimizationResult() {\n+        return optimizationResult;\n+    }\n+\n+    public void setOptimizationResult(Map<String, Object> optimizationResult) {\n+        this.optimizationResult = optimizationResult;\n+    }\n+\n+    @Description(\"The session identifier for requests to Cruise Control pertaining to this KafkaRebalance resource.\" +", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421086657", "bodyText": "I do not see anything what would correspond to this in the KafkaRebalanceStatus. So is this comment not valid anymore? I guess this is the status the previous Enum discussion relates to?", "author": "scholzj", "createdAt": "2020-05-06T20:56:20Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2MTA5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421261093", "bodyText": "The type field in the status condition reflects the corresponding state of the rebalacing resource/state machine operator. Should I clarify it here?", "author": "ppatierno", "createdAt": "2020-05-07T06:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDk2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421324968", "bodyText": "But that means there is zero documentation for this in the API reference. I think you should clarify it here but also add it to the api - for example using @DescriptionFile", "author": "scholzj", "createdAt": "2020-05-07T08:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2NDUyNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421964527", "bodyText": "I will add @DescriptionFile when doc will be available in documentation/book/api but in a next PR.", "author": "ppatierno", "createdAt": "2020-05-08T06:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjEyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423032129", "bodyText": "When would that be? That sounds like 0.19 only?", "author": "scholzj", "createdAt": "2020-05-11T13:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNjkzNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423036935", "bodyText": "@PaulRMellor @laidan6000 ?", "author": "ppatierno", "createdAt": "2020-05-11T13:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0MDg1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423040859", "bodyText": "Any changes to the api module should not be done without a further RC - so unlike the documentation or ST PRs which we historically merged without RCs, this would need an RX.", "author": "scholzj", "createdAt": "2020-05-11T13:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4Nzc3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421087779", "bodyText": "Since the resource seems to be used just once ... does this really need to be annotation? Have you thought about a field in .spec?", "author": "scholzj", "createdAt": "2020-05-06T20:58:27Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzkzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421267933", "bodyText": "We had a discussion in December about more or less how to handle this and the annotation was mentioned here #2202 . At the end, it is like we interact to delete pod for example and annotation seems to be the more natural way instead of a field. To be honest I think that's too late for changing this now. Why do you think the field would be better than an annotation?", "author": "ppatierno", "createdAt": "2020-05-07T06:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4Nzc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTgzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421325832", "bodyText": "The main reason why we use the annotation for deleting a pod is that there we need it to disappear after the action. So using a field inside the .spec would mean that we have to delete it somehow. That does not necessarily apply here. But its fine if you thought about it and think that anno is better.", "author": "scholzj", "createdAt": "2020-05-07T08:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4Nzc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNzA0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421327041", "bodyText": "Anyway, the operator deletes the annotation when the operation is executed.", "author": "ppatierno", "createdAt": "2020-05-07T08:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4Nzc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421088672", "bodyText": "I know his is not docs. But what happens when the rebalance is stopped? Will it revert? Will it finish the partition it is moving? Will it leave half finished things?", "author": "scholzj", "createdAt": "2020-05-06T20:59:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2ODc1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421268752", "bodyText": "So stopping a in-progress rebalance proposal is not really a thing. There is no way on the CC REST API stopping something like that, stopping here is useful to stop the periodic time for requesting status to CC REST API. About rebalancing, yes there is a way for stopping an ongoing rebalancing task and I guess that it leaves the work as it is. Is that right @tomncooper ?", "author": "ppatierno", "createdAt": "2020-05-07T06:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNzUyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421327524", "bodyText": "So stopping a in-progress rebalance proposal is not really a thing.\n\nThis Javadoc says it does - it says you can use this annotation when the state is Rebalancing.", "author": "scholzj", "createdAt": "2020-05-07T08:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzY3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421353670", "bodyText": "So you can stop an on going rebalance(dryryun=false), you cannot stop the creation of a optimization proposal (rabalance(dryrun=true)). As Paolo said the stop annotation here is to signal to the operator that you don't want it to hang around for the proposal to be ready.", "author": "tomncooper", "createdAt": "2020-05-07T09:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1NTYwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421355604", "bodyText": "I guess now I'm totally confused ... you say cannot stop the creation of a optimization proposal but also that it is to signal to the operator that you don't want it to hang around for the proposal to be ready  ... isn't creation of the proposal and waiting for the proposal to be ready the same thing?", "author": "scholzj", "createdAt": "2020-05-07T09:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1OTQxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421359416", "bodyText": "So a user deploys a rebalance.yaml with a bunch of custom options. They apply it and off CC goes calculating the optimization while we hold the lock. The user then realises \"dam I missed something\" and stops the rebalance. If we did not allow for stopping a proposal (on the Strimzi side --- it is not possible on the CC side) the CO would wait for the custom proposal to be ready and then wait for the next reconcile before stopping things and releasing the lock.", "author": "tomncooper", "createdAt": "2020-05-07T09:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTA2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421365062", "bodyText": "Ok, that sounds reasonable. So perhaps you need to clarify here (+ somewhere on the docs, but that migth be other PR) what does do something in CC and what does just do something in the operator since that does not seem to be clear. Even now I still don't understand whether stopping an active rebalance is now again operator only or if that is actually in CC.", "author": "scholzj", "createdAt": "2020-05-07T09:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxNTc5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421415797", "bodyText": "stopping an active rebalance is an actual operation on CC", "author": "ppatierno", "createdAt": "2020-05-07T10:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMzg5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423033894", "bodyText": "Ok ... since you are using single annotation for two different things, could you make it clear in the comment? (and in the docs?)", "author": "scholzj", "createdAt": "2020-05-11T13:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2NTkyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423065924", "bodyText": "I updated the comments with clarification of the two stop conditions.", "author": "tomncooper", "createdAt": "2020-05-11T14:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTY0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421091649", "bodyText": "So ... shouldn't thi have any impact on things? Such as stopping the rebalance or proposal preparation?", "author": "scholzj", "createdAt": "2020-05-06T21:05:08Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       KafkaRebalance clusterRebalance,\n+                                                       RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccApiErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccApiErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.Rebalancing) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                        if (stopResult.succeeded()) {\n+                                            p.complete(new KafkaRebalanceStatusBuilder()\n+                                                    .withSessionId(null)\n+                                                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control stopping execution failed\", reconciliation, stopResult.cause());\n+                                            p.fail(stopResult.cause());\n+                                        }\n+                                    });\n+                                } else {\n+                                    log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                    apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                        if (userTaskResult.succeeded()) {\n+                                            CruiseControlUserTaskResponse response = userTaskResult.result();\n+                                            JsonObject taskStatusJson = response.getJson();\n+                                            CruiseControlUserTaskStatus taskStatus;\n+                                            // Due to a bug in the CC rest API (https://github.com/linkedin/cruise-control/issues/1187), if we ask\n+                                            // for the status of a task that has COMPLETED_WITH_ERROR with fetch_completed_task=true, will will get\n+                                            // 500 error instead of the task status. So the client currently handles this case and sets a flag in\n+                                            // the CC response object.\n+                                            if (response.completedWithError()) {\n+                                                log.debug(\"{}: User tasks end-point returned {} for task: {}\", reconciliation,\n+                                                        CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR, sessionId);\n+                                                taskStatus = CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR;\n+                                            } else {\n+                                                String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                                taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                            }\n+                                            switch (taskStatus) {\n+                                                case COMPLETED:\n+                                                    vertx.cancelTimer(t);\n+                                                    log.info(\"{}: Rebalance ({}) is now complete\", reconciliation, sessionId);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(null)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                    break;\n+                                                case COMPLETED_WITH_ERROR:\n+                                                    // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                    //       We may need to propose an upstream PR for this.\n+                                                    // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                    //       details of any issues while rebalancing.\n+                                                    log.error(\"{}: Rebalance ({}) optimization proposal has failed to complete\", reconciliation, sessionId);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                    break;\n+                                                case IN_EXECUTION: // Rebalance is still in progress\n+                                                    // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                    // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                    // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                    // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                    if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                            freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                        log.info(\"{}: Rebalance ({}) optimization proposal is now ready and has been added to the status\", reconciliation, sessionId);\n+                                                        // Cancel the timer so that the status is returned and updated.\n+                                                        vertx.cancelTimer(t);\n+                                                        p.complete(new KafkaRebalanceStatusBuilder()\n+                                                                .withSessionId(sessionId)\n+                                                                .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                                .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                    }\n+                                                    ccApiErrorCount.set(0);\n+                                                    // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                    //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                    //       We can then update the status at this point.\n+                                                    break;\n+                                                case ACTIVE: // Rebalance proposal is still being calculated\n+                                                    // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                    // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                    // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                    log.info(\"{}: Rebalance ({}) optimization proposal is still being prepared\", reconciliation, sessionId);\n+                                                    ccApiErrorCount.set(0);\n+                                                    break;\n+                                                default:\n+                                                    log.error(\"{}: Unexpected state {}\", reconciliation, taskStatus);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(\"Unexpected state \" + taskStatus);\n+                                                    break;\n+                                            }\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control getting rebalance task status failed\", reconciliation, userTaskResult.cause());\n+                                            // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                            // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                            ccApiErrorCount.getAndIncrement();\n+                                        }\n+                                    });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                String host, CruiseControlApi apiClient,\n+                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n+        if (kafkaRebalance == null) {\n+            log.info(\"{}: Rebalance resource deleted\", reconciliation);", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2OTMxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421269318", "bodyText": "This code is mostly related to the trigger periodic reconcile. When a resource is deleted in the middle of a proposal computation or actual rebalancing, the resource deletion is handled there stopping polling mechanism and ongoing task. See onPendingProposal and onRebalancing.", "author": "ppatierno", "createdAt": "2020-05-07T06:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421095750", "bodyText": "Wait, this sounds confusing ... this for sure does nto work synchronously but is checking the states with Cruise Control asynchronously at every reconciliation, or? So what entire period does the lock need to be hold?", "author": "scholzj", "createdAt": "2020-05-06T21:12:53Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be", "originalCommit": "72fcd17f64761a8bd4c852466f8d875ed9a7e638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MDIwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421270204", "bodyText": "When a rebalance resource is created, during the pending proposal computation and rebalancing a lock is hold on the resource with a timer/polling mechanism to check the action status on the CC REST API. It's released when the proposal is ready or the rebalancing is end. I did a lot of back and forth with @tombentley 3 months ago about doing this across reconciliation or in one reconciliation holding the lock. I should get our discussion but this came as the best solution. Even in this case, changing could mean starting from scratch.", "author": "ppatierno", "createdAt": "2020-05-07T06:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDE2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421330163", "bodyText": "I don't really understand this. You have periodic reconciliation -> when it is started you check the CC API and update the resource. Why is there any need for an additional timer?", "author": "scholzj", "createdAt": "2020-05-07T08:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDgwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421330803", "bodyText": "What is the impact on resource consumption of this? We have already problem with this and I can immagine when many more addiitonal recocnile loops are added by this it will further increase?", "author": "scholzj", "createdAt": "2020-05-07T08:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMTMyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421331320", "bodyText": "the first bad thing I remember is that you should wait for 2 minutes to have the resource updated but it's just a minor thing. The discussion was long over Christmas, my memory is bad and I should get the discussion content if possible with @tombentley :-)", "author": "ppatierno", "createdAt": "2020-05-07T08:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzNDk3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421334976", "bodyText": "Not sure how the 2 minutes are a problem when the rebalance might AFAIU take hours or days. Anyway, probably too late to change now.", "author": "scholzj", "createdAt": "2020-05-07T08:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MTU2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421371569", "bodyText": "How long the proposal takes will depend on many factors. I don't think we really have enough experience of the parameter space to have any intuition, but I think days is unlikely. Seconds, minutes and hours all seem likely.\nBut using a 2nd timer we are, in effect, optimising the <2 minutes case. We can form a judgement about whether this is the right way to do it when we have more experience.\nWhether a 2nd timer takes up much resources is something else where we have no data.\n\nSo I think it's better to keep it as it is and be open to revising this later when we have more of a feeling for these things. Another option would be to add some websocket notification endpoint to CC so it could tell us without our needing to poll.", "author": "tombentley", "createdAt": "2020-05-07T09:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNzg4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423037887", "bodyText": "You really thing that majority of rebalances take less than 2 minutes? If I follow the idea that we do not have the data, then the simplest solution should have been chosen first and that is using the regular reocnciliation loop. I think that if nothing else this would cause lot of confusion around the locks.", "author": "scholzj", "createdAt": "2020-05-11T13:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0MDE5Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423040196", "bodyText": "The \"simplest\" solution (as you call it) was tried and it didn't work well. Tbh it was 3 months ago and I don't remember the reason. Maybe it was my fault maybe not. Right now I think that this works and we can live with it, exploring and trying to use the reconcile loop with the next iteration in a future release (after 0.18.0).", "author": "ppatierno", "createdAt": "2020-05-11T13:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzOTY2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421339664", "bodyText": "This is fairly heavy use of the Kubernetes API if you poll this every few seconds. I wonder if this will cause any issues.", "author": "scholzj", "createdAt": "2020-05-07T08:44:24Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NTMxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421375316", "bodyText": "It's a valid point. One thing we could do would be to utilise the watch we've already got to store the latest version when it changes and here to retrieve that. A little care other threading would be needed, but it wouldn't put any extra load on k8s.", "author": "tombentley", "createdAt": "2020-05-07T09:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzOTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAwMTg2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422001867", "bodyText": "It could make sense but it means having a globally available updatedRebalance variable updated by the watcher every time it's fired inside a synchronized block and before acquiring the Vert.x lock for doing the reconcile. The above code could avoid calling K8S and using that global updatedRebalance in a sync block as well. My question is: if the watcher is raised more time, the global var will always contain the last updated one, but when the watcher code will be unlocked on the Vert.x lock for doing the reconcile, should it process the latest updated  or the one got when it was fired? I mean an old watch could operate on a more recent resource compared to when the watcher was raised.", "author": "ppatierno", "createdAt": "2020-05-08T07:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzOTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxODA1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422018050", "bodyText": "Anyway it needs more testing, I would leave it for later when we'll have more tests with upcoming PR.", "author": "ppatierno", "createdAt": "2020-05-08T08:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzOTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0ODI0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421348246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The specification of the Kafka Rebalance.\")\n          \n          \n            \n                @Description(\"The specification of the Kafka rebalance.\")", "author": "tombentley", "createdAt": "2020-05-07T08:57:33Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaRebalance.RESOURCE_KIND,\n+                        plural = KafkaRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaRebalance.RESOURCE_GROUP,\n+                scope = KafkaRebalance.SCOPE,\n+                version = KafkaRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API,\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\", \"status\"})\n+@EqualsAndHashCode\n+public class KafkaRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = Constants.V1ALPHA1;\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = Constants.RESOURCE_GROUP_NAME;\n+    public static final String RESOURCE_PLURAL = \"kafkarebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkarebalance\";\n+    public static final String CRD_API_VERSION = Constants.V1BETA1_API_VERSION;\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kr\";\n+    public static final List<String> RESOURCE_SHORTNAMES = singletonList(SHORT_NAME);\n+\n+    private String apiVersion;\n+    private ObjectMeta metadata;\n+    private KafkaRebalanceSpec spec;\n+    private KafkaRebalanceStatus status;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonProperty(\"kind\")\n+    @Override\n+    public String getKind() {\n+        return RESOURCE_KIND;\n+    }\n+\n+    @Override\n+    public String getApiVersion() {\n+        return apiVersion;\n+    }\n+\n+    @Override\n+    public void setApiVersion(String apiVersion) {\n+        this.apiVersion = apiVersion;\n+    }\n+\n+    @Override\n+    public ObjectMeta getMetadata() {\n+        return super.getMetadata();\n+    }\n+\n+    @Override\n+    public void setMetadata(ObjectMeta metadata) {\n+        super.setMetadata(metadata);\n+    }\n+\n+    @Description(\"The specification of the Kafka Rebalance.\")", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0ODM1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421348357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The status of the Kafka Rebalance.\")\n          \n          \n            \n                @Description(\"The status of the Kafka rebalance.\")", "author": "tombentley", "createdAt": "2020-05-07T08:57:45Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaRebalance.RESOURCE_KIND,\n+                        plural = KafkaRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaRebalance.RESOURCE_GROUP,\n+                scope = KafkaRebalance.SCOPE,\n+                version = KafkaRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API,\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\", \"status\"})\n+@EqualsAndHashCode\n+public class KafkaRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = Constants.V1ALPHA1;\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = Constants.RESOURCE_GROUP_NAME;\n+    public static final String RESOURCE_PLURAL = \"kafkarebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkarebalance\";\n+    public static final String CRD_API_VERSION = Constants.V1BETA1_API_VERSION;\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kr\";\n+    public static final List<String> RESOURCE_SHORTNAMES = singletonList(SHORT_NAME);\n+\n+    private String apiVersion;\n+    private ObjectMeta metadata;\n+    private KafkaRebalanceSpec spec;\n+    private KafkaRebalanceStatus status;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonProperty(\"kind\")\n+    @Override\n+    public String getKind() {\n+        return RESOURCE_KIND;\n+    }\n+\n+    @Override\n+    public String getApiVersion() {\n+        return apiVersion;\n+    }\n+\n+    @Override\n+    public void setApiVersion(String apiVersion) {\n+        this.apiVersion = apiVersion;\n+    }\n+\n+    @Override\n+    public ObjectMeta getMetadata() {\n+        return super.getMetadata();\n+    }\n+\n+    @Override\n+    public void setMetadata(ObjectMeta metadata) {\n+        super.setMetadata(metadata);\n+    }\n+\n+    @Description(\"The specification of the Kafka Rebalance.\")\n+    public KafkaRebalanceSpec getSpec() {\n+        return spec;\n+    }\n+\n+    public void setSpec(KafkaRebalanceSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    @Override\n+    @Description(\"The status of the Kafka Rebalance.\")", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421350750", "bodyText": "Out of interest what's the use case for skipping hard goals. On the face of it skipping a hard goal is worse than skipping a soft goal. It might be worth mentioning this in the @Description.", "author": "tombentley", "createdAt": "2020-05-07T09:01:29Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")\n+    public List<String> getGoals() {\n+        return goals;\n+    }\n+\n+    public void setGoals(List<String> goals) {\n+        this.goals = goals;\n+    }\n+\n+    @Description(\"Whether to allow hard goals to be skipped in rebalance proposal generation. Default is false.\")", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ1MTQyNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421451427", "bodyText": "Of course, you should always hit hard goals but it's anyway a feature that CC allows to you, so why not exposing it?", "author": "ppatierno", "createdAt": "2020-05-07T12:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ2NzQ4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421467487", "bodyText": "But what's the use case for it? If we don't understand, how can we inform users about when to use this?", "author": "tombentley", "createdAt": "2020-05-07T12:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzODMxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421638318", "bodyText": "Imagine by default you care about 4 particular hard goals and this is fine most of the time. However, you notice that your cluster has got into a really strange state (somehow) and that one goal will fix this specific issue. You want to fix only this issue and don't want the other configured hard.goals overriding it or preventing a solution being found. In that case you can skip_hard_goal_check and just get a proposal for the goal(s) you care about.", "author": "tomncooper", "createdAt": "2020-05-07T16:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0MjY0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421642647", "bodyText": "So why would I not just comment out those hard goals in my CR and do the rebalance? Why this special config for ignoring some other config?", "author": "tombentley", "createdAt": "2020-05-07T16:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0NDA1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421644053", "bodyText": "I could be wrong, @tomncooper and @kyguy can help on this, but maybe because there are some default hard goals that you don't have in your CR but they are there by default from CC default configuration and in the scenario Tom mentioned you are able to skip checks in this way.", "author": "ppatierno", "createdAt": "2020-05-07T16:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0Njg3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421646874", "bodyText": "Default hard.goals are set at the CC server level. If you want to use your own set of goals in a KafkaRebalance CR they must include all those configured hard.goals or you will get an error. Unless you pass skip_hard_goals=true.\nIf you do not include any goals in a KafkaRebalance CR then CC will use the configured default.goals (also set at CC server level) to prepare the proposal.", "author": "tomncooper", "createdAt": "2020-05-07T16:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTQ5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421649492", "bodyText": "OK, I understand now! Thanks! Can we turn that into a pithy sentence or two for the @Description? Something like\n@Description(\"Whether to allow the hard goals specified in the Kafka CR to be skipped in rebalance proposal generation. \" + \n             \"This can be useful when some of those hard goals are preventing a balance solution being found. \" + \n             \"Default is false.\")", "author": "tombentley", "createdAt": "2020-05-07T16:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MTA2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421351067", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"A JSON describing the optimization result\")\n          \n          \n            \n                @Description(\"A JSON object describing the optimization result\")", "author": "tombentley", "createdAt": "2020-05-07T09:02:06Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzYzOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421353638", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (anomalyDetectionGoals.size() > 0) {\n          \n          \n            \n                    if (!anomalyDetectionGoals.isEmpty()) {", "author": "tombentley", "createdAt": "2020-05-07T09:06:27Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -226,16 +236,56 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence.\n+        // Right now, self.healing.goals must either be null or an empty list\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // If no anomaly detection goals have been defined by the user, the defaults defined in Cruise Control will be used.\n+        String anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY, CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS);\n+        Set<String> anomalyDetectionGoals = new HashSet<>(Arrays.asList(anomalyGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        String defaultGoalsString = configuration.getConfigOption(CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY);\n+        Set<String> defaultGoals = new HashSet<>(Arrays.asList(defaultGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        // Remove all the goals which are present in the default goals set from the anomaly detection goals\n+        anomalyDetectionGoals.removeAll(defaultGoals);\n+\n+        if (anomalyDetectionGoals.size() > 0) {", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MTUxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421361514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * <pre><code>\n          \n          \n            \n             *   User        Kube           Operator              CC\n          \n          \n            \n             *    | Create KR  |               |                   |\n          \n          \n            \n             *    |----------->|   Watch       |                   |\n          \n          \n            \n             *    |            |-------------->|   Proposal        |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            | Update Status |------------------>|\n          \n          \n            \n             *    |            |<--------------|                   |\n          \n          \n            \n             *    |            |   Watch       |                   |\n          \n          \n            \n             *    |            |-------------->|                   |\n          \n          \n            \n             *    | Get        |               |                   |\n          \n          \n            \n             *    |----------->|               |                   |\n          \n          \n            \n             *    |            |               |                   |\n          \n          \n            \n             *    | Approve    |               |                   |\n          \n          \n            \n             *    |----------->|  Watch        |                   |\n          \n          \n            \n             *    |            |-------------->|   Rebalance       |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            | Update Status |------------------>|\n          \n          \n            \n             *    |            |<--------------|                   |\n          \n          \n            \n             *    |            |   Watch       |                   |\n          \n          \n            \n             *    |            |-------------->|                   |\n          \n          \n            \n             *    | Get        |               |                   |\n          \n          \n            \n             *    |----------->|               |                   |\n          \n          \n            \n             * </code></pre>", "author": "tombentley", "createdAt": "2020-05-07T09:19:02Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ0OTk3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421449975", "bodyText": "Do you really want me to put this asciiart in the doc? Why not having official doc for this? Isn't it too much for a source file?", "author": "ppatierno", "createdAt": "2020-05-07T12:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ3Mjg3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421472872", "bodyText": "Sure, why not? Don't you think it summaries the basic flow in a readily understandable form? Much more easily understood than having to read paragraphs of text, imho. And I didn't know there could be too much documentation in a place like this were only us developers are going to benefit from it.", "author": "tombentley", "createdAt": "2020-05-07T12:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxNTkyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421515920", "bodyText": "Ok, I added it.", "author": "ppatierno", "createdAt": "2020-05-07T13:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxODE0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421518149", "bodyText": "You might thank me in 6 months time when you're having to debug a problem and can't remember how this code works \ud83d\ude42", "author": "tombentley", "createdAt": "2020-05-07T13:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2Mjc4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421362784", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String ccHost = null;\n          \n          \n            \n                private final String ccHost = null;", "author": "tombentley", "createdAt": "2020-05-07T09:21:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NDAxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421364012", "bodyText": "Can you do this by:\n\nHaving a protected method to return the ccHost() at the point you need it. Impl in this class returns the service address.\nUse a subclass for the test which returns something else?\n\nThat would be neater than having this field which we don't actually need in the production code.", "author": "tombentley", "createdAt": "2020-05-07T09:22:58Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421365789", "bodyText": "I still feel, like Jakub, that this is fragile. Let's do the right thing and fnd the condition that we're interested in rather than assuming that there is a nonempty list of conditions and that the one we want is the first.", "author": "tombentley", "createdAt": "2020-05-07T09:25:45Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ0ODQ2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421448467", "bodyText": "I still don't understand what you mean guys. Which condition should I search for? What should be the query and the parameter? There is only one condition, that's it. Can you elaborate please?", "author": "ppatierno", "createdAt": "2020-05-07T11:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ3MDkyMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421470923", "bodyText": "Today there's a single condition with type: Status. If the conditions are not empty we know it must be at index 0. We're not checking for emptiness, but if our code is perfect maybe the state machine guarantees it's never empty. But maybe our code is not perfect. If we later decided to add another condition with type: Warning then we can't be sure so certain it'll be at index 0 any more. So let's write a method which searches the conditions for the first condition of type: Status, with null checks on all the getters. It's just more robust code.", "author": "tombentley", "createdAt": "2020-05-07T12:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxNzUwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421517502", "bodyText": "Maybe this is the misunderstanding! type is not Status, but type contains the actual status ... so type: PendingProposal, type: ProposalReady, type: Rebalancing ... so we are storing the state machine status in the type field of the only one condition we have there.", "author": "ppatierno", "createdAt": "2020-05-07T13:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyOTE5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421529198", "bodyText": "I think Tom means that in future there could be more than one condition and that we cannot guarantee that the CC state condition will be at position 0 in the list returned by getConditions(). If there was ever more than one condtion we could end up checking the type of a different condition.\nWe should have a function that loops through the condition list and searches for one that has a status type matching any of those defined in the state enum and then return that type.", "author": "tomncooper", "createdAt": "2020-05-07T14:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzODk4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421538982", "bodyText": "What's the value of that? At this point, we should completely change the structure of the status and set type: State then adding a new field state with the actual value as PendingProposal, Ready, .... while today something like Ready is just set in the type field.", "author": "ppatierno", "createdAt": "2020-05-07T14:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0MzE2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421543164", "bodyText": "We don't need to do that. This issue is what if desiredStatus.getConditions().get(0) is for a different condition where getType() is null but desiredStatus.getConditions().get(1).getType() is our condition and is not null?\nWe just need something like findCCStateCondition(desiredStatus.getConditions()).getType() != null or something similar.", "author": "tomncooper", "createdAt": "2020-05-07T14:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0Mjg4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422942888", "bodyText": "I'm in agreement here, this may well be fragile. implementing a method like Tom described should fix this.", "author": "samuel-hawker", "createdAt": "2020-05-11T10:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2ODU0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423068546", "bodyText": "I have added a function to search for a condition which has a type matching one of the enum states and return that. This should prevent issues with multiple conditions in the future.", "author": "tomncooper", "createdAt": "2020-05-11T14:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2ODY0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423068648", "bodyText": "We are using the type field as the state of the state machine, what's the filter we should use to get THE condition? I still don't understand. It makes sense to me if having more conditions, one has type: State so filtering on it and then getting the state from a state field but it's not the case here.", "author": "ppatierno", "createdAt": "2020-05-11T14:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNjgxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r423536813", "bodyText": "We addressed this in the latest commit. Now type is always State in the condition, while the status field contains the state machine state (i.e. PendingProposal, Rebalancing, Ready and so on).", "author": "ppatierno", "createdAt": "2020-05-12T07:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NjUxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421366511", "bodyText": "Surely the idiomatic way to do this is to set the status in the builder, rather than build and then set? Then you can inline the whole builder expression and you only need one line where you currently have 3.", "author": "tombentley", "createdAt": "2020-05-07T09:26:53Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzAxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421373011", "bodyText": "Similar to the previous comment, this looks like an NPE waiting to happen. However you obtain the condition, you should factor this chain of gets into a method.", "author": "tombentley", "createdAt": "2020-05-07T09:37:32Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ4Nzc3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421487775", "bodyText": "The status was updated at this point with at least/max one condition, so how the NPE could happen? Maybe it's related to the fact that I haven't got yet what you mean in the previous comment. :-)", "author": "ppatierno", "createdAt": "2020-05-07T13:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MTM1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421491352", "bodyText": "My point is not that the code is broken, but that it's fragile to future changes.", "author": "tombentley", "createdAt": "2020-05-07T13:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NjAzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421376032", "bodyText": "logging for these two cases?", "author": "tombentley", "createdAt": "2020-05-07T09:42:28Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3ODAzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421378030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimzio.io/rebalance annotation\n          \n          \n            \n                 * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimz.io/rebalance annotation", "author": "tombentley", "createdAt": "2020-05-07T09:45:41Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       KafkaRebalance clusterRebalance,\n+                                                       RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccApiErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccApiErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.Rebalancing) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                        if (stopResult.succeeded()) {\n+                                            p.complete(new KafkaRebalanceStatusBuilder()\n+                                                    .withSessionId(null)\n+                                                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control stopping execution failed\", reconciliation, stopResult.cause());\n+                                            p.fail(stopResult.cause());\n+                                        }\n+                                    });\n+                                } else {\n+                                    log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                    apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                        if (userTaskResult.succeeded()) {\n+                                            CruiseControlUserTaskResponse response = userTaskResult.result();\n+                                            JsonObject taskStatusJson = response.getJson();\n+                                            CruiseControlUserTaskStatus taskStatus;\n+                                            // Due to a bug in the CC rest API (https://github.com/linkedin/cruise-control/issues/1187), if we ask\n+                                            // for the status of a task that has COMPLETED_WITH_ERROR with fetch_completed_task=true, will will get\n+                                            // 500 error instead of the task status. So the client currently handles this case and sets a flag in\n+                                            // the CC response object.\n+                                            if (response.completedWithError()) {\n+                                                log.debug(\"{}: User tasks end-point returned {} for task: {}\", reconciliation,\n+                                                        CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR, sessionId);\n+                                                taskStatus = CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR;\n+                                            } else {\n+                                                String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                                taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                            }\n+                                            switch (taskStatus) {\n+                                                case COMPLETED:\n+                                                    vertx.cancelTimer(t);\n+                                                    log.info(\"{}: Rebalance ({}) is now complete\", reconciliation, sessionId);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(null)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                    break;\n+                                                case COMPLETED_WITH_ERROR:\n+                                                    // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                    //       We may need to propose an upstream PR for this.\n+                                                    // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                    //       details of any issues while rebalancing.\n+                                                    log.error(\"{}: Rebalance ({}) optimization proposal has failed to complete\", reconciliation, sessionId);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                    break;\n+                                                case IN_EXECUTION: // Rebalance is still in progress\n+                                                    // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                    // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                    // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                    // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                    if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                            freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                        log.info(\"{}: Rebalance ({}) optimization proposal is now ready and has been added to the status\", reconciliation, sessionId);\n+                                                        // Cancel the timer so that the status is returned and updated.\n+                                                        vertx.cancelTimer(t);\n+                                                        p.complete(new KafkaRebalanceStatusBuilder()\n+                                                                .withSessionId(sessionId)\n+                                                                .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                                .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                    }\n+                                                    ccApiErrorCount.set(0);\n+                                                    // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                    //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                    //       We can then update the status at this point.\n+                                                    break;\n+                                                case ACTIVE: // Rebalance proposal is still being calculated\n+                                                    // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                    // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                    // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                    log.info(\"{}: Rebalance ({}) optimization proposal is still being prepared\", reconciliation, sessionId);\n+                                                    ccApiErrorCount.set(0);\n+                                                    break;\n+                                                default:\n+                                                    log.error(\"{}: Unexpected state {}\", reconciliation, taskStatus);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(\"Unexpected state \" + taskStatus);\n+                                                    break;\n+                                            }\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control getting rebalance task status failed\", reconciliation, userTaskResult.cause());\n+                                            // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                            // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                            ccApiErrorCount.getAndIncrement();\n+                                        }\n+                                    });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                String host, CruiseControlApi apiClient,\n+                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n+        if (kafkaRebalance == null) {\n+            log.info(\"{}: Rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+            if (clusterName != null) {\n+                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                        .compose(kafka -> {\n+                            if (kafka == null) {\n+                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                            } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                                        .compose(fetchedClusterRebalance -> {\n+                                            KafkaRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                                            // cluster rebalance is new or it is in one of others states\n+                                            State currentState = clusterRebalanceStatus == null ? State.New :\n+                                                    State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                                            // check annotation\n+                                            RebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedClusterRebalance);\n+                                            return reconcile(reconciliation, ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+\n+                            } else {\n+                                log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                            }\n+                        }, exception -> updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception).mapEmpty());\n+            } else {\n+                log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                        new InvalidResourceException(\"Resource lacks label '\"\n+                                + Labels.STRIMZI_CLUSTER_LABEL\n+                                + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+            }\n+        }\n+\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                          String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaRebalanceStatusBuilder()\n+                                .withNewSessionId(response.getUserTaskId())\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    /**\n+     * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimzio.io/rebalance annotation", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3ODE1OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421378158", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * returns {@code RebalanceAnnotation.unknown}\n          \n          \n            \n                 * returns {@code RebalanceAnnotation.unknown}.", "author": "tombentley", "createdAt": "2020-05-07T09:45:53Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       KafkaRebalance clusterRebalance,\n+                                                       RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccApiErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccApiErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.Rebalancing) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                        if (stopResult.succeeded()) {\n+                                            p.complete(new KafkaRebalanceStatusBuilder()\n+                                                    .withSessionId(null)\n+                                                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control stopping execution failed\", reconciliation, stopResult.cause());\n+                                            p.fail(stopResult.cause());\n+                                        }\n+                                    });\n+                                } else {\n+                                    log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                    apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                        if (userTaskResult.succeeded()) {\n+                                            CruiseControlUserTaskResponse response = userTaskResult.result();\n+                                            JsonObject taskStatusJson = response.getJson();\n+                                            CruiseControlUserTaskStatus taskStatus;\n+                                            // Due to a bug in the CC rest API (https://github.com/linkedin/cruise-control/issues/1187), if we ask\n+                                            // for the status of a task that has COMPLETED_WITH_ERROR with fetch_completed_task=true, will will get\n+                                            // 500 error instead of the task status. So the client currently handles this case and sets a flag in\n+                                            // the CC response object.\n+                                            if (response.completedWithError()) {\n+                                                log.debug(\"{}: User tasks end-point returned {} for task: {}\", reconciliation,\n+                                                        CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR, sessionId);\n+                                                taskStatus = CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR;\n+                                            } else {\n+                                                String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                                taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                            }\n+                                            switch (taskStatus) {\n+                                                case COMPLETED:\n+                                                    vertx.cancelTimer(t);\n+                                                    log.info(\"{}: Rebalance ({}) is now complete\", reconciliation, sessionId);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(null)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                    break;\n+                                                case COMPLETED_WITH_ERROR:\n+                                                    // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                    //       We may need to propose an upstream PR for this.\n+                                                    // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                    //       details of any issues while rebalancing.\n+                                                    log.error(\"{}: Rebalance ({}) optimization proposal has failed to complete\", reconciliation, sessionId);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                    break;\n+                                                case IN_EXECUTION: // Rebalance is still in progress\n+                                                    // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                    // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                    // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                    // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                    if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                            freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                        log.info(\"{}: Rebalance ({}) optimization proposal is now ready and has been added to the status\", reconciliation, sessionId);\n+                                                        // Cancel the timer so that the status is returned and updated.\n+                                                        vertx.cancelTimer(t);\n+                                                        p.complete(new KafkaRebalanceStatusBuilder()\n+                                                                .withSessionId(sessionId)\n+                                                                .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                                .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                    }\n+                                                    ccApiErrorCount.set(0);\n+                                                    // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                    //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                    //       We can then update the status at this point.\n+                                                    break;\n+                                                case ACTIVE: // Rebalance proposal is still being calculated\n+                                                    // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                    // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                    // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                    log.info(\"{}: Rebalance ({}) optimization proposal is still being prepared\", reconciliation, sessionId);\n+                                                    ccApiErrorCount.set(0);\n+                                                    break;\n+                                                default:\n+                                                    log.error(\"{}: Unexpected state {}\", reconciliation, taskStatus);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(\"Unexpected state \" + taskStatus);\n+                                                    break;\n+                                            }\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control getting rebalance task status failed\", reconciliation, userTaskResult.cause());\n+                                            // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                            // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                            ccApiErrorCount.getAndIncrement();\n+                                        }\n+                                    });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                String host, CruiseControlApi apiClient,\n+                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n+        if (kafkaRebalance == null) {\n+            log.info(\"{}: Rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+            if (clusterName != null) {\n+                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                        .compose(kafka -> {\n+                            if (kafka == null) {\n+                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                            } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                                        .compose(fetchedClusterRebalance -> {\n+                                            KafkaRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                                            // cluster rebalance is new or it is in one of others states\n+                                            State currentState = clusterRebalanceStatus == null ? State.New :\n+                                                    State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                                            // check annotation\n+                                            RebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedClusterRebalance);\n+                                            return reconcile(reconciliation, ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+\n+                            } else {\n+                                log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                            }\n+                        }, exception -> updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception).mapEmpty());\n+            } else {\n+                log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                        new InvalidResourceException(\"Resource lacks label '\"\n+                                + Labels.STRIMZI_CLUSTER_LABEL\n+                                + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+            }\n+        }\n+\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                          String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaRebalanceStatusBuilder()\n+                                .withNewSessionId(response.getUserTaskId())\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    /**\n+     * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimzio.io/rebalance annotation\n+     * set on the provided KafkaRebalance resource instance.\n+     * If the annotation is not set it returns {@code RebalanceAnnotation.none} while if it's a not valid value, it\n+     * returns {@code RebalanceAnnotation.unknown}", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDk2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421380969", "bodyText": "Is this really the only test directly covering all that code in the KafkaRebalanceAssemblyOperator, or did I miss something?", "author": "tombentley", "createdAt": "2020-05-07T09:50:23Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.api.model.ObjectMetaBuilder;\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBridge;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpec;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpecBuilder;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.MockCruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaRebalanceAssemblyOperatorTest {", "originalCommit": "624962484fec6f6ec518a4ac5a7387312b0851b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyMzM1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421423352", "bodyText": "I am working on tests in a separate PR", "author": "tomncooper", "createdAt": "2020-05-07T11:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDk2OQ=="}], "type": "inlineReview"}, {"oid": "5a37cbff2d2af0c7ea040733e297d4070904a0d7", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5a37cbff2d2af0c7ea040733e297d4070904a0d7", "message": "Fixed tests (#59)\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-07T10:09:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDEzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422940133", "bodyText": "Do we want to limit its size to 7?", "author": "samuel-hawker", "createdAt": "2020-05-11T10:24:25Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -40,23 +39,31 @@\n         \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal,\" +\n         \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PreferredLeaderElectionGoal\";\n \n+    public static final String CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY = \"default.goals\";\n+    public static final String CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY = \"self.healing.goals\";\n+    public static final String CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY = \"anomaly.detection.goals\";\n+    public static final String CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS =\n+            \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal, \" +\n+                    \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal, \" +\n+                    \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal\";\n+\n    /*\n     * Map containing default values for required configuration properties\n     */\n-    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+    private static final Map<String, String> CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP;\n \n     private static final List<String> FORBIDDEN_OPTIONS;\n     private static final List<String> EXCEPTIONS;\n \n     static {\n-        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Long.toString(TimeUnit.DAYS.toMillis(1)));\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"default.goals\", DEFAULT_GOALS);\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"goals\", DEFAULT_GOALS);\n+        CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP = new HashMap<>();", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2MzY1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422963652", "bodyText": "Converted it to an unmodifiable map.", "author": "tomncooper", "createdAt": "2020-05-11T11:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDkzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422940930", "bodyText": "Do we perhaps want to clone the map to stop any objects from modifying the defaults? (This might not be neccessary though...)", "author": "samuel-hawker", "createdAt": "2020-05-11T10:25:51Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -76,16 +83,7 @@ private CruiseControlConfiguration(String configuration, List<String> forbiddenO\n         super(configuration, forbiddenOptions);\n     }\n \n-    /**\n-     * Returns a CruiseControlConfiguration created without forbidden option filtering.\n-     * @param string A string representation of the Properties\n-     * @return The CruiseControlConfiguration\n-     */\n-    public static CruiseControlConfiguration unvalidated(String string) {\n-        return new CruiseControlConfiguration(string, emptyList());\n-    }\n-\n     public static Map<String, String> getCruiseControlDefaultPropertiesMap() {\n-        return CC_DEFAULT_PROPERTIES_MAP;\n+        return CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP;", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2Mjk5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422962992", "bodyText": "I converted it to an unmodifiable map in the definition at the top of the file (using CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP = Collections.unmodifiableMap(config);) this matches what we do with the zookeeper default config.", "author": "tomncooper", "createdAt": "2020-05-11T11:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4Mjc0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422982749", "bodyText": "@tomncooper remember to run checkstyle and mainly spotbugs. I had a problem with it. thanks.", "author": "ppatierno", "createdAt": "2020-05-11T11:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MTIwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422941206", "bodyText": "rebalacing -> rebalancing", "author": "samuel-hawker", "createdAt": "2020-05-11T10:26:22Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,904 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MzkwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422943902", "bodyText": "I wonder, if we are re-using these strings, might we want to set each as a constant in the CruiseControl class to avoid string repetition?", "author": "samuel-hawker", "createdAt": "2020-05-11T10:31:16Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -723,6 +725,41 @@ public void testRestApiPortNetworkPolicy() {\n         assertThat(rules.contains(clusterOperatorPeer), is(true));\n     }\n \n+\n+    @Test\n+    public void testGoalsCheck() {\n+\n+        String customGoals = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NDc4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422964781", "bodyText": "Did as you suggested and pointed all goal refs at these constants. Also made the default goal configs actual lists so we can programatically use them if we need to at a later date.", "author": "tomncooper", "createdAt": "2020-05-11T11:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0NDE1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422944151", "bodyText": "context.succeeding and use checkpoint flags", "author": "samuel-hawker", "createdAt": "2020-05-11T10:31:49Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(4);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(6);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"proposals\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadBeforeOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(result -> {\n+                    if (result.succeeded()) {", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0NDM1OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422944358", "bodyText": "This many flags is unnecessary I believe one at the end is sufficient", "author": "samuel-hawker", "createdAt": "2020-05-11T10:32:15Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(4);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(6);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0NDQ0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422944442", "bodyText": "ditto", "author": "samuel-hawker", "createdAt": "2020-05-11T10:32:25Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(4);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(6);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"proposals\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadBeforeOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(result -> {\n+                    if (result.succeeded()) {\n+                        assertThat(result.result().thereIsNotEnoughDataForProposal(), is(true));\n+                        context.completeNow();\n+                    } else {\n+                        context.failNow(result.cause());\n+                    }\n+                });\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID;\n+\n+        Checkpoint checkpoint = context.checkpoint(2);\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceVerboseUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID;\n+\n+        Checkpoint checkpoint = context.checkpoint(2);\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            checkpoint.flag();", "originalCommit": "20e8900b5f22868803630f6b1cd95817767262db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "483803a61a88980bf6a60487e04678db6ae599ce", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/483803a61a88980bf6a60487e04678db6ae599ce", "message": "Rebalance operator condition refactor (#68)\n\n* Refactored Rebalance Status conditions and addressed other PR comments\r\n\r\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>\r\n\r\n* Minor fixes on status refactoring\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\r\n\r\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-05-12T07:51:53Z", "type": "forcePushed"}, {"oid": "0ae874da356e8165f927acec064ad98f3ce16307", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0ae874da356e8165f927acec064ad98f3ce16307", "message": "Added KafkaClusterRebalance CRD and related operator\nAdded Mock Cruise Control server and client REST API and related tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-05-12T13:05:39Z", "type": "commit"}, {"oid": "0ae874da356e8165f927acec064ad98f3ce16307", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0ae874da356e8165f927acec064ad98f3ce16307", "message": "Added KafkaClusterRebalance CRD and related operator\nAdded Mock Cruise Control server and client REST API and related tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-05-12T13:05:39Z", "type": "forcePushed"}]}