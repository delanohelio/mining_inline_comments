{"pr_number": 2432, "pr_title": "Added Keycloak Authorization configuration", "pr_createdAt": "2020-01-20T21:28:04Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NTc3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368875777", "bodyText": "Should we maybe split this into two methods? configureSimpleAuthorization and configureKeycloakAuthorization?", "author": "scholzj", "createdAt": "2020-01-21T08:57:27Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -369,32 +370,64 @@ private String getSecurityProtocol(boolean tls, boolean sasl)   {\n     public KafkaBrokerConfigurationBuilder withAuthorization(String clusterName, KafkaAuthorization authorization)  {\n         if (authorization != null) {\n             List<String> superUsers = new ArrayList<>();\n-            String authorizerClass = \"\";\n \n             // Broker super users\n             superUsers.add(String.format(\"User:CN=%s,O=io.strimzi\", KafkaResources.kafkaStatefulSetName(clusterName)));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"entity-operator\"));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"kafka-exporter\"));\n \n-            // User configured super users\n-            if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n-                KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n-                authorizerClass = KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME;\n-\n-                if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n-                    superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n-                }\n-            }\n-\n             printSectionHeader(\"Authorization\");\n-            writer.println(\"authorizer.class.name=\" + authorizerClass);\n+            configureAuthorization(clusterName, superUsers, authorization);\n             writer.println(\"super.users=\" + String.join(\";\", superUsers));\n             writer.println();\n         }\n \n         return this;\n     }\n \n+    /**\n+     * Configures authorization for the Kafka brokers. This method is used only internally.\n+     *\n+     * @param clusterName Name of the cluster\n+     * @param superUsers Super users list who have all the rights on the cluster\n+     * @param authorization The authorization configuration from the Kafka CR\n+     */\n+    private void configureAuthorization(String clusterName, List<String> superUsers, KafkaAuthorization authorization) {", "originalCommit": "fecbfe54fb8c01a5243dba44e431ce25ef048b30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3OTI2Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368879266", "bodyText": "We already have a similar pattern for configuring authentication on which I agree. The configuraAuthentication method is just one and we have the logic for different authentication mechanisms inside. I am not sure about the advantage of having different methods here.", "author": "ppatierno", "createdAt": "2020-01-21T09:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjQ5Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368876496", "bodyText": "Maybe I forgot something, but don't you need to also add it to the volumes somewhere?", "author": "scholzj", "createdAt": "2020-01-21T08:58:59Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -1475,6 +1484,11 @@ private void setDataVolumesClaimsAndMountPaths(Storage storage) {\n             }\n         }\n \n+        if (authorization instanceof KafkaAuthorizationKeycloak) {\n+            KafkaAuthorizationKeycloak keycloakAuthz = (KafkaAuthorizationKeycloak) authorization;\n+            volumeMountList.addAll(AuthenticationUtils.configureOauthCertificateVolumeMounts(\"authz-keycloak\", keycloakAuthz.getTlsTrustedCertificates(), OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs\"));", "originalCommit": "fecbfe54fb8c01a5243dba44e431ce25ef048b30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3OTY5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368879694", "bodyText": "yep, I forgot it :-)", "author": "ppatierno", "createdAt": "2020-01-21T09:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NzA0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368877047", "bodyText": "Can you double check what impact does this have on the internal super users? Do they still keey their own names?", "author": "scholzj", "createdAt": "2020-01-21T09:00:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -369,32 +370,64 @@ private String getSecurityProtocol(boolean tls, boolean sasl)   {\n     public KafkaBrokerConfigurationBuilder withAuthorization(String clusterName, KafkaAuthorization authorization)  {\n         if (authorization != null) {\n             List<String> superUsers = new ArrayList<>();\n-            String authorizerClass = \"\";\n \n             // Broker super users\n             superUsers.add(String.format(\"User:CN=%s,O=io.strimzi\", KafkaResources.kafkaStatefulSetName(clusterName)));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"entity-operator\"));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"kafka-exporter\"));\n \n-            // User configured super users\n-            if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n-                KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n-                authorizerClass = KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME;\n-\n-                if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n-                    superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n-                }\n-            }\n-\n             printSectionHeader(\"Authorization\");\n-            writer.println(\"authorizer.class.name=\" + authorizerClass);\n+            configureAuthorization(clusterName, superUsers, authorization);\n             writer.println(\"super.users=\" + String.join(\";\", superUsers));\n             writer.println();\n         }\n \n         return this;\n     }\n \n+    /**\n+     * Configures authorization for the Kafka brokers. This method is used only internally.\n+     *\n+     * @param clusterName Name of the cluster\n+     * @param superUsers Super users list who have all the rights on the cluster\n+     * @param authorization The authorization configuration from the Kafka CR\n+     */\n+    private void configureAuthorization(String clusterName, List<String> superUsers, KafkaAuthorization authorization) {\n+        if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n+            KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n+            writer.println(\"authorizer.class.name=\" + KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME);\n+\n+            // User configured super users\n+            if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n+                superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n+            }\n+        } else if (KafkaAuthorizationKeycloak.TYPE_KEYCLOAK.equals(authorization.getType())) {\n+            KafkaAuthorizationKeycloak keycloakAuthz = (KafkaAuthorizationKeycloak) authorization;\n+            writer.println(\"authorizer.class.name=\" + KafkaAuthorizationKeycloak.AUTHORIZER_CLASS_NAME);\n+            writer.println(\"principal.builder.class=\" + KafkaAuthorizationKeycloak.PRINCIPAL_BUILDER_CLASS_NAME);", "originalCommit": "fecbfe54fb8c01a5243dba44e431ce25ef048b30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg5NTQxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368895418", "bodyText": "They should keep their names, yes.\nThe JwtKafkaPrincipalBuilder only does something different when user was authenticated over SASL_OAUTHBEARER as seen here. An internal user would be handled by the same logic as before.", "author": "mstruk", "createdAt": "2020-01-21T09:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NzA0Nw=="}], "type": "inlineReview"}, {"oid": "524883aee80904682ee41d296f5d242cd2bcbffc", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/524883aee80904682ee41d296f5d242cd2bcbffc", "message": "Set required properties for Keycloak authorization\nFixed a minor bug\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-24T11:46:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371251874", "bodyText": "hostname verification of what? Presumably the authz serverm but you should say that.\nAnd should it be \"enable...\", defaulting to true?", "author": "tombentley", "createdAt": "2020-01-27T13:55:39Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaAuthorizationKeycloak.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Example;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.List;\n+\n+/**\n+ * Configures Keycloak authorization on the brokers\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"type\", \"clientId\", \"tokenEndpointUri\",\n+                    \"tlsTrustedCertificates\", \"disableTlsHostnameVerification\",\n+                    \"delegateToKafkaAcls\", \"superUsers\"})\n+@EqualsAndHashCode\n+public class KafkaAuthorizationKeycloak extends KafkaAuthorization {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TYPE_KEYCLOAK = \"keycloak\";\n+\n+    public static final String AUTHORIZER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.KeycloakRBACAuthorizer\";\n+    public static final String PRINCIPAL_BUILDER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.JwtKafkaPrincipalBuilder\";\n+\n+    private String clientId;\n+    private String tokenEndpointUri;\n+    private List<CertSecretSource> tlsTrustedCertificates;\n+    private boolean disableTlsHostnameVerification = false;\n+    private boolean delegateToKafkaAcls = false;\n+    private List<String> superUsers;\n+\n+    @Description(\"Must be `\" + TYPE_KEYCLOAK + \"`\")\n+    @Override\n+    public String getType() {\n+        return TYPE_KEYCLOAK;\n+    }\n+\n+    @Description(\"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.clientId = clientId;\n+    }\n+\n+    @Description(\"Authorization server token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getTokenEndpointUri() {\n+        return tokenEndpointUri;\n+    }\n+\n+    public void setTokenEndpointUri(String tokenEndpointUri) {\n+        this.tokenEndpointUri = tokenEndpointUri;\n+    }\n+\n+    @Description(\"Trusted certificates for TLS connection to the OAuth server.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<CertSecretSource> getTlsTrustedCertificates() {\n+        return tlsTrustedCertificates;\n+    }\n+\n+    public void setTlsTrustedCertificates(List<CertSecretSource> tlsTrustedCertificates) {\n+        this.tlsTrustedCertificates = tlsTrustedCertificates;\n+    }\n+\n+    @Description(\"Enable or disable TLS hostname verification. \" +", "originalCommit": "af2861e52c6a40d3e9d11574ee26ac0cbecbe99e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NDI2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371274268", "bodyText": "I used the same convention of the other OAuth authentication classes (i.e. see KafkaListenerAuthenticationOAuth)", "author": "ppatierno", "createdAt": "2020-01-27T14:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NzMxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371277316", "bodyText": "OK", "author": "tombentley", "createdAt": "2020-01-27T14:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzY4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371253689", "bodyText": "There are a couple of variables you can usefully factor out here.", "author": "tombentley", "createdAt": "2020-01-27T13:58:59Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/KafkaClusterTest.java", "diffHunk": "@@ -3222,4 +3223,83 @@ public void testCustomCertificateTls() {\n         assertThat(k.getSecretSourceTls().getKey(), is(key));\n         assertThat(k.getSecretSourceTls().getCertificate(), is(cert));\n     }\n+\n+    @Test\n+    public void testGenerateDeploymentWithKeycloakAuthorizationMissingOAuthListeners() {\n+        assertThrows(InvalidResourceException.class, () -> {\n+            Kafka kafkaAssembly = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas,\n+                    image, healthDelay, healthTimeout, metricsCm, configuration, emptyMap()))\n+                    .editSpec()\n+                    .editKafka()\n+                    .withAuthorization(\n+                            new KafkaAuthorizationKeycloakBuilder()\n+                                    .build())\n+                    .endKafka()\n+                    .endSpec()\n+                    .build();\n+\n+            KafkaCluster.fromCrd(kafkaAssembly, VERSIONS);\n+        });\n+    }\n+\n+    @Test\n+    public void testGenerateDeploymentWithKeycloakAuthorization() {\n+        CertSecretSource cert1 = new CertSecretSourceBuilder()\n+                .withSecretName(\"first-certificate\")\n+                .withCertificate(\"ca.crt\")\n+                .build();\n+\n+        CertSecretSource cert2 = new CertSecretSourceBuilder()\n+                .withSecretName(\"second-certificate\")\n+                .withCertificate(\"tls.crt\")\n+                .build();\n+\n+        Kafka kafkaAssembly = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas,\n+                image, healthDelay, healthTimeout, metricsCm, configuration, emptyMap()))\n+                .editSpec()\n+                .editKafka()\n+                .withNewListeners()\n+                    .withNewPlain()\n+                        .withAuth(\n+                                new KafkaListenerAuthenticationOAuthBuilder()\n+                                        .withClientId(\"my-client-id\")\n+                                        .withValidIssuerUri(\"http://valid-issuer\")\n+                                        .withIntrospectionEndpointUri(\"http://introspection\")\n+                                        .withNewClientSecret()\n+                                            .withSecretName(\"my-secret-secret\")\n+                                            .withKey(\"my-secret-key\")\n+                                        .endClientSecret()\n+                                        .withDisableTlsHostnameVerification(true)\n+                                        .withTlsTrustedCertificates(cert1, cert2)\n+                                        .build())\n+                    .endPlain()\n+                .endListeners()\n+                .withAuthorization(\n+                        new KafkaAuthorizationKeycloakBuilder()\n+                                .withClientId(\"my-client-id\")\n+                                .withTokenEndpointUri(\"http://token-endpoint-uri\")\n+                                .withDisableTlsHostnameVerification(true)\n+                                .withDelegateToKafkaAcls(false)\n+                                .withTlsTrustedCertificates(cert1, cert2)\n+                                .build())\n+                .endKafka()\n+                .endSpec()\n+                .build();\n+\n+        KafkaCluster kc = KafkaCluster.fromCrd(kafkaAssembly, VERSIONS);\n+        StatefulSet sts = kc.generateStatefulSet(true, null, null);\n+        Container cont = sts.getSpec().getTemplate().getSpec().getContainers().get(0);\n+\n+        // Volume mounts\n+        assertThat(cont.getVolumeMounts().stream().filter(mount -> \"authz-keycloak-0\".equals(mount.getName())).findFirst().orElse(null).getMountPath(), is(KafkaCluster.OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs/first-certificate-0\"));\n+        assertThat(cont.getVolumeMounts().stream().filter(mount -> \"authz-keycloak-1\".equals(mount.getName())).findFirst().orElse(null).getMountPath(), is(KafkaCluster.OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs/second-certificate-1\"));\n+\n+        // Volumes\n+        assertThat(sts.getSpec().getTemplate().getSpec().getVolumes().stream().filter(vol -> \"authz-keycloak-0\".equals(vol.getName())).findFirst().orElse(null).getSecret().getItems().size(), is(1));", "originalCommit": "af2861e52c6a40d3e9d11574ee26ac0cbecbe99e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "70468c896e036970038001ea7251380c04f6c7c8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/70468c896e036970038001ea7251380c04f6c7c8", "message": "Added Keycloak Authorization configuration\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "6bf09a9613659a26bcf50b5a67d25d34c90466ad", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6bf09a9613659a26bcf50b5a67d25d34c90466ad", "message": "Update derived resources\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "b6feb156ec0daf9623e3566004622a041d4cd27f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b6feb156ec0daf9623e3566004622a041d4cd27f", "message": "Fixed adding certificates volume\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "936521ec460a3b7641ee1d069a38571db116ade2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/936521ec460a3b7641ee1d069a38571db116ade2", "message": "Added Keycloak authorization tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "6b7e134cbe7054bbd94b13feabfd5c96ae51bace", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6b7e134cbe7054bbd94b13feabfd5c96ae51bace", "message": "Set required properties for Keycloak authorization\nFixed a minor bug\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "51615d1d1aac76766fda34712c424a6b4cb6b6b3", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/51615d1d1aac76766fda34712c424a6b4cb6b6b3", "message": "Added kafka-oauth-keycloak-authorizer third party dependency\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "7be7e599ae2a3afb1ff5b0127ef79306c1478b18", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7be7e599ae2a3afb1ff5b0127ef79306c1478b18", "message": "Review comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "c8cffa389f574c48f2cf7f7bf6d2dd0f07a23f53", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c8cffa389f574c48f2cf7f7bf6d2dd0f07a23f53", "message": "Updated keycloack authorizer library parameters prefix\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "c8c63d45617bc9b0749ee54c9d6b2e99b290c40d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c8c63d45617bc9b0749ee54c9d6b2e99b290c40d", "message": "Updated OAuth library version\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "cdadec11f11deccda8d29a325e541511c8e9730b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cdadec11f11deccda8d29a325e541511c8e9730b", "message": "Updated oauth library version for Kafka thirdparty libs\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "4e504025ae62d455c39a3f5485d9a5ab58233299", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4e504025ae62d455c39a3f5485d9a5ab58233299", "message": "Fixed certificates generation for Keycloak authorization\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "48c7eb63d7084baf71890193cac992da87e74b30", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/48c7eb63d7084baf71890193cac992da87e74b30", "message": "Fixed CRD problem with required field now checked by CO\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "bca703998e34c4d06a05d92e075fe98d0d099d3f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/bca703998e34c4d06a05d92e075fe98d0d099d3f", "message": "Added missing file\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "commit"}, {"oid": "bca703998e34c4d06a05d92e075fe98d0d099d3f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/bca703998e34c4d06a05d92e075fe98d0d099d3f", "message": "Added missing file\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:33:48Z", "type": "forcePushed"}, {"oid": "ae4beced0eb9660cf420bfbc8b83b1311b1881f7", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ae4beced0eb9660cf420bfbc8b83b1311b1881f7", "message": "Adding staging repo for testing oauth library 0.3.0 RC\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T09:44:29Z", "type": "commit"}, {"oid": "6a3372fa726b07d26edb63fea2c0a0864fbc1ae4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6a3372fa726b07d26edb63fea2c0a0864fbc1ae4", "message": "Removing staging repo for oauth library 0.3.0\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-01-30T15:59:45Z", "type": "commit"}]}