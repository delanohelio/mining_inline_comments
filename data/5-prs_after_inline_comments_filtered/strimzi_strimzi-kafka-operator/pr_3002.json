{"pr_number": 3002, "pr_title": "Kafka Rebalance operator tests", "pr_createdAt": "2020-05-13T06:18:12Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMDg3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424330876", "bodyText": "Probably worth having an exception class for this, since fail(String) uses the unhelpful NoStackTraceThrowable which (I'm guessing) could propagate to the CR status condition.", "author": "tombentley", "createdAt": "2020-05-13T10:20:22Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -116,18 +115,18 @@ public CruiseControlApiImpl(Vertx vertx) {\n                         response.bodyHandler(buffer -> {\n                             String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n                             JsonObject json = buffer.toJsonObject();\n-                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n                             if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n                                 // If there was a client side error, check whether it was due to not enough data being available\n                                 if (json.getString(CC_REST_API_ERROR_KEY).contains(\"NotEnoughValidWindowsException\")) {\n+                                    CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n                                     ccResponse.setNotEnoughDataForProposal(true);\n                                     result.complete(ccResponse);\n                                 } else {\n                                     // If there was any other kind of error propagate this to the operator\n                                     result.fail(json.getString(CC_REST_API_ERROR_KEY));\n                                 }\n                             } else {\n-                                result.complete(ccResponse);\n+                                result.fail(json.toString());", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODc2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424388767", "bodyText": "Good point. Will use the (already created) CruiseControlRestException that I should have used in the first place!", "author": "tomncooper", "createdAt": "2020-05-13T12:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMDg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMTQ2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424331463", "bodyText": "Same comment, I think we need a CruiseControlException or similar. Also is this error key the only piece of relevant info to include?", "author": "tombentley", "createdAt": "2020-05-13T10:21:30Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -176,15 +175,22 @@ public CruiseControlApiImpl(Vertx vertx) {\n                         String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n                         response.bodyHandler(buffer -> {\n                             JsonObject jsonUserTask = buffer.toJsonObject().getJsonArray(\"userTasks\").getJsonObject(0);\n-                            JsonObject json = new JsonObject()\n-                                    .put(\"Status\", jsonUserTask.getString(\"Status\"))\n-                                    .put(\"summary\", ((JsonObject) Json.decodeValue(jsonUserTask.getString(\"originalResponse\"))).getJsonObject(\"summary\"));\n-                            if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n-                                result.fail(json.getString(CC_REST_API_ERROR_KEY));\n-                            } else {\n-                                CruiseControlUserTaskResponse ccResponse = new CruiseControlUserTaskResponse(userTaskID, json);\n-                                result.complete(ccResponse);\n+                            // This should not be an error with a 200 status but we play it safe\n+                            if (jsonUserTask.containsKey(CC_REST_API_ERROR_KEY)) {\n+                                result.fail(jsonUserTask.getString(CC_REST_API_ERROR_KEY));", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MTY1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424391655", "bodyText": "I will add the request path to the exception message to aid debugging.", "author": "tomncooper", "createdAt": "2020-05-13T12:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMjE0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424332142", "bodyText": "Again, same comment.", "author": "tombentley", "createdAt": "2020-05-13T10:22:45Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -199,6 +205,8 @@ public CruiseControlApiImpl(Vertx vertx) {\n                                 } else {\n                                     result.fail(json.getString(CC_REST_API_ERROR_KEY));\n                                 }\n+                            } else {\n+                                result.fail(json.toString());", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMzY0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424333646", "bodyText": "I think a javadoc description of precisely the scenario being tested for each of the tests in the class might prove useful when maintaining them in the future.", "author": "tombentley", "createdAt": "2020-05-13T10:25:21Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTA1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424335059", "bodyText": "setHandler() returns the Future on which it is called, not a new Future. Calling compose() on that sets the handler again, replacing the handler which you set by calling setHandlder().", "author": "tombentley", "createdAt": "2020-05-13T10:28:00Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4ODc3Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424588773", "bodyText": "That's true so what do you mean by that? That the lambda specified via the setHandler isn't called because overridden by the handler from compose. I would agree but the lambda code inside the setHandler is actually executed before the one in the compose. A similar pattern is used in the KafkaConnectorIT as well.", "author": "ppatierno", "createdAt": "2020-05-13T16:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4OTI0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424889243", "bodyText": "Digging into the FutureImpl implementation it's not true. The handler in the compose doesn't override the previous one defined via setHandler, it's added in a collection if there are other handlers.\nhttps://github.com/eclipse-vertx/vert.x/blob/3.8/src/main/java/io/vertx/core/impl/FutureImpl.java#L73\nThe same is called by the compose\nhttps://github.com/eclipse-vertx/vert.x/blob/3.8/src/main/java/io/vertx/core/Future.java#L356\nSo actually, in the test, the first setHandler call sets a handler and the subsequent calls (compose or other setHandler) just adds the handler without overriding the previous ones.", "author": "ppatierno", "createdAt": "2020-05-14T06:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzMjgzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424932832", "bodyText": "Ah, I never knew this. Thank you for correcting me!", "author": "tombentley", "createdAt": "2020-05-14T07:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzNzg2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424937863", "bodyText": "Well, I just learned it! :-D", "author": "ppatierno", "createdAt": "2020-05-14T07:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTQ2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424335465", "bodyText": "Do this 10 seconds make the test run slow? We should avoid that if possible, and ideally avoid hard coded timeouts in tests altogether.", "author": "tombentley", "createdAt": "2020-05-13T10:28:47Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwMjg5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424502893", "bodyText": "We have a hardcoded polling in the Kafka Rebalance operator of 5 seconds. I am just providing the time of a couple of poll requests before annotating the resource with \"stop\" for testing the Stopped state.", "author": "ppatierno", "createdAt": "2020-05-13T14:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwOTkzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424509934", "bodyText": "Yes, I understand what you're trying to do. But presumably that means it takes at least 10s for this test to run. That's fine for you right here and now, when you're focussed on these tests. But if we did that everywhere, in all the unit tests, then it becomes a problem. People stop running the unit tests because they're too slow. So the question I'm really trying to ask is: \"Can you write this test so that it doesn't take 10s?\" and \"Can you make sure all the tests that you write don't have arbitrary sleeps in them\". I know that usually makes the tests harder to write. It often makes them more robust, because you end up waiting for an observation, rather than an arbitrary time that's based on some other time configured somewhere else. With the sleep, if the reconciliation doesn't run (e.g. due to resource contraints on some CI) then the test fails. OTOH, if you wait for an observation the test is more robust because you maybe have a two minute timeout for the CI to get its act together. It also means the test runs as fast as it can.", "author": "tombentley", "createdAt": "2020-05-13T15:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMDY0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424520644", "bodyText": "In this case, we have this \"internal\" polling in the rebalance operator; tbh I don't see a way to \"observe\" something. If the operator was relying on the reconcile loop then I had control on it and applying the annotation before doing a reconcile. Right now I can avoid the timer here and applying the annotation straight in the handler but anyway the operator will get this change after 5 seconds (the hard coded one in the polling). So I think that we cannot have less then 5 seconds duration for this kind of test.", "author": "ppatierno", "createdAt": "2020-05-13T15:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNDM2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424524365", "bodyText": "Can't you wait to observe the internal timers interaction with the CC mock?", "author": "tombentley", "createdAt": "2020-05-13T15:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNjcxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424336719", "bodyText": "I've seeing a very large chain of compose etc here, and (I've not looked thoroughly) I suspect there's a lot of duplication between the tests in the kinds of things the handler are doing. If so there's scope to factor out the handlers as methods, which will make the tests easier to read and maintain.", "author": "tombentley", "createdAt": "2020-05-13T10:31:12Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedAndRefreshRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(2000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                }))).compose(v -> {\n+\n+                    // apply the \"refresh\" annotation to the resource in the Stopped state\n+                    KafkaRebalance kr4 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    KafkaRebalance refreshedKr = new KafkaRebalanceBuilder(kr4)\n+                            .editMetadata()\n+                                .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"refresh\")\n+                            .endMetadata()\n+                            .build();\n+\n+                    Crds.kafkaRebalanceOperation(kubernetesClient)\n+                            .inNamespace(CLUSTER_NAMESPACE)\n+                            .withName(RESOURCE_NAME)\n+                            .patch(refreshedKr);\n+\n+                    // trigger another reconcile to process the Stopped state\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            refreshedKr);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from Stopped to PendingProposal\n+                    KafkaRebalance kr5 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr5, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr6 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr6);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from PendingProposal to ProposalReady\n+                    KafkaRebalance kr7 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr7, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NzIzOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424567238", "bodyText": "+1 to this. If we can capture some singular chunks of the compose + handlers we can turn them into re-usable pieces and the readability of each tests should go up", "author": "samuel-hawker", "createdAt": "2020-05-13T16:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNjcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzMzY5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424933699", "bodyText": "I have factored out a few methods for common operations to be used in the handlers.", "author": "ppatierno", "createdAt": "2020-05-14T07:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNjcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNzk3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424337977", "bodyText": "Overall it feels like you have good coverage of various paths through the states, which is good. You don't have any coverage for error cases (like what happens if CC returns an error). Could you add some tests for that?\nHow does the CC client cope with CC not responding, does it timeout the returned Futures (in which case that would be covered by the extra testing I just described)? If not we should probably plan to add that, as I think the operator is complex enough, and it's easier to add that to the client.", "author": "tombentley", "createdAt": "2020-05-13T10:33:33Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -157,25 +762,23 @@ public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOExc\n         when(mockRebalanceOps.updateStatusAsync(any(KafkaRebalance.class))).thenAnswer(invocation -> {\n             try {\n                 return Future.succeededFuture(Crds.kafkaRebalanceOperation(client)\n-                        .inNamespace(CLUSTER_NAMESPACE)\n-                        .withName(RESOURCE_NAME)\n+                        .inNamespace(namespace)\n+                        .withName(resource)\n+                        .patch(invocation.getArgument(0)));\n+            } catch (Exception e) {\n+                return Future.failedFuture(e);\n+            }\n+        });\n+        when(mockRebalanceOps.patchAsync(any(KafkaRebalance.class))).thenAnswer(invocation -> {\n+            try {\n+                return Future.succeededFuture(Crds.kafkaRebalanceOperation(client)\n+                        .inNamespace(namespace)\n+                        .withName(resource)\n                         .patch(invocation.getArgument(0)));\n             } catch (Exception e) {\n                 return Future.failedFuture(e);\n             }\n         });\n-\n-        kcrao.reconcileRebalance(\n-                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n-                kcRebalance).setHandler(context.succeeding(v -> context.verify(() -> {\n-                    KafkaRebalance kr = Crds.kafkaRebalanceOperation(client).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n-                    assertThat(kr, notNullValue());\n-                    assertThat(kr.getStatus(), notNullValue());\n-                    assertThat(kr.getStatus().getConditions(), notNullValue());\n-                    assertThat(kr.getStatus().getConditions().get(0).getType(), is(KafkaRebalanceStatus.REBALANCE_STATUS_CONDITION_TYPE));\n-                    assertThat(kr.getStatus().getConditions().get(0).getStatus(), is(KafkaRebalanceAssemblyOperator.State.ProposalReady.toString()));\n-                    context.completeNow();\n-                })));\n     }\n \n }", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0NTg0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424945844", "bodyText": "@ppatierno can you comment on this one?", "author": "tombentley", "createdAt": "2020-05-14T08:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNzk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5MzA5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424993092", "bodyText": "So yes, currently the CC client uses the Vertx HTTP client but leaving the timeout to the default (which should be 60 secs). For testing, we should add a way to set a lower timeout on the CC client API.", "author": "ppatierno", "createdAt": "2020-05-14T09:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzODkwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424338908", "bodyText": "Why use an if when you could write assertEquals(shouldBeEmpty, result.result().getOptimizationResult().isEmpty()) ?", "author": "tombentley", "createdAt": "2020-05-13T10:35:26Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceStateMachineTest.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpec;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpecBuilder;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.MockCruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaRebalanceStateMachineTest {\n+\n+    private static final String HOST = \"localhost\";\n+    private static final String RESOURCE_NAME = \"my-rebalance\";\n+    private static final String CLUSTER_NAMESPACE = \"cruise-control-namespace\";\n+    private static final String CLUSTER_NAME = \"kafka-cruise-control-test-cluster\";\n+\n+    private final KubernetesVersion kubernetesVersion = KubernetesVersion.V1_11;\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceStateMachineTest.class.getName());\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void before() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    /**\n+     * Checks all conditions in the supplied status to see if type of one of them matches the supplied rebalance state.\n+     *\n+     * @param  received The status instance to be checked.\n+     * @param expectedState The expected rebalance state to be searched for.\n+     * @return True if any of the conditions in the supplied status are of a type matching the supplied expected state.\n+     */\n+    public static boolean expectedStatusCheck(KafkaRebalanceStatus received, KafkaRebalanceAssemblyOperator.State expectedState) {\n+\n+        List<String> foundStatuses = new ArrayList<>();\n+\n+        for (Condition condition :  received.getConditions()) {\n+            String status = condition.getStatus();\n+            if (status.equals(expectedState.toString())) {\n+                log.info(\"Found condition with expected state: \" + expectedState.toString());\n+                return true;\n+            } else {\n+                foundStatuses.add(status);\n+            }\n+        }\n+        log.error(\"Expected : \" + expectedState.toString() + \" but found : \" + foundStatuses);\n+        return false;\n+    }\n+\n+    /**\n+     * Creates an example {@link KafkaRebalanceBuilder} instance using the supplied state parameters.\n+     *\n+     * @param currentState The current state of the resource before being passed to computeNextStatus.\n+     * @param currentStatusSessionID The user task ID attached to the current KafkaRebalance resource. Can be null.\n+     * @param userAnnotation An annotation to be applied after the reconcile has started, for example \"approve\" or \"stop\".\n+     * @param rebalanceSpec A custom rebalance specification. If null a blank spec will be used.\n+     * @return A KafkaRebalance instance configured with the supplied parameters.\n+     */\n+    private KafkaRebalance createKafkaRebalance(KafkaRebalanceAssemblyOperator.State currentState,\n+                                                String currentStatusSessionID,\n+                                                String userAnnotation,\n+                                                KafkaRebalanceSpec rebalanceSpec) {\n+\n+        KafkaRebalanceBuilder kafkaRebalanceBuilder =\n+                new KafkaRebalanceBuilder()\n+                        .editOrNewMetadata()\n+                            .withName(RESOURCE_NAME)\n+                            .withNamespace(CLUSTER_NAMESPACE)\n+                            .withLabels(Collections.singletonMap(Labels.STRIMZI_CLUSTER_LABEL, CLUSTER_NAME))\n+                            .withAnnotations(Collections.singletonMap(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, userAnnotation == null ? \"none\" : userAnnotation))\n+                        .endMetadata()\n+                        .withSpec(rebalanceSpec);\n+\n+        // there is no actual status and related condition when a KafkaRebalance is just created\n+        if (currentState != KafkaRebalanceAssemblyOperator.State.New) {\n+            Condition currentRebalanceCondition = new Condition();\n+            currentRebalanceCondition.setStatus(currentState.toString());\n+            currentRebalanceCondition.setType(KafkaRebalanceStatus.REBALANCE_STATUS_CONDITION_TYPE);\n+\n+            KafkaRebalanceStatus currentStatus = new KafkaRebalanceStatus();\n+            currentStatus.setConditions(Collections.singletonList(currentRebalanceCondition));\n+            currentStatus.setSessionId(currentStatusSessionID);\n+\n+            kafkaRebalanceBuilder.withStatus(currentStatus);\n+        }\n+        return kafkaRebalanceBuilder.build();\n+    }\n+\n+    /**\n+     *  Checks the expected transition between two states of the Kafka Rebalance operator.\n+     *\n+     * @param vertx The vertx test instance.\n+     * @param context The test context instance.\n+     * @param currentState The current state of the resource before being passed to computeNextStatus.\n+     * @param nextState The expected state of the resouce after computeNextStatus has been called.\n+     * @param initialAnnotation The initial annotation attached to the Kafka Rebalance resource. For example none or refresh.\n+     * @param kcRebalance The Kafka Rebalance instance that will be returned by the resourceSupplier.\n+     * @return A future for the {@link KafkaRebalanceStatus} returned by the {@link KafkaRebalanceAssemblyOperator#computeNextStatus} method\n+     */\n+    private Future<KafkaRebalanceStatus> checkTransition(Vertx vertx, VertxTestContext context,\n+                                                         KafkaRebalanceAssemblyOperator.State currentState,\n+                                                         KafkaRebalanceAssemblyOperator.State nextState,\n+                                                         KafkaRebalanceAssemblyOperator.RebalanceAnnotation initialAnnotation,\n+                                                         KafkaRebalance kcRebalance) {\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        KafkaRebalanceAssemblyOperator kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        Reconciliation recon = new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME);\n+\n+        RebalanceOptions.RebalanceOptionsBuilder rbOptions = new RebalanceOptions.RebalanceOptionsBuilder();\n+\n+        if (kcRebalance.getSpec() != null) {\n+            if (kcRebalance.getSpec().getGoals() != null) {\n+                rbOptions.withGoals(kcRebalance.getSpec().getGoals());\n+            }\n+\n+            if (kcRebalance.getSpec().isSkipHardGoalCheck()) {\n+                rbOptions.withSkipHardGoalCheck();\n+            }\n+        }\n+\n+        CrdOperator<KubernetesClient,\n+                KafkaRebalance,\n+                KafkaRebalanceList,\n+                DoneableKafkaRebalance> mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+\n+        when(mockRebalanceOps.get(CLUSTER_NAMESPACE, RESOURCE_NAME)).thenReturn(kcRebalance);\n+        when(mockRebalanceOps.getAsync(CLUSTER_NAMESPACE, RESOURCE_NAME)).thenReturn(Future.succeededFuture(kcRebalance));\n+\n+        return kcrao.computeNextStatus(\n+                recon, HOST, client, kcRebalance, currentState, initialAnnotation, rbOptions).compose(result -> {\n+                    context.verify(() -> {\n+                        assertTrue(expectedStatusCheck(result, nextState));\n+                    });\n+                    return Future.succeededFuture(result);\n+                });\n+    }\n+\n+    /**\n+     *  Checks the expected transition between two states of the Kafka Rebalance operator.\n+     *\n+     * @param vertx The vertx test instance.\n+     * @param context The test context instance.\n+     * @param currentState The current state of the resource before being passed to computeNextStatus.\n+     * @param nextState The expected state of the resouce after computeNextStatus has been called.\n+     * @param initialAnnotation The initial annotation attached to the Kafka Rebalance resource. For example none or refresh.\n+     * @param userAnnotation An annotation to be applied after the reconcile has started, for example \"approve\" or \"stop\".\n+     * @param currentStatusSessionID The user task ID attached to the current KafkaRebalance resource. Can be null.\n+     * @return A future for the {@link KafkaRebalanceStatus} returned by the {@link KafkaRebalanceAssemblyOperator#computeNextStatus} method\n+     */\n+    private Future<KafkaRebalanceStatus> checkTransition(Vertx vertx, VertxTestContext context,\n+                                                         KafkaRebalanceAssemblyOperator.State currentState,\n+                                                         KafkaRebalanceAssemblyOperator.State nextState,\n+                                                         KafkaRebalanceAssemblyOperator.RebalanceAnnotation initialAnnotation,\n+                                                         String userAnnotation, String currentStatusSessionID) {\n+\n+        KafkaRebalance kcRebalance = createKafkaRebalance(currentState, currentStatusSessionID, userAnnotation, null);\n+\n+        return checkTransition(vertx, context, currentState, nextState, initialAnnotation, kcRebalance);\n+\n+    }\n+\n+    private static void defaultStatusHandler(AsyncResult<KafkaRebalanceStatus> result, VertxTestContext context) {\n+        if (result.succeeded()) {\n+            context.completeNow();\n+        } else {\n+            context.failNow(result.cause());\n+        }\n+    }\n+\n+    private static void checkOptimizationResults(AsyncResult<KafkaRebalanceStatus> result, VertxTestContext context, boolean shouldBeEmpty) {\n+        if (result.succeeded()) {\n+            if (shouldBeEmpty) {\n+                context.verify(() -> assertTrue(result.result().getOptimizationResult().isEmpty()));\n+            } else {\n+                context.verify(() -> assertFalse(result.result().getOptimizationResult().isEmpty()));\n+            }", "originalCommit": "2d3dfe79821301c894b540952e1a93116d4b3c21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMzk4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424413984", "bodyText": "Why not indeed?", "author": "tomncooper", "createdAt": "2020-05-13T12:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzODkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTg4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424535889", "bodyText": "I prefer context.checkpoint()\nand a flag, more extensible and clearer timeouts", "author": "samuel-hawker", "createdAt": "2020-05-13T15:37:31Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();", "originalCommit": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkxNDkxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424914916", "bodyText": "I am not an expert on this, so a genuine question ... what's the value? I am not using multiple steps to check but just completing the test on the last handler of each chain. I have a sequential composition, not parallel async executions. As far as I understood the value of checkpoints is when you have more async executions to assert before having the overall test passed. If I am going to use just one flag, it seems to be quite the same as leaving as it is now.", "author": "ppatierno", "createdAt": "2020-05-14T07:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2MTIyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424961220", "bodyText": "I think that is a more than fair question - I am by no means an expert either ;P\nSo semantically I like checkpoints more as context.completeNow signals to the reader a more abrupt end to the test (this may be a case of taste)\nBut to me, if i see a checkpoint it signals ahead of time that I have a single (or more) processes that have to be completed and properly state  checked before the test is done, so when I see a  flag, it is normally a softer end to test.\nI also think flags + checkpoints are easier to extend, I.e. if more needs to be added to the tests we dont have to remove the context.completeNow if it no longer makes sense.\nThirdly (coming back to semantics again) I think checkpoints and flag are more in line with the async nature of futures, a flag registers with a checkpoint and once its goal is reached the context knows the test can finish, a completeNow sort of feels like sticking a system.exit at the end of a promise which feels a little odd to me.\nDon't get me wrong though, this is mostly academic and doesnt effect the tests as they are now. And I dont want to impose my coding styles on others if they dont agree", "author": "samuel-hawker", "createdAt": "2020-05-14T08:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5MjI2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424992269", "bodyText": "I can see all your points. In this specific case the usage of checkpoints just collapse to be the same as completeNow with no difference. Anyway, the semantic will be the same, I can do the change easily.", "author": "ppatierno", "createdAt": "2020-05-14T09:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5NzUyOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424997528", "bodyText": "Yeah I agree - I wouldn't stop approval from you leaving them in, just a convention I have been following :)", "author": "samuel-hawker", "createdAt": "2020-05-14T09:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNjQzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424536437", "bodyText": "ditto", "author": "samuel-hawker", "createdAt": "2020-05-13T15:38:09Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();", "originalCommit": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424539022", "bodyText": "Don't want to propose additional work for little value, but I do wonder if we could make some generic hamcrest matchers for states across our operators, for instance this line could be calling:\n assertThat(kr1, hasState(KafkaRebalanceAssemblyOperator.State.PendingProposal));\n\nwhere hasState is the custom matcher. An example of a custom matcher can be found in the CustomMatchers class.\nIf we made one that was abstract we could simple implement the abstract matcher for this class and make the AbstractOperatorState KafkaRebalanceAssemblyOperator.State", "author": "samuel-hawker", "createdAt": "2020-05-13T15:41:38Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);", "originalCommit": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzNDE4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424934185", "bodyText": "That could be a good idea. Let's evaluate if doing that in a future PR. I would like to have this one merged soon for 0.18.0 release.", "author": "ppatierno", "createdAt": "2020-05-14T07:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0NTMxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424945318", "bodyText": "Yeah, I think this idea, too. Can we capture it in an issue please?", "author": "tombentley", "createdAt": "2020-05-14T08:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1Mzg3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424953878", "bodyText": "Absolutely.", "author": "samuel-hawker", "createdAt": "2020-05-14T08:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NzQ0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424957446", "bodyText": "FYI: #3018", "author": "samuel-hawker", "createdAt": "2020-05-14T08:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA0Mzg0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425043843", "bodyText": "Thanks", "author": "tombentley", "createdAt": "2020-05-14T10:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NjM1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424566350", "bodyText": "\"", "author": "samuel-hawker", "createdAt": "2020-05-13T16:19:58Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                    context.completeNow();", "originalCommit": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2ODYxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424568613", "bodyText": "1 is not needed here, and ditto the test, default is 1", "author": "samuel-hawker", "createdAt": "2020-05-13T16:23:22Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -114,15 +115,32 @@ public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTest\n         Checkpoint checkpoint = context.checkpoint(1);\n         client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n                 .setHandler(context.succeeding(result -> {\n-                    assertThat(result.thereIsNotEnoughDataForProposal(), is(true));\n+                    assertTrue(result.thereIsNotEnoughDataForProposal());\n+                    checkpoint.flag();\n+                }));\n+    }\n+\n+    @Test\n+    public void testCCRebalancePropsosalNotReady(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 1);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(1);", "originalCommit": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2ODczOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424568738", "bodyText": "missing context.verify", "author": "samuel-hawker", "createdAt": "2020-05-13T16:23:33Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -114,15 +115,32 @@ public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTest\n         Checkpoint checkpoint = context.checkpoint(1);\n         client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n                 .setHandler(context.succeeding(result -> {\n-                    assertThat(result.thereIsNotEnoughDataForProposal(), is(true));\n+                    assertTrue(result.thereIsNotEnoughDataForProposal());\n+                    checkpoint.flag();\n+                }));\n+    }\n+\n+    @Test\n+    public void testCCRebalancePropsosalNotReady(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 1);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(1);\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(context.succeeding(result -> {\n+                    assertTrue(result.proposalIsStillCalculating());", "originalCommit": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f9c278bcc94747ee80568cc8cde21183c862fe67", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f9c278bcc94747ee80568cc8cde21183c862fe67", "message": "Added Cruise Control Tests\n\n    * Added rebalance state machine transition tests\n    * Added rebalance operator reconcile tests\n    * Updated previous client api and mock server tests for new CC\n      Status Condition format\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-05-14T20:18:11Z", "type": "commit"}, {"oid": "b601bcd6975b6be0b9982a7047e3bcbcd50eb4b2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b601bcd6975b6be0b9982a7047e3bcbcd50eb4b2", "message": "Added more KRAO tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-14T20:18:11Z", "type": "commit"}, {"oid": "c5c278ff3757e7d7c07de8b68b723d3304571af6", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c5c278ff3757e7d7c07de8b68b723d3304571af6", "message": "Addressed PR comments\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-05-14T20:18:11Z", "type": "commit"}, {"oid": "ac5baf935673b2313235b845e3621391b8345b17", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ac5baf935673b2313235b845e3621391b8345b17", "message": "Addressed PR comments\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-05-14T20:18:11Z", "type": "commit"}, {"oid": "dd14fd2a2d8d85cbc07f3717b2225aa0b435acc2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dd14fd2a2d8d85cbc07f3717b2225aa0b435acc2", "message": "Added Javadoc\nFactored out methods for common operations\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-14T20:18:11Z", "type": "commit"}, {"oid": "88e42ec58fcedfb43483282ea7724c04e04d3231", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/88e42ec58fcedfb43483282ea7724c04e04d3231", "message": "Reviewed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-14T20:27:06Z", "type": "commit"}, {"oid": "88e42ec58fcedfb43483282ea7724c04e04d3231", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/88e42ec58fcedfb43483282ea7724c04e04d3231", "message": "Reviewed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-14T20:27:06Z", "type": "forcePushed"}, {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "message": "Fixed spotbugs and removed not needed idle timeout setting\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-15T07:41:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyODU3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425628577", "bodyText": "protected or package access", "author": "tombentley", "createdAt": "2020-05-15T07:53:43Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -143,30 +140,30 @@\n      */\n     public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                                           ResourceOperatorSupplier supplier) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n     }\n \n     /**\n-     * @param vertx The Vertx instance\n-     * @param pfa Platform features availability properties\n-     * @param supplier Supplies the operators for different resources\n-     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n-     *             service address will be used. This parameter is intended for use in testing.\n+     * Provides an implementation of the Cruise Control API client\n+     *\n+     * @return Cruise Control API client instance\n      */\n-    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n-                                          ResourceOperatorSupplier supplier, String ccHost) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    public CruiseControlApi cruiseControlClientProvider() {", "originalCommit": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyODY0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425628643", "bodyText": "protected or package access", "author": "tombentley", "createdAt": "2020-05-15T07:53:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -143,30 +140,30 @@\n      */\n     public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                                           ResourceOperatorSupplier supplier) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n     }\n \n     /**\n-     * @param vertx The Vertx instance\n-     * @param pfa Platform features availability properties\n-     * @param supplier Supplies the operators for different resources\n-     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n-     *             service address will be used. This parameter is intended for use in testing.\n+     * Provides an implementation of the Cruise Control API client\n+     *\n+     * @return Cruise Control API client instance\n      */\n-    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n-                                          ResourceOperatorSupplier supplier, String ccHost) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    public CruiseControlApi cruiseControlClientProvider() {\n+        return new CruiseControlApiImpl(vertx);\n     }\n \n-    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n-                                          ResourceOperatorSupplier supplier,\n-                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n-        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n-        this.pfa = pfa;\n-        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n-        this.kafkaOperator = supplier.kafkaOperator;\n-        this.cruiseControlClientProvider = cruiseControlClientProvider;\n-        this.ccHost = ccHost;\n+    /**\n+     * The Cruise Control hostname to connect to\n+     *\n+     * @param clusterName the Kafka cluster resource name\n+     * @param clusterNamespace the namespace of the Kafka cluster\n+     * @return the Cruise Control hostname to connect to\n+     */\n+    public String cruiseControlHost(String clusterName, String clusterNamespace) {", "originalCommit": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTQ3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425629471", "bodyText": "HTTP_DEFAULT_IDLE_TIMEOUT_SECONDS", "author": "tombentley", "createdAt": "2020-05-15T07:55:36Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -12,14 +12,24 @@\n import io.vertx.core.json.Json;\n import io.vertx.core.json.JsonObject;\n \n+import java.net.ConnectException;\n+import java.util.concurrent.TimeoutException;\n+\n public class CruiseControlApiImpl implements CruiseControlApi {\n \n     private static final boolean HTTP_CLIENT_ACTIVITY_LOGGING = false;\n+    private static final int HTTP_DEFAULT_IDLE_TIMEOUT = 0; // seconds", "originalCommit": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb602034282e3d623864cb0187e8d09c2bcc97e4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fb602034282e3d623864cb0187e8d09c2bcc97e4", "message": "Fixed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-15T08:19:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NjA4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425666083", "bodyText": "So by default we are not waiting at all for a slow CC response?", "author": "tomncooper", "createdAt": "2020-05-15T09:04:06Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -12,14 +12,24 @@\n import io.vertx.core.json.Json;\n import io.vertx.core.json.JsonObject;\n \n+import java.net.ConnectException;\n+import java.util.concurrent.TimeoutException;\n+\n public class CruiseControlApiImpl implements CruiseControlApi {\n \n     private static final boolean HTTP_CLIENT_ACTIVITY_LOGGING = false;\n+    private static final int HTTP_DEFAULT_IDLE_TIMEOUT_SECONDS = 0;", "originalCommit": "fb602034282e3d623864cb0187e8d09c2bcc97e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NzA4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425667083", "bodyText": "No, we are waiting. When the idleTimeout is 0 (the default here) we don't set the timeout on the request, which means using the default internal timeout.", "author": "ppatierno", "createdAt": "2020-05-15T09:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2ODM1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425668353", "bodyText": "Oh right. That is ok then.", "author": "tomncooper", "createdAt": "2020-05-15T09:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDQyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425670429", "bodyText": "IMHO it's confusing for a timeout of 0 to mean \"use the default\". Can we use -1 instead, since it's obviously not valid at a timeout.", "author": "tombentley", "createdAt": "2020-05-15T09:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3NTU2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425675560", "bodyText": "Yeah that's a fair point.", "author": "ppatierno", "createdAt": "2020-05-15T09:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NjA4Mw=="}], "type": "inlineReview"}, {"oid": "a1066fa6e1ce01ce9d5d8a18eb9cadcd3e768a35", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a1066fa6e1ce01ce9d5d8a18eb9cadcd3e768a35", "message": "Fixed comment\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-05-15T09:23:16Z", "type": "commit"}]}