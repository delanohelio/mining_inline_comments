{"pr_number": 3430, "pr_title": "chore: Cruise control refactor", "pr_createdAt": "2020-08-01T20:01:31Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430", "timeline": [{"oid": "96c36bbd8bf19c55e5f73bc9bac6d0a97b2f8335", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/96c36bbd8bf19c55e5f73bc9bac6d0a97b2f8335", "message": "feat: Aesthetic changes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-07-18T21:15:02Z", "type": "commit"}, {"oid": "6937b3390f84fad95e12955f89faed3813e4d5c4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6937b3390f84fad95e12955f89faed3813e4d5c4", "message": "feat: Simplify futures\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-07-19T13:15:14Z", "type": "commit"}, {"oid": "460bc5c3160d1cdaccb12623c9a7e04a87c73f5d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/460bc5c3160d1cdaccb12623c9a7e04a87c73f5d", "message": "feat: Improve tests\n\nAdd new custom matchers\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-07-20T13:25:14Z", "type": "commit"}, {"oid": "05110fd5588c16b8baa81489156a457dac80fbb1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/05110fd5588c16b8baa81489156a457dac80fbb1", "message": "feat: Consistent comment terminology\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-08-01T19:50:48Z", "type": "commit"}, {"oid": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "message": "Merge branch 'master' of https://github.com/strimzi/strimzi-kafka-operator into cruise-control-refactor", "committedDate": "2020-08-01T19:58:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxNDg2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464214868", "bodyText": "the equals implementation for enum is just this == other, tbh I think that using equals for enums is less readable. Furthermore, I found articles talking about preferring == instead of equals just for enums.", "author": "ppatierno", "createdAt": "2020-08-03T06:21:34Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -413,29 +434,29 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n     }\n \n     /**\n-     * This method handles the transition from {@code NotReady} state.\n-     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n-     * of an error during a reconcile.\n+     * This method handles the transition from the {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error.\n+     * This could be due to misconfiguration or the result of an error during a reconcile.\n      *\n      * @param reconciliation Reconciliation information\n      * @param host Cruise Control service to which sending the rebalance proposal request\n      * @param apiClient Cruise Control REST API client instance\n      * @param kafkaRebalance Current {@code KafkaRebalance} resource\n      * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n      * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n-     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     * @return a Future with the next {@code KafkaRebalanceStatus} including the state\n      */\n     private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n                                                     String host, CruiseControlApi apiClient,\n                                                     KafkaRebalance kafkaRebalance,\n                                                     KafkaRebalanceAnnotation rebalanceAnnotation,\n                                                     RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n-        if (rebalanceAnnotation == KafkaRebalanceAnnotation.refresh) {\n-            // the user fixed the error on the resource and want to \"refresh\", actually\n-            // requesting a new rebalance proposal\n+        if (KafkaRebalanceAnnotation.refresh.equals(rebalanceAnnotation)) {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI0MzQwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r478243405", "bodyText": "@samuel-hawker do you think to address this comment?", "author": "ppatierno", "createdAt": "2020-08-27T08:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxNDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxNTYzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464215637", "bodyText": "can we put the onFailure after the onSuccess just for having branch code that should be called most of the times as first during the code reading?", "author": "ppatierno", "createdAt": "2020-08-03T06:24:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -455,66 +477,65 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n      * @param kafkaRebalance Current {@code KafkaRebalance} resource\n      * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n      * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n-     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     * @return a Future with the next {@code KafkaRebalanceStatus} including the state\n      */\n     private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n                                                            String host, CruiseControlApi apiClient,\n                                                            KafkaRebalance kafkaRebalance,\n                                                            KafkaRebalanceAnnotation rebalanceAnnotation,\n                                                            RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n         Promise<KafkaRebalanceStatus> p = Promise.promise();\n-        if (rebalanceAnnotation == KafkaRebalanceAnnotation.none) {\n-            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n-            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n-                kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName()).onComplete(getResult -> {\n-                    if (getResult.succeeded()) {\n-                        KafkaRebalance freshKafkaRebalance = getResult.result();\n-                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n-                        if (freshKafkaRebalance != null) {\n-                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n-                            // and the previous execution set the status and completed the future\n-                            if (state(freshKafkaRebalance) == KafkaRebalanceState.PendingProposal) {\n-                                if (rebalanceAnnotation(freshKafkaRebalance) == KafkaRebalanceAnnotation.stop) {\n+        if (KafkaRebalanceAnnotation.none.equals(rebalanceAnnotation)) {\n+            log.debug(\"{}: Starting Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t ->\n+                kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                    .onFailure(e -> {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, e.getCause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(e.getCause());\n+                    })\n+                    .onSuccess(currentKafkaRebalance -> {\n+                        // Checking that the resource was not deleted between periodic polls\n+                        if (currentKafkaRebalance != null) {\n+                            // Check resource is in the right state as previous execution might have set the status and completed the future\n+                            // Safety check as timer might be called again (from a delayed timer firing)\n+                            if (KafkaRebalanceState.PendingProposal.equals(state(currentKafkaRebalance))) {\n+                                if (KafkaRebalanceAnnotation.stop.equals(rebalanceAnnotation(currentKafkaRebalance))) {\n                                     log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n                                     vertx.cancelTimer(t);\n                                     p.complete(buildRebalanceStatus(null, KafkaRebalanceState.Stopped));\n                                 } else {\n                                     requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n-                                            freshKafkaRebalance.getStatus().getSessionId()).onComplete(rebalanceResult -> {\n-                                                if (rebalanceResult.succeeded()) {\n-                                                    // If the returned status has an optimization result then the rebalance proposal\n-                                                    // is ready, so stop the polling\n-                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n-                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n-                                                        vertx.cancelTimer(t);\n-                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n-                                                        p.complete(rebalanceResult.result());\n-                                                    } else {\n-                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n-                                                    }\n-                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n-                                                } else {\n-                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n-                                                    vertx.cancelTimer(t);\n-                                                    p.fail(rebalanceResult.cause());\n-                                                }\n-                                            });\n+                                            currentKafkaRebalance.getStatus().getSessionId())\n+                                        .onFailure(e -> {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxNTc3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464215775", "bodyText": "ditto as above", "author": "ppatierno", "createdAt": "2020-08-03T06:24:25Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -564,25 +585,25 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n      * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n      * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n      * When the rebalance is finished, the next state is {@code Ready}.\n-     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n-     * and then move to the {@code Stopped} state.\n-     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * If the user sets the strimzi.io/rebalance annotation to 'stop', it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then transitions to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the user task checks continue.\n      * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n      *\n      * @param reconciliation Reconciliation information\n      * @param host Cruise Control service to which sending the REST API requests\n      * @param apiClient Cruise Control REST API client instance\n      * @param kafkaRebalance Current {@code KafkaRebalance} resource\n      * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n-     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     * @return a Future with the next {@code KafkaRebalanceStatus} including the state\n      */\n     private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n                                                        String host, CruiseControlApi apiClient,\n                                                        KafkaRebalance kafkaRebalance,\n                                                        KafkaRebalanceAnnotation rebalanceAnnotation) {\n         Promise<KafkaRebalanceStatus> p = Promise.promise();\n-        if (rebalanceAnnotation == KafkaRebalanceAnnotation.none) {\n-            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+        if (KafkaRebalanceAnnotation.none.equals(rebalanceAnnotation)) {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxNTg4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464215885", "bodyText": "ditto as above", "author": "ppatierno", "createdAt": "2020-08-03T06:24:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -591,31 +612,32 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n                     vertx.cancelTimer(t);\n                     p.fail(new CruiseControlRestException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n                 }\n-                kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName()).onComplete(getResult -> {\n-                    if (getResult.succeeded()) {\n-                        KafkaRebalance freshKafkaRebalance = getResult.result();\n-                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n-                        if (freshKafkaRebalance != null) {\n-                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n-                            // and the previous execution set the status and completed the future\n-                            if (state(freshKafkaRebalance) == KafkaRebalanceState.Rebalancing) {\n-                                if (rebalanceAnnotation(freshKafkaRebalance) == KafkaRebalanceAnnotation.stop) {\n+                kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                    .onFailure(e -> {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxODM2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464218362", "bodyText": "I think that @tomncooper was using the logic with thereIsNotEnough.... because the Cruise Control has something similar about the window in which you need samples for data. I would leave that logic tbh to have the same kind of mapping with Cruise Control logic. Starting to use the opposite logic in the code and then negate it ... it's quite confusing. Just my 2 cents.", "author": "ppatierno", "createdAt": "2020-08-03T06:32:18Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -794,36 +814,36 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n         return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n                 .map(response -> {\n                     if (dryrun) {\n-                        if (response.thereIsNotEnoughDataForProposal()) {\n-                            // If there are not enough data for a rebalance, it's an actual error at Cruise Control level\n-                            // and we need to re-request the proposal at a later stage so we move to the PendingProposal State.\n+                        if (!response.isSufficientDataForProposal()) {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxNjU3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464316579", "bodyText": "The \"NotEnoughData\" flag is based on the \"NotEnoughValidWindows\" error on the CC side. It is an exceptional state (hopefully) so we went with a flag that has to be actively set to true when the error occurs. I am not clear what the advantage is to swapping this around?", "author": "tomncooper", "createdAt": "2020-08-03T10:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxODM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIxODYyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464218625", "bodyText": "as already mentioned above I think we should leave the logic notEnoughData... as it is in Cruise Control.", "author": "ppatierno", "createdAt": "2020-08-03T06:33:11Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlRebalanceResponse.java", "diffHunk": "@@ -8,28 +8,30 @@\n \n public class CruiseControlRebalanceResponse extends CruiseControlResponse {\n \n-    private boolean notEnoughDataForProposal;\n-    private boolean proposalIsStillCalculating;\n+    private boolean isSufficientDataForProposal;", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyMDU0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464220549", "bodyText": "it's a personal choice ... I always start comments with low letter :-) otherwise you should fix in a TONS of places :-)", "author": "ppatierno", "createdAt": "2020-08-03T06:39:13Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -250,60 +249,60 @@ public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestCon\n \n         Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n \n-        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME))\n+            .thenReturn(Future.succeededFuture(kafka));\n         mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient, new Runnable() {\n                 int count = 0;\n \n                 @Override\n                 public void run() {\n                     if (++count == 4) {\n-                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        // After a while, apply the \"stop\" annotation to the resource in the PendingProposal state", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyMTU3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464221574", "bodyText": "at this point even just return new ClientAndServer(port);", "author": "ppatierno", "createdAt": "2020-08-03T06:42:07Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/MockCruiseControl.java", "diffHunk": "@@ -70,24 +70,28 @@ public static ClientAndServer getCCServer(int port) throws IOException, URISynta\n                 \"io.netty.handler.ssl.SslHandler.level=WARNING\";\n         LogManager.getLogManager().readConfiguration(new ByteArrayInputStream(loggingConfiguration.getBytes(UTF_8)));\n \n-        ClientAndServer ccServer = new ClientAndServer(port);\n-        return ccServer;\n+        ClientAndServer server = new ClientAndServer(port);\n+        return server;", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMwNDU2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464304560", "bodyText": "I agree with @ppatierno, that the \"==\" version reads cleaner that this \".equals\" version", "author": "tomncooper", "createdAt": "2020-08-03T09:38:28Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -455,66 +477,65 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n      * @param kafkaRebalance Current {@code KafkaRebalance} resource\n      * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n      * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n-     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     * @return a Future with the next {@code KafkaRebalanceStatus} including the state\n      */\n     private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n                                                            String host, CruiseControlApi apiClient,\n                                                            KafkaRebalance kafkaRebalance,\n                                                            KafkaRebalanceAnnotation rebalanceAnnotation,\n                                                            RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n         Promise<KafkaRebalanceStatus> p = Promise.promise();\n-        if (rebalanceAnnotation == KafkaRebalanceAnnotation.none) {\n-            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n-            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n-                kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName()).onComplete(getResult -> {\n-                    if (getResult.succeeded()) {\n-                        KafkaRebalance freshKafkaRebalance = getResult.result();\n-                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n-                        if (freshKafkaRebalance != null) {\n-                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n-                            // and the previous execution set the status and completed the future\n-                            if (state(freshKafkaRebalance) == KafkaRebalanceState.PendingProposal) {\n-                                if (rebalanceAnnotation(freshKafkaRebalance) == KafkaRebalanceAnnotation.stop) {\n+        if (KafkaRebalanceAnnotation.none.equals(rebalanceAnnotation)) {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxNzcxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464317712", "bodyText": "Most of the time a user will not be asking for some exotic rebalance with strange options and will just get the cached proposal straight back or close to it. The \"proposalStillCalaculating\" state is assumed to be exceptional so that is why it a flag that has to be explicitly set to true. I am not sure what the advantage is in switching this around.", "author": "tomncooper", "createdAt": "2020-08-03T10:04:18Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -794,36 +814,36 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n         return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n                 .map(response -> {\n                     if (dryrun) {\n-                        if (response.thereIsNotEnoughDataForProposal()) {\n-                            // If there are not enough data for a rebalance, it's an actual error at Cruise Control level\n-                            // and we need to re-request the proposal at a later stage so we move to the PendingProposal State.\n+                        if (!response.isSufficientDataForProposal()) {\n+                            // If there is not enough data for a rebalance, it's an error at Cruise Control level\n+                            // Need to re-request the proposal at a later time so move to the PendingProposal State.\n                             return buildRebalanceStatus(null, KafkaRebalanceState.PendingProposal);\n-                        } else if (response.proposalIsStillCalculating()) {\n-                            // If rebalance proposal is still being processed we need to re-request the proposal at a later stage\n+                        } else if (response.isProposalInProgress()) {", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMDM4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464330383", "bodyText": "Out of interest what hard-wrap width are you working to, seems a lot of edits in this PR are hard wraps. I actually think it would be nice to define a project wide one as a style guide.", "author": "tomncooper", "createdAt": "2020-08-03T10:31:37Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/MockCruiseControl.java", "diffHunk": "@@ -70,24 +70,28 @@ public static ClientAndServer getCCServer(int port) throws IOException, URISynta\n                 \"io.netty.handler.ssl.SslHandler.level=WARNING\";\n         LogManager.getLogManager().readConfiguration(new ByteArrayInputStream(loggingConfiguration.getBytes(UTF_8)));\n \n-        ClientAndServer ccServer = new ClientAndServer(port);\n-        return ccServer;\n+        ClientAndServer server = new ClientAndServer(port);\n+        return server;\n     }\n \n     private static JsonBody getJsonFromResource(String resource) throws URISyntaxException, IOException {\n \n-        URI jsonURI = Objects.requireNonNull(MockCruiseControl.class.getClassLoader().getResource(CC_JSON_ROOT + resource)).toURI();\n+        URI jsonURI = Objects.requireNonNull(MockCruiseControl.class.getClassLoader().getResource(CC_JSON_ROOT + resource))", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2MzM4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r467463384", "bodyText": "I tend to wrap in logical sections, readbaility is unfortunately a little subjective but the reason I split this was to make clear that we are modifying to the objects, then converting them to a URI\ni.e. one clear operation per a line, for things like filters this rule can get a bit more subjective and arguable, but just because a final method is a simple conversioon and only a few letters in length for the method I don't neccessarily think it belongs on the same line as the rest, if that makes sense.\nultimately though this is styling and consistency only has so much value.\nWould be open to discussing a hardwrap limit though!", "author": "samuel-hawker", "createdAt": "2020-08-08T13:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMDM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1OTU4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r464959587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // with the rebalance operator in order to start, stop or refresh rebalancing proposals and operations\n          \n          \n            \n                // with the rebalance operator in order to start, stop or refresh rebalancing proposals and operations.", "author": "michalxo", "createdAt": "2020-08-04T10:39:52Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -20,8 +20,8 @@\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n     public static final String STRIMZI_IO_USE_CONNECTOR_RESOURCES = STRIMZI_DOMAIN + \"use-connector-resources\";\n     public static final String ANNO_STRIMZI_IO_MANUAL_ROLLING_UPDATE = STRIMZI_DOMAIN + \"manual-rolling-update\";\n-    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n-    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    // This annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalancing proposals and operations", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MzM3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r465163376", "bodyText": "resouce -> resource", "author": "kyguy", "createdAt": "2020-08-04T16:07:12Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -720,62 +736,66 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n         }\n     }\n \n+    /**\n+     * Reconcile loop for the KafkaRebalance\n+     */\n     /* test */ Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n         if (kafkaRebalance == null) {\n             log.info(\"{}: Rebalance resource deleted\", reconciliation);\n             return Future.succeededFuture();\n-        } else {\n-            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n-            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n-            if (clusterName != null) {\n-                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n-                        .compose(kafka -> {\n-                            if (kafka == null) {\n-                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n-                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n-                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n-                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n-                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n-                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n-                            } else if (kafka.getSpec().getCruiseControl() != null) {\n-                                CruiseControlApi apiClient = cruiseControlClientProvider();\n-\n-                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n-                                        .compose(fetchedKafkaRebalance -> {\n-                                            KafkaRebalanceStatus kafkaRebalanceStatus = fetchedKafkaRebalance.getStatus();\n-                                            // cluster rebalance is new or it is in one of others states\n-                                            KafkaRebalanceState currentState;\n-                                            if (kafkaRebalanceStatus == null) {\n-                                                currentState = KafkaRebalanceState.New;\n-                                            } else {\n-                                                String rebalanceStateConditionStatus = rebalanceStateConditionType(kafkaRebalanceStatus);\n-                                                if (rebalanceStateConditionStatus != null) {\n-                                                    currentState = KafkaRebalanceState.valueOf(rebalanceStateConditionStatus);\n-                                                } else {\n-                                                    throw new RuntimeException(\"Unable to find KafkaRebalace State in current KafkaRebalance status\");\n-                                                }\n-                                            }\n-                                            // check annotation\n-                                            KafkaRebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedKafkaRebalance);\n-                                            return reconcile(reconciliation, cruiseControlHost(clusterName, clusterNamespace), apiClient, fetchedKafkaRebalance, currentState, rebalanceAnnotation).mapEmpty();\n-                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+\n+        String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+        String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+        if (clusterName == null) {\n+            log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+            return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                    new InvalidResourceException(\"Resource lacks label '\"\n+                            + Labels.STRIMZI_CLUSTER_LABEL\n+                            + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+        }\n+\n+        // Get associated Kafka cluster state\n+        return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                .compose(kafka -> {\n+                    if (kafka == null) {\n+                        log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                        + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                    } else if (kafka.getSpec().getCruiseControl() == null) {\n+                        log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2NTU2Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r465165566", "bodyText": "resouce -> resource", "author": "kyguy", "createdAt": "2020-08-04T16:10:26Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -720,62 +736,66 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n         }\n     }\n \n+    /**\n+     * Reconcile loop for the KafkaRebalance\n+     */\n     /* test */ Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n         if (kafkaRebalance == null) {\n             log.info(\"{}: Rebalance resource deleted\", reconciliation);\n             return Future.succeededFuture();\n-        } else {\n-            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n-            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n-            if (clusterName != null) {\n-                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n-                        .compose(kafka -> {\n-                            if (kafka == null) {\n-                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n-                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n-                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n-                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n-                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n-                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n-                            } else if (kafka.getSpec().getCruiseControl() != null) {\n-                                CruiseControlApi apiClient = cruiseControlClientProvider();\n-\n-                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n-                                        .compose(fetchedKafkaRebalance -> {\n-                                            KafkaRebalanceStatus kafkaRebalanceStatus = fetchedKafkaRebalance.getStatus();\n-                                            // cluster rebalance is new or it is in one of others states\n-                                            KafkaRebalanceState currentState;\n-                                            if (kafkaRebalanceStatus == null) {\n-                                                currentState = KafkaRebalanceState.New;\n-                                            } else {\n-                                                String rebalanceStateConditionStatus = rebalanceStateConditionType(kafkaRebalanceStatus);\n-                                                if (rebalanceStateConditionStatus != null) {\n-                                                    currentState = KafkaRebalanceState.valueOf(rebalanceStateConditionStatus);\n-                                                } else {\n-                                                    throw new RuntimeException(\"Unable to find KafkaRebalace State in current KafkaRebalance status\");\n-                                                }\n-                                            }\n-                                            // check annotation\n-                                            KafkaRebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedKafkaRebalance);\n-                                            return reconcile(reconciliation, cruiseControlHost(clusterName, clusterNamespace), apiClient, fetchedKafkaRebalance, currentState, rebalanceAnnotation).mapEmpty();\n-                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+\n+        String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+        String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+        if (clusterName == null) {\n+            log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+            return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                    new InvalidResourceException(\"Resource lacks label '\"\n+                            + Labels.STRIMZI_CLUSTER_LABEL\n+                            + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+        }\n+\n+        // Get associated Kafka cluster state\n+        return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                .compose(kafka -> {\n+                    if (kafka == null) {\n+                        log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                        + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                    } else if (kafka.getSpec().getCruiseControl() == null) {\n+                        log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2NjcxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r465166716", "bodyText": "of others states -> of the other states", "author": "kyguy", "createdAt": "2020-08-04T16:12:07Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -720,62 +736,66 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n         }\n     }\n \n+    /**\n+     * Reconcile loop for the KafkaRebalance\n+     */\n     /* test */ Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n         if (kafkaRebalance == null) {\n             log.info(\"{}: Rebalance resource deleted\", reconciliation);\n             return Future.succeededFuture();\n-        } else {\n-            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n-            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n-            if (clusterName != null) {\n-                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n-                        .compose(kafka -> {\n-                            if (kafka == null) {\n-                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n-                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n-                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n-                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n-                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n-                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n-                            } else if (kafka.getSpec().getCruiseControl() != null) {\n-                                CruiseControlApi apiClient = cruiseControlClientProvider();\n-\n-                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n-                                        .compose(fetchedKafkaRebalance -> {\n-                                            KafkaRebalanceStatus kafkaRebalanceStatus = fetchedKafkaRebalance.getStatus();\n-                                            // cluster rebalance is new or it is in one of others states\n-                                            KafkaRebalanceState currentState;\n-                                            if (kafkaRebalanceStatus == null) {\n-                                                currentState = KafkaRebalanceState.New;\n-                                            } else {\n-                                                String rebalanceStateConditionStatus = rebalanceStateConditionType(kafkaRebalanceStatus);\n-                                                if (rebalanceStateConditionStatus != null) {\n-                                                    currentState = KafkaRebalanceState.valueOf(rebalanceStateConditionStatus);\n-                                                } else {\n-                                                    throw new RuntimeException(\"Unable to find KafkaRebalace State in current KafkaRebalance status\");\n-                                                }\n-                                            }\n-                                            // check annotation\n-                                            KafkaRebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedKafkaRebalance);\n-                                            return reconcile(reconciliation, cruiseControlHost(clusterName, clusterNamespace), apiClient, fetchedKafkaRebalance, currentState, rebalanceAnnotation).mapEmpty();\n-                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+\n+        String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+        String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+        if (clusterName == null) {\n+            log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+            return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                    new InvalidResourceException(\"Resource lacks label '\"\n+                            + Labels.STRIMZI_CLUSTER_LABEL\n+                            + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+        }\n+\n+        // Get associated Kafka cluster state\n+        return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                .compose(kafka -> {\n+                    if (kafka == null) {\n+                        log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                        + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                    } else if (kafka.getSpec().getCruiseControl() == null) {\n+                        log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                        + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                    }\n+\n+                    CruiseControlApi apiClient = cruiseControlClientProvider();\n \n+                    // Get latest KafkaRebalance state as it may have changed\n+                    return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                        .compose(currentKafkaRebalance -> {\n+                            KafkaRebalanceStatus kafkaRebalanceStatus = currentKafkaRebalance.getStatus();\n+                            KafkaRebalanceState currentState;\n+                            // cluster rebalance is new or it is in one of others states", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2NzM4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r465167389", "bodyText": "KafkaRebalace -> KafkaRebalance", "author": "kyguy", "createdAt": "2020-08-04T16:13:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -720,62 +736,66 @@ private KafkaRebalanceStatus buildRebalanceStatus(String sessionID, KafkaRebalan\n         }\n     }\n \n+    /**\n+     * Reconcile loop for the KafkaRebalance\n+     */\n     /* test */ Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n         if (kafkaRebalance == null) {\n             log.info(\"{}: Rebalance resource deleted\", reconciliation);\n             return Future.succeededFuture();\n-        } else {\n-            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n-            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n-            if (clusterName != null) {\n-                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n-                        .compose(kafka -> {\n-                            if (kafka == null) {\n-                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n-                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n-                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n-                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n-                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n-                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n-                            } else if (kafka.getSpec().getCruiseControl() != null) {\n-                                CruiseControlApi apiClient = cruiseControlClientProvider();\n-\n-                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n-                                        .compose(fetchedKafkaRebalance -> {\n-                                            KafkaRebalanceStatus kafkaRebalanceStatus = fetchedKafkaRebalance.getStatus();\n-                                            // cluster rebalance is new or it is in one of others states\n-                                            KafkaRebalanceState currentState;\n-                                            if (kafkaRebalanceStatus == null) {\n-                                                currentState = KafkaRebalanceState.New;\n-                                            } else {\n-                                                String rebalanceStateConditionStatus = rebalanceStateConditionType(kafkaRebalanceStatus);\n-                                                if (rebalanceStateConditionStatus != null) {\n-                                                    currentState = KafkaRebalanceState.valueOf(rebalanceStateConditionStatus);\n-                                                } else {\n-                                                    throw new RuntimeException(\"Unable to find KafkaRebalace State in current KafkaRebalance status\");\n-                                                }\n-                                            }\n-                                            // check annotation\n-                                            KafkaRebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedKafkaRebalance);\n-                                            return reconcile(reconciliation, cruiseControlHost(clusterName, clusterNamespace), apiClient, fetchedKafkaRebalance, currentState, rebalanceAnnotation).mapEmpty();\n-                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+\n+        String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+        String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+        if (clusterName == null) {\n+            log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+            return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                    new InvalidResourceException(\"Resource lacks label '\"\n+                            + Labels.STRIMZI_CLUSTER_LABEL\n+                            + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+        }\n+\n+        // Get associated Kafka cluster state\n+        return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                .compose(kafka -> {\n+                    if (kafka == null) {\n+                        log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                        + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                    } else if (kafka.getSpec().getCruiseControl() == null) {\n+                        log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                        return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n+                                new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                        + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                    }\n+\n+                    CruiseControlApi apiClient = cruiseControlClientProvider();\n \n+                    // Get latest KafkaRebalance state as it may have changed\n+                    return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                        .compose(currentKafkaRebalance -> {\n+                            KafkaRebalanceStatus kafkaRebalanceStatus = currentKafkaRebalance.getStatus();\n+                            KafkaRebalanceState currentState;\n+                            // cluster rebalance is new or it is in one of others states\n+                            if (kafkaRebalanceStatus == null) {\n+                                currentState = KafkaRebalanceState.New;\n                             } else {\n-                                log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n-                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(),\n-                                        new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n-                                                + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                                String rebalanceStateType = rebalanceStateConditionType(kafkaRebalanceStatus);\n+                                if (rebalanceStateType == null) {\n+                                    throw new RuntimeException(\"Unable to find KafkaRebalace State in current KafkaRebalance status\");", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4MjYzOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r465182638", "bodyText": "stop -> stop,\n(I think there there should be a comma there, if not, please ignore this comment!)", "author": "kyguy", "createdAt": "2020-08-04T16:37:10Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -20,8 +20,8 @@\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n     public static final String STRIMZI_IO_USE_CONNECTOR_RESOURCES = STRIMZI_DOMAIN + \"use-connector-resources\";\n     public static final String ANNO_STRIMZI_IO_MANUAL_ROLLING_UPDATE = STRIMZI_DOMAIN + \"manual-rolling-update\";\n-    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n-    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    // This annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalancing proposals and operations", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4MzY2Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3430#discussion_r465183666", "bodyText": "cluster rebalancing -> cluster rebalance", "author": "kyguy", "createdAt": "2020-08-04T16:38:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -58,19 +57,20 @@\n import static io.strimzi.operator.common.Annotations.ANNO_STRIMZI_IO_REBALANCE;\n \n /**\n- * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with the Cruise Control REST API</p>\n  *\n  * <p>\n- *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n- *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     This operator takes care of the {@code KafkaRebalance} custom resource type that a user can create in order\n+ *     to interact with the Cruise Control REST API and execute a cluster rebalancing.", "originalCommit": "dfc5b6d2a0fd9f5a89464f18cca813a7879f2e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b771f61cefaec0a4bc856fa1f773d5eb0c4f66c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8b771f61cefaec0a4bc856fa1f773d5eb0c4f66c", "message": "feat: Address review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-08-08T13:50:40Z", "type": "commit"}, {"oid": "8b771f61cefaec0a4bc856fa1f773d5eb0c4f66c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8b771f61cefaec0a4bc856fa1f773d5eb0c4f66c", "message": "feat: Address review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-08-08T13:50:40Z", "type": "forcePushed"}, {"oid": "7be2f7b4d56fb8f0f75ffd0c86bedfa389da03a2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7be2f7b4d56fb8f0f75ffd0c86bedfa389da03a2", "message": "fix:  enum comparisons\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-08-28T10:50:00Z", "type": "commit"}]}