{"pr_number": 2637, "pr_title": "Prevent ZK cluster roll when scaling 3.5.x clusters ", "pr_createdAt": "2020-03-03T16:22:57Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDE5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387140198", "bodyText": "Havig this here suggests this can be override and is just default. I think this should be in forbidden options + ardcoded in zookeeper_config_generator.sh. That probably applies also to 4lw.commands.whitelist, but I'm fine to leave that for other day.", "author": "scholzj", "createdAt": "2020-03-03T16:28:10Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -34,6 +34,8 @@\n         config.put(\"tickTime\", \"2000\");\n         config.put(\"initLimit\", \"5\");\n         config.put(\"syncLimit\", \"2\");\n+        config.put(\"standaloneEnabled\", \"false\");\n+        config.put(\"reconfigEnabled\", \"true\");", "originalCommit": "8fffe1e23cc30434e3241aa90213c6446390db53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE1ODE5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387158199", "bodyText": "Agreed.", "author": "tomncooper", "createdAt": "2020-03-03T16:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387141307", "bodyText": "Should this be added tot he status in addition to printing a warning? The warning will be missed by most people.", "author": "scholzj", "createdAt": "2020-03-03T16:29:42Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1356,13 +1358,21 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n+            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)\n-            ));\n+            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +", "originalCommit": "8fffe1e23cc30434e3241aa90213c6446390db53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3NjAyOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387176028", "bodyText": "Would that require adding to fields to the KafkaStatus class or should we create a ZookeeperStatus class and add information there?", "author": "tomncooper", "createdAt": "2020-03-03T17:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMjM3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387212377", "bodyText": "Added KafkaStatus updates", "author": "tomncooper", "createdAt": "2020-03-03T18:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387141834", "bodyText": "Does this TODO still apply?", "author": "scholzj", "createdAt": "2020-03-03T16:30:33Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "originalCommit": "8fffe1e23cc30434e3241aa90213c6446390db53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2MTk2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387161964", "bodyText": "Yes, someone could set the replica to two higher and both node would be added (without the roll). For stability we only want to add 1 node at time to the cluster. Which is still possible as things stand, but the procedure says only add one at a time.", "author": "tomncooper", "createdAt": "2020-03-03T17:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MjAzNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387172035", "bodyText": "To prevent this (if the user specifies more than one extra node) I think we would need to overwrite the STS zookeeper spec and apply it. Do you think that is worth it or can we rely on the user following the procedure?", "author": "tomncooper", "createdAt": "2020-03-03T17:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjExMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387252113", "bodyText": "I didn't realized these were connected at first. But main of this comment was whether we really need the TODO, especially with temp solution. You should either do it or remove the TODO.", "author": "scholzj", "createdAt": "2020-03-03T19:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5NDYwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387694607", "bodyText": "Ok, I have added logic at the start of the zkScalingSetup method to abort the reconciliation (with a status + log message) if a user tries to scale more than one zk server at a time.", "author": "tomncooper", "createdAt": "2020-03-04T14:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MjY4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387142687", "bodyText": "Should this be named scaleInSmallSteps now?", "author": "scholzj", "createdAt": "2020-03-03T16:31:44Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {", "originalCommit": "8fffe1e23cc30434e3241aa90213c6446390db53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMjExNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387212116", "bodyText": "Renamed it to zkScalingSetup", "author": "tomncooper", "createdAt": "2020-03-03T18:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MjY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0NTUzOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387145539", "bodyText": "What if the anno is missing? Will this trigger or what will it do?", "author": "scholzj", "createdAt": "2020-03-03T16:36:05Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {", "originalCommit": "8fffe1e23cc30434e3241aa90213c6446390db53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NjY0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387166649", "bodyText": "That branch will only be hit if we are not scaling or if we are scaling a 3.4.14 cluster. In which case if the anno is not there it will return false and the ZK roll will proceed as zkManualScaling will be false. I will add an else clause at the end to make sure it is false.", "author": "tomncooper", "createdAt": "2020-03-03T17:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0NTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0OTk5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387149999", "bodyText": "Does this or the scaleDown method need to be protected by the annotation as well? IIRC you said scaleup should happen node by node ... but unless this is protected, and someone changes the replicas e.g. from 3 to 7 it scale up every reocnciliation regardless whether the user finished the manual tasks, or?", "author": "scholzj", "createdAt": "2020-03-03T16:42:51Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // We need to check if we are still in a manual scaling operation. Only the user can set this to false\n+                                // once it has been set to true.\n+                                log.info(\"Detected manual Zookeeper scaling operation in progress\");\n+                                zkManualScaling = true;\n+                            }\n+                        }\n                         return Future.succeededFuture(this);\n                     });\n         }\n \n         Future<ReconciliationState> zkScaleUp() {\n             if (zkScalingUp) {\n                 return zkSetOperations.scaleUp(namespace, zkCluster.getName(), zkCluster.getReplicas())", "originalCommit": "8fffe1e23cc30434e3241aa90213c6446390db53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTQ4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387219486", "bodyText": "See comments above above for zkScalingSetup method. We would need to catch the scale down of more than one and overwrite the STS. Do we want to do that or rely on the method saying one at a time?", "author": "tomncooper", "createdAt": "2020-03-03T18:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0OTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1Nzg5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387557892", "bodyText": "We \u2192 The Cluster Operator", "author": "tombentley", "createdAt": "2020-03-04T09:55:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -29,13 +29,18 @@\n         FORBIDDEN_OPTIONS.addAll(Arrays.asList(ZookeeperClusterSpec.FORBIDDEN_PREFIXES.split(\" *, *\")));\n         // This option is handled in the Zookeeper container startup script\n         FORBIDDEN_OPTIONS.add(\"snapshot.trust.empty\");\n+        // This option would prevent scaling beyond 1 node for clusters started with a single node\n+        FORBIDDEN_OPTIONS.add(\"standaloneEnabled\");\n+        // Reconfiguration needs to be enabled to allow scaling of the cluster\n+        FORBIDDEN_OPTIONS.add(\"reconfigEnabled\");\n+        // We require access to multiple 4LW and access to the nodes is secured by the TLS-Sidecars so we set all allowed", "originalCommit": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2MDU4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387560580", "bodyText": "Do you mean for the Future returned by this method to have completed before the status has been updated?", "author": "tombentley", "createdAt": "2020-03-04T10:00:23Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            this.updateStatus(kStatus).setHandler(statusResult -> {", "originalCommit": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyMDc1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387620751", "bodyText": "Good point, I will compose it with the final returned future", "author": "tomncooper", "createdAt": "2020-03-04T11:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2MDU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzI1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387617252", "bodyText": "Should \"3.4.99\" be in a variable. Also this line isn't very readable, would it make sense to wrap the zk version check in a helper function with a readable name?", "author": "katheris", "createdAt": "2020-03-04T11:51:08Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {", "originalCommit": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzU3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387617575", "bodyText": "There is duplicate code here, so again a helper function would read better.", "author": "katheris", "createdAt": "2020-03-04T11:51:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {", "originalCommit": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxODUyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387618524", "bodyText": "Might be nice to use string formatting here rather than all the concatenations.", "author": "katheris", "createdAt": "2020-03-04T11:53:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +", "originalCommit": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyMzQ3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387623475", "bodyText": "It might read easier to have an Optional here rather than the ternary operator.", "author": "katheris", "createdAt": "2020-03-04T12:05:10Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperCluster.java", "diffHunk": "@@ -181,16 +182,18 @@ public static ZookeeperCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup\n         if (replicas <= 0) {\n             replicas = ZookeeperClusterSpec.DEFAULT_REPLICAS;\n         }\n-\n         if (replicas == 1 && zookeeperClusterSpec.getStorage() != null && \"ephemeral\".equals(zookeeperClusterSpec.getStorage().getType())) {\n             log.warn(\"A ZooKeeper cluster with a single replica and ephemeral storage will be in a defective state after any restart or rolling update. It is recommended that a minimum of three replicas are used.\");\n         }\n-\n         zk.setReplicas(replicas);\n \n+        // Get the ZK version information from either the CRD or from the default setting\n+        KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+        String version = versions.version(kafkaClusterSpec != null ? kafkaClusterSpec.getVersion() : null).zookeeperVersion();", "originalCommit": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b8bc84b83bc553b0b5898bbddedb0de09e9b302", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1b8bc84b83bc553b0b5898bbddedb0de09e9b302", "message": "Added logic to fail (with status) the reconciliation zk scale of more than one is set\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-03-04T14:16:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNzYzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387717634", "bodyText": "Can we put the failedResult lambda on a new line? It's easily missed otherwise.", "author": "tombentley", "createdAt": "2020-03-04T14:53:52Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,122 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log and update status with the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChangeGreaterThanOne\")\n+                                        .withStatus(\"False\")\n+                                        .withMessage(scaleErrorMessage);\n+\n+                                KafkaStatus kStatus = this.kafkaStatus;\n+                                kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                                return this.updateStatus(kStatus).compose(successResult -> {\n+                                    log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                                    return Future.succeededFuture(); }, failedResult -> {\n+                                        log.error(\"Failed to set status for {}\", kafkaAssembly.getMetadata().getName());\n+                                        return Future.succeededFuture();\n+                                    }).compose(result -> Future.failedFuture(new IllegalArgumentException(scaleErrorMessage)));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation to false.\", Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n \n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (isZK35x) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            return this.updateStatus(kStatus).compose(successResult -> {\n+                                log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                                return Future.succeededFuture(); }, failedResult -> {", "originalCommit": "1b8bc84b83bc553b0b5898bbddedb0de09e9b302", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5Nzg1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388097852", "bodyText": "just one line using a ternary operator instead of this if/else block?", "author": "ppatierno", "createdAt": "2020-03-05T06:22:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,15 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions;\n+            if (oldConditions != null) {\n+                newConditions = new ArrayList<>(oldConditions);\n+            } else {\n+                newConditions = new ArrayList<>();\n+            }", "originalCommit": "78764a4ea39e7beb7625e0560e4886f390c0ed90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODc4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388098780", "bodyText": "Ditto as above", "author": "ppatierno", "createdAt": "2020-03-05T06:26:06Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation to false.\", Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n \n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                if (isZK35x) {\n+                                    zkManualScalingCondition\n+                                            .withStatus(\"False\")\n+                                            .withReason(\"manualScalingNotRequired\")\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                            List<Condition> newConditions;\n+                            if (oldConditions != null) {\n+                                newConditions = new ArrayList<>(oldConditions);\n+                            } else {\n+                                newConditions = new ArrayList<>();\n+                            }", "originalCommit": "78764a4ea39e7beb7625e0560e4886f390c0ed90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODk3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388098972", "bodyText": "I see all three conditions verifying currentReplicas > 0. What if for any reason currentReplicas is zero?", "author": "ppatierno", "createdAt": "2020-03-05T06:26:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }", "originalCommit": "78764a4ea39e7beb7625e0560e4886f390c0ed90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE5ODAxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388198011", "bodyText": "Good catch, this was left over from the old code where if the STS was null currentReplicas would be 0. However, now all this code is already wrapped in a check for a null STS.", "author": "tomncooper", "createdAt": "2020-03-05T10:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODk3Mg=="}], "type": "inlineReview"}, {"oid": "83a762e3b8997ff8e16f72c6698c90db6597c36f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/83a762e3b8997ff8e16f72c6698c90db6597c36f", "message": "Addressed comments on ZK scaling procedures\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-03-05T10:03:50Z", "type": "forcePushed"}, {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a22a3174c8dad0cf2939b7354d1212c66922b31c", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-03-05T11:24:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388253275", "bodyText": "Why do you create a new ArrayList and not just add it to the existing if it exists?", "author": "scholzj", "createdAt": "2020-03-05T12:07:59Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,10 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTgwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388289805", "bodyText": "The existing list is an unmodifiable list so we have to create a modifiable copy to be able to add the new status.", "author": "tomncooper", "createdAt": "2020-03-05T13:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5Mzk0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388293946", "bodyText": "Ok, makes sense.", "author": "scholzj", "createdAt": "2020-03-05T13:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzgyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388253825", "bodyText": "I guess we should probably fix the JavaDoc?", "author": "scholzj", "createdAt": "2020-03-05T12:09:21Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTkyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388289924", "bodyText": "Good point", "author": "tomncooper", "createdAt": "2020-03-05T13:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NTA4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388255088", "bodyText": "I'm not sure I understand the comment, because at this point you do not know this is 3.4 or 3.5 - it is not part of this particular else if, or?", "author": "scholzj", "createdAt": "2020-03-05T12:12:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NjQ2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388256461", "bodyText": "Do we need the empty line here?", "author": "scholzj", "createdAt": "2020-03-05T12:15:14Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MjUyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388292524", "bodyText": "no", "author": "tomncooper", "createdAt": "2020-03-05T13:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388258851", "bodyText": "If I read the code right, the initial status from line 1435 will be there only until the next reocnciliation which will replace it with the next one. That sounds like very short time and possibly people might not see it. Maybe you can add some parts of that message here as well to make the status more clear (such as the reference to the docs etc.).", "author": "scholzj", "createdAt": "2020-03-05T12:20:36Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxMTUyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388311524", "bodyText": "Good point, I will update the status message. However, at the moment the procedure is in a markdown file in documentation/misc. Were we going to add it to the official docs or the release notes? Is it ok just to refer to the genrnic \"docs\" ?", "author": "tomncooper", "createdAt": "2020-03-05T14:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMzODc5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388338799", "bodyText": "I think the generic reference to the docs as it is in the status above should be ok.", "author": "scholzj", "createdAt": "2020-03-05T14:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTI2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388259267", "bodyText": "I don't like nitpicking about empty lines, but it really hits me in the eyes that half of the code has empty line before } and the other half doesn't.", "author": "scholzj", "createdAt": "2020-03-05T12:21:32Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388259596", "bodyText": "Again, what is the advantage of always creating new ArrayList over using the old one if it already exists? Also, this code seems to be used now at least twice - maybe we can factor it out?", "author": "scholzj", "createdAt": "2020-03-05T12:22:16Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScaling = false;\n+                            }\n+\n+                            if (zkManualScalingCondition != null && isZK35x) {\n+                                List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                                List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "originalCommit": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NjcyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388296721", "bodyText": "So as above this is due to the Status object keeping the Conditions in an unmodifiable list. Should we add a method to the abstract Status class that allows adding conditions to its internal list. That would remove the need for repeating this code.", "author": "tomncooper", "createdAt": "2020-03-05T13:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxMjM5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388312393", "bodyText": "Yeah, I gues either there or in some Utils. Why is it using unmodifiable list? And is it ok if you replace it with regular ArrayList then? Should it be also unmodifiable?", "author": "scholzj", "createdAt": "2020-03-05T14:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng=="}], "type": "inlineReview"}, {"oid": "e65be260c341df1c39e883d3179b1d898af45aab", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e65be260c341df1c39e883d3179b1d898af45aab", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n    * Added condition adding method to Status class\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-03-05T15:42:22Z", "type": "commit"}, {"oid": "e65be260c341df1c39e883d3179b1d898af45aab", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e65be260c341df1c39e883d3179b1d898af45aab", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n    * Added condition adding method to Status class\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-03-05T15:42:22Z", "type": "forcePushed"}]}