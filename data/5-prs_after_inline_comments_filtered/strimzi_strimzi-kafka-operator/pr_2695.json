{"pr_number": 2695, "pr_title": "Connector conditional put", "pr_createdAt": "2020-03-12T18:01:00Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695", "timeline": [{"oid": "a7acdb5b4d11cbb8680c2a6dcc5e50ada841dcbe", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a7acdb5b4d11cbb8680c2a6dcc5e50ada841dcbe", "message": "Only reconcile connectors if they don't exist or have different config\n\nThis fixes #2688 where unconditionally doing the PUT request\ncaused connector to reconfigure which caused status update when caused\nreconciliation ad infinitum.\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T16:41:55Z", "type": "commit"}, {"oid": "a26b6e929f73bb6068c68771604c28ce178b03e8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a26b6e929f73bb6068c68771604c28ce178b03e8", "message": "Refactor KafkaConnectApi a little to remove some dupe code.\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T16:42:28Z", "type": "commit"}, {"oid": "d8d9fef9852d070d5ade988c04ecfe7acb2dad35", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d8d9fef9852d070d5ade988c04ecfe7acb2dad35", "message": "test for #2688\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T16:42:41Z", "type": "commit"}, {"oid": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "message": "Checkstyle, fix test\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T17:59:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzQxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391803411", "bodyText": "Should this be really info level?", "author": "scholzj", "createdAt": "2020-03-12T18:10:46Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -333,40 +338,95 @@ protected KafkaConnectApi getKafkaConnectApi() {\n         }\n     }\n \n-    protected Future<Map<String, Object>> createOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, \n-            String connectorName, KafkaConnectorSpec connectorSpec) {\n-        return apiClient.createOrUpdatePutRequest(host, KafkaConnectCluster.REST_API_PORT, connectorName, asJson(connectorSpec))\n-            .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 6), host, KafkaConnectCluster.REST_API_PORT,\n-                    connectorName))\n-            .compose(status -> {\n-                Object path = ((Map) status.getOrDefault(\"connector\", emptyMap())).get(\"state\");\n-                if (!(path instanceof String)) {\n-                    return Future.failedFuture(\"JSON response lacked $.connector.state\");\n+    /**\n+     * Try to get the current connector config. If the connector does not exist, or its config differs from the \n+     * {@code connectorSpec}'s, then call\n+     * {@link #createOrUpdateConnector(Reconciliation, String, KafkaConnectApi, String, KafkaConnectorSpec)}\n+     * otherwise, just return the connectors current state.\n+     * @param reconciliation The reconciliation.\n+     * @param host The REST API host.\n+     * @param apiClient The client instance.\n+     * @param connectorName The connector name.\n+     * @param connectorSpec The desired connector spec.\n+     * @return A Future whose result, when successfully completed, is a map of the current connector state.\n+     */\n+    protected Future<Map<String, Object>> maybeCreateOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient,\n+                                                                       String connectorName, KafkaConnectorSpec connectorSpec) {\n+        return apiClient.getConnectorConfig(new BackOff(200L, 2, 6), host, port, connectorName).compose(\n+            config -> {\n+                if (!needsReconfiguring(reconciliation, connectorName, connectorSpec, config)) {\n+                    log.info(\"{}: Connector {} exists and has desired config, {}=={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);", "originalCommit": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzg2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391803862", "bodyText": "Same as above.", "author": "scholzj", "createdAt": "2020-03-12T18:11:34Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -333,40 +338,95 @@ protected KafkaConnectApi getKafkaConnectApi() {\n         }\n     }\n \n-    protected Future<Map<String, Object>> createOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, \n-            String connectorName, KafkaConnectorSpec connectorSpec) {\n-        return apiClient.createOrUpdatePutRequest(host, KafkaConnectCluster.REST_API_PORT, connectorName, asJson(connectorSpec))\n-            .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 6), host, KafkaConnectCluster.REST_API_PORT,\n-                    connectorName))\n-            .compose(status -> {\n-                Object path = ((Map) status.getOrDefault(\"connector\", emptyMap())).get(\"state\");\n-                if (!(path instanceof String)) {\n-                    return Future.failedFuture(\"JSON response lacked $.connector.state\");\n+    /**\n+     * Try to get the current connector config. If the connector does not exist, or its config differs from the \n+     * {@code connectorSpec}'s, then call\n+     * {@link #createOrUpdateConnector(Reconciliation, String, KafkaConnectApi, String, KafkaConnectorSpec)}\n+     * otherwise, just return the connectors current state.\n+     * @param reconciliation The reconciliation.\n+     * @param host The REST API host.\n+     * @param apiClient The client instance.\n+     * @param connectorName The connector name.\n+     * @param connectorSpec The desired connector spec.\n+     * @return A Future whose result, when successfully completed, is a map of the current connector state.\n+     */\n+    protected Future<Map<String, Object>> maybeCreateOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient,\n+                                                                       String connectorName, KafkaConnectorSpec connectorSpec) {\n+        return apiClient.getConnectorConfig(new BackOff(200L, 2, 6), host, port, connectorName).compose(\n+            config -> {\n+                if (!needsReconfiguring(reconciliation, connectorName, connectorSpec, config)) {\n+                    log.info(\"{}: Connector {} exists and has desired config, {}=={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);\n+                    return apiClient.status(host, port, connectorName)\n+                        .compose(status -> {\n+                            return pauseResume(reconciliation, host, apiClient, connectorName, connectorSpec, status);\n+                        });\n                 } else {\n-                    String state = (String) path;\n-                    boolean shouldPause = Boolean.TRUE.equals(connectorSpec.getPause());\n-                    if (\"RUNNING\".equals(state) && shouldPause) {\n-                        log.debug(\"{}: Pausing connector {}\", reconciliation, connectorName);\n-                        return apiClient.pause(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-                    } else if (\"PAUSED\".equals(state) && !shouldPause) {\n-                        log.debug(\"{}: Resuming connector {}\", reconciliation, connectorName);\n-                        return apiClient.resume(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-\n-                    } else {\n-                        return Future.succeededFuture(status);\n-                    }\n+                    log.info(\"{}: Connector {} exists but does not have desired config, {}!={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);", "originalCommit": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDU4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391804588", "bodyText": "Given the isDebugEnabled I guess this should definitely be debug?", "author": "scholzj", "createdAt": "2020-03-12T18:13:00Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -333,40 +338,95 @@ protected KafkaConnectApi getKafkaConnectApi() {\n         }\n     }\n \n-    protected Future<Map<String, Object>> createOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, \n-            String connectorName, KafkaConnectorSpec connectorSpec) {\n-        return apiClient.createOrUpdatePutRequest(host, KafkaConnectCluster.REST_API_PORT, connectorName, asJson(connectorSpec))\n-            .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 6), host, KafkaConnectCluster.REST_API_PORT,\n-                    connectorName))\n-            .compose(status -> {\n-                Object path = ((Map) status.getOrDefault(\"connector\", emptyMap())).get(\"state\");\n-                if (!(path instanceof String)) {\n-                    return Future.failedFuture(\"JSON response lacked $.connector.state\");\n+    /**\n+     * Try to get the current connector config. If the connector does not exist, or its config differs from the \n+     * {@code connectorSpec}'s, then call\n+     * {@link #createOrUpdateConnector(Reconciliation, String, KafkaConnectApi, String, KafkaConnectorSpec)}\n+     * otherwise, just return the connectors current state.\n+     * @param reconciliation The reconciliation.\n+     * @param host The REST API host.\n+     * @param apiClient The client instance.\n+     * @param connectorName The connector name.\n+     * @param connectorSpec The desired connector spec.\n+     * @return A Future whose result, when successfully completed, is a map of the current connector state.\n+     */\n+    protected Future<Map<String, Object>> maybeCreateOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient,\n+                                                                       String connectorName, KafkaConnectorSpec connectorSpec) {\n+        return apiClient.getConnectorConfig(new BackOff(200L, 2, 6), host, port, connectorName).compose(\n+            config -> {\n+                if (!needsReconfiguring(reconciliation, connectorName, connectorSpec, config)) {\n+                    log.info(\"{}: Connector {} exists and has desired config, {}=={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);\n+                    return apiClient.status(host, port, connectorName)\n+                        .compose(status -> {\n+                            return pauseResume(reconciliation, host, apiClient, connectorName, connectorSpec, status);\n+                        });\n                 } else {\n-                    String state = (String) path;\n-                    boolean shouldPause = Boolean.TRUE.equals(connectorSpec.getPause());\n-                    if (\"RUNNING\".equals(state) && shouldPause) {\n-                        log.debug(\"{}: Pausing connector {}\", reconciliation, connectorName);\n-                        return apiClient.pause(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-                    } else if (\"PAUSED\".equals(state) && !shouldPause) {\n-                        log.debug(\"{}: Resuming connector {}\", reconciliation, connectorName);\n-                        return apiClient.resume(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-\n-                    } else {\n-                        return Future.succeededFuture(status);\n-                    }\n+                    log.info(\"{}: Connector {} exists but does not have desired config, {}!={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);\n+                    return createOrUpdateConnector(reconciliation, host, apiClient, connectorName, connectorSpec);\n+                }\n+            },\n+            error -> {\n+                if (error instanceof ConnectRestException\n+                        && ((ConnectRestException) error).getStatusCode() == 404) {\n+                    log.info(\"{}: Connector {} does not exist\", reconciliation, connectorName);\n+                    return createOrUpdateConnector(reconciliation, host, apiClient, connectorName, connectorSpec);\n+                } else {\n+                    return Future.failedFuture(error);\n                 }\n             });\n     }\n \n+    private boolean needsReconfiguring(Reconciliation reconciliation, String connectorName, KafkaConnectorSpec connectorSpec, Map<String, Object> actual) {\n+        // The actual which comes from Connect API includes tasks.max, connector.class and name,\n+        // which connectorSpec.getConfig() does not\n+        Map<String, Object> desired = log.isDebugEnabled() ? new TreeMap<>(connectorSpec.getConfig()) : new HashMap<>(connectorSpec.getConfig());\n+        desired.put(\"tasks.max\", connectorSpec.getTasksMax().toString());\n+        desired.put(\"name\", connectorName);\n+        desired.put(\"connector.class\", connectorSpec.getClassName());\n+        if (log.isDebugEnabled()) {\n+            log.info(\"{}: Desired: {}\", reconciliation, desired);", "originalCommit": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTIyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391805224", "bodyText": "debug ot trace level I guess?", "author": "scholzj", "createdAt": "2020-03-12T18:14:09Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -89,13 +188,16 @@ public KafkaConnectApiImpl(Vertx vertx) {\n                         response.bodyHandler(buffer -> {\n                             ObjectMapper mapper = new ObjectMapper();\n                             try {\n-                                result.complete(mapper.readValue(buffer.getBytes(), Map.class));\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.info(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);", "originalCommit": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTM2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391805365", "bodyText": "Again ...", "author": "scholzj", "createdAt": "2020-03-12T18:14:27Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -89,13 +188,16 @@ public KafkaConnectApiImpl(Vertx vertx) {\n                         response.bodyHandler(buffer -> {\n                             ObjectMapper mapper = new ObjectMapper();\n                             try {\n-                                result.complete(mapper.readValue(buffer.getBytes(), Map.class));\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.info(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n                             } catch (IOException e) {\n                                 result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n                             }\n                         });\n                     } else {\n                         // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.info(\"Got {} response to PUT request to {}\", response.statusCode(), path);", "originalCommit": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "283c2a832c775cfcb46c8f8585a18ef6e1b76744", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/283c2a832c775cfcb46c8f8585a18ef6e1b76744", "message": "Review comments and less logging for travis\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T18:55:15Z", "type": "commit"}, {"oid": "e62d3416eb824389f47bf218c8ed1bda651844d1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e62d3416eb824389f47bf218c8ed1bda651844d1", "message": "Remove unnecessary code\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T18:55:15Z", "type": "commit"}, {"oid": "e62d3416eb824389f47bf218c8ed1bda651844d1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e62d3416eb824389f47bf218c8ed1bda651844d1", "message": "Remove unnecessary code\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T18:55:15Z", "type": "forcePushed"}, {"oid": "4b617b3b432b47de9bba01fa0acfa333af96b32b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4b617b3b432b47de9bba01fa0acfa333af96b32b", "message": "Checkstyle\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-03-12T19:00:03Z", "type": "commit"}]}