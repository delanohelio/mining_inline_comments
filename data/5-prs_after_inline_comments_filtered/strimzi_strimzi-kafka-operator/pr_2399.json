{"pr_number": 2399, "pr_title": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()", "pr_createdAt": "2020-01-14T23:55:43Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399", "timeline": [{"oid": "17a4521986514c1054714290de3cf712abe7cc7e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/17a4521986514c1054714290de3cf712abe7cc7e", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error", "committedDate": "2020-01-15T01:31:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NzAzMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r366847031", "bodyText": "I think we can avoid the local variable here, just chaining the setHandler on the getAsync call.", "author": "ppatierno", "createdAt": "2020-01-15T12:22:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1223,35 +1223,28 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         Future<ReconciliationState> getZookeeperDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = zkSetOperations.get(namespace, ZookeeperCluster.zookeeperClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            Future<StatefulSet> futSts = zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name));", "originalCommit": "17a4521986514c1054714290de3cf712abe7cc7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NzIzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r366847233", "bodyText": "ditto as above", "author": "ppatierno", "createdAt": "2020-01-15T12:22:34Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1418,30 +1411,24 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         /*test*/ Future<ReconciliationState> getKafkaClusterDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = kafkaSetOperations.get(namespace, KafkaCluster.kafkaClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            Future<StatefulSet> futSts = kafkaSetOperations.getAsync(namespace, KafkaCluster.kafkaClusterName(name));", "originalCommit": "17a4521986514c1054714290de3cf712abe7cc7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5499e3da30fc946452db6878df1d8830866b76b9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5499e3da30fc946452db6878df1d8830866b76b9", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables", "committedDate": "2020-01-15T21:19:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNzkxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367927912", "bodyText": "I wonder if we can further simplify this by using the compose method. It could look something like this:\nreturn zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n                    .compose(sts -> {\n                        Storage oldStorage = getOldStorage(sts);\n\n                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n                        this.zkService = zkCluster.generateService();\n                        this.zkHeadlessService = zkCluster.generateHeadlessService();\n\n                        if (zkCluster.getLogging() instanceof ExternalLogging)  {\n                            return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) zkCluster.getLogging()).getName());\n                        } else {\n                            return Future.succeededFuture(null);\n                        }\n                    })\n                    .compose(cm -> {\n                        ConfigMap logAndMetricsConfigMap = zkCluster.generateMetricsAndLogConfigMap(cm);\n                        this.zkMetricsAndLogsConfigMap = zkCluster.generateMetricsAndLogConfigMap(logAndMetricsConfigMap);\n\n                        return Future.succeededFuture(this);\n                    });\nI think the same can be applied to all of the other methods you changed.", "author": "scholzj", "createdAt": "2020-01-17T13:11:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1223,35 +1223,26 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         Future<ReconciliationState> getZookeeperDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = zkSetOperations.get(namespace, ZookeeperCluster.zookeeperClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name)).setHandler(res -> {", "originalCommit": "5499e3da30fc946452db6878df1d8830866b76b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyODQ0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367928443", "bodyText": "You cannot call result() here, because that would need to wait after the future completes. The suggestion above should be able to deal with it.", "author": "scholzj", "createdAt": "2020-01-17T13:13:11Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1223,35 +1223,26 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         Future<ReconciliationState> getZookeeperDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = zkSetOperations.get(namespace, ZookeeperCluster.zookeeperClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name)).setHandler(res -> {\n+                if (res.succeeded()) {\n+                    StatefulSet sts = res.result();\n+                    Storage oldStorage = getOldStorage(sts);\n \n-                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n+                    this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n \n-                        ConfigMap logAndMetricsConfigMap = zkCluster.generateMetricsAndLogConfigMap(zkCluster.getLogging() instanceof ExternalLogging ?\n-                                configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) zkCluster.getLogging()).getName()) :\n-                                null);\n+                    ConfigMap logAndMetricsConfigMap = zkCluster.generateMetricsAndLogConfigMap(zkCluster.getLogging() instanceof ExternalLogging ?\n+                            configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) zkCluster.getLogging()).getName()).result() :", "originalCommit": "5499e3da30fc946452db6878df1d8830866b76b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTA4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367929088", "bodyText": "Since we don't do anything asynchronous here, you can probably just do return Future.succeededFuture(this); and not use the Promise at all.", "author": "scholzj", "createdAt": "2020-01-17T13:14:51Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3077,26 +3027,9 @@ String getInternalServiceHostname(String serviceName)    {\n \n         private final Future<ReconciliationState> getKafkaExporterDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n-\n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        this.kafkaExporter = KafkaExporter.fromCrd(kafkaAssembly, versions);\n-                        this.exporterDeployment = kafkaExporter.generateDeployment(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n-\n-                        future.complete(this);\n-                    } catch (Throwable e) {\n-                        future.fail(e);\n-                    }\n-                }, true,\n-                res -> {\n-                    if (res.succeeded()) {\n-                        promise.complete(res.result());\n-                    } else {\n-                        promise.fail(res.cause());\n-                    }\n-                }\n-            );\n+            this.kafkaExporter = KafkaExporter.fromCrd(kafkaAssembly, versions);\n+            this.exporterDeployment = kafkaExporter.generateDeployment(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n+            promise.complete(this);", "originalCommit": "5499e3da30fc946452db6878df1d8830866b76b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTUyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367929524", "bodyText": "You would again need to use these for example as a compose pattern similar to what I suggested above.", "author": "scholzj", "createdAt": "2020-01-17T13:16:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2627,43 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n+                        topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n+                                configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()).result() :", "originalCommit": "5499e3da30fc946452db6878df1d8830866b76b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5e53e3d46d671b4623b148830b245beaa0da1508", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5e53e3d46d671b4623b148830b245beaa0da1508", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock", "committedDate": "2020-01-18T00:38:52Z", "type": "forcePushed"}, {"oid": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription", "committedDate": "2020-01-18T02:08:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368228246", "bodyText": "I do not think this would work. Because of the ExteralLogging is not used in Topic Operator but used in User Operator, this code will be never executed.", "author": "scholzj", "createdAt": "2020-01-18T13:57:08Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,97 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                final String[] configAnnotation = {\"\"};\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && userOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName())\n+                                .compose(cm -> {\n+                                    ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(cm);\n+                                    this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(topicOperatorLogAndMetricsConfigMap);\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                                    configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            String configAnnotation = \"\";\n+                                    if (userOperator.getLogging() instanceof ExternalLogging) {", "originalCommit": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgzODk5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368838999", "bodyText": "the current version is checking both Topic Operator logging \n  \n    \n      strimzi-kafka-operator/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n    \n    \n         Line 2675\n      in\n      6527d7a\n    \n    \n    \n    \n\n        \n          \n           topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ? \n        \n    \n  \n\n   and User Operator logging \n  \n    \n      strimzi-kafka-operator/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n    \n    \n         Line 2680\n      in\n      6527d7a\n    \n    \n    \n    \n\n        \n          \n           userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ? \n        \n    \n  \n\n\nShould we be only checking User Operator logging?", "author": "RickyRajinder", "createdAt": "2020-01-21T07:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjY1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368862652", "bodyText": "You need to check both. But right now you have wrapped them into each other. So when if (topicOperator.getLogging() instanceof ExternalLogging) { evalates to false, this if (userOperator.getLogging() instanceof ExternalLogging) { will be never executed.", "author": "scholzj", "createdAt": "2020-01-21T08:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368228274", "bodyText": "I wonder if this could be somehow split into 3 small methods: getEntityoperatorDescription, getEntityTopicOperatorDescription and getEntityUserOperatorDescription which would split the work and make it easier to chain the async work. But that is just a quick idea, nto sure how well would it work. Right now it seems to dupliacate a bit on the variants with both operators, just one of them etc.", "author": "scholzj", "createdAt": "2020-01-18T13:57:40Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,97 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {", "originalCommit": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0cf16a528cf513c06789b6c7b6be87d249fead2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c0cf16a528cf513c06789b6c7b6be87d249fead2", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription", "committedDate": "2020-01-21T19:22:07Z", "type": "forcePushed"}, {"oid": "8c7c2b15826ac75d40bac22aba189e599c723cec", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8c7c2b15826ac75d40bac22aba189e599c723cec", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription\n\nFix lambda expression\n\nAdd deprecation warning suppression", "committedDate": "2020-01-21T20:01:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3ODM2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r369278365", "bodyText": "I didn't actually run any tests with it. But I wonder if you can rewrite this whole thing with something like this?\nprivate final Future<ReconciliationState> getEntityOperatorDescription2() {\n            this.entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n\n            if (entityOperator != null) {\n                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n                EntityUserOperator userOperator = entityOperator.getUserOperator();\n\n                Future<ConfigMap> futToConfigMap;\n\n                if (topicOperator != null && topicOperator.getLogging() instanceof ExternalLogging)  {\n                    futToConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName());\n                } else {\n                    futToConfigMap = Future.succeededFuture(null);\n                }\n\n                Future<ConfigMap> futUoConfigMap;\n\n                if (userOperator != null && userOperator.getLogging() instanceof ExternalLogging)  {\n                    futUoConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName());\n                } else {\n                    futUoConfigMap = Future.succeededFuture(null);\n                }\n\n                return CompositeFuture.join(futToConfigMap, futUoConfigMap)\n                        .compose(res -> {\n                            ConfigMap toCm = res.resultAt(0);\n                            ConfigMap uoCm = res.resultAt(1);\n                            String configAnnotation = \"\";\n\n                            if (topicOperator != null && toCm != null)  {\n                                this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(toCm);\n                                configAnnotation += this.topicOperatorMetricsAndLogsConfigMap.getData().get(\"log4j2.properties\");\n                            }\n\n                            if (userOperator != null && uoCm != null)   {\n                                this.userOperatorMetricsAndLogsConfigMap = userOperator.generateMetricsAndLogConfigMap(uoCm);\n                                configAnnotation += this.userOperatorMetricsAndLogsConfigMap.getData().get(\"log4j2.properties\");\n                            }\n\n                            Map<String, String> annotations = new HashMap<>();\n                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation);\n\n                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n\n                            return Future.succeededFuture(this);\n                        });\n            } else {\n                return Future.succeededFuture(this);\n            }\n        }", "author": "scholzj", "createdAt": "2020-01-21T22:29:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,112 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n+\n+                final String[] configAnnotation = {\"\"};\n+                Map<String, String> annotations = new HashMap<>();\n+\n+                if (topicOperator != null && userOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging && userOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityTopicOperatorDescription(configAnnotation, annotations, entityOperator).compose(to ->\n+                                getEntityUserOperatorDescription(configAnnotation, annotations, entityOperator));\n+                    } else if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityTopicOperatorDescription(configAnnotation, annotations, entityOperator).compose(to -> {\n+                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator.generateMetricsAndLogConfigMap(null);\n+                            this.userOperatorMetricsAndLogsConfigMap = userOperatorLogAndMetricsConfigMap;\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+                            configAnnotation[0] += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                            this.entityOperator = entityOperator;\n+                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                            return Future.succeededFuture(this);\n+                        });\n+                    } else if (userOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityUserOperatorDescription(configAnnotation, annotations, entityOperator).compose(uo -> {\n+                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(null);\n+                            this.topicOperatorMetricsAndLogsConfigMap = topicOperatorLogAndMetricsConfigMap;\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                            configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n \n-                            String configAnnotation = \"\";\n+                            this.entityOperator = entityOperator;\n+                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n \n-                            if (topicOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n-                            }\n+                            return Future.succeededFuture(this);\n+                        });\n+                    } else {\n+                        ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(null);\n+                        configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            if (userOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n-                            }\n+                        ConfigMap userOperatorLogAndMetricsConfigMap = userOperator.generateMetricsAndLogConfigMap(null);\n+                        configAnnotation[0] += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            Map<String, String> annotations = new HashMap<>();\n-                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation);\n+                        annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n \n-                            this.entityOperator = entityOperator;\n-                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n-                            this.topicOperatorMetricsAndLogsConfigMap = topicOperatorLogAndMetricsConfigMap;\n-                            this.userOperatorMetricsAndLogsConfigMap = userOperatorLogAndMetricsConfigMap;\n-                        }\n+                        this.entityOperator = entityOperator;\n+                        this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n+                        this.topicOperatorMetricsAndLogsConfigMap = topicOperatorLogAndMetricsConfigMap;\n+                        this.userOperatorMetricsAndLogsConfigMap = userOperatorLogAndMetricsConfigMap;\n \n-                        future.complete(this);\n-                    } catch (Throwable e) {\n-                        future.fail(e);\n+                        return Future.succeededFuture(this);\n                     }\n-                }, true,\n-                res -> {\n-                    if (res.succeeded()) {\n-                        fut.complete(res.result());\n-                    } else {\n-                        fut.fail(res.cause());\n+                }\n+                if (topicOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityTopicOperatorDescription(configAnnotation, annotations, entityOperator);\n                     }\n                 }\n-            );\n-            return fut;\n+                if (userOperator != null) {\n+                    if (userOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityUserOperatorDescription(configAnnotation, annotations, entityOperator);\n+                    }\n+                }\n+            }\n+            return Future.succeededFuture(this);\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        private Future<ReconciliationState> getEntityTopicOperatorDescription(final String[] configAnnotation, Map<String, String> annotations, EntityOperator entityOperator) {\n+            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+            return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName())\n+                    .compose(cm -> {\n+                        ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(cm);\n+                        this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(topicOperatorLogAndMetricsConfigMap);\n+\n+                        configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+\n+                        annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n+\n+                        this.entityOperator = entityOperator;\n+                        this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n+\n+                        return Future.succeededFuture(null);\n+                    });\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        private Future<ReconciliationState> getEntityUserOperatorDescription(final String[] configAnnotation, Map<String, String> annotations, EntityOperator entityOperator) {\n+            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+            return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName())\n+                    .compose(cm -> {\n+                        ConfigMap userOperatorLogAndMetricsConfigMap = userOperator.generateMetricsAndLogConfigMap(cm);\n+                        this.userOperatorMetricsAndLogsConfigMap = userOperator.generateMetricsAndLogConfigMap(userOperatorLogAndMetricsConfigMap);\n+\n+                        configAnnotation[0] += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+\n+                        annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n+\n+                        this.entityOperator = entityOperator;\n+                        this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n+\n+                        return Future.succeededFuture(this);\n+                    });", "originalCommit": "8c7c2b15826ac75d40bac22aba189e599c723cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9c3f405f15398e52981dd3908d9e96812479700", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a9c3f405f15398e52981dd3908d9e96812479700", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription\n\nFix lambda expression\n\nAdd deprecation warning suppression\n\nRefactor getEntityOperatorDescription", "committedDate": "2020-01-21T23:07:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyODA3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r371028072", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (topicOperator != null && toCm != null)  {\n          \n          \n            \n                                        if (topicOperator != null)  {", "author": "scholzj", "createdAt": "2020-01-26T20:44:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,54 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            this.entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                Future<ConfigMap> futToConfigMap;\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && topicOperator.getLogging() instanceof ExternalLogging)  {\n+                    futToConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName());\n+                } else {\n+                    futToConfigMap = Future.succeededFuture(null);\n+                }\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                Future<ConfigMap> futUoConfigMap;\n \n+                if (userOperator != null && userOperator.getLogging() instanceof ExternalLogging)  {\n+                    futUoConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName());\n+                } else {\n+                    futUoConfigMap = Future.succeededFuture(null);\n+                }\n+\n+                return CompositeFuture.join(futToConfigMap, futUoConfigMap)\n+                        .compose(res -> {\n+                            ConfigMap toCm = res.resultAt(0);\n+                            ConfigMap uoCm = res.resultAt(1);\n                             String configAnnotation = \"\";\n \n-                            if (topicOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            if (topicOperator != null && toCm != null)  {", "originalCommit": "a9c3f405f15398e52981dd3908d9e96812479700", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyODA4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r371028081", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (userOperator != null && uoCm != null)   {\n          \n          \n            \n                                        if (userOperator != null)   {", "author": "scholzj", "createdAt": "2020-01-26T20:45:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,54 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            this.entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                Future<ConfigMap> futToConfigMap;\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && topicOperator.getLogging() instanceof ExternalLogging)  {\n+                    futToConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName());\n+                } else {\n+                    futToConfigMap = Future.succeededFuture(null);\n+                }\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                Future<ConfigMap> futUoConfigMap;\n \n+                if (userOperator != null && userOperator.getLogging() instanceof ExternalLogging)  {\n+                    futUoConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName());\n+                } else {\n+                    futUoConfigMap = Future.succeededFuture(null);\n+                }\n+\n+                return CompositeFuture.join(futToConfigMap, futUoConfigMap)\n+                        .compose(res -> {\n+                            ConfigMap toCm = res.resultAt(0);\n+                            ConfigMap uoCm = res.resultAt(1);\n                             String configAnnotation = \"\";\n \n-                            if (topicOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            if (topicOperator != null && toCm != null)  {\n+                                this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(toCm);\n+                                configAnnotation += this.topicOperatorMetricsAndLogsConfigMap.getData().get(\"log4j2.properties\");\n                             }\n \n-                            if (userOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            if (userOperator != null && uoCm != null)   {", "originalCommit": "a9c3f405f15398e52981dd3908d9e96812479700", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6c416c0235432fb6489a123617087724b9b75550", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6c416c0235432fb6489a123617087724b9b75550", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription\n\nFix lambda expression\n\nAdd deprecation warning suppression\n\nRefactor getEntityOperatorDescription\n\nRemove unnecessary null checks", "committedDate": "2020-01-27T00:38:09Z", "type": "forcePushed"}, {"oid": "22d97553233a20e8c4ab27ccfd0bb991c0fca589", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/22d97553233a20e8c4ab27ccfd0bb991c0fca589", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription\n\nFix lambda expression\n\nAdd deprecation warning suppression\n\nRefactor getEntityOperatorDescription\n\nRemove unnecessary null checks", "committedDate": "2020-01-29T18:14:40Z", "type": "forcePushed"}, {"oid": "f98e7d96518d57f8bc98eee9bdd43443ab9486e9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f98e7d96518d57f8bc98eee9bdd43443ab9486e9", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription\n\nFix lambda expression\n\nAdd deprecation warning suppression\n\nRefactor getEntityOperatorDescription\n\nRemove unnecessary null checks", "committedDate": "2020-01-30T23:41:06Z", "type": "commit"}, {"oid": "f98e7d96518d57f8bc98eee9bdd43443ab9486e9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f98e7d96518d57f8bc98eee9bdd43443ab9486e9", "message": "Refactor KafkaAssemblyOperator get*Description() methods to use getAsync()\n\nSigned-off-by: RickyRajinder <singh.sangh@gmail.com>\n\nRevert \"Change get*Description() methods to use getAsync()\"\n\nThis reverts commit d0a709a577ba8b3450821dcc6030655cc8737c2d.\n\nRefactor KafkaAssemblyOperator\n\nFix checkstyle error\n\nRemove unnecessary variables\n\nUse compose with getAsync and fix tests to use getAsync mock\n\nRemove casts from getEntityOperatorDescription\n\nFix getEntityOperatorDescription\n\nFix lambda expression\n\nAdd deprecation warning suppression\n\nRefactor getEntityOperatorDescription\n\nRemove unnecessary null checks", "committedDate": "2020-01-30T23:41:06Z", "type": "forcePushed"}]}