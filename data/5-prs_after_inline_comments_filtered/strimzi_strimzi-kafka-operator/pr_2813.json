{"pr_number": 2813, "pr_title": "[systemtest][refactor] CRs and ST refactor", "pr_createdAt": "2020-04-08T20:23:42Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODE5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r406128194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void waitForKafkaBridgeIsReady(String clusterName, int expectPods) {\n          \n          \n            \n                public static void waitForKafkaBridgePodIsReady(String clusterName, int expectPods) {\n          \n      \n    \n    \n  \n\nThis is maybe a thing that we can take into consideration. I think this could be generalized on the more abstract way. For instance, create a generic method in the PodUtils? What do you think @Frawless  ?", "author": "see-quick", "createdAt": "2020-04-09T11:06:32Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaBridgeUtils.java", "diffHunk": "@@ -64,11 +68,40 @@ public static void checkSendResponse(JsonObject response, int messageCount) {\n         }\n     }\n \n-    public static void waitUntilKafkaBridgeStatus(String clusterName, String state) {\n+    /**\n+     * Wait until KafkaBridge is in desired state\n+     * @param clusterName name of KafkaBridge cluster\n+     * @param state desired state\n+     */\n+    public static void waitForKafkaBridgeStatus(String clusterName, String state) {\n         LOGGER.info(\"Waiting till Kafka Bridge CR will be in state: {}\", state);\n         TestUtils.waitFor(\"Waiting for Kafka resource status is: \" + state, Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n-            () -> KafkaBridgeResource.kafkaBridgeClient().inNamespace(kubeClient().getNamespace()).withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(state)\n+            () -> kafkaBridgeClient().inNamespace(namespace).withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(state),\n+            () -> StUtils.logCurrentStatus(kafkaBridgeClient().inNamespace(namespace).withName(clusterName).get())\n         );\n         LOGGER.info(\"Kafka Bridge CR is in state: {}\", state);\n     }\n+\n+    public static void waitForKafkaBridgeIsReady(String clusterName) {\n+        waitForKafkaBridgeStatus(clusterName, \"Ready\");\n+    }\n+\n+    public static void waitForKafkaBridgeIsNotReady(String clusterName) {\n+        waitForKafkaBridgeStatus(clusterName, \"NotReady\");\n+    }\n+\n+    /**\n+     * Wait until KafkaBridge and its pods will be in Ready state\n+     * @param clusterName name of KafkaBridge cluster\n+     * @param expectPods number of expected pods to be ready\n+     */\n+    public static void waitForKafkaBridgeIsReady(String clusterName, int expectPods) {", "originalCommit": "ca89bfece7cdd53ce129acebfa9b2ef00872db8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNTUzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r408715530", "bodyText": "The name is fine from my POV. Anyway do we need to wait here for pods after the resource is ready? AFAIU the resource shouldn't be ready when pods are not ready. And how do you want to generalize it? IT checks resource status and then use PodUtils to wait for pods", "author": "Frawless", "createdAt": "2020-04-15T09:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE0MzI4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r410143281", "bodyText": "@im-konge  @see-quick ^", "author": "Frawless", "createdAt": "2020-04-17T10:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIxODA5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r410218092", "bodyText": "@Frawless I took look at it and the reason why I add waiting for pods was that DeploymentUtils have it same way. So there are two options from my POV:\n\nremove it from DeploymentUtils as it is not necessary\nwe will let it on each utils to be sure it is really ready", "author": "im-konge", "createdAt": "2020-04-17T13:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyNTQ2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r410225468", "bodyText": "Well...the question is - do we want to check deployment status or just check Ready status of the bridge CR? In case of pure dpeloyment (clients for example) I would keep it there. My questions was mostly connected with CRs", "author": "Frawless", "createdAt": "2020-04-17T13:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTEzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r406129132", "bodyText": "same here..This is related to the Kubernetes Pod Object not the Connect itself.", "author": "see-quick", "createdAt": "2020-04-09T11:08:32Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -5,36 +5,58 @@\n package io.strimzi.systemtest.utils.kafkaUtils;\n \n import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.utils.StUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n import io.strimzi.test.TestUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n+import static io.strimzi.systemtest.resources.crd.KafkaConnectResource.kafkaConnectClient;\n import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n \n public class KafkaConnectUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(KafkaConnectUtils.class);\n+    private static String namespace = kubeClient().getNamespace();\n \n     private KafkaConnectUtils() {}\n \n-    public static void createFileSinkConnector(String podName, String topicName, String sinkFileName, String apiUrl) {\n-        cmdKubeClient().execInPod(podName, \"/bin/bash\", \"-c\",\n-            \"curl -X POST -H \\\"Content-Type: application/json\\\" \" + \"--data '{ \\\"name\\\": \\\"sink-test\\\", \" +\n-                \"\\\"config\\\": \" + \"{ \\\"connector.class\\\": \\\"FileStreamSink\\\", \" +\n-                \"\\\"tasks.max\\\": \\\"1\\\", \\\"topics\\\": \\\"\" + topicName + \"\\\",\" + \" \\\"file\\\": \\\"\" + sinkFileName + \"\\\" } }' \" +\n-                    apiUrl + \"/connectors\"\n-        );\n+    /**\n+     * Wait until the given Kafka Connect is in desired state.\n+     * @param clusterName name of KafkaConnect cluster\n+     * @param status desired state\n+     */\n+    public static void waitForConnectStatus(String clusterName, String status) {\n+        LOGGER.info(\"Waiting for Kafka Connect {} state: {}\", clusterName, status);\n+        TestUtils.waitFor(\"Kafka Connect \" + clusterName + \" state: \" + status, Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n+            () -> kafkaConnectClient().inNamespace(namespace).withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(status),\n+            () -> StUtils.logCurrentStatus(kafkaConnectClient().inNamespace(namespace).withName(clusterName).get()));\n+        LOGGER.info(\"Kafka Connect {} is in desired state: {}\", clusterName, status);\n     }\n \n-    public static void waitForConnectStatus(String name, String status) {\n-        LOGGER.info(\"Waiting for Kafka Connect {} state: {}\", name, status);\n-        TestUtils.waitFor(\"Kafka Connect \" + name + \" state: \" + status, Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n-            () -> KafkaConnectResource.kafkaConnectClient().inNamespace(kubeClient().getNamespace()).withName(name).get().getStatus().getConditions().get(0).getType().equals(status));\n-        LOGGER.info(\"Kafka Connect {} is in desired state: {}\", name, status);\n+    public static void waitForConnectIsReady(String clusterName) {\n+        waitForConnectStatus(clusterName, \"Ready\");\n     }\n \n+    public static void waitForConnectIsNotReady(String clusterName) {\n+        waitForConnectStatus(clusterName, \"NotReady\");\n+    }\n+\n+    /**\n+     * Wait until KafkaConnect and its pods to be in Ready state\n+     * @param clusterName name of KafkaConnect cluster\n+     * @param expectPods expected pods to be ready\n+     */\n+    public static void waitForConnectIsReady(String clusterName, int expectPods) {\n+        waitForConnectIsReady(clusterName);\n+        LOGGER.info(\"Wait for KafkaConnect pods to be ready\");\n+        PodUtils.waitForPodsReady(kubeClient().getDeploymentSelectors(clusterName), expectPods, true,\n+            () -> StUtils.logCurrentStatus(kafkaConnectClient().inNamespace(namespace).withName(clusterName).get()));\n+        LOGGER.info(\"Expected pods are ready\");\n+    }", "originalCommit": "ca89bfece7cdd53ce129acebfa9b2ef00872db8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "36bae195c208e87a276361785fceaec1efaa64f7", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/36bae195c208e87a276361785fceaec1efaa64f7", "message": "refactor all cr resources classes and sts\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-22T15:24:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxNjMwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413216302", "bodyText": "The capitalization of S2IIs is a ugly! Maybe it should be S2iIs, or maybe just drop the Is entirely (I guess for this and all the other IsReady/IsNotReady methods?", "author": "tombentley", "createdAt": "2020-04-22T18:24:04Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectS2IUtils.java", "diffHunk": "@@ -5,43 +5,54 @@\n package io.strimzi.systemtest.utils.kafkaUtils;\n \n import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.resources.crd.KafkaConnectS2IResource;\n import io.strimzi.systemtest.utils.StUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n import io.strimzi.test.TestUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n+import static io.strimzi.systemtest.resources.crd.KafkaConnectS2IResource.kafkaConnectS2IClient;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n \n public class KafkaConnectS2IUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(KafkaConnectS2IUtils.class);\n+    private static String namespace = kubeClient().getNamespace();\n \n     private KafkaConnectS2IUtils() {}\n \n     /**\n      * Wait until the given Kafka Connect S2I cluster is in desired state.\n-     * @param name The name of the Kafka Connect S2I cluster.\n+     * @param clusterName The name of the Kafka Connect S2I cluster.\n      * @param status desired status value\n      */\n-    public static void waitForConnectS2IStatus(String name, String status) {\n-        LOGGER.info(\"Waiting for Kafka Connect S2I {} state: {}\", name, status);\n-        TestUtils.waitFor(\"Kafka Connect S2I \" + name + \" state: \" + status, Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n-            () -> KafkaConnectS2IResource.kafkaConnectS2IClient().inNamespace(kubeClient().getNamespace())\n-                    .withName(name).get().getStatus().getConditions().get(0).getType().equals(status),\n-            () -> StUtils.logCurrentStatus(KafkaConnectS2IResource.kafkaConnectS2IClient().inNamespace(kubeClient().getNamespace()).withName(name).get()));\n-        LOGGER.info(\"Kafka Connect S2I {} is in desired state: {}\", name, status);\n+    public static void waitForConnectS2IStatus(String clusterName, String status) {\n+        LOGGER.info(\"Waiting for Kafka Connect S2I {} state: {}\", clusterName, status);\n+        TestUtils.waitFor(\"Kafka Connect S2I \" + clusterName + \" state: \" + status, Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n+            () -> kafkaConnectS2IClient().inNamespace(namespace)\n+                    .withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(status),\n+            () -> StUtils.logCurrentStatus(kafkaConnectS2IClient().inNamespace(namespace).withName(clusterName).get()));\n+        LOGGER.info(\"Kafka Connect S2I {} is in desired state: {}\", clusterName, status);\n     }\n \n-    public static void waitForRebalancingDone(String name) {\n-        LOGGER.info(\"Waiting for Kafka Connect S2I {} to rebalance\", name);\n-        TestUtils.waitFor(\"Kafka Connect S2I rebalancing\", Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n-            () -> {\n-                String connect = kubeClient().listPodNames(\"strimzi.io/kind\", \"KafkaConnectS2I\").get(0);\n-                String log = kubeClient().logs(connect);\n-                // wait for second occurrence of message about finished rebalancing\n-                return (log.length() - log.replace(\"Finished starting connectors and tasks\", \"\").length()) / \"Finished starting connectors and tasks\".length() == 2;\n-            });\n-        LOGGER.info(\"Kafka Connect S2I {} rebalanced\", name);\n+    public static void waitForConnectS2IIsReady(String clusterName) {\n+        waitForConnectS2IStatus(clusterName, \"Ready\");\n+    }\n+\n+    public static void waitForConnectS2IIsNotReady(String clusterName) {", "originalCommit": "494e94370b6388575ac1aeb0152fc08ab9e0f9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyNzU5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413227593", "bodyText": "Yes, you are right, it looks like Roman number .. I will remove it, thanks :)", "author": "im-konge", "createdAt": "2020-04-22T18:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxNjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzODAxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413338012", "bodyText": "You seem to have two methods waitForKafkaBridgeReady and one waitForKafkaBridgeNotReady. But each works a bit differently -> one checks the pods and KafkaBridge status and one checks the CR status only. Wouldn't that be confusing when using it?", "author": "scholzj", "createdAt": "2020-04-22T21:15:06Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaBridgeUtils.java", "diffHunk": "@@ -64,11 +68,40 @@ public static void checkSendResponse(JsonObject response, int messageCount) {\n         }\n     }\n \n-    public static void waitUntilKafkaBridgeStatus(String clusterName, String state) {\n+    /**\n+     * Wait until KafkaBridge is in desired state\n+     * @param clusterName name of KafkaBridge cluster\n+     * @param state desired state\n+     */\n+    public static void waitForKafkaBridgeStatus(String clusterName, String state) {\n         LOGGER.info(\"Waiting till Kafka Bridge CR will be in state: {}\", state);\n         TestUtils.waitFor(\"Waiting for Kafka resource status is: \" + state, Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n-            () -> KafkaBridgeResource.kafkaBridgeClient().inNamespace(kubeClient().getNamespace()).withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(state)\n+            () -> kafkaBridgeClient().inNamespace(namespace).withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(state),\n+            () -> StUtils.logCurrentStatus(kafkaBridgeClient().inNamespace(namespace).withName(clusterName).get())\n         );\n         LOGGER.info(\"Kafka Bridge CR is in state: {}\", state);\n     }\n+\n+    public static void waitForKafkaBridgeReady(String clusterName) {\n+        waitForKafkaBridgeStatus(clusterName, \"Ready\");\n+    }\n+\n+    public static void waitForKafkaBridgeNotReady(String clusterName) {\n+        waitForKafkaBridgeStatus(clusterName, \"NotReady\");\n+    }\n+\n+    /**\n+     * Wait until KafkaBridge and its pods will be in Ready state\n+     * @param clusterName name of KafkaBridge cluster\n+     * @param expectPods number of expected pods to be ready\n+     */\n+    public static void waitForKafkaBridgeReady(String clusterName, int expectPods) {", "originalCommit": "05775b3423f6508e127fd7cb4ccdd73f84036d06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNTM0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413905347", "bodyText": "The waitForKafkaBridgeReady and waitForKafkaBridgeNotReady are only overloading methods so we don't need always write \"Ready\" or \"NotReady\" states for each wait and use it little bit easier.\nAbout second part of this nit - when I took look on DeploymentUtils (as lot of our CR deploy used this class) we have there two same name methods waitForDeploymentReady - one for only deployment to be ready and the second one for deployment and pods to be ready. Maybe it's just opinion but for me it's not confusing. Because if you want to check also if pods are ready, you'll just add number of replicas to method parameters.\nWe discuss this with @see-quick and @Frawless sooner. I think we can change it to be more clear (@see-quick has this comment too).", "author": "im-konge", "createdAt": "2020-04-23T15:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzODAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzODM3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413338377", "bodyText": "Should this pass the replicas as well to check the pods as it was doing before?", "author": "scholzj", "createdAt": "2020-04-22T21:15:45Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/crd/KafkaBridgeResource.java", "diffHunk": "@@ -93,7 +92,7 @@ private static KafkaBridge waitFor(KafkaBridge kafkaBridge) {\n         String kafkaBridgeCrName = kafkaBridge.getMetadata().getName();\n \n         LOGGER.info(\"Waiting for Kafka Bridge {}\", kafkaBridgeCrName);\n-        DeploymentUtils.waitForDeploymentReady(KafkaBridgeResources.deploymentName(kafkaBridgeCrName), kafkaBridge.getSpec().getReplicas());\n+        KafkaBridgeUtils.waitForKafkaBridgeReady(kafkaBridgeCrName);", "originalCommit": "05775b3423f6508e127fd7cb4ccdd73f84036d06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjk2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413906960", "bodyText": "After discussion with @Frawless and @see-quick we agreed that we don't really need to know if the pods are in ready status, because if they're not, the CR or deployment itself is not in ready state.\nPlease correct me if I'm wrong @scholzj ..", "author": "im-konge", "createdAt": "2020-04-23T15:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzODM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzOTE2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2813#discussion_r413339163", "bodyText": "Same as above -> this looks like repeated pattern.", "author": "scholzj", "createdAt": "2020-04-22T21:16:53Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectS2IUtils.java", "diffHunk": "@@ -5,43 +5,54 @@\n package io.strimzi.systemtest.utils.kafkaUtils;\n \n import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.resources.crd.KafkaConnectS2IResource;\n import io.strimzi.systemtest.utils.StUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n import io.strimzi.test.TestUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n+import static io.strimzi.systemtest.resources.crd.KafkaConnectS2IResource.kafkaConnectS2IClient;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n \n public class KafkaConnectS2IUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(KafkaConnectS2IUtils.class);\n+    private static String namespace = kubeClient().getNamespace();\n \n     private KafkaConnectS2IUtils() {}\n \n     /**\n      * Wait until the given Kafka Connect S2I cluster is in desired state.\n-     * @param name The name of the Kafka Connect S2I cluster.\n+     * @param clusterName The name of the Kafka Connect S2I cluster.\n      * @param status desired status value\n      */\n-    public static void waitForConnectS2IStatus(String name, String status) {\n-        LOGGER.info(\"Waiting for Kafka Connect S2I {} state: {}\", name, status);\n-        TestUtils.waitFor(\"Kafka Connect S2I \" + name + \" state: \" + status, Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n-            () -> KafkaConnectS2IResource.kafkaConnectS2IClient().inNamespace(kubeClient().getNamespace())\n-                    .withName(name).get().getStatus().getConditions().get(0).getType().equals(status),\n-            () -> StUtils.logCurrentStatus(KafkaConnectS2IResource.kafkaConnectS2IClient().inNamespace(kubeClient().getNamespace()).withName(name).get()));\n-        LOGGER.info(\"Kafka Connect S2I {} is in desired state: {}\", name, status);\n+    public static void waitForConnectS2IStatus(String clusterName, String status) {\n+        LOGGER.info(\"Waiting for Kafka Connect S2I {} state: {}\", clusterName, status);\n+        TestUtils.waitFor(\"Kafka Connect S2I \" + clusterName + \" state: \" + status, Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n+            () -> kafkaConnectS2IClient().inNamespace(namespace)\n+                    .withName(clusterName).get().getStatus().getConditions().get(0).getType().equals(status),\n+            () -> StUtils.logCurrentStatus(kafkaConnectS2IClient().inNamespace(namespace).withName(clusterName).get()));\n+        LOGGER.info(\"Kafka Connect S2I {} is in desired state: {}\", clusterName, status);\n     }\n \n-    public static void waitForRebalancingDone(String name) {\n-        LOGGER.info(\"Waiting for Kafka Connect S2I {} to rebalance\", name);\n-        TestUtils.waitFor(\"Kafka Connect S2I rebalancing\", Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, Constants.TIMEOUT_FOR_RESOURCE_READINESS,\n-            () -> {\n-                String connect = kubeClient().listPodNames(\"strimzi.io/kind\", \"KafkaConnectS2I\").get(0);\n-                String log = kubeClient().logs(connect);\n-                // wait for second occurrence of message about finished rebalancing\n-                return (log.length() - log.replace(\"Finished starting connectors and tasks\", \"\").length()) / \"Finished starting connectors and tasks\".length() == 2;\n-            });\n-        LOGGER.info(\"Kafka Connect S2I {} rebalanced\", name);\n+    public static void waitForConnectS2IReady(String clusterName) {\n+        waitForConnectS2IStatus(clusterName, \"Ready\");\n+    }\n+\n+    public static void waitForConnectS2INotReady(String clusterName) {\n+        waitForConnectS2IStatus(clusterName, \"NotReady\");\n+    }\n+\n+    /**\n+     * Wait until KafkaConnectS2I and its pods to be in Ready state\n+     * @param clusterName name of KafkaConnectS2I cluster\n+     * @param expectPods expected number of pods to be ready\n+     */\n+    public static void waitForConnectS2IReady(String clusterName, int expectPods) {", "originalCommit": "05775b3423f6508e127fd7cb4ccdd73f84036d06", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb3807f8f48dd8bb2e102068923cce93ada70115", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fb3807f8f48dd8bb2e102068923cce93ada70115", "message": "fixup! fixup! removing 'is' from method names\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-23T18:23:09Z", "type": "forcePushed"}, {"oid": "b0107d7d1be35cb566c641edf0db206955566b5f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b0107d7d1be35cb566c641edf0db206955566b5f", "message": "remove big slip from utils classes\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-24T11:11:21Z", "type": "forcePushed"}, {"oid": "d0cf483d1aa73bc4fb8329bd1424da0673e13e93", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d0cf483d1aa73bc4fb8329bd1424da0673e13e93", "message": "refactor all cr resources classes and sts\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "cd70dcc298a47e5bae7664271788f1649211ce94", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cd70dcc298a47e5bae7664271788f1649211ce94", "message": "removing unnecessary waits and waits for pods from CR creation\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "620f6cc30b69b5314d1b69b68976c90b0ecba1ec", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/620f6cc30b69b5314d1b69b68976c90b0ecba1ec", "message": "remove unnecessary exceptions from tests\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "ea233365ef7c3c6d77a6ee50af19c83b3f2d0811", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ea233365ef7c3c6d77a6ee50af19c83b3f2d0811", "message": "removing 'is' from method names\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "3b0f6bf9c85376efb177d8608aeddd648f9b6c9d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3b0f6bf9c85376efb177d8608aeddd648f9b6c9d", "message": "fixup! removing 'is' from method names\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "88f4f5bd1d9446f9c42074e55f2005dabb223360", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/88f4f5bd1d9446f9c42074e55f2005dabb223360", "message": "fixup! fixup! removing 'is' from method names\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "d0c32b1bea2c0caa779c6209ddbcdb5455f9a2f0", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d0c32b1bea2c0caa779c6209ddbcdb5455f9a2f0", "message": "fixup! fixup! fixup! removing 'is' from method names\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "ec45263389fe43fa6c1db2d891e9321c5d0d4988", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ec45263389fe43fa6c1db2d891e9321c5d0d4988", "message": "remove big slip from utils classes\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "fddf5c2390198caea27692f3208b5579f0ed13bd", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fddf5c2390198caea27692f3208b5579f0ed13bd", "message": "fix another slip\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "18b65af06096945b54df72e83d796449e3c5b3f2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/18b65af06096945b54df72e83d796449e3c5b3f2", "message": "fixup! fix another slip\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "commit"}, {"oid": "18b65af06096945b54df72e83d796449e3c5b3f2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/18b65af06096945b54df72e83d796449e3c5b3f2", "message": "fixup! fix another slip\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T08:11:47Z", "type": "forcePushed"}, {"oid": "50bdd851a8d35ac739f90558d1ef7ce3d944da9c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/50bdd851a8d35ac739f90558d1ef7ce3d944da9c", "message": "fix testAppDomainLabels test\n\nSigned-off-by: Lukas Kral <lkral@redhat.com>", "committedDate": "2020-04-27T16:37:20Z", "type": "commit"}]}