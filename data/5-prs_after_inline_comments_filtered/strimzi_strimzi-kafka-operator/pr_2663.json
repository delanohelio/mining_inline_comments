{"pr_number": 2663, "pr_title": "feat: Add warnings to CR status conditions", "pr_createdAt": "2020-03-09T08:21:31Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663", "timeline": [{"oid": "034f6ec1c7034d3319d370408ba4a08763c58e47", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/034f6ec1c7034d3319d370408ba4a08763c58e47", "message": "feat: Add warnings to CR status conditions\n\nThis commit extends the use of the conditions list in the CR status\nto include warnings about potential problems and recommendations for\nbest practice. It introduces a single point in the reconcile loop\nwhere the cluster spec can be checked for things that the user\nmight not be aware of.\n\nThe list of warnings that can be generated is relatively short, but\nthe intent is to introduce the scaffolding where new checks and\nwarnings could later be introduced.\n\nContributes to: #2609\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-11T17:04:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MDAxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391460014", "bodyText": "If we're going to the trouble to size the new list why not pass in the number of things which will be added?", "author": "tombentley", "createdAt": "2020-03-12T08:20:08Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/status/Status.java", "diffHunk": "@@ -45,13 +45,24 @@ public void setConditions(List<Condition> conditions) {\n         this.conditions = conditions;\n     }\n \n-    public void addCondition(Condition condition) {\n+    private List<Condition> prepareConditionsUpdate() {\n         List<Condition> oldConditions = getConditions();\n         List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3Njg4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391676887", "bodyText": "As the constructor is using an existing list, rather than a size, this looked a bit fiddly to change so I've left it as-is for now.", "author": "dalelane", "createdAt": "2020-03-12T14:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MTE5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391461194", "bodyText": "Can we factor out a utility method for creating the timestamp (maybe put it in ModelUtils)? Because I know there are at least a few other places where we do this (grep -F '\"yyyy-MM-dd'T'HH:mm:ssZ\"')", "author": "tombentley", "createdAt": "2020-03-12T08:22:57Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(new Date());", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NTg4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391675881", "bodyText": "Nice idea, thanks", "author": "dalelane", "createdAt": "2020-03-12T14:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MTU5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391461599", "bodyText": "Can we put this before the member fields?", "author": "tombentley", "createdAt": "2020-03-12T08:23:47Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(new Date());\n+    }\n+\n+\n+    public List<Condition> run() {\n+        List<Condition> notifications = new ArrayList<>();\n+        checkKafkaLogMessageFormatVersion(notifications);\n+        checkKafkaStorage(notifications);\n+        checkZooKeeperStorage(notifications);\n+        checkZooKeeperReplicas(notifications);\n+        return notifications;\n+    }\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NTczNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391675735", "bodyText": "sure - done", "author": "dalelane", "createdAt": "2020-03-12T14:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MzYwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391463600", "bodyText": "IIRC it's possible to have JBOD storage with ephemeral volumes, so I think you need to cover that case too.", "author": "tombentley", "createdAt": "2020-03-12T08:28:00Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(new Date());\n+    }\n+\n+\n+    public List<Condition> run() {\n+        List<Condition> notifications = new ArrayList<>();\n+        checkKafkaLogMessageFormatVersion(notifications);\n+        checkKafkaStorage(notifications);\n+        checkZooKeeperStorage(notifications);\n+        checkZooKeeperReplicas(notifications);\n+        return notifications;\n+    }\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");\n+\n+    /**\n+     * Checks if the version of the Kafka brokers matches any custom log.message.format.version config.\n+     *\n+     * Updating this is the final step in upgrading Kafka version, so if this doesn't match it is possibly an\n+     * indication that a user has updated their Kafka cluster and is unaware that they also should update\n+     * their format version to match.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaLogMessageFormatVersion(List<Condition> warnings) {\n+        String logMsgFormatVersion = kafkaCluster.getConfiguration().getConfigOption(KafkaConfiguration.LOG_MESSAGE_FORMAT_VERSION);\n+        String kafkaBrokerVersion = spec.getKafka().getVersion();\n+        if (logMsgFormatVersion != null && kafkaBrokerVersion != null) {\n+            Matcher m = VERSION_REGEX.matcher(logMsgFormatVersion);\n+            if (m.find() && !kafkaBrokerVersion.startsWith(m.group(0))) {\n+                warnings.add(buildCondition(\"KafkaLogMessageFormatVersion\",\n+                                            \"log.message.format.version does not match the Kafka cluster version, which suggests that an upgrade is incomplete.\"));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-broker Kafka cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the broker will result in data loss, as the single broker won't allow for any\n+     * topic replicas.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaStorage(List<Condition> warnings) {\n+        if (kafkaCluster.getReplicas() == 1 &&\n+            kafkaCluster.getStorage() != null && Storage.TYPE_EPHEMERAL.equals(kafkaCluster.getStorage().getType())) {", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5MDU3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391490575", "bodyText": "Yeah that's right.", "author": "ppatierno", "createdAt": "2020-03-12T09:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MzYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MzcyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391463724", "bodyText": "Ditto", "author": "tombentley", "createdAt": "2020-03-12T08:28:14Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(new Date());\n+    }\n+\n+\n+    public List<Condition> run() {\n+        List<Condition> notifications = new ArrayList<>();\n+        checkKafkaLogMessageFormatVersion(notifications);\n+        checkKafkaStorage(notifications);\n+        checkZooKeeperStorage(notifications);\n+        checkZooKeeperReplicas(notifications);\n+        return notifications;\n+    }\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");\n+\n+    /**\n+     * Checks if the version of the Kafka brokers matches any custom log.message.format.version config.\n+     *\n+     * Updating this is the final step in upgrading Kafka version, so if this doesn't match it is possibly an\n+     * indication that a user has updated their Kafka cluster and is unaware that they also should update\n+     * their format version to match.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaLogMessageFormatVersion(List<Condition> warnings) {\n+        String logMsgFormatVersion = kafkaCluster.getConfiguration().getConfigOption(KafkaConfiguration.LOG_MESSAGE_FORMAT_VERSION);\n+        String kafkaBrokerVersion = spec.getKafka().getVersion();\n+        if (logMsgFormatVersion != null && kafkaBrokerVersion != null) {\n+            Matcher m = VERSION_REGEX.matcher(logMsgFormatVersion);\n+            if (m.find() && !kafkaBrokerVersion.startsWith(m.group(0))) {\n+                warnings.add(buildCondition(\"KafkaLogMessageFormatVersion\",\n+                                            \"log.message.format.version does not match the Kafka cluster version, which suggests that an upgrade is incomplete.\"));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-broker Kafka cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the broker will result in data loss, as the single broker won't allow for any\n+     * topic replicas.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaStorage(List<Condition> warnings) {\n+        if (kafkaCluster.getReplicas() == 1 &&\n+            kafkaCluster.getStorage() != null && Storage.TYPE_EPHEMERAL.equals(kafkaCluster.getStorage().getType())) {\n+            warnings.add(buildCondition(\"KafkaStorage\",\n+                    \"A Kafka cluster with a single replica and ephemeral storage will lose topic messages after any restart or rolling update.\"));\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-node ZooKeeper cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the pod will cause the loss of cluster metadata.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkZooKeeperStorage(List<Condition> warnings) {\n+        if (zkCluster.getReplicas() == 1 &&\n+            zkCluster.getStorage() != null && Storage.TYPE_EPHEMERAL.equals(zkCluster.getStorage().getType())) {", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2NDQ3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391464472", "bodyText": "Elsewhere in this class you call this list warnings. It would be good to be consistent.", "author": "tombentley", "createdAt": "2020-03-12T08:29:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(new Date());\n+    }\n+\n+\n+    public List<Condition> run() {\n+        List<Condition> notifications = new ArrayList<>();", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2NTU3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391465570", "bodyText": "I wonder if we should also add warnings from the ValidationVisitor. Potentially that could add quite a few warnings, but it makes them more visible than just in the logs. WDYT @scholzj ?", "author": "tombentley", "createdAt": "2020-03-12T08:32:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -523,6 +525,17 @@ ReconciliationState createReconciliationState(Reconciliation reconciliation, Kaf\n             return initialStatusPromise.future();\n         }\n \n+        /**\n+         * Checks the requested Kafka spec for potential issues, and adds warnings and advice for best\n+         * practice to the status.\n+         */\n+        Future<ReconciliationState> checkKafkaSpec() {\n+            KafkaSpecChecker checker = new KafkaSpecChecker(kafkaAssembly.getSpec(), kafkaCluster, zkCluster);\n+            List<Condition> warnings = checker.run();", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NzY0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r393967643", "bodyText": "Sorry, I missed this earlier. But I think this would be good idea for next PR.", "author": "scholzj", "createdAt": "2020-03-17T21:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2NTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2NzE4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391467184", "bodyText": "I'm not completely sure about this. Unlike the other checks in this class, I think there are valid use cases where someone want might to stick with the old log.message.format.version (e.g. because they're using older clients and can't upgrade them right now). It would be kind of annoying if they're doing that intentionally and they get this warning which they can't remove. But I'm not sure it's worth an annotation to be able to disable the warning, for example.", "author": "tombentley", "createdAt": "2020-03-12T08:35:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(new Date());\n+    }\n+\n+\n+    public List<Condition> run() {\n+        List<Condition> notifications = new ArrayList<>();\n+        checkKafkaLogMessageFormatVersion(notifications);\n+        checkKafkaStorage(notifications);\n+        checkZooKeeperStorage(notifications);\n+        checkZooKeeperReplicas(notifications);\n+        return notifications;\n+    }\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");\n+\n+    /**\n+     * Checks if the version of the Kafka brokers matches any custom log.message.format.version config.\n+     *\n+     * Updating this is the final step in upgrading Kafka version, so if this doesn't match it is possibly an\n+     * indication that a user has updated their Kafka cluster and is unaware that they also should update\n+     * their format version to match.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaLogMessageFormatVersion(List<Condition> warnings) {\n+        String logMsgFormatVersion = kafkaCluster.getConfiguration().getConfigOption(KafkaConfiguration.LOG_MESSAGE_FORMAT_VERSION);\n+        String kafkaBrokerVersion = spec.getKafka().getVersion();\n+        if (logMsgFormatVersion != null && kafkaBrokerVersion != null) {\n+            Matcher m = VERSION_REGEX.matcher(logMsgFormatVersion);\n+            if (m.find() && !kafkaBrokerVersion.startsWith(m.group(0))) {\n+                warnings.add(buildCondition(\"KafkaLogMessageFormatVersion\",\n+                                            \"log.message.format.version does not match the Kafka cluster version, which suggests that an upgrade is incomplete.\"));", "originalCommit": "034f6ec1c7034d3319d370408ba4a08763c58e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4MTM0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r391681347", "bodyText": "It's a fair point - if the user is aware of the issue and is doing it their way intentionally, the warning is potentially annoying.\nI've come across more people who updated their brokers (albeit not using Strimzi) and either forgot or didn't realise they needed to update the config they'd been using since they started, than I have people who are intentionally using a previous/legacy format. So on balance I think the potential benefit outweighs the cost.\nBut this is absolutely an anecdotal and not-very-scientific or representative view :-)", "author": "dalelane", "createdAt": "2020-03-12T14:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2NzE4NA=="}], "type": "inlineReview"}, {"oid": "c816b4ccc49cfb017865fd6b95386ad07128b9a2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c816b4ccc49cfb017865fd6b95386ad07128b9a2", "message": "fix: Review updates\n\nMoved timestamp formatter to ModelUtils.\nAdded check for Jbod storage using ephemeral storage.\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-12T14:51:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNDYwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r392934600", "bodyText": "Date supplier?", "author": "tombentley", "createdAt": "2020-03-16T10:54:05Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ModelUtils;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = ModelUtils.formatTimestamp(new Date());", "originalCommit": "c816b4ccc49cfb017865fd6b95386ad07128b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg1MjMwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r394852308", "bodyText": "@dalelane why this was marked as resolved? Isn't it better passing the date supplier as we have it in the KafkaAssemblyOperator?", "author": "ppatierno", "createdAt": "2020-03-19T08:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNDYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg3OTY4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r394879680", "bodyText": "Added it now", "author": "dalelane", "createdAt": "2020-03-19T09:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjAyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r392936029", "bodyText": "I think these could be static, and probably ModelUtil is a better place for them (more likely to be reused there).", "author": "tombentley", "createdAt": "2020-03-16T10:56:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ModelUtils;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = ModelUtils.formatTimestamp(new Date());\n+    }\n+\n+    public List<Condition> run() {\n+        List<Condition> warnings = new ArrayList<>();\n+        checkKafkaLogMessageFormatVersion(warnings);\n+        checkKafkaStorage(warnings);\n+        checkZooKeeperStorage(warnings);\n+        checkZooKeeperReplicas(warnings);\n+        return warnings;\n+    }\n+\n+    /**\n+     * Checks if the version of the Kafka brokers matches any custom log.message.format.version config.\n+     *\n+     * Updating this is the final step in upgrading Kafka version, so if this doesn't match it is possibly an\n+     * indication that a user has updated their Kafka cluster and is unaware that they also should update\n+     * their format version to match.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaLogMessageFormatVersion(List<Condition> warnings) {\n+        String logMsgFormatVersion = kafkaCluster.getConfiguration().getConfigOption(KafkaConfiguration.LOG_MESSAGE_FORMAT_VERSION);\n+        String kafkaBrokerVersion = spec.getKafka().getVersion();\n+        if (logMsgFormatVersion != null && kafkaBrokerVersion != null) {\n+            Matcher m = VERSION_REGEX.matcher(logMsgFormatVersion);\n+            if (m.find() && !kafkaBrokerVersion.startsWith(m.group(0))) {\n+                warnings.add(buildCondition(\"KafkaLogMessageFormatVersion\",\n+                                            \"log.message.format.version does not match the Kafka cluster version, which suggests that an upgrade is incomplete.\"));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-broker Kafka cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the broker will result in data loss, as the single broker won't allow for any\n+     * topic replicas.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaStorage(List<Condition> warnings) {\n+        if (kafkaCluster.getReplicas() == 1 && usesEphemeral(kafkaCluster.getStorage())) {\n+            warnings.add(buildCondition(\"KafkaStorage\",\n+                    \"A Kafka cluster with a single replica and ephemeral storage will lose topic messages after any restart or rolling update.\"));\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-node ZooKeeper cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the pod will cause the loss of cluster metadata.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkZooKeeperStorage(List<Condition> warnings) {\n+        if (zkCluster.getReplicas() == 1 && usesEphemeral(zkCluster.getStorage())) {\n+            warnings.add(buildCondition(\"ZooKeeperStorage\",\n+                    \"A ZooKeeper cluster with a single replica and ephemeral storage will be in a defective state after any restart or rolling update. It is recommended that a minimum of three replicas are used.\"));\n+        }\n+    }\n+\n+    private boolean isEphemeral(Storage storage) {\n+        return Storage.TYPE_EPHEMERAL.equals(storage.getType());\n+    }\n+\n+    private boolean usesEphemeral(Storage storage) {\n+        if (storage != null) {\n+            if (isEphemeral(storage)) {\n+                return true;\n+            }\n+            if (Storage.TYPE_JBOD.equals(storage.getType())) {\n+                JbodStorage jbodStorage = (JbodStorage) storage;\n+                return jbodStorage.getVolumes().stream().anyMatch(this::isEphemeral);\n+            }\n+        }\n+        return false;\n+    }", "originalCommit": "c816b4ccc49cfb017865fd6b95386ad07128b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "152f53f9d99c5809f44e32e9eabc5d91bf4ea5cc", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/152f53f9d99c5809f44e32e9eabc5d91bf4ea5cc", "message": "fix: Address review comments\n\nMoved the methods for checking if a storage uses ephemeral volumes\nto a static method in StorageUtils.\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-16T22:25:51Z", "type": "commit"}, {"oid": "2b962379595c71e4a8ddbede17d7d332f74cbaaf", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2b962379595c71e4a8ddbede17d7d332f74cbaaf", "message": "fix: Add instanceof test before class cast\n\nAdding additional check to satisfy spotbugs check.\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-17T09:05:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg1NTc0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r394855749", "bodyText": "could it be assertThat(checker.run(), empty()) ?", "author": "ppatierno", "createdAt": "2020-03-19T08:21:18Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecCheckerTest.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorageBuilder;\n+import io.strimzi.api.kafka.model.storage.JbodStorageBuilder;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.KafkaVersion;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.StringReader;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.emptyOrNullString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+\n+public class KafkaSpecCheckerTest {\n+\n+    private static final String NAMESPACE = \"ns\";\n+    private static final String NAME = \"foo\";\n+    private static final String IMAGE = \"image\";\n+    private static final int HEALTH_DELAY = 120;\n+    private static final int HEALTH_TIMEOUT = 30;\n+\n+    private KafkaSpecChecker generateChecker(Kafka kafka) {\n+        KafkaVersion.Lookup versions = new KafkaVersion.Lookup(\n+                new StringReader(KafkaVersionTestUtils.getKafkaVersionYaml()),\n+                KafkaVersionTestUtils.getKafkaImageMap(),\n+                emptyMap(),\n+                emptyMap(),\n+                emptyMap(),\n+                emptyMap()) { };\n+        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, versions);\n+        ZookeeperCluster zkCluster = ZookeeperCluster.fromCrd(kafka, versions);\n+        return new KafkaSpecChecker(kafka.getSpec(), kafkaCluster, zkCluster);\n+    }\n+\n+    @Test\n+    public void checkEmptyWarnings() {\n+        Kafka kafka = ResourceUtils.createKafkaCluster(NAMESPACE, NAME, 3, IMAGE, HEALTH_DELAY, HEALTH_TIMEOUT);\n+        KafkaSpecChecker checker = generateChecker(kafka);\n+        assertThat(checker.run().isEmpty(), is(true));", "originalCommit": "2b962379595c71e4a8ddbede17d7d332f74cbaaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e5335294ea54fd5574fa58c59b915f6ebcb56f9a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e5335294ea54fd5574fa58c59b915f6ebcb56f9a", "message": "fix: More review updates\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-19T09:05:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4MTIxNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r394881215", "bodyText": "I was mostly thinking about passing the date supplier from the outside because it's created in the KafkaAssemblyOperator using the spec checker. I know they are the same (just returning new Date()) but if we do a change for any reason I don't have right now in the KafkaAssemblyOperator, it should be reflected in the spec checker. @tombentley wdyt? You had a related comment about this.", "author": "ppatierno", "createdAt": "2020-03-19T09:10:19Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaSpecChecker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.ConditionBuilder;\n+import io.strimzi.operator.cluster.model.KafkaCluster;\n+import io.strimzi.operator.cluster.model.KafkaConfiguration;\n+import io.strimzi.operator.cluster.model.ModelUtils;\n+import io.strimzi.operator.cluster.model.StorageUtils;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Checks for potential problems in the configuration requested by the user, to provide\n+ * warnings and share best practice. The intent is this class will generate warnings about\n+ * configurations that aren't necessarily illegal or invalid, but that could potentially\n+ * lead to problems.\n+ */\n+public class KafkaSpecChecker {\n+\n+    private KafkaSpec spec;\n+    private KafkaCluster kafkaCluster;\n+    private ZookeeperCluster zkCluster;\n+    private String timestamp;\n+\n+    private final static Pattern VERSION_REGEX = Pattern.compile(\"(\\\\d\\\\.\\\\d+).*\");\n+\n+    /**\n+     * @param spec The spec requested by the user in the CR\n+     * @param kafkaCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     * @param zkCluster The model generated based on the spec. This is requested so that default\n+     *                     values not included in the spec can be taken into account, without needing\n+     *                     this class to include awareness of what defaults are applied.\n+     */\n+    public KafkaSpecChecker(KafkaSpec spec, KafkaCluster kafkaCluster, ZookeeperCluster zkCluster) {\n+        this.spec = spec;\n+        this.kafkaCluster = kafkaCluster;\n+        this.zkCluster = zkCluster;\n+        this.timestamp = ModelUtils.formatTimestamp(dateSupplier());\n+    }\n+\n+    public List<Condition> run() {\n+        List<Condition> warnings = new ArrayList<>();\n+        checkKafkaLogMessageFormatVersion(warnings);\n+        checkKafkaStorage(warnings);\n+        checkZooKeeperStorage(warnings);\n+        checkZooKeeperReplicas(warnings);\n+        return warnings;\n+    }\n+\n+    /**\n+     * Checks if the version of the Kafka brokers matches any custom log.message.format.version config.\n+     *\n+     * Updating this is the final step in upgrading Kafka version, so if this doesn't match it is possibly an\n+     * indication that a user has updated their Kafka cluster and is unaware that they also should update\n+     * their format version to match.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaLogMessageFormatVersion(List<Condition> warnings) {\n+        String logMsgFormatVersion = kafkaCluster.getConfiguration().getConfigOption(KafkaConfiguration.LOG_MESSAGE_FORMAT_VERSION);\n+        String kafkaBrokerVersion = spec.getKafka().getVersion();\n+        if (logMsgFormatVersion != null && kafkaBrokerVersion != null) {\n+            Matcher m = VERSION_REGEX.matcher(logMsgFormatVersion);\n+            if (m.find() && !kafkaBrokerVersion.startsWith(m.group(0))) {\n+                warnings.add(buildCondition(\"KafkaLogMessageFormatVersion\",\n+                                            \"log.message.format.version does not match the Kafka cluster version, which suggests that an upgrade is incomplete.\"));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-broker Kafka cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the broker will result in data loss, as the single broker won't allow for any\n+     * topic replicas.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkKafkaStorage(List<Condition> warnings) {\n+        if (kafkaCluster.getReplicas() == 1 && StorageUtils.usesEphemeral(kafkaCluster.getStorage())) {\n+            warnings.add(buildCondition(\"KafkaStorage\",\n+                    \"A Kafka cluster with a single replica and ephemeral storage will lose topic messages after any restart or rolling update.\"));\n+        }\n+    }\n+\n+    /**\n+     * Checks for a single-node ZooKeeper cluster using ephemeral storage. This is potentially a problem as it\n+     * means any restarts of the pod will cause the loss of cluster metadata.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkZooKeeperStorage(List<Condition> warnings) {\n+        if (zkCluster.getReplicas() == 1 && StorageUtils.usesEphemeral(zkCluster.getStorage())) {\n+            warnings.add(buildCondition(\"ZooKeeperStorage\",\n+                    \"A ZooKeeper cluster with a single replica and ephemeral storage will be in a defective state after any restart or rolling update. It is recommended that a minimum of three replicas are used.\"));\n+        }\n+    }\n+\n+    /**\n+     * Checks for an even number of ZooKeeper replicas. As ZooKeeper is dependent on maintaining a quorum,\n+     * this means that users should deploy clusters with an odd number of nodes.\n+     *\n+     * @param warnings List to add a warning to, if appropriate.\n+     */\n+    private void checkZooKeeperReplicas(List<Condition> warnings) {\n+        if (zkCluster.getReplicas() == 2) {\n+            warnings.add(buildCondition(\"ZooKeeperReplicas\",\n+                    \"Running ZooKeeper with two nodes is not advisable as both replicas will be needed to avoid downtime. It is recommended that a minimum of three replicas are used.\"));\n+        } else if (zkCluster.getReplicas() % 2 == 0) {\n+            warnings.add(buildCondition(\"ZooKeeperReplicas\",\n+                    \"Running ZooKeeper with an odd number of replicas is recommended.\"));\n+        }\n+    }\n+\n+    private Condition buildCondition(String reason, String message) {\n+        return new ConditionBuilder()\n+                .withLastTransitionTime(timestamp)\n+                .withType(\"Warning\")\n+                .withStatus(\"True\")\n+                .withReason(reason)\n+                .withMessage(message)\n+                .build();\n+    }\n+    private Date dateSupplier() {\n+        return new Date();\n+    }", "originalCommit": "e5335294ea54fd5574fa58c59b915f6ebcb56f9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4NTYxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r394885618", "bodyText": "Sorry if my comment wasn't clear. The point I was trying to make is that the KAO already uses a Supplier<Date> to abstract how it obtains the current time (in support of the \"maintenance time\" functionality). I think we should use the same Supplier<Date> instance here. In also makes it easier to write tests which depend on the \"current\" time.", "author": "tombentley", "createdAt": "2020-03-19T09:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4MTIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3OTI4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r394979283", "bodyText": "@tombentley I've tried moving it into ModelUtils alongside the formatter - was that what you had in mind?", "author": "dalelane", "createdAt": "2020-03-19T12:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4MTIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA4NTc3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2663#discussion_r395085777", "bodyText": "Almost. Please can we pass a Supplier<Date> to the constructor or run() method from the call site in KAO. Ideally only one place in KAO will depend on the ModelUtils method.", "author": "tombentley", "createdAt": "2020-03-19T14:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4MTIxNQ=="}], "type": "inlineReview"}, {"oid": "e0d1023e99dd903c5f1a650a45c63dd4d7d2ed0e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e0d1023e99dd903c5f1a650a45c63dd4d7d2ed0e", "message": "chore: Move date supplier into ModelUtils\n\nMoves the method for creating a new date into a common reusable\nplace.\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-19T12:07:52Z", "type": "commit"}, {"oid": "5c1a4715b8cb815b8721def2e23fcb413571bdf9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5c1a4715b8cb815b8721def2e23fcb413571bdf9", "message": "Revert \"chore: Move date supplier into ModelUtils\"\n\nThis reverts commit e0d1023e99dd903c5f1a650a45c63dd4d7d2ed0e.\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-19T17:28:37Z", "type": "commit"}, {"oid": "9ab22c56055754bd04c9c0817d8f2c3adb19fabe", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9ab22c56055754bd04c9c0817d8f2c3adb19fabe", "message": "chore: More review updates\n\nPass date supplier to use to the KafkaSpecChecker\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-19T17:28:48Z", "type": "commit"}, {"oid": "944b4c865d7a1313d1c70db8120a2357c3dbd742", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/944b4c865d7a1313d1c70db8120a2357c3dbd742", "message": "chore: Add missing javadoc\n\nSigned-off-by: Dale Lane <dale.lane@uk.ibm.com>", "committedDate": "2020-03-19T17:38:55Z", "type": "commit"}]}