{"pr_number": 2773, "pr_title": "Cruise Control deployment", "pr_createdAt": "2020-04-01T16:44:39Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjkyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401802920", "bodyText": "*Container needs capitalization in cruiseControlContainer", "author": "samuel-hawker", "createdAt": "2020-04-01T17:55:28Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/template/CruiseControlTemplate.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.template;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of a template for Cruise Control resources.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"deployment\", \"pod\", \"apiService\", \"podDisruptionBudget\", \"cruiseControlcontainer\", \"tlsSidecarContainer\"})", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNTYwOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402135609", "bodyText": "I've opened #2779 for resolving this sort of thing once and for all.", "author": "tombentley", "createdAt": "2020-04-02T08:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNjE2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401816161", "bodyText": "Minor niggle, but from a failing test point of view might the check\nassertThat(svc.getMetadata().getLabels(), is(svcLabels));\n\ngive a more informative error message on failure? This applys to all of the assertions in this file with containsAll calls", "author": "samuel-hawker", "createdAt": "2020-04-01T18:18:11Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testTemplate() {\n+        Map<String, String> depLabels = TestUtils.map(\"l1\", \"v1\", \"l2\", \"v2\");\n+        Map<String, String> depAnots = TestUtils.map(\"a1\", \"v1\", \"a2\", \"v2\");\n+\n+        Map<String, String> podLabels = TestUtils.map(\"l3\", \"v3\", \"l4\", \"v4\");\n+        Map<String, String> podAnots = TestUtils.map(\"a3\", \"v3\", \"a4\", \"v4\");\n+\n+        Map<String, String> svcLabels = TestUtils.map(\"l5\", \"v5\", \"l6\", \"v6\");\n+        Map<String, String> svcAnots = TestUtils.map(\"a5\", \"v5\", \"a6\", \"v6\");\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+                .editSpec()\n+                    .withNewCruiseControl()\n+                        .withImage(ccImage)\n+                        .withNewTemplate()\n+                            .withNewDeployment()\n+                                .withNewMetadata()\n+                                    .withLabels(depLabels)\n+                                    .withAnnotations(depAnots)\n+                                .endMetadata()\n+                            .endDeployment()\n+                            .withNewPod()\n+                                .withNewMetadata()\n+                                    .withLabels(podLabels)\n+                                    .withAnnotations(podAnots)\n+                                .endMetadata()\n+                                .withNewPriorityClassName(\"top-priority\")\n+                                .withNewSchedulerName(\"my-scheduler\")\n+                            .endPod()\n+                            .withNewApiService()\n+                                .withNewMetadata()\n+                                    .withLabels(svcLabels)\n+                                    .withAnnotations(svcAnots)\n+                                .endMetadata()\n+                            .endApiService()\n+                        .endTemplate()\n+                    .endCruiseControl()\n+                .endSpec()\n+                .build();\n+\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        // Check Deployment\n+        Deployment dep = cc.generateDeployment(true, depAnots, null, null);\n+        assertThat(dep.getMetadata().getLabels().entrySet().containsAll(depLabels.entrySet()), is(true));\n+        assertThat(dep.getMetadata().getAnnotations().entrySet().containsAll(depAnots.entrySet()), is(true));\n+\n+        // Check Pods\n+        assertThat(dep.getSpec().getTemplate().getMetadata().getLabels().entrySet().containsAll(podLabels.entrySet()), is(true));\n+        assertThat(dep.getSpec().getTemplate().getMetadata().getAnnotations().entrySet().containsAll(podAnots.entrySet()), is(true));\n+        assertThat(dep.getSpec().getTemplate().getSpec().getPriorityClassName(), is(\"top-priority\"));\n+        assertThat(dep.getSpec().getTemplate().getSpec().getSchedulerName(), is(\"my-scheduler\"));\n+\n+        // Check Service\n+        Service svc = cc.generateService();\n+        assertThat(svc.getMetadata().getLabels().entrySet().containsAll(svcLabels.entrySet()), is(true));", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzE5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401817193", "bodyText": "Just to be a little more consistent with the rest of the tests in Strimzi would you opposed to using\nassertThrows(NullPointerException.class, () -> cc.generateService());", "author": "samuel-hawker", "createdAt": "2020-04-01T18:19:58Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0ODE3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402148178", "bodyText": "And let's be clear that the code above it wrong anyway. If you're expecting cc.generateService() to throw there's no point in having the assertThat and the cc.generateService() statement should be followed by a fail(), otherwise in the case of no NPE the test will erroneously pass.", "author": "tombentley", "createdAt": "2020-04-02T08:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401818717", "bodyText": "assertThat(kafkaEnvVars, hasEntry(testEnvOneKey, testEnvOneValue) suggested improvement\nAnd maybe have same for envar2?", "author": "samuel-hawker", "createdAt": "2020-04-01T18:22:40Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYzOTk2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402639969", "bodyText": "Since kafkaEnvVars is a list instead of a map I used hasItem() instead. How does this look:\nList<EnvVar> envVarList = cc.getEnvVars();\n\nassertThat(envVarList, hasItems(new EnvVar(testEnvOneKey, testEnvOneValue, null)));\nassertThat(envVarList, hasItems(new EnvVar(testEnvTwoKey, testEnvTwoValue, null)));\n\nLet me know what you think!", "author": "kyguy", "createdAt": "2020-04-02T22:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA4MDgyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403080825", "bodyText": "Looks good, though since hasItems takes ...items you could achieve the same with\nassertThat(envVarList, hasItems(new EnvVar(testEnvOneKey, testEnvOneValue, null),\n    new EnvVar(testEnvTwoKey, testEnvTwoValue, null)));\n\nBut this is only a suggestion , not a required change at all! :P", "author": "samuel-hawker", "createdAt": "2020-04-03T15:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODg2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401818868", "bodyText": "assertThat(kafkaEnvVars, hasEntry(testEnvOneKey, testEnvOneValue) suggested improvement\nAnd maybe have same for envar2?", "author": "samuel-hawker", "createdAt": "2020-04-01T18:22:54Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MDIxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402640214", "bodyText": "See above", "author": "kyguy", "createdAt": "2020-04-02T22:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401819976", "bodyText": "Just as an aside, this might be a good function to contribute to test utils as I can see all of the tests needing to call this method!", "author": "samuel-hawker", "createdAt": "2020-04-01T18:24:44Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NDYxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402144616", "bodyText": "Yes please! Good spot @samuel-hawker!", "author": "tombentley", "createdAt": "2020-04-02T08:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MDgzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402640834", "bodyText": "I'll save this for another PR if that is alright with you two, the PR already changes a lot of files!", "author": "kyguy", "createdAt": "2020-04-02T22:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY5NjE3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403696179", "bodyText": "@kyguy for sure updating ALL the other files should be done in a different PR but here you could start to move the method in the test utils and using it. Then, again, reusing the method for ALL the other tests has to be done in a different PR. Wdyt?", "author": "ppatierno", "createdAt": "2020-04-05T12:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzA0NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127045", "bodyText": "@kyguy is there a link to the documentation about all these configs?", "author": "tombentley", "createdAt": "2020-04-02T08:08:21Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYzODM2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402638368", "bodyText": "Just added this link[1] above the field\n[1] https://github.com/linkedin/cruise-control/wiki/Configurations", "author": "kyguy", "createdAt": "2020-04-02T22:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzQ1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127453", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The Cruise Control broker capacity config.\")\n          \n          \n            \n                @Description(\"The Cruise Control broker capacity configuration.\")", "author": "tombentley", "createdAt": "2020-04-02T08:09:02Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzgxMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127812", "bodyText": "The class is called ...BokerCapacity, so should the property be called that too?", "author": "tombentley", "createdAt": "2020-04-02T08:09:39Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MTMyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402641322", "bodyText": "Refactored", "author": "kyguy", "createdAt": "2020-04-02T22:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODExNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128116", "bodyText": "We should include a link here to the place where the user can learn about what the valid configs are.", "author": "tombentley", "createdAt": "2020-04-02T08:10:14Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MTQ2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402641463", "bodyText": "Added this link [1] to the description\n[1] https://github.com/linkedin/cruise-control/wiki/Configurations", "author": "kyguy", "createdAt": "2020-04-02T22:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODc4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128785", "bodyText": "For the cruise control pod (singular)? If so, please say so in the Description to the reader of the docs is left in no doubt about what they're configuring.", "author": "tombentley", "createdAt": "2020-04-02T08:11:30Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODk3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128976", "bodyText": "For which container?", "author": "tombentley", "createdAt": "2020-04-02T08:11:51Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")\n+    public JvmOptions getJvmOptions() {\n+        return jvmOptions;\n+    }\n+\n+    public void setJvmOptions(JvmOptions jvmOptions) {\n+        this.jvmOptions = jvmOptions;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"CPU and memory resources to reserve.\")", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyOTY4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402129681", "bodyText": "Again, no harm in being more explicit about which container", "author": "tombentley", "createdAt": "2020-04-02T08:13:06Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")\n+    public JvmOptions getJvmOptions() {\n+        return jvmOptions;\n+    }\n+\n+    public void setJvmOptions(JvmOptions jvmOptions) {\n+        this.jvmOptions = jvmOptions;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"CPU and memory resources to reserve.\")\n+    public ResourceRequirements getResources() {\n+        return resources;\n+    }\n+\n+    public void setResources(ResourceRequirements resources) {\n+        this.resources = resources;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"Pod liveness checking.\")", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDE5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130190", "bodyText": "Say what happens if this is not specified (do I get a default CC or no CC?)", "author": "tombentley", "createdAt": "2020-04-02T08:13:56Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaSpec.java", "diffHunk": "@@ -136,6 +137,15 @@ public void setKafkaExporter(KafkaExporterSpec kafkaExporter) {\n         this.kafkaExporter = kafkaExporter;\n     }\n \n+    @Description(\"Configuration of Cruise Control.\")", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDU1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130557", "bodyText": "Are these base 10 megabytes or base 2 mebibytes? We should document it at least.\nCan we call the property diskMB (or diskMiB`) , so the unit is explicit?", "author": "tombentley", "createdAt": "2020-04-02T08:14:36Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMTAzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404431030", "bodyText": "They are in base 2 mebibytes, refactored the properties to diskMib, cpuUtilization, inboundNetworkKiBPerSecond and outboundNetworkKiBPerSecond to be more explicit and updated the documentation", "author": "kyguy", "createdAt": "2020-04-06T22:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130961", "bodyText": "So how does this work if the brokers have resource requests and limits for >1.0 CPU?", "author": "tombentley", "createdAt": "2020-04-02T08:15:24Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzNTcwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404435700", "bodyText": "No matter how many cores are specified for a broker in the resource requests and limits, when Cruise Control is running on top of k8s Cruise Control sees those CPU cores as a single resource. Cruise Control calculates the CPU utilization by checking how often the broker's threads are running on the CPU resources available to that process, using a method [1] that respects cgroup boundaries.\nThe CC CPU capacity is the utilization(or percentage) of this broker's CPU resource that can be used before the CC considers the broker's CPU resources to have been exhausted/exceeded/violated.\n[1] https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getProcessCpuLoad()", "author": "kyguy", "createdAt": "2020-04-06T22:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzMTk4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411031984", "bodyText": "I was wrong about the method[1] respecting cgroup boundaries. It does not and it causes the CPU utilization of the brokers to be underestimated. I am currently looking into a way around this issue but in the meantime, it may be best for stripping this cpuUtilization configuration out of here before committing to a specific format. I may need to use this field to get around this problem.\nWould it be alright if I removed this cpuUtilization field for this PR and add it in at a later point in time? Or do all the properties of cruiseControl.brokerCapacity have to all be added at the same time?\n[1] https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getProcessCpuLoad()", "author": "kyguy", "createdAt": "2020-04-20T00:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzg2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402133862", "bodyText": "Again we should make clear the units KB or KiB, and reflect that in the name. But networkInKBPerSecond is a bit confusing because people might think that the \"in\" is referring to the units be \"in KB/s\", so maybe inboundNetworkKBPerSecond is better.", "author": "tombentley", "createdAt": "2020-04-02T08:20:42Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMTMwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404431300", "bodyText": "Just refactored the properties to inboundNetworkKiBPerSecond and outboundNetworkKiBPerSecond", "author": "kyguy", "createdAt": "2020-04-06T22:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzk2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402133963", "bodyText": "Similar comments.", "author": "tombentley", "createdAt": "2020-04-02T08:20:52Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {\n+        return networkIn;\n+    }\n+\n+    public void setNetworkIn(Integer networkIn) {\n+        this.networkIn = networkIn;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in kilobytes per second.\")\n+    public Integer getNetworkOut() {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTU0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402139543", "bodyText": "Do us a favour an include a comment with that this time is in more meaningful units.\nAnd use _ as a thousands separator, it makes large literals so much easier to read!", "author": "tombentley", "createdAt": "2020-04-02T08:30:25Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", \"86400000\");", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4MjI5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403182297", "bodyText": "Would something like this work?\n// The maximum time in milliseconds to store the response and access details of a completed user task.\nCC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Integer.toString(86_400_000));\n\nOr I could add a link to the CC configuration settings. Let me know what you think!", "author": "kyguy", "createdAt": "2020-04-03T17:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTk1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402139951", "bodyText": "Use addAll(), rather than building a new HashSet", "author": "tombentley", "createdAt": "2020-04-02T08:31:10Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            metricReporterList = new HashSet<String>(Arrays.asList(configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\")));", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDI0NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402140245", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static long parseMemorybyFactor(String memory, String factor) {\n          \n          \n            \n                public static long parseMemoryByFactor(String memory, String factor) {", "author": "tombentley", "createdAt": "2020-04-02T08:31:39Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,17 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number factor of bytes represented as a long.\n+     * @param memory The String representation of the quantity of memory.\n+     * @param factor The factor which the bytes should be converted to\n+     * @return The equivalent number factor of bytes.\n+     */\n+    public static long parseMemorybyFactor(String memory, String factor) {", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDg5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402140893", "bodyText": "I think you should give an example, because this doesn't make complete sense to me.", "author": "tombentley", "createdAt": "2020-04-02T08:32:41Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,17 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number factor of bytes represented as a long.", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MTY5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402141698", "bodyText": "Again _ as a separator.", "author": "tombentley", "createdAt": "2020-04-02T08:33:57Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemorybyFactor;\n+\n+public class Capacity {\n+    public static final int DEFAULT_BROKER_DISK_CAPACITY   = 100000;  // in MB\n+    public static final int DEFAULT_BROKER_CPU_CAPACITY    = 100;     // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_NW_IN_CAPACITY  = 10000;   // in KB/s\n+    public static final int DEFAULT_BROKER_NW_OUT_CAPACITY = 10000;   // in KB/s", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MzY2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402143668", "bodyText": "Why not just use a Long to avoid the possibility of overflow and hence an exception?", "author": "tombentley", "createdAt": "2020-04-02T08:36:57Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemorybyFactor;\n+\n+public class Capacity {\n+    public static final int DEFAULT_BROKER_DISK_CAPACITY   = 100000;  // in MB\n+    public static final int DEFAULT_BROKER_CPU_CAPACITY    = 100;     // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_NW_IN_CAPACITY  = 10000;   // in KB/s\n+    public static final int DEFAULT_BROKER_NW_OUT_CAPACITY = 10000;   // in KB/s\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+\n+    public Capacity(KafkaSpec spec) {\n+        CruiseControlBrokerCapacity bc = spec.getCruiseControl().getCapacity();\n+\n+        this.disk = bc != null && bc.getDisk() != null ? bc.getDisk() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpu = bc != null && bc.getCpu() != null ? bc.getCpu() : DEFAULT_BROKER_CPU_CAPACITY;\n+        this.networkIn = bc != null && bc.getNetworkIn() != null ? bc.getNetworkIn() : DEFAULT_BROKER_NW_IN_CAPACITY;\n+        this.networkOut = bc != null && bc.getNetworkOut() != null ? bc.getNetworkOut() : DEFAULT_BROKER_NW_OUT_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate disk capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a String\n+     */\n+    public static Integer generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMb(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMb(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            int size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;\n+        } else {\n+            throw new IllegalStateException(\"The declared storage '\" + storage.getType() + \"' is not supported\");\n+        }\n+    }\n+\n+    /*\n+     * Parse a K8S-style representation of a disk size, such as {@code 100Gi},\n+     * into the equivalent number of megabytes represented as a Integer.\n+     *\n+     * @param size The String representation of the volume size.\n+     * @return The equivalent number of Megabytes.\n+     */\n+    public static Integer getSizeInMb(String size) {\n+        return Math.toIntExact(parseMemorybyFactor(size, size.charAt(size.length() - 1) == 'i' ? \"Mi\" : \"M\"));", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTU0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402145542", "bodyText": "Let's include the units in the env vars too, because there's nothing more embarrassing that a bug due to confused units.", "author": "tombentley", "createdAt": "2020-04-02T08:40:01Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NjIzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402146236", "bodyText": "new ArrayList<>(). But I'm looking forward to the day we more the operator to Java 11 and can just write var volumes = new ArrayList<SingleVolumeStorage>();", "author": "tombentley", "createdAt": "2020-04-02T08:41:08Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2ODU5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402268598", "bodyText": "as Tom suggested above, config should also be configuration here", "author": "samuel-hawker", "createdAt": "2020-04-02T12:19:45Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "originalCommit": "232d8aeeff07cfabe6bfc684e5f5b19668da0983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a6ca6fc27e97919e7988bbda0f7f348ffd4ffb1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4a6ca6fc27e97919e7988bbda0f7f348ffd4ffb1", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-06T23:18:31Z", "type": "forcePushed"}, {"oid": "25ae97a34e3b4b9852c5e358a59bb5033e6085a2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25ae97a34e3b4b9852c5e358a59bb5033e6085a2", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-06T23:20:25Z", "type": "forcePushed"}, {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-06T23:21:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTUzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595532", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n          \n          \n            \n                    + \"cruise.control.metrics.reporter.bootstrap.servers, sasl.interceptor.classes\";", "author": "tombentley", "createdAt": "2020-04-07T07:31:45Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTU5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595593", "bodyText": "I guess we should add ssl.cipher.suites and ssl.enabled.protocols to the exceptions.", "author": "tombentley", "createdAt": "2020-04-07T07:31:49Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NDQ3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406294472", "bodyText": "I am going to enable ssl configurations until I secure the communication between Cruise Control and Kafka brokers with SSL", "author": "kyguy", "createdAt": "2020-04-09T15:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTg2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n          \n          \n            \n                    + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic,\"", "author": "tombentley", "createdAt": "2020-04-07T07:32:19Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjQzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596432", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The Cruise Control brokerCapacity configuration.\")\n          \n          \n            \n                @Description(\"The Cruise Control `brokerCapacity` configuration.\")", "author": "tombentley", "createdAt": "2020-04-07T07:33:14Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjcwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596702", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n          \n          \n            \n                        \" https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties \" +", "author": "tombentley", "createdAt": "2020-04-07T07:33:41Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596902", "bodyText": "You'll need to add the exception if they're non-empty.", "author": "tombentley", "createdAt": "2020-04-07T07:34:01Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA0OTc2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405049762", "bodyText": "Not sure I understand, like add an exception if a user tries to use a configuration property that is forbidden?", "author": "kyguy", "createdAt": "2020-04-07T19:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNjM2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405336367", "bodyText": "I meant that if you accept that the cipher suites and protocols are exceptions to the forbidden prefixes (as I mentioned elsewhere) you need to mention that here.", "author": "tombentley", "createdAt": "2020-04-08T08:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzE3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404597178", "bodyText": "Is this a log4j2 logging config or a log4j1 logging config?", "author": "tombentley", "createdAt": "2020-04-07T07:34:30Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MTE0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405881149", "bodyText": "It is log4j1, I have just updated this description to specify this", "author": "kyguy", "createdAt": "2020-04-08T23:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNDEwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404604106", "bodyText": "So the alternative to doing it like this would be to use String-typed properties and @Pattern(\"[0-9]+([KMG]i?)?B/s.\n\nIt reads nicer (outboundNetwork: 100KiB/s vs outboundNetworkKiBPerSecond: 100) and is shorter.\nIt is a little more flexible for the user to specify.\nWe could, perhaps, be relaxed about capitalisation too (cf. KiBPerSecond which will tire my pinkie pretty fast).\nIt's more consistent with how Kubernetes specifies memory usage.", "author": "tombentley", "createdAt": "2020-04-07T07:46:26Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"diskMiB\", \"cpuUtilization\", \"inboundNetworkKiBPerSecond\", \"outboundNetworkKiBPerSecond\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboundNetworkKiBPerSecond;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in base 2 mebibytes.\")\n+    public Integer getDiskMiB() {\n+        return diskMiB;\n+    }\n+\n+    public void setDiskMiB(Integer diskMiB) {\n+        this.diskMiB = diskMiB;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in base 2 kibibytes per second.\")\n+    public Integer getInboundNetworkKiBPerSecond() {\n+        return inboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setInboundNetworkKiBPerSecond(Integer inboundNetworkKiBPerSecond) {\n+        this.inboundNetworkKiBPerSecond = inboundNetworkKiBPerSecond;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in base 2 kibibytes per second.\")\n+    public Integer getOutboundNetworkKiBPerSecond() {\n+        return outboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setOutboundNetworkKiBPerSecond(Integer outboundNetworkKiBPerSecond) {\n+        this.outboundNetworkKiBPerSecond = outboundNetworkKiBPerSecond;\n+    }", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NTAzOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405885038", "bodyText": "I like this idea, I changed diskMiB property back to disk again to follow this strategy as well. Now a user can specify disk values the same way as storage and memory values, using k8s format for memory, e.g. disk: 100M for 100 megabytes. This value is then parsed and converted to mebibytes for Cruise Control.", "author": "kyguy", "createdAt": "2020-04-09T00:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNDEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNTY0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404605648", "bodyText": "Comment that this is 1 day, or use TimeUnit.DAYS.toMillis(1)", "author": "tombentley", "createdAt": "2020-04-07T07:49:08Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Integer.toString(86_400_000));", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNzQ1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404607450", "bodyText": "I think it's better to move this down to just before the variable is first used.", "author": "tombentley", "createdAt": "2020-04-07T07:52:02Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwODIzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404608232", "bodyText": "Is it legal to have whitespace in there too (between items or at each end?) org.example.Foo, com.example.Bar", "author": "tombentley", "createdAt": "2020-04-07T07:53:27Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQzNzY3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406437676", "bodyText": "Yes, Kafka removes these whitespaces between and at the end of the elements when parsing the metric.reporter string", "author": "kyguy", "createdAt": "2020-04-09T19:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwODIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwOTUxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404609514", "bodyText": "So it they added CRUISE_CONTROL_METRIC_REPORTER explicitly themselves we remove it unless they also specified a CruiseControlSpec? I think this is more or less a moot point at the moment, since there's no mechanism for people to add plugin classes to our Kafka images (apart from them building their own images, which perhaps some people do). But I would none the less argue that this is not the right thing to do.", "author": "tombentley", "createdAt": "2020-04-07T07:55:36Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));\n+        }\n+        if (cruiseControlSpec != null) {\n+            metricReporterList.add(CRUISE_CONTROL_METRIC_REPORTER);\n+        } else {\n+            metricReporterList.remove(CRUISE_CONTROL_METRIC_REPORTER);", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1MTIzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406451233", "bodyText": "So it they added CRUISE_CONTROL_METRIC_REPORTER explicitly themselves we remove it unless they also specified a CruiseControlSpec?\n\nYes, but the main intention of this code is to stop the Cruise Control metric reporters after the Cruise Control application has been deleted. Otherwise, the Cruise Control metric reporters will continue to run and cost resources even if they are not being used.", "author": "kyguy", "createdAt": "2020-04-09T20:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwOTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMDczNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404610734", "bodyText": "Rounding? e.g. what happens if I ask for 100MB in GB, presumably I get 0?", "author": "tombentley", "createdAt": "2020-04-07T07:57:43Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,21 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number of bytes in the specified units.\n+     * For example, a memory value of \"100Gb\" and a unit value of \"Mb\" will return 100000,", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MDY5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405880694", "bodyText": "Yes the value will get truncated to 0.\nFor this reason and the fact that Cruise Control will cast these capacity values to doubles anyway, I have switched the return type and capacity types from Long to Double and updated this method to do floating point division.", "author": "kyguy", "createdAt": "2020-04-08T23:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMDczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404611494", "bodyText": "So does this mean the CC doesn't really distinguish the disks as having individual sizes?", "author": "tombentley", "createdAt": "2020-04-07T07:58:55Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemory;\n+\n+public class Capacity {\n+    public static final long DEFAULT_BROKER_DISK_MIB_CAPACITY = 100_000;  // in MiB\n+    public static final int DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY = 100;  // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+    public static final int DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+\n+    private Long diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboutNetworkKibPerSecond;\n+\n+    public Capacity(KafkaSpec spec) {\n+        BrokerCapacity bc = spec.getCruiseControl().getBrokerCapacity();\n+\n+        this.diskMiB = bc != null && bc.getDiskMiB() != null ? bc.getDiskMiB() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpuUtilization = bc != null && bc.getCpuUtilization() != null ? bc.getCpuUtilization() : DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY;\n+        this.inboundNetworkKiBPerSecond = bc != null && bc.getInboundNetworkKiBPerSecond() != null ? bc.getInboundNetworkKiBPerSecond() : DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+        this.outboutNetworkKibPerSecond = bc != null && bc.getOutboundNetworkKiBPerSecond() != null ? bc.getOutboundNetworkKiBPerSecond() : DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate diskMiB capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a Long\n+     */\n+    public static Long generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMiB(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMiB(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_MIB_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            long size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;", "originalCommit": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NjkzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405886930", "bodyText": "Cruise Control does distinguish the disks as having individual sizes using the adminClient.\nHowever, for balancing partitions between disks of the same broker, Cruise Control needs us to explicitly state the capacity of each disk here, which I have not done yet. This will require some extra logic.", "author": "kyguy", "createdAt": "2020-04-09T00:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNDQwMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411214401", "bodyText": "So will that extra logic be in this PR, or a future one?", "author": "tombentley", "createdAt": "2020-04-20T09:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2NDM2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411364369", "bodyText": "A future one", "author": "kyguy", "createdAt": "2020-04-20T13:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA=="}], "type": "inlineReview"}, {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "message": "Fix logging and typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-15T15:33:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDE3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411220171", "bodyText": "I think we should allow stuff like 1.5T and exponential notation like 2e6 (which Kube does for memory, for example).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")\n          \n          \n            \n                @Pattern(\"^[0-9]+([.][0-9]*)?([KMGTPE]i?|e[0-9]+)?$\")\n          \n      \n    \n    \n  \n\nAnd I guess to be consistent with the network settings we should allow the B suffix in there too. It's difficult because we're trying to be consistent with Kube, but what Kube does (omitting the actual unit) doesn't really work for the network rates.", "author": "tombentley", "createdAt": "2020-04-20T09:13:12Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MTkyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411661929", "bodyText": "Updated to include . and exponential notation.\nI think we should leave the B suffix out of the disk capacity values so that it is consistent with the storage values we use for Strimzi (which follow the K8s memory format). I do still think the B suffix is very important for the network rates though! What do you think?", "author": "kyguy", "createdAt": "2020-04-20T20:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzQ4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411223484", "bodyText": "Can we explicitly say that this is in bytes per second, just to avoid people mistakenly thinking it might be in bits per second? Same for the outbound.", "author": "tombentley", "createdAt": "2020-04-20T09:18:17Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")\n+    @Description(\"Broker capacity for disk, for example, 100Gi.\")\n+    public String getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(String disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Pattern(\"[0-9]+([KMG]i?)?B/s\")\n+    @Description(\"Broker capacity for network inbound throughput, for example, 10000KB/s\")", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDMwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411224300", "bodyText": "I don't think we need these double empty lines (here and the following two).", "author": "tombentley", "createdAt": "2020-04-20T09:19:25Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDY2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411224660", "bodyText": "Collections.singletonList()", "author": "tombentley", "createdAt": "2020-04-20T09:19:53Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNTAwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411225002", "bodyText": "If you insist on doing it like this then get the right number of items:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Volume> volumeList = new ArrayList<>(1);\n          \n          \n            \n                    List<Volume> volumeList = new ArrayList<>(3);\n          \n      \n    \n    \n  \n\nBut even better would be to use\nreturn Arrays.asList(createSecretVolume(...),\n                     createSecretVolume(...),\n                     createConfigMapVolume(...));", "author": "tombentley", "createdAt": "2020-04-20T09:20:21Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        List<Volume> volumeList = new ArrayList<>(1);", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNTEzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411225133", "bodyText": "Same comment.", "author": "tombentley", "createdAt": "2020-04-20T09:20:31Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        List<Volume> volumeList = new ArrayList<>(1);\n+        volumeList.add(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift));\n+        volumeList.add(createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift));\n+        volumeList.add(createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+\n+        return volumeList;\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        List<VolumeMount> volumeMountList = new ArrayList<>(1);", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyODA1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411228055", "bodyText": "Using \", *\" (split takes a regex) would protect you a little from people being careless with whitespace when making changes in the future.", "author": "tombentley", "createdAt": "2020-04-20T09:24:51Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PreferredLeaderElectionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Long.toString(TimeUnit.DAYS.toMillis(1)));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"default.goals\", DEFAULT_GOALS);\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"goals\", DEFAULT_GOALS);\n+\n+        FORBIDDEN_OPTIONS = asList(CruiseControlSpec.FORBIDDEN_PREFIXES.split(\", \"));", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyOTkyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411229920", "bodyText": "Collections.singletonMap()", "author": "tombentley", "createdAt": "2020-04-20T09:27:36Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3068,6 +3083,86 @@ private boolean isPodUpToDate(StatefulSet sts, Pod pod) {\n             return stsGeneration == podGeneration;\n         }\n \n+        private final Future<ReconciliationState> getCruiseControlDescription() {\n+            CruiseControl cruiseControl = CruiseControl.fromCrd(kafkaAssembly, versions);\n+            if (cruiseControl != null) {\n+                ConfigMap logAndMetricsConfigMap = cruiseControl.generateMetricsAndLogConfigMap(\n+                        cruiseControl.getLogging() instanceof ExternalLogging ?\n+                                configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) cruiseControl.getLogging()).getName()) :\n+                                null);\n+                Map<String, String> annotations = new HashMap<>();\n+                annotations.put(CruiseControl.ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(ANCILLARY_CM_KEY_LOG_CONFIG));", "originalCommit": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0f5eb115c5dcef25a514a32c69408f00772a994f", "message": "Addressing comments ( Update allowed disk capacity notation + refactoring)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-20T19:32:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODgwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411898807", "bodyText": "we are in the KafkaClusterSpec, why this is about Cruise Control container resources?", "author": "ppatierno", "createdAt": "2020-04-21T06:15:13Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterSpec.java", "diffHunk": "@@ -172,7 +174,7 @@ public void setImage(String image) {\n     }\n \n     @JsonInclude(JsonInclude.Include.NON_NULL)\n-    @Description(\"CPU and memory resources to reserve.\")\n+    @Description(\"CPU and memory resources to reserve for the Cruise Control container.\")", "originalCommit": "0f5eb115c5dcef25a514a32c69408f00772a994f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMDU5Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411900596", "bodyText": "Have you rebased against the latest master? Just asking because lately the Annotations.STRIMZI_DOMAIN was changed from strimzi.io to strimzi.io/. In this case, we are going to have strimzi.io//logging so you should remove the / from logging. I had the same problem with one of my latest PR :-)", "author": "ppatierno", "createdAt": "2020-04-21T06:19:02Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,486 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";", "originalCommit": "0f5eb115c5dcef25a514a32c69408f00772a994f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d52a0be51c0ddfdcbee52a97b2b8de615a0c7b2e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d52a0be51c0ddfdcbee52a97b2b8de615a0c7b2e", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-21T13:12:15Z", "type": "forcePushed"}, {"oid": "e9ac04bbe1ce2aa1fca6c9674d5d8125c0be340d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e9ac04bbe1ce2aa1fca6c9674d5d8125c0be340d", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-21T13:40:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412445993", "bodyText": "Do we really need this? In other places we have 1 replica hardcoded.", "author": "scholzj", "createdAt": "2020-04-21T19:51:03Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,\"\n+        + \"webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,\"\n+        + \"metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,\"\n+        + \"capacity.config.file, self.healing.\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;", "originalCommit": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NjE1MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413096150", "bodyText": "This allows scaling the CC pod to 0 to pause the CC application without removing the CC metric reporters from the Kafka brokers. This will stop CC from processing the raw metrics and sending them to Kafka. However, the CC metric reporters will continue to push raw metrics to Kafka when the CC application is paused.", "author": "kyguy", "createdAt": "2020-04-22T15:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NzIxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413097213", "bodyText": "Does that sound reasonable? If not, we can revert it back to it being hardcoded", "author": "kyguy", "createdAt": "2020-04-22T15:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMDA1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413400052", "bodyText": "Moved the replicas property out for now as it could potential confuse users into thinking that Cruise Control deployments can scale past 1 pod, it is inconsistent with the other component deployment configurations, and it adds another property that users would need to remember to deploy Cruise Control.\nNow users can deploy Cruise Control with cruiseControl: {}\nWe can add it back in later if people find this functionality useful and want it!", "author": "kyguy", "createdAt": "2020-04-22T23:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw=="}], "type": "inlineReview"}, {"oid": "b57762a5d170de91a8530da7d0e67226e950cb5c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b57762a5d170de91a8530da7d0e67226e950cb5c", "message": "Securing communication between Cruise Control and Kafka (#37)\n\n* Adding TLS communication between CC and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Adding TLS communication between metric reporter and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Fixed metrics report to use TLS hostname verification (#38)\n\nMoved metrics topic to Cruise Control configuration\nHiding truststore and keystore passwords in the log\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\n\nCo-authored-by: Paolo Patierno <ppatierno@live.com>\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T16:04:53Z", "type": "forcePushed"}, {"oid": "940f6c8b1ca412cd4d155884939b8763aae79ac9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/940f6c8b1ca412cd4d155884939b8763aae79ac9", "message": "Cruise Control Deployment\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "f4efd009aebf5d658591becab0ea89ec6ae59bc5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f4efd009aebf5d658591becab0ea89ec6ae59bc5", "message": "Added Cruise Control System Tests\n\n    - Added deployment with CC to Kafka ST resources\n    - Added pod name and deployment resources\n    - Added CC deployment system test\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "3fecbc816331655000a74ac893b68ea0c48e7af1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3fecbc816331655000a74ac893b68ea0c48e7af1", "message": "Add broker capacity estimation and configuration\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "d7653b1c5589df4aa8c930830884ef92e1b454c0", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d7653b1c5589df4aa8c930830884ef92e1b454c0", "message": "Add k8s memory parsing to return different byte multiples\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "7717398ad611857fa020bf4edb277fb87b778c80", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7717398ad611857fa020bf4edb277fb87b778c80", "message": "Refactor Capacity constructor\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "488cc11f08cf3d80490ff302c6f9b039586ac7d9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/488cc11f08cf3d80490ff302c6f9b039586ac7d9", "message": "Regenerate helm charts\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "a5cb50f4a8af4a58557c07fdec04607196272a31", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a5cb50f4a8af4a58557c07fdec04607196272a31", "message": "Addressing some comments\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "0f9c7e9ce1983902f3c8140d6093d96dd264a693", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0f9c7e9ce1983902f3c8140d6093d96dd264a693", "message": "Addressing more comments\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "d9cb6dac2bbbed14e1c337190a7b310c5e30b9f0", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d9cb6dac2bbbed14e1c337190a7b310c5e30b9f0", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "89390d11b360ef9d1dd80ad375b10f6d9376f87e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/89390d11b360ef9d1dd80ad375b10f6d9376f87e", "message": "Addressing comments ( capacity properties as strings/validate units in schema)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "3a90c655eb8038501b5af7388521324205e5b3e2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3a90c655eb8038501b5af7388521324205e5b3e2", "message": "Tightening capacity regex; fixing docs\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "42ee71630840d04d3e085f67a6a98914578cd02f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/42ee71630840d04d3e085f67a6a98914578cd02f", "message": "Another doc fix\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "955b9a06cce53f391075e820f7faa207332228cf", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/955b9a06cce53f391075e820f7faa207332228cf", "message": "Add missing goal; bump CC version to 2.0.100\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "3dde8bfdc579a0169b7418420d1dae7d96f18c33", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3dde8bfdc579a0169b7418420d1dae7d96f18c33", "message": "Fix logging and typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "c0150bfb19a5f7137eae218f7434008223605533", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c0150bfb19a5f7137eae218f7434008223605533", "message": "Addressing comments ( Update allowed disk capacity notation + refactoring)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "857ccbd6bf4434919cd885811637fd2b1e131699", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/857ccbd6bf4434919cd885811637fd2b1e131699", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "309aeecac5f45a53b83318eb5d14d7317077dafe", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/309aeecac5f45a53b83318eb5d14d7317077dafe", "message": "Fixing another doc issue\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "5345da76a6bb7e8485bcbc060dc6fc46d5942901", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5345da76a6bb7e8485bcbc060dc6fc46d5942901", "message": "Securing communication between Cruise Control and Kafka (#37)\n\n* Adding TLS communication between CC and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Adding TLS communication between metric reporter and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Fixed metrics report to use TLS hostname verification (#38)\n\nMoved metrics topic to Cruise Control configuration\nHiding truststore and keystore passwords in the log\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\n\nCo-authored-by: Paolo Patierno <ppatierno@live.com>\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "91ac7f21e43549dca16004910147417dbf94cb89", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/91ac7f21e43549dca16004910147417dbf94cb89", "message": "Removing CC replicas, refactor Dockerfile + CC dependencies\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "commit"}, {"oid": "91ac7f21e43549dca16004910147417dbf94cb89", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/91ac7f21e43549dca16004910147417dbf94cb89", "message": "Removing CC replicas, refactor Dockerfile + CC dependencies\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-04-22T23:16:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3NzI3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413677271", "bodyText": "I think you could remove the replicas from here.", "author": "scholzj", "createdAt": "2020-04-23T09:53:05Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",", "originalCommit": "91ac7f21e43549dca16004910147417dbf94cb89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTMzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413679333", "bodyText": "I think we need to add here the securityontext form the container templates.", "author": "scholzj", "createdAt": "2020-04-23T09:56:09Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9091;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(DEFAULT_REPLICAS);\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = Collections.singletonList(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        return Arrays.asList(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift),\n+                createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift),\n+                createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        return Arrays.asList(createVolumeMount(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(logAndMetricsConfigVolumeName, logAndMetricsConfigMountPath));\n+    }\n+\n+    public Deployment generateDeployment(boolean isOpenShift, Map<String, String> annotations, ImagePullPolicy imagePullPolicy, List<LocalObjectReference> imagePullSecrets) {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        DeploymentStrategy updateStrategy = new DeploymentStrategyBuilder()\n+                .withType(\"RollingUpdate\")\n+                .withRollingUpdate(new RollingUpdateDeploymentBuilder()\n+                        .withMaxSurge(new IntOrString(1))\n+                        .withMaxUnavailable(new IntOrString(0))\n+                        .build())\n+                .build();\n+\n+        return createDeployment(\n+                updateStrategy,\n+                Collections.emptyMap(),\n+                Collections.emptyMap(),\n+                getMergedAffinity(),\n+                getInitContainers(imagePullPolicy),\n+                getContainers(imagePullPolicy),\n+                getVolumes(isOpenShift),\n+                imagePullSecrets);\n+    }\n+\n+    @Override\n+    protected List<Container> getContainers(ImagePullPolicy imagePullPolicy) {\n+        List<Container> containers = new ArrayList<>();\n+        Container container = new ContainerBuilder()\n+                .withName(CRUISE_CONTROL_CONTAINER_NAME)\n+                .withImage(getImage())\n+                .withCommand(\"/opt/cruise-control/cruise_control_run.sh\")\n+                .withEnv(getEnvVars())\n+                .withPorts(getContainerPortList())\n+                .withLivenessProbe(ModelUtils.createHttpProbe(livenessPath, REST_API_PORT_NAME, livenessProbeOptions))\n+                .withReadinessProbe(ModelUtils.createHttpProbe(readinessPath, REST_API_PORT_NAME, readinessProbeOptions))\n+                .withResources(getResources())\n+                .withVolumeMounts(getVolumeMounts())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, getImage()))", "originalCommit": "91ac7f21e43549dca16004910147417dbf94cb89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTY1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413679656", "bodyText": "We need to add here the security context from the tlsSidecar container template.", "author": "scholzj", "createdAt": "2020-04-23T09:56:34Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9091;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(DEFAULT_REPLICAS);\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = Collections.singletonList(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        return Arrays.asList(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift),\n+                createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift),\n+                createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        return Arrays.asList(createVolumeMount(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(logAndMetricsConfigVolumeName, logAndMetricsConfigMountPath));\n+    }\n+\n+    public Deployment generateDeployment(boolean isOpenShift, Map<String, String> annotations, ImagePullPolicy imagePullPolicy, List<LocalObjectReference> imagePullSecrets) {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        DeploymentStrategy updateStrategy = new DeploymentStrategyBuilder()\n+                .withType(\"RollingUpdate\")\n+                .withRollingUpdate(new RollingUpdateDeploymentBuilder()\n+                        .withMaxSurge(new IntOrString(1))\n+                        .withMaxUnavailable(new IntOrString(0))\n+                        .build())\n+                .build();\n+\n+        return createDeployment(\n+                updateStrategy,\n+                Collections.emptyMap(),\n+                Collections.emptyMap(),\n+                getMergedAffinity(),\n+                getInitContainers(imagePullPolicy),\n+                getContainers(imagePullPolicy),\n+                getVolumes(isOpenShift),\n+                imagePullSecrets);\n+    }\n+\n+    @Override\n+    protected List<Container> getContainers(ImagePullPolicy imagePullPolicy) {\n+        List<Container> containers = new ArrayList<>();\n+        Container container = new ContainerBuilder()\n+                .withName(CRUISE_CONTROL_CONTAINER_NAME)\n+                .withImage(getImage())\n+                .withCommand(\"/opt/cruise-control/cruise_control_run.sh\")\n+                .withEnv(getEnvVars())\n+                .withPorts(getContainerPortList())\n+                .withLivenessProbe(ModelUtils.createHttpProbe(livenessPath, REST_API_PORT_NAME, livenessProbeOptions))\n+                .withReadinessProbe(ModelUtils.createHttpProbe(readinessPath, REST_API_PORT_NAME, readinessProbeOptions))\n+                .withResources(getResources())\n+                .withVolumeMounts(getVolumeMounts())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, getImage()))\n+                .build();\n+\n+        String tlsSidecarImage = this.tlsSidecarImage;\n+        if (tlsSidecar != null && tlsSidecar.getImage() != null) {\n+            tlsSidecarImage = tlsSidecar.getImage();\n+        }\n+\n+        Container tlsSidecarContainer = new ContainerBuilder()\n+                .withName(TLS_SIDECAR_NAME)\n+                .withImage(tlsSidecarImage)\n+                .withCommand(\"/opt/stunnel/cruise_control_stunnel_run.sh\")\n+                .withLivenessProbe(ModelUtils.tlsSidecarLivenessProbe(tlsSidecar))\n+                .withReadinessProbe(ModelUtils.tlsSidecarReadinessProbe(tlsSidecar))\n+                .withResources(tlsSidecar != null ? tlsSidecar.getResources() : null)\n+                .withEnv(getTlsSidecarEnvVars())\n+                .withVolumeMounts(createVolumeMount(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                        createVolumeMount(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT))\n+                .withLifecycle(new LifecycleBuilder().withNewPreStop().withNewExec()\n+                        .withCommand(\"/opt/stunnel/cruise_control_stunnel_pre_stop.sh\",\n+                                String.valueOf(templateTerminationGracePeriodSeconds))\n+                        .endExec().endPreStop().build())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, tlsSidecarImage))", "originalCommit": "91ac7f21e43549dca16004910147417dbf94cb89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MTc0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413681747", "bodyText": "Do we need to set some network policies on the CruiseControl ports?", "author": "scholzj", "createdAt": "2020-04-23T09:59:45Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {", "originalCommit": "91ac7f21e43549dca16004910147417dbf94cb89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee9b1a28e67a1a879ff96e372992fdaa0bf3d3db", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ee9b1a28e67a1a879ff96e372992fdaa0bf3d3db", "message": "Added security context, network policy and tests (#39)\n\n* Added security context and tests\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\r\n\r\n* Added network policy for the cruise control REST API port\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-04-23T16:20:29Z", "type": "commit"}, {"oid": "2bc4a05f7275595083d01e84df5568a80c900fb2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2bc4a05f7275595083d01e84df5568a80c900fb2", "message": "Added CruiseControl ST to regression tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-04-23T17:06:40Z", "type": "commit"}, {"oid": "38fb0cff82ce54358f1af64dd139872f507b263a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/38fb0cff82ce54358f1af64dd139872f507b263a", "message": "Fixed NPE on Cruise Control network policy\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>", "committedDate": "2020-04-23T19:10:55Z", "type": "commit"}]}