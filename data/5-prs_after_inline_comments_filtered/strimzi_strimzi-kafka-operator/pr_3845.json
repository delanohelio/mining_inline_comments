{"pr_number": 3845, "pr_title": "feat: Namespace RBAC scope deployment option", "pr_createdAt": "2020-10-20T09:01:16Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845", "timeline": [{"oid": "bca43b2fe62dea6d39e2d2f1670e84a0e6af15a2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/bca43b2fe62dea6d39e2d2f1670e84a0e6af15a2", "message": "feat: Better method names\n\nRename generators to be less confusing\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-10-20T11:33:57Z", "type": "forcePushed"}, {"oid": "2ab041ca4f060a4870d92ed3a6a25bb54af9b958", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2ab041ca4f060a4870d92ed3a6a25bb54af9b958", "message": "feat: System test cleanup\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-10-21T15:52:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4NzA4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510187084", "bodyText": "Is it really a boolean or should it be role_mode being cluster or namespace for now, but leaving the door open to some other alternative in future?", "author": "tombentley", "createdAt": "2020-10-22T14:02:05Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -36,10 +36,17 @@\n     public static final String STRIMZI_NAMESPACE = \"STRIMZI_NAMESPACE\";\n     public static final String STRIMZI_FULL_RECONCILIATION_INTERVAL_MS = \"STRIMZI_FULL_RECONCILIATION_INTERVAL_MS\";\n     public static final String STRIMZI_OPERATION_TIMEOUT_MS = \"STRIMZI_OPERATION_TIMEOUT_MS\";\n-    public static final String STRIMZI_CREATE_CLUSTER_ROLES = \"STRIMZI_CREATE_CLUSTER_ROLES\";\n     public static final String STRIMZI_IMAGE_PULL_POLICY = \"STRIMZI_IMAGE_PULL_POLICY\";\n     public static final String STRIMZI_IMAGE_PULL_SECRETS = \"STRIMZI_IMAGE_PULL_SECRETS\";\n \n+    // Feature Flags\n+    public static final String STRIMZI_ROLES_ONLY = \"STRIMZI_ROLES_ONLY\";\n+    public static final boolean DEFAULT_STRIMZI_ROLES_ONLY = false;", "originalCommit": "6fca2241893149bfa589cba849fbe6d10a030592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMzk3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r512013978", "bodyText": "Makes sense, will switch to this.", "author": "samuel-hawker", "createdAt": "2020-10-26T14:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4NzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4ODQ2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510188460", "bodyText": "getOrDefault?", "author": "tombentley", "createdAt": "2020-10-22T14:03:50Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -122,14 +131,15 @@ private static void warningsForRemovedEndVars(Map<String, String> map) {\n      * @return  Cluster Operator configuration instance\n      */\n     public static ClusterOperatorConfig fromMap(Map<String, String> map, KafkaVersion.Lookup lookup) {\n-        Set<String> namespaces = parseNamespaceList(map.get(ClusterOperatorConfig.STRIMZI_NAMESPACE));\n-        long reconciliationInterval = parseReconciliationInerval(map.get(ClusterOperatorConfig.STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));\n-        long operationTimeout = parseOperationTimeout(map.get(ClusterOperatorConfig.STRIMZI_OPERATION_TIMEOUT_MS));\n-        boolean createClusterRoles = parseCreateClusterRoles(map.get(ClusterOperatorConfig.STRIMZI_CREATE_CLUSTER_ROLES));\n-        ImagePullPolicy imagePullPolicy = parseImagePullPolicy(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_POLICY));\n-        List<LocalObjectReference> imagePullSecrets = parseImagePullSecrets(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_SECRETS));\n-        return new ClusterOperatorConfig(namespaces, reconciliationInterval, operationTimeout, createClusterRoles, lookup, imagePullPolicy, imagePullSecrets);\n-\n+        Set<String> namespaces = parseNamespaceList(map.get(STRIMZI_NAMESPACE));\n+        long reconciliationInterval = parseReconciliationInerval(map.get(STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));\n+        long operationTimeout = parseOperationTimeout(map.get(STRIMZI_OPERATION_TIMEOUT_MS));\n+        boolean createClusterRoles = parseCreateClusterRoles(map.get(STRIMZI_CREATE_CLUSTER_ROLES));\n+        ImagePullPolicy imagePullPolicy = parseImagePullPolicy(map.get(STRIMZI_IMAGE_PULL_POLICY));\n+        List<LocalObjectReference> imagePullSecrets = parseImagePullSecrets(map.get(STRIMZI_IMAGE_PULL_SECRETS));\n+        boolean rolesOnly = parseRolesOnly(map.get(STRIMZI_ROLES_ONLY));", "originalCommit": "6fca2241893149bfa589cba849fbe6d10a030592", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4ODYwOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510188609", "bodyText": "could we fix the typo while we're here?", "author": "tombentley", "createdAt": "2020-10-22T14:04:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -122,14 +131,15 @@ private static void warningsForRemovedEndVars(Map<String, String> map) {\n      * @return  Cluster Operator configuration instance\n      */\n     public static ClusterOperatorConfig fromMap(Map<String, String> map, KafkaVersion.Lookup lookup) {\n-        Set<String> namespaces = parseNamespaceList(map.get(ClusterOperatorConfig.STRIMZI_NAMESPACE));\n-        long reconciliationInterval = parseReconciliationInerval(map.get(ClusterOperatorConfig.STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));\n-        long operationTimeout = parseOperationTimeout(map.get(ClusterOperatorConfig.STRIMZI_OPERATION_TIMEOUT_MS));\n-        boolean createClusterRoles = parseCreateClusterRoles(map.get(ClusterOperatorConfig.STRIMZI_CREATE_CLUSTER_ROLES));\n-        ImagePullPolicy imagePullPolicy = parseImagePullPolicy(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_POLICY));\n-        List<LocalObjectReference> imagePullSecrets = parseImagePullSecrets(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_SECRETS));\n-        return new ClusterOperatorConfig(namespaces, reconciliationInterval, operationTimeout, createClusterRoles, lookup, imagePullPolicy, imagePullSecrets);\n-\n+        Set<String> namespaces = parseNamespaceList(map.get(STRIMZI_NAMESPACE));\n+        long reconciliationInterval = parseReconciliationInerval(map.get(STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));", "originalCommit": "6fca2241893149bfa589cba849fbe6d10a030592", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4OTI1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510189257", "bodyText": "getServiceAccountRole()?", "author": "tombentley", "createdAt": "2020-10-22T14:04:57Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -656,6 +659,13 @@ protected String getServiceAccountName() {\n         return null;\n     }\n \n+    /**\n+     * @return the name of the role used by the service account for the deployed cluster for Kubernetes API operations.\n+     */\n+    protected String getRoleName() {", "originalCommit": "6fca2241893149bfa589cba849fbe6d10a030592", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5Mzk4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510193983", "bodyText": "Probably we should validate that the value is either true or false and error if it's anything else.", "author": "tombentley", "createdAt": "2020-10-22T14:10:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -181,6 +191,16 @@ private static boolean parseCreateClusterRoles(String createClusterRolesEnvVar)\n         return createClusterRoles;\n     }\n \n+    private static boolean parseRolesOnly(String rolesOnlyEnvVar) {\n+        boolean rolesOnly = DEFAULT_STRIMZI_ROLES_ONLY;\n+\n+        if (rolesOnlyEnvVar != null) {\n+            rolesOnly = Boolean.parseBoolean(rolesOnlyEnvVar);", "originalCommit": "6fca2241893149bfa589cba849fbe6d10a030592", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzc0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515507748", "bodyText": "Should this print permissionsMode= instead of rolesOnly=? Seems more logical given the parameter name and the values.", "author": "scholzj", "createdAt": "2020-10-31T15:24:53Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -313,6 +369,7 @@ public String toString() {\n                 \",versions=\" + versions +\n                 \",imagePullPolicy=\" + imagePullPolicy +\n                 \",imagePullSecrets=\" + imagePullSecrets +\n+                \",rolesOnly=\" + permissionsMode +", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4NTIyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535085221", "bodyText": "Addressed", "author": "samuel-hawker", "createdAt": "2020-12-03T10:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzkxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515507917", "bodyText": "I wonder if this should have some better name. There might be different and non-mutually exclusive permission modes (I mentioned network policies in the past). So I'm not sure this is clear enough and future proof enough.", "author": "scholzj", "createdAt": "2020-10-31T15:26:47Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -67,26 +71,29 @@\n     private final KafkaVersion.Lookup versions;\n     private final ImagePullPolicy imagePullPolicy;\n     private final List<LocalObjectReference> imagePullSecrets;\n+    private final PermissionsMode permissionsMode;", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4NDg5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535084898", "bodyText": "Renamed to STRIMZI_RBAC_SCOPE and rbacScope which I believe is a more accurate name", "author": "samuel-hawker", "createdAt": "2020-12-03T10:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODE5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508193", "bodyText": "I do not think this makes sense with the getServiceAccountRoleName returning null because it creates invalid resource. Maybe getServiceAccountRoleName should be abstract instead?", "author": "scholzj", "createdAt": "2020-10-31T15:29:43Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -1305,6 +1315,18 @@ public ServiceAccount generateServiceAccount() {\n             .build();\n     }\n \n+    public Role generateRole(List<PolicyRule> rules) {\n+        return new RoleBuilder()\n+                .withNewMetadata()\n+                    .withName(getServiceAccountRoleName())", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NDc4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515884788", "bodyText": "The problem with making it abstract is it means all implementing classes must override it, which is not completely desired heree", "author": "samuel-hawker", "createdAt": "2020-11-02T10:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5NjQ4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515996481", "bodyText": "I see ... But I think it is still weird. Maybe we need some additional layer between the two classes?", "author": "scholzj", "createdAt": "2020-11-02T14:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4OTM3Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535089373", "bodyText": "I don't disagree, but I don't think this is under the scope of this PR necessarily, given the AbstractModel is home to similar builders to this", "author": "samuel-hawker", "createdAt": "2020-12-03T10:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODI4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508288", "bodyText": "I'm not sure I understand the method and its name ... there is no ServiceAccountRole name, so this is confusing because it is not cleare what does it name. Since it is used in the method below, should it be getRoleName?", "author": "scholzj", "createdAt": "2020-10-31T15:30:46Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -656,6 +659,13 @@ protected String getServiceAccountName() {\n         return null;\n     }\n \n+    /**\n+     * @return the name of the role used by the service account for the deployed cluster for Kubernetes API operations.\n+     */\n+    protected String getServiceAccountRoleName() {", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4NTUyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535085521", "bodyText": "I have kept this the same, but renamed to keep the convention that already exists", "author": "samuel-hawker", "createdAt": "2020-12-03T10:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODM5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508392", "bodyText": "This seems to be used only from the method above. So why not return there directly entityOperatorRoleName(cluster)?", "author": "scholzj", "createdAt": "2020-10-31T15:32:02Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +352,48 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String entityOperatorRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    protected static String getRoleName(String cluster) {\n+        return entityOperatorRoleName(cluster);\n+    }", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NTE5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515885190", "bodyText": "This is done so that the overridden getRoleName gets called in abstractmodel", "author": "samuel-hawker", "createdAt": "2020-11-02T10:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5NjAzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515996036", "bodyText": "Not sure I follow. Should this have @OverRide if it overrides a method defined in abstract model?", "author": "scholzj", "createdAt": "2020-11-02T14:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4OTY3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535089678", "bodyText": "Addressed this", "author": "samuel-hawker", "createdAt": "2020-12-03T10:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODQ4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508482", "bodyText": "I don't like this. This hardcodes the RBAC files into the code. So we now have it both in the YAMLs ad in the code and need to update it. I think you need to generate this from the YAMLs or something to make sure this is done only in one place.\nOr assuming the installation will anyway be non-trivial, you should expect the Role objects to already exist from the installation.", "author": "scholzj", "createdAt": "2020-10-31T15:33:30Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +352,48 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String entityOperatorRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    protected static String getRoleName(String cluster) {\n+        return entityOperatorRoleName(cluster);\n+    }\n+\n+    public Role generateRole() {\n+        List<PolicyRule> rules = new ArrayList<>();\n+\n+        rules.add(new PolicyRuleBuilder()\n+                .addToResources(\"secrets\")\n+                .addToVerbs(\"create\", \"delete\", \"get\", \"list\", \"patch\", \"update\")\n+                .addToApiGroups(\"\")\n+                .build());\n+\n+        rules.add(new PolicyRuleBuilder()\n+                .addToResources(\"events\")\n+                .addToVerbs(\"create\")\n+                .addToApiGroups(\"\")\n+                .build());\n+\n+        rules.add(new PolicyRuleBuilder()\n+                .addToResources(\"kafkatopics\", \"kafkatopics/status\", \"kafkausers\", \"kafkausers/status\")\n+                .addToVerbs(\"create\", \"delete\", \"get\", \"list\", \"patch\", \"update\", \"watch\")\n+                .addToApiGroups(Constants.RESOURCE_GROUP_NAME)\n+                .build());", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODY5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508698", "bodyText": "Why do we need a different name here from the cluster role?", "author": "scholzj", "createdAt": "2020-10-31T15:35:36Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -170,13 +170,23 @@ public static String metricAndLogConfigsName(String cluster) {\n \n     /**\n      * Get the name of the TO role binding given the name of the {@code cluster}.\n+     * This binding binds to a ClusterRole, retains old naming convention for backwards compatibility.\n      * @param cluster The cluster name.\n      * @return The name of the role binding.\n      */\n-    public static String roleBindingName(String cluster) {\n+    public static String clusterRoleRoleBindingName(String cluster) {\n         return \"strimzi-\" + cluster + \"-entity-topic-operator\";\n     }\n \n+    /**\n+     * Get the name of the TO role binding given the name of the {@code cluster}.\n+     * @param cluster The cluster name.\n+     * @return The name of the role binding.\n+     */\n+    public static String roleRoleBindingName(String cluster) {\n+        return \"strimzi-\" + cluster + \"-entity-topic-operator-role\";", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NjA3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515886071", "bodyText": "Like all other resources created for an operand, I wanted it to have a unique name\n-> includes the instance name\nThis is just in following with naming conventions\nI saw no value in retaining the cluster unique name that the cluster roles followed", "author": "samuel-hawker", "createdAt": "2020-11-02T10:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5NDU1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515994553", "bodyText": "Well, fair enough. Although I think that naming was a terrible mistake we done in the past :-o.", "author": "scholzj", "createdAt": "2020-11-02T14:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODkyNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508927", "bodyText": "You have a single Role for the whole EntityOperator and single service account per EntityOperator. So why do we need to generate the RoleBinding on what is essentially the container level? Shouldn't this be in EntityOperator.java instead?", "author": "scholzj", "createdAt": "2020-10-31T15:38:35Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -309,6 +319,38 @@ public RoleBinding generateRoleBinding(String namespace, String watchedNamespace\n         return rb;\n     }\n \n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return EntityOperator.getRoleName(cluster);\n+    }\n+\n+    public RoleBinding generateRoleBindingForRole(String namespace, String watchedNamespace) {\n+        Subject ks = new SubjectBuilder()\n+                .withKind(\"ServiceAccount\")\n+                .withName(EntityOperator.entityOperatorServiceAccountName(cluster))\n+                .withNamespace(namespace)\n+                .build();\n+\n+        RoleRef roleRef = new RoleRefBuilder()\n+                .withName(getServiceAccountRoleName())\n+                .withApiGroup(\"rbac.authorization.k8s.io\")\n+                .withKind(\"Role\")\n+                .build();\n+\n+        RoleBinding rb = new RoleBindingBuilder()\n+                .withNewMetadata()\n+                .withName(roleRoleBindingName(cluster))\n+                .withNamespace(watchedNamespace)\n+                .withOwnerReferences(createOwnerReference())\n+                .withLabels(labels.toMap())\n+                .endMetadata()\n+                .withRoleRef(roleRef)\n+                .withSubjects(singletonList(ks))\n+                .build();\n+\n+        return rb;\n+    }", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NjU0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515886542", "bodyText": "Could do, just following the same logic that was set for cluster roles, where the role bindings are handled separately for each operator container", "author": "samuel-hawker", "createdAt": "2020-11-02T10:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5NzMyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515997321", "bodyText": "Actually, maybe that has to do with the difference between the watched namespace and the namespace they are running in? Maybe it needs to be separate in case each watches a separate namespace?", "author": "scholzj", "createdAt": "2020-11-02T14:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA5MDcxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535090713", "bodyText": "This definitely does have to do with the multi-watched namespaces, initially this new feature will only support watchedNamespace of the current namespace", "author": "samuel-hawker", "createdAt": "2020-12-03T10:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTA2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515509068", "bodyText": "Same as above.", "author": "scholzj", "createdAt": "2020-10-31T15:39:56Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityUserOperator.java", "diffHunk": "@@ -328,6 +338,39 @@ public RoleBinding generateRoleBinding(String namespace, String watchedNamespace\n         return rb;\n     }\n \n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return EntityOperator.getRoleName(cluster);\n+    }\n+\n+    public RoleBinding generateRoleBindingForRole(String namespace, String watchedNamespace) {\n+        Subject ks = new SubjectBuilder()\n+                .withKind(\"ServiceAccount\")\n+                .withName(EntityOperator.entityOperatorServiceAccountName(cluster))\n+                .withNamespace(namespace)\n+                .build();\n+\n+        RoleRef roleRef = new RoleRefBuilder()\n+                .withName(getServiceAccountRoleName())\n+                .withApiGroup(\"rbac.authorization.k8s.io\")\n+                .withKind(\"Role\")\n+                .build();\n+\n+\n+        RoleBinding rb = new RoleBindingBuilder()\n+                .withNewMetadata()\n+                .withName(roleRoleBindingName(cluster))\n+                .withNamespace(watchedNamespace)\n+                .withOwnerReferences(createOwnerReference())\n+                .withLabels(labels.toMap())\n+                .endMetadata()\n+                .withRoleRef(roleRef)\n+                .withSubjects(singletonList(ks))\n+                .build();\n+\n+        return rb;\n+    }", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTQzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515509433", "bodyText": "This seems a bit suspicious to me. The Cluster-wide resources are used in Kafka as well. At least for:\n\nNode port access\nRack awareness\n\nI do not see that handled anywhere.", "author": "scholzj", "createdAt": "2020-10-31T15:44:18Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -315,9 +322,12 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                 .compose(state -> state.checkUnsupportedTopicOperator())\n \n                 .compose(state -> state.getEntityOperatorDescription())\n+                .compose(state -> state.entityOperatorRole())\n                 .compose(state -> state.entityOperatorServiceAccount())\n-                .compose(state -> state.entityOperatorTopicOpRoleBinding())\n-                .compose(state -> state.entityOperatorUserOpRoleBinding())\n+                .compose(state -> state.entityOperatorTopicOpRoleRoleBinding())\n+                .compose(state -> state.entityOperatorTopicOpClusterRoleRoleBinding())\n+                .compose(state -> state.entityOperatorUserOpRoleRoleBinding())\n+                .compose(state -> state.entityOperatorUserOpClusterRoleRoleBinding())", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTc0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515509747", "bodyText": "You defined canUseRoles in this class. Should you then use it here?", "author": "scholzj", "createdAt": "2020-10-31T15:47:29Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDEwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510107", "bodyText": "This is confusing. When does the EO need any ClusterRoleBindings? IMHO it is always using only RoleBindings. That also seems to what is done in the previous code.", "author": "scholzj", "createdAt": "2020-10-31T15:51:24Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for is the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return permissionsMode.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n \n-                return withVoid(roleBindingOperations.reconcile(\n-                        watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+        Future<ReconciliationState> entityOperatorTopicOpRoleRoleBinding() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpRoleRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleRoleBindingName(name), null));\n             }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorTopicOpClusterRoleRoleBinding() {\n+            // Don't deploy ClusterRole RoleBinding if it can use roles,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator doesn't need to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpClusterRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.clusterRoleRoleBindingName(name), null));\n+            }", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NzYzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515887637", "bodyText": "It never needs ClusterRoleBindings as far as im aware.\nWould renaming:\nentityOperatorTopicOpClusterRoleRoleBinding\n\n->\nentityOperatorTopicOpRoleBindingForClusterRole\n\nbe better", "author": "samuel-hawker", "createdAt": "2020-11-02T10:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5NzkyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515997921", "bodyText": "Sounds better yeah. Thanks.", "author": "scholzj", "createdAt": "2020-11-02T14:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDIwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510205", "bodyText": "Please wrap this into else { ... } to make the code more readable.", "author": "scholzj", "createdAt": "2020-10-31T15:52:28Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for is the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return permissionsMode.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n \n-                return withVoid(roleBindingOperations.reconcile(\n-                        watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+        Future<ReconciliationState> entityOperatorTopicOpRoleRoleBinding() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpRoleRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleRoleBindingName(name), null));\n             }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorTopicOpClusterRoleRoleBinding() {\n+            // Don't deploy ClusterRole RoleBinding if it can use roles,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator doesn't need to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpClusterRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.clusterRoleRoleBindingName(name), null));\n+            }\n \n-                String watchedNamespace = namespace;\n+            String watchedNamespace = namespace;\n \n-                if (entityOperator.getUserOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n-                }\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            }\n \n-                if (!namespace.equals(watchedNamespace)) {\n-                    watchedNamespaceFuture = roleBindingOperations.reconcile(watchedNamespace, EntityUserOperator.roleBindingName(name), entityOperator.getUserOperator().generateRoleBinding(namespace, watchedNamespace));\n-                } else {\n-                    watchedNamespaceFuture = Future.succeededFuture();\n-                }\n+            return withVoid(roleBindingOperations.reconcile(\n+                    watchedNamespace,\n+                    EntityTopicOperator.clusterRoleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForClusterRole(namespace, watchedNamespace)));", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDM1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510352", "bodyText": "Are you sure this method follows the same handling of the watched namespace and own namespace as the previous? From the code it does not seem to be the case.", "author": "scholzj", "createdAt": "2020-10-31T15:53:59Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for is the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return permissionsMode.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n \n-                return withVoid(roleBindingOperations.reconcile(\n-                        watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+        Future<ReconciliationState> entityOperatorTopicOpRoleRoleBinding() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpRoleRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleRoleBindingName(name), null));\n             }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorTopicOpClusterRoleRoleBinding() {", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDU1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510555", "bodyText": "Again, there are no ClusterRoleBindings here.", "author": "scholzj", "createdAt": "2020-10-31T15:56:02Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/EntityTopicOperatorTest.java", "diffHunk": "@@ -223,10 +223,32 @@ public void testGetContainers() {\n     }\n \n     @Test\n-    public void testRoleBinding()   {\n-        RoleBinding binding = entityTopicOperator.generateRoleBinding(namespace, toWatchedNamespace);\n+    public void testClusterRoleRoleBindingDefault() {\n+        RoleBinding binding = entityTopicOperator.generateRoleBindingForClusterRole(namespace, toWatchedNamespace);\n \n         assertThat(binding.getSubjects().get(0).getNamespace(), is(namespace));\n         assertThat(binding.getMetadata().getNamespace(), is(toWatchedNamespace));\n     }\n+\n+    @Test\n+    public void testClusterRoleRoleBinding() {", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA5MTEyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535091124", "bodyText": "Renamed", "author": "samuel-hawker", "createdAt": "2020-12-03T10:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDU3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510574", "bodyText": "Same as above.", "author": "scholzj", "createdAt": "2020-10-31T15:56:12Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/EntityUserOperatorTest.java", "diffHunk": "@@ -286,10 +286,24 @@ public void testEntityUserOperatorEnvVarValidityAndRenewal() {\n     }\n \n     @Test\n-    public void testRoleBinding()   {\n-        RoleBinding binding = entityUserOperator.generateRoleBinding(namespace, uoWatchedNamespace);\n+    public void testClusterRoleRoleBinding()   {", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA5MTYyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535091625", "bodyText": "Addressed", "author": "samuel-hawker", "createdAt": "2020-12-03T10:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDcxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510719", "bodyText": "As mentioned in the previous comments. This completely ignores the features using ClusterRoleBindings like rack awareness and node port listeners.", "author": "scholzj", "createdAt": "2020-10-31T15:57:48Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorPermissionsModeTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.api.model.rbac.RoleBinding;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRef;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRefBuilder;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.certs.CertManager;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.EntityOperator;\n+import io.strimzi.operator.cluster.model.KafkaVersion;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.PasswordGenerator;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.operator.MockCertManager;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.RoleBindingOperator;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeDiagnosingMatcher;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaAssemblyOperatorPermissionsModeTest {", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA5MTkzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535091936", "bodyText": "Addressed in a followup commit and tested!", "author": "samuel-hawker", "createdAt": "2020-12-03T10:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTA4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515511089", "bodyText": "I guess you will need to also fix the ClusterRoleBindings somewhere? To not install them randomly against missing clusterRoles?", "author": "scholzj", "createdAt": "2020-10-31T16:01:45Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/AbstractST.java", "diffHunk": "@@ -144,6 +155,48 @@ protected void installClusterOperator(String namespace) throws Exception {\n         installClusterOperator(namespace, Constants.CO_OPERATION_TIMEOUT_DEFAULT);\n     }\n \n+    /**\n+     * Perform application of ServiceAccount, Roles and CRDs needed for proper cluster operator deployment.\n+     * Configuration files are loaded from install/cluster-operator directory.\n+     */\n+    public void applyClusterOperatorInstallFiles(String namespace) {\n+        clusterOperatorConfigs.clear();\n+        Map<File, String> operatorFiles = Arrays.stream(new File(CO_INSTALL_DIR).listFiles()).sorted()\n+                .filter(file ->\n+                        !file.getName().matches(\".*(Binding|Deployment)-.*\"))\n+                .collect(Collectors.toMap(\n+                    file -> file,\n+                    f -> TestUtils.getContent(f, TestUtils::toYamlString),\n+                    (x, y) -> x, LinkedHashMap::new));\n+        for (Map.Entry<File, String> entry : operatorFiles.entrySet()) {\n+            LOGGER.info(\"Applying configuration file: {}\", entry.getKey());\n+            if (Environment.isRolesOnly()) {\n+                switchClusterRolesToRoles(entry.getValue());\n+            }\n+            clusterOperatorConfigs.push(entry.getKey().getPath());\n+            cmdKubeClient().clientWithAdmin().namespace(namespace).apply(entry.getKey().getPath());\n+        }\n+    }\n+\n+    /**\n+     * Replace all references to ClusterRole to Role.\n+     * This includes ClusterRoles themselves as well as RoleBindings that reference them.\n+     */\n+    private void switchClusterRolesToRoles(String fileContents) {\n+        fileContents.replace(\"ClusterRole\", \"Role\");\n+    }", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA5NjQ0NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r535096445", "bodyText": "This replaces the string ClusterRole for Role even in bindings", "author": "samuel-hawker", "createdAt": "2020-12-03T10:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTQ3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515511475", "bodyText": "I'm not sure I follow the point of this test. It seems to run only when the tests are triggered with isRolesOnly == true, but it doesn't really test anything else what the other tests would not do. So it seems completely useless to me (of course it is possible i miss the point). I think much bigger value would be if:\n\nThis test runs in regular Acceptance pipeline\nIt deploys the CO with the roles only setup\nTests a simple deployment, topic and user creation and sending of messages\n\nThat would be IMHO added value.", "author": "scholzj", "createdAt": "2020-10-31T16:05:57Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/operators/RolesOnlyOperatorST.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.operators;\n+\n+import io.strimzi.systemtest.AbstractST;\n+import io.strimzi.systemtest.Environment;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.operator.BundleResource;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+@Tag(REGRESSION)\n+class RolesOnlyOperatorST extends AbstractST {\n+\n+    static final String NAMESPACE = \"roles-only-cluster-test\";\n+    static final String CLUSTER_NAME = \"roles-only-cluster\";\n+\n+    private static final Logger LOGGER = LogManager.getLogger(RolesOnlyOperatorST.class);\n+\n+    @Test\n+    void testRolesOnlyDeploysRoles() {\n+        assumeTrue(Environment.isRolesOnly());\n+        prepareEnvironment();\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 3).done();\n+\n+        // Obviously not right.\n+        // Get advice on how to resolve what this test should do.\n+        assertThat(kubeClient().listClusterRoles(), is(Collections.emptyList()));\n+    }\n+\n+    private void prepareEnvironment() {\n+        prepareEnvForOperator(NAMESPACE);\n+        applyBindings(NAMESPACE);\n+        // 060-Deployment\n+        BundleResource.clusterOperator(NAMESPACE).done();\n+    }\n+}", "originalCommit": "6bd8016da67fc76e37171d9d8907411e829468d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk2NzMxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515967319", "bodyText": "I think you're right...\nI was thinking there was value in checking that a rolesOnly deployment had no cluster roles -this would stop new ClusterRoles sneaking into the deployment and 'breaking' the point of tihs mode, maybe youre right that ssimply installing in rolesOnly and then runnign acceptance is enough, but unfortunately this doesnt cover the case where someones adds a new ClusterRole and doesn't think about how that factors into this feature.", "author": "samuel-hawker", "createdAt": "2020-11-02T13:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTQ3NQ=="}], "type": "inlineReview"}, {"oid": "5584b0549304b3f23d39335455e66ebe8b57fa7d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5584b0549304b3f23d39335455e66ebe8b57fa7d", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-03T10:34:09Z", "type": "forcePushed"}, {"oid": "c756be07053209c4c7be35fcea2facf045bd6f23", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c756be07053209c4c7be35fcea2facf045bd6f23", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-03T11:08:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MTE1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539071156", "bodyText": "Should it be something lile canUseClusterRoles? It is the cluster scope you are reall limiting, so that will be or will not be available.", "author": "scholzj", "createdAt": "2020-12-09T07:33:28Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -196,6 +221,37 @@ private static boolean parseCreateClusterRoles(String createClusterRolesEnvVar)\n         return createClusterRoles;\n     }\n \n+    /**\n+     * enum to represent the various permission modes the cluster operator can be set to\n+     *\n+     * CLUSTER is the default and uses ClusterRoles to set permissions\n+     * NAMESPACE allows for the use of Roles where possible instead of ClusterRoles\n+     */\n+    public enum RbacScope {\n+        CLUSTER(),\n+        NAMESPACE();\n+\n+        public boolean canUseRoles() {\n+            return this.equals(RbacScope.NAMESPACE);\n+        }", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NjQwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539076400", "bodyText": "Do we need to have the builder multiple times in several classes? Can't we just parametrize it and have it once in AbstractCluster or in ModelUtils?", "author": "scholzj", "createdAt": "2020-12-09T07:43:44Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityUserOperator.java", "diffHunk": "@@ -329,7 +339,40 @@ public RoleBinding generateRoleBinding(String namespace, String watchedNamespace\n \n         RoleBinding rb = new RoleBindingBuilder()\n                 .withNewMetadata()\n-                    .withName(roleBindingName(cluster))\n+                    .withName(roleBindingForClusterRoleName(cluster))\n+                    .withNamespace(watchedNamespace)\n+                    .withOwnerReferences(createOwnerReference())\n+                    .withLabels(labels.toMap())\n+                .endMetadata()\n+                .withRoleRef(roleRef)\n+                .withSubjects(singletonList(ks))\n+                .build();\n+\n+        return rb;\n+    }\n+\n+    @Override\n+    protected String getRoleName() {\n+        return EntityOperator.getRoleName(cluster);\n+    }\n+\n+    public RoleBinding generateRoleBindingForRole(String namespace, String watchedNamespace) {", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MDA2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539080061", "bodyText": "I do not think this is right. It basically ignores the issue and send the pods looping. If we do not have access and it is needed, we should just error the reconciliation and have the user fix it. Thsi otherwise gives a very bad UX where users do something and it will not work and they will not understand why.\nI also wonder if we should maintain both methods of running this => the one above which silently ignores things and the one where it is intentionally configured. I think we should go for the simplicity and keep just one of them (yours) and if users do not set the Namespaced RBAC_SCOPE and do not give it the right it will just error. It will give us less paths to maintain.\nFinally, the right thing to do is to not make the call when you are in the namespaced RbacScope. This way you trigger the error every 2 minutes while you know it will fail. That also triggers various security monitoring systems etc. So we need to check the scope before making the call.", "author": "scholzj", "createdAt": "2020-12-09T07:50:40Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1716,26 +1726,30 @@ String zkConnectionString(int connectToReplicas, Function<Integer, String> zkNod\n \n         Future<ReconciliationState> kafkaInitClusterRoleBinding() {\n             ClusterRoleBinding desired = kafkaCluster.generateClusterRoleBinding(namespace);\n-            Future<ReconcileResult<ClusterRoleBinding>> fut = clusterRoleBindingOperations.reconcile(\n-                    KafkaResources.initContainerClusterRoleBindingName(name, namespace), desired);\n-\n-            Promise replacementPromise = Promise.promise();\n \n-            fut.onComplete(res -> {\n-                if (res.failed()) {\n-                    if (desired == null && res.cause() != null && res.cause().getMessage() != null &&\n-                            res.cause().getMessage().contains(\"Message: Forbidden!\")) {\n-                        log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka rack awareness is disabled.\");\n-                        replacementPromise.complete();\n-                    } else {\n-                        replacementPromise.fail(res.cause());\n-                    }\n-                } else {\n-                    replacementPromise.complete();\n-                }\n-            });\n+            return withVoid(clusterRoleBindingOperations.reconcile(\n+                        KafkaResources.initContainerClusterRoleBindingName(name, namespace),\n+                        desired)\n+                    .compose(\n+                        rr -> Future.succeededFuture(),\n+                        e -> {\n+                            if (desired == null\n+                                    && e.getMessage() != null\n+                                    && e.getMessage().contains(\"Message: Forbidden!\")) {\n+                                log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka rack awareness is disabled.\");\n+                                return Future.succeededFuture();\n+                            }\n+                            if (rbacScope.canUseRoles()\n+                                    && e.getMessage() != null\n+                                    && e.getMessage().contains(\"Message: Forbidden!\")) {\n+                                log.info(\"Using STRIMZI_RBAC_SCOPE set to namespace requires user to apply ClusterRole and ClusterRoleBinding\");", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MTA2Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539081066", "bodyText": "I think this needs to have different naming. You can always use roles. It is the ClusterRoles which you can or cannot use. Renaming it will make it more clear. With the current name it creates things like !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace()) which I need to think about 5 minutes to actually understand what does it mean.", "author": "scholzj", "createdAt": "2020-12-09T07:52:38Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3049,74 +3063,178 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_RBAC_SCOPE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (canUseRoles(namespace) && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4Mzg3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539083870", "bodyText": "Not sure I understand the namespace check. I did not saw any validation in the ClusterOperatorConfig which would for example forbid watching multiple namespaces there. So I'm not sure why exactly do we impose this limitation here.", "author": "scholzj", "createdAt": "2020-12-09T07:57:54Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3049,74 +3063,178 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_RBAC_SCOPE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (canUseRoles(namespace) && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return rbacScope.canUseRoles() && this.namespace.equals(watchedNamespace);", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NDE4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539084184", "bodyText": "Is this still something TODO? Or should it be removed?", "author": "scholzj", "createdAt": "2020-12-09T07:58:23Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3049,74 +3063,178 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_RBAC_SCOPE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (canUseRoles(namespace) && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return rbacScope.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n+\n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForRole not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingForRoleName(name), null));\n+            }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n+        }\n \n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForClusterRole() {\n+            // Don't deploy ClusterRole RoleBinding if it can use roles,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator doesn't need to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForClusterRole not required\");\n                 return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityTopicOperator.roleBindingForClusterRoleName(name),\n+                        null));\n+            }\n+\n+            final String watchedNamespace;\n+\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                watchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+\n+            if (!namespace.equals(watchedNamespace)) {\n+                watchedNamespaceFuture = roleBindingOperations.reconcile(\n                         watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+                        EntityTopicOperator.roleBindingForClusterRoleName(name),\n+                        entityOperator.getTopicOperator().generateRoleBindingForClusterRole(namespace, watchedNamespace));\n+            } else {\n+                watchedNamespaceFuture = Future.succeededFuture();\n             }\n+\n+            // Create role binding for the the UI runs in (it needs to access the CA etc.)\n+            Future<ReconcileResult<RoleBinding>> ownNamespaceFuture = roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForClusterRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForClusterRole(namespace, namespace));\n+\n+            return withVoid(CompositeFuture.join(ownNamespaceFuture, watchedNamespaceFuture));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorUserOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the user operator is not deployed,\n+            // or if the user operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getUserOperator() == null\n+                    || !canUseRoles(entityOperator.getUserOperator().getWatchedNamespace())) {\n+                log.debug(\"entityOperatorUserOpRoleBindingForRole not required\");\n+                return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityUserOperator.roleBindingForRoleName(name),\n+                        null));\n+            }\n \n-                String watchedNamespace = namespace;\n+            // TODO Comment true?", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NTMxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539085316", "bodyText": "I wonder if this should again be updated and bound to the RbacScope instead of silently ignoring things. That will make it work everywhere the same way.\nAlso as I said in the KafkaAssemblyOperator => this should be gated by the RbacScope to not be called in the first place.", "author": "scholzj", "createdAt": "2020-12-09T08:00:28Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -194,25 +194,20 @@ protected KafkaConnectStatus createStatus() {\n      */\n     Future<ReconcileResult<ClusterRoleBinding>> connectInitClusterRoleBinding(String namespace, String name, KafkaConnectCluster connectCluster) {\n         ClusterRoleBinding desired = connectCluster.generateClusterRoleBinding();\n-        Future<ReconcileResult<ClusterRoleBinding>> fut = clusterRoleBindingOperations.reconcile(\n-                KafkaConnectResources.initContainerClusterRoleBindingName(name, namespace), desired);\n-\n-        Promise<ReconcileResult<ClusterRoleBinding>> replacementPromise = Promise.promise();\n-\n-        fut.onComplete(res -> {\n-            if (res.failed()) {\n-                if (desired == null && res.cause() != null && res.cause().getMessage() != null &&\n-                        res.cause().getMessage().contains(\"Message: Forbidden!\")) {\n-                    log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka Connect rack awareness is disabled.\");\n-                    replacementPromise.complete();\n-                } else {\n-                    replacementPromise.fail(res.cause());\n-                }\n-            } else {\n-                replacementPromise.complete(res.result());\n-            }\n-        });\n-\n-        return replacementPromise.future();\n+        return clusterRoleBindingOperations.reconcile(\n+                    KafkaConnectResources.initContainerClusterRoleBindingName(name, namespace),\n+                    desired)\n+                .compose(\n+                    rr -> Future.succeededFuture(),\n+                    e -> {\n+                        if (desired == null\n+                                && e.getMessage() != null\n+                                && e.getMessage().contains(\"Message: Forbidden!\")) {\n+                            log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka Connect rack awareness is disabled.\");\n+                            return Future.succeededFuture();\n+                        }", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4Njc5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539086799", "bodyText": "Can we also add checks here that the ClusterRoleBinding etc. APIs are never called? That would help to test not just that it does the right steps but that it skips the wrong steps.", "author": "scholzj", "createdAt": "2020-12-09T08:03:07Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorRbacScopeTest.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.api.model.rbac.ClusterRoleBinding;\n+import io.fabric8.kubernetes.api.model.rbac.RoleBinding;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRef;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRefBuilder;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.listener.arraylistener.KafkaListenerType;\n+import io.strimzi.certs.CertManager;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.EntityOperator;\n+import io.strimzi.operator.cluster.model.KafkaVersion;\n+import io.strimzi.operator.cluster.operator.resource.KafkaSetOperator;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.PasswordGenerator;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.operator.MockCertManager;\n+import io.strimzi.operator.common.operator.resource.ClusterRoleBindingOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.RoleBindingOperator;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeDiagnosingMatcher;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaAssemblyOperatorRbacScopeTest {\n+    private final KubernetesVersion kubernetesVersion = KubernetesVersion.V1_11;\n+    private final MockCertManager certManager = new MockCertManager();\n+    private final PasswordGenerator passwordGenerator = new PasswordGenerator(10, \"a\", \"a\");\n+    private final ClusterOperatorConfig config = ResourceUtils.dummyClusterOperatorConfig(VERSIONS);\n+    private final ClusterOperatorConfig configNamespaceRbacScope = ResourceUtils.dummyClusterOperatorConfigRolesOnly(\n+            VERSIONS,\n+            ClusterOperatorConfig.DEFAULT_OPERATION_TIMEOUT_MS);\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String namespace = \"test-ns\";\n+    private final String clusterName = \"test-instance\";\n+    protected static Vertx vertx;\n+\n+    @BeforeAll\n+    public static void before() {\n+        vertx = Vertx.vertx();\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        vertx.close();\n+    }\n+\n+    /**\n+     * Override KafkaAssemblyOperator to only run reconciliation steps that concern the STRIMZI_RBAC_SCOPE feature\n+     */\n+    class KafkaAssemblyOperatorRolesSubset extends KafkaAssemblyOperator {\n+        public KafkaAssemblyOperatorRolesSubset(\n+                Vertx vertx,\n+                PlatformFeaturesAvailability pfa,\n+                CertManager certManager,\n+                PasswordGenerator passwordGenerator,\n+                ResourceOperatorSupplier supplier,\n+                ClusterOperatorConfig config\n+        ) {\n+            super(vertx, pfa, certManager, passwordGenerator, supplier, config);\n+        }\n+\n+        @Override\n+        Future<Void> reconcile(ReconciliationState reconcileState)  {\n+            return reconcileState.getEntityOperatorDescription()\n+                    .compose(state -> state.entityOperatorRole())\n+                    .compose(state -> state.entityOperatorServiceAccount())\n+                    .compose(state -> state.entityOperatorTopicOpRoleBindingForRole())\n+                    .compose(state -> state.entityOperatorTopicOpRoleBindingForClusterRole())\n+                    .compose(state -> state.entityOperatorUserOpRoleBindingForRole())\n+                    .compose(state -> state.entityOperatorUserOpRoleBindingForClusterRole())\n+                    .map((Void) null);\n+        }\n+\n+    }\n+\n+    /**\n+     * This test checks that when STRIMZI_RBAC_SCOPE feature is set to 'NAMESPACE', the cluster operator only\n+     * deploys and binds to Roles\n+     */\n+    @Test\n+    public void testRolesDeployedWhenNamespaceRbacScope(VertxTestContext context) {\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(clusterName)\n+                    .withNamespace(namespace)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                    .endZookeeper()\n+                    .withNewEntityOperator()\n+                        .withNewUserOperator()\n+                        .endUserOperator()\n+                        .withNewTopicOperator()\n+                        .endTopicOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+\n+        // Mock the CRD Operator for Kafka resources\n+        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n+        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafka));\n+        when(mockKafkaOps.get(eq(namespace), eq(clusterName))).thenReturn(kafka);\n+        when(mockKafkaOps.updateStatusAsync(any(Kafka.class))).thenReturn(Future.succeededFuture());\n+\n+        // Mock the operations for RoleBindings\n+        RoleBindingOperator mockRoleBindingOps = supplier.roleBindingOperations;\n+        // Capture the names of reconciled rolebindings and their patched state\n+        ArgumentCaptor<String> roleBindingNameCaptor = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<RoleBinding> roleBindingCaptor = ArgumentCaptor.forClass(RoleBinding.class);\n+        when(mockRoleBindingOps.reconcile(eq(namespace), roleBindingNameCaptor.capture(), roleBindingCaptor.capture()))\n+                .thenReturn(Future.succeededFuture());\n+\n+        KafkaAssemblyOperatorRolesSubset kao = new KafkaAssemblyOperatorRolesSubset(\n+                vertx,\n+                new PlatformFeaturesAvailability(false, kubernetesVersion),\n+                certManager,\n+                passwordGenerator,\n+                supplier,\n+                configNamespaceRbacScope);\n+\n+        Checkpoint async = context.checkpoint();\n+        kao.reconcile(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName))\n+                .onComplete(context.succeeding(v -> context.verify(() -> {\n+                    List<String> roleBindingNames = roleBindingNameCaptor.getAllValues();\n+                    List<RoleBinding> roleBindings = roleBindingCaptor.getAllValues();\n+\n+                    assertThat(roleBindingNames, hasSize(4));\n+                    assertThat(roleBindings, hasSize(4));\n+\n+                    // Check all RoleBindings, easier to index by order applied\n+                    assertThat(roleBindingNames.get(0), is(\"test-instance-entity-topic-operator-role\"));\n+                    assertThat(roleBindings.get(0), hasRoleRef(new RoleRefBuilder()\n+                            .withApiGroup(\"rbac.authorization.k8s.io\")\n+                            .withKind(\"Role\")\n+                            .withName(\"test-instance-entity-operator\")\n+                            .build()));\n+\n+                    assertThat(roleBindingNames.get(1), is(\"strimzi-test-instance-entity-topic-operator\"));\n+                    assertThat(roleBindings.get(1), is(nullValue()));\n+\n+                    assertThat(roleBindingNames.get(2), is(\"test-instance-entity-user-operator-role\"));\n+                    assertThat(roleBindings.get(2), hasRoleRef(new RoleRefBuilder()\n+                            .withApiGroup(\"rbac.authorization.k8s.io\")\n+                            .withKind(\"Role\")\n+                            .withName(\"test-instance-entity-operator\")\n+                            .build()));\n+\n+                    assertThat(roleBindingNames.get(3), is(\"strimzi-test-instance-entity-user-operator\"));\n+                    assertThat(roleBindings.get(3), is(nullValue()));\n+\n+                    async.flag();\n+                })));", "originalCommit": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a52844df4d8e14f073a7cefdf2148809d5b4f7ff", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a52844df4d8e14f073a7cefdf2148809d5b4f7ff", "message": "feat: Review comments + STs\n\nFix Acceptance test pipeline\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-11T13:30:17Z", "type": "forcePushed"}, {"oid": "65051ffb458e484636f6e8100e8145e94c9e2656", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/65051ffb458e484636f6e8100e8145e94c9e2656", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-14T10:09:11Z", "type": "forcePushed"}, {"oid": "a896f7d79faaffe1a288f1450abdbecb809afd6f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a896f7d79faaffe1a288f1450abdbecb809afd6f", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-14T10:27:20Z", "type": "forcePushed"}, {"oid": "485e550d9757867d3474b3696e53ec3deb2ad8d4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/485e550d9757867d3474b3696e53ec3deb2ad8d4", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-15T09:28:50Z", "type": "forcePushed"}, {"oid": "c6d0673e1c7937b5d7ffa9d7ab68431b0bed8035", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c6d0673e1c7937b5d7ffa9d7ab68431b0bed8035", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-15T14:11:47Z", "type": "forcePushed"}, {"oid": "25f9cc44d57f572064a97f16e9c1b982df6bbc50", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25f9cc44d57f572064a97f16e9c1b982df6bbc50", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-16T12:12:56Z", "type": "forcePushed"}, {"oid": "fce39f7b09cbd4a01026290b5c1d0209452c39ac", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fce39f7b09cbd4a01026290b5c1d0209452c39ac", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-16T12:39:24Z", "type": "forcePushed"}, {"oid": "de18000e7b614e6dc80674dade99a9d813f62996", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/de18000e7b614e6dc80674dade99a9d813f62996", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-16T12:50:49Z", "type": "forcePushed"}, {"oid": "d53197ab6812ee1791e4797b7a8b7f70554113bd", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d53197ab6812ee1791e4797b7a8b7f70554113bd", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-16T13:13:36Z", "type": "forcePushed"}, {"oid": "b26d77ed35a42765df676965c2a7da8eff0496b0", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b26d77ed35a42765df676965c2a7da8eff0496b0", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-16T16:40:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxMjAwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545012003", "bodyText": "Maybe create a constant for it?", "author": "Frawless", "createdAt": "2020-12-17T11:19:38Z", "path": "systemtest/src/main/java/io/strimzi/systemtest/Environment.java", "diffHunk": "@@ -173,6 +179,10 @@ public static boolean isHelmInstall() {\n         return CLUSTER_OPERATOR_INSTALL_TYPE.equals(ClusterOperatorInstallType.HELM);\n     }\n \n+    public static boolean isNamespaceRbacScope() {\n+        return \"NAMESPACE\".equals(STRIMZI_RBAC_SCOPE);", "originalCommit": "1b16ad8a283561b83f636e751a8944540c8f1621", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNjgzOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545016839", "bodyText": "I wonder why we have nodePort listener here when we don't use it at all...guess we should double-check it and remove/use it in some next PR.", "author": "Frawless", "createdAt": "2020-12-17T11:27:42Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthPlainST.java", "diffHunk": "@@ -222,6 +224,7 @@ void testProducerConsumerMirrorMaker() {\n     @Test\n     @Tag(MIRROR_MAKER2)\n     @Tag(CONNECT_COMPONENTS)\n+    @Tag(NODEPORT_SUPPORTED)", "originalCommit": "1b16ad8a283561b83f636e751a8944540c8f1621", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyMTMxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545021313", "bodyText": "There're quite a few instances of tests like this!", "author": "samuel-hawker", "createdAt": "2020-12-17T11:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNjgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ2NjQwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545466405", "bodyText": "ye....I will open an issue for it :)", "author": "Frawless", "createdAt": "2020-12-17T23:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNjgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTA3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459070", "bodyText": "Can we add some JavaDoc please?", "author": "scholzj", "createdAt": "2020-12-21T00:29:09Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -1368,6 +1380,31 @@ public ServiceAccount generateServiceAccount() {\n             .build();\n     }\n \n+    public Role generateRole(String namespace, List<PolicyRule> rules) {", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTA3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459079", "bodyText": "Can we add some JavaDoc please?", "author": "scholzj", "createdAt": "2020-12-21T00:29:14Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -1368,6 +1380,31 @@ public ServiceAccount generateServiceAccount() {\n             .build();\n     }\n \n+    public Role generateRole(String namespace, List<PolicyRule> rules) {\n+        return new RoleBuilder()\n+                .withNewMetadata()\n+                    .withName(getRoleName())\n+                    .withNamespace(namespace)\n+                    .withOwnerReferences(createOwnerReference())\n+                    .addToLabels(labels.toMap())\n+                .endMetadata()\n+                .withRules(rules)\n+                .build();\n+    }\n+\n+    public RoleBinding generateRoleBinding(String name, String namespace, RoleRef roleRef, List<Subject> subjects) {", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTQ0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459441", "bodyText": "I still think this is a bit weird. Should we instead throw some UnsupportedException or something? I think that will help to make sure this is not used by mistake somewhere. But maybe I'm just overthinking it.", "author": "scholzj", "createdAt": "2020-12-21T00:32:13Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -719,6 +724,13 @@ protected String getServiceAccountName() {\n         return null;\n     }\n \n+    /**\n+     * @return the name of the role used by the service account for the deployed cluster for Kubernetes API operations.\n+     */\n+    protected String getRoleName() {\n+        return null;", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNjc0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546636742", "bodyText": "I think that makes sense as a solution, I will change to this.", "author": "samuel-hawker", "createdAt": "2020-12-21T10:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTczNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459734", "bodyText": "I'm sorry, but I still don't follow this. Why do we need two static methods? Why not just use this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String entityOperatorRoleName(String cluster) {\n          \n          \n            \n                    return entityOperatorName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                protected String getRoleName() {\n          \n          \n            \n                    return getRoleName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                protected static String getRoleName(String cluster) {\n          \n          \n            \n                    return entityOperatorRoleName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n                public static String entityOperatorRoleName(String cluster) {\n          \n          \n            \n                    return entityOperatorName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                protected String getRoleName() {\n          \n          \n            \n                    return entityOperatorRoleName(cluster);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nI.e. deleting the protected static String getRoleName(String cluster) which doesn't seem to do anything useful.", "author": "scholzj", "createdAt": "2020-12-21T00:34:35Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +358,53 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String entityOperatorRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    @Override\n+    protected String getRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    protected static String getRoleName(String cluster) {\n+        return entityOperatorRoleName(cluster);\n+    }", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MTA2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546461062", "bodyText": "I think I said it before ... but I do not agree with this solution. This cannot pass with just a debug message. If the init role is needed, this IMHO needs to fail to make it obvious to the user that this does not work. I understand the intention that the user might create the cluster role binding manually. But I think the risk of not understanding that and thinking they have a feature enabled which isn't is too big and too dangerous. Also, if the user has the rights to create the cluster role binding manually, he can also give it to the operator in the first place and doesn't have to use namespaced scope. So I think we should change this.\nThis is also important because for example with node ports, this is your chance to give it a nice and understandable error and gate the feature here. If you let it pass, the user will in many cases not create the cluster role binding and get much weirder errors later.", "author": "scholzj", "createdAt": "2020-12-21T00:44:05Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1813,9 +1821,19 @@ String zkConnectionString(int connectToReplicas, Function<Integer, String> zkNod\n         }\n \n         Future<ReconciliationState> kafkaInitClusterRoleBinding() {\n+            if (!rbacScope.canUseClusterRoles()) {\n+                log.debug(\"Using STRIMZI_RBAC_SCOPE set to namespace requires user to apply ClusterRole and ClusterRoleBinding manually\");\n+                return withVoid(Future.succeededFuture());\n+            }\n+", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjA0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462041", "bodyText": "I'm not sure I understand this comment. Is this still a TODO for this PR? It looks to me like the code bellow created the roles in watchedNamespaces ... so maybe this is invalid now?", "author": "scholzj", "createdAt": "2020-12-21T00:50:48Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjI0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462244", "bodyText": "What happens when userWatchedNamespace and topicWatchedNamespace are the same? Do we need to handle that to not overwrite the roles?", "author": "scholzj", "createdAt": "2020-12-21T00:52:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature\n+            final Future<ReconcileResult<Role>> ownNamespaceFuture = roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role);\n+\n+            final String userWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getUserOperator() != null\n+                    && entityOperator.getUserOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n+                userWatchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n+            } else {\n+                userWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> userWatchedNamespaceFuture;\n+            if (!namespace.equals(userWatchedNamespace)) {\n+                userWatchedNamespaceFuture = roleOperations.reconcile(\n+                        userWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(userWatchedNamespace));\n+            } else {\n+                userWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            final String topicWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getTopicOperator() != null\n+                    && entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                topicWatchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                topicWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> topicWatchedNamespaceFuture;\n+            if (!namespace.equals(topicWatchedNamespace)) {\n+                topicWatchedNamespaceFuture = roleOperations.reconcile(\n+                        topicWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(topicWatchedNamespace));\n+            } else {\n+                topicWatchedNamespaceFuture = Future.succeededFuture();\n+            }", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzODkwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546638904", "bodyText": "I think it re-applying the same role in the namespace is non-dangerous, it would just be a no-op?", "author": "samuel-hawker", "createdAt": "2020-12-21T10:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjM1NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462354", "bodyText": "I wonder if we should split this into 3 smaller methods ... the code seems to be fairly independent for the 3 different sections.", "author": "scholzj", "createdAt": "2020-12-21T00:53:00Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjU4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462587", "bodyText": "Does the first line of the comment still apply?", "author": "scholzj", "createdAt": "2020-12-21T00:54:37Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature\n+            final Future<ReconcileResult<Role>> ownNamespaceFuture = roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role);\n+\n+            final String userWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getUserOperator() != null\n+                    && entityOperator.getUserOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n+                userWatchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n+            } else {\n+                userWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> userWatchedNamespaceFuture;\n+            if (!namespace.equals(userWatchedNamespace)) {\n+                userWatchedNamespaceFuture = roleOperations.reconcile(\n+                        userWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(userWatchedNamespace));\n+            } else {\n+                userWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            final String topicWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getTopicOperator() != null\n+                    && entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                topicWatchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                topicWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> topicWatchedNamespaceFuture;\n+            if (!namespace.equals(topicWatchedNamespace)) {\n+                topicWatchedNamespaceFuture = roleOperations.reconcile(\n+                        topicWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(topicWatchedNamespace));\n+            } else {\n+                topicWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            return withVoid(CompositeFuture.join(\n+                    ownNamespaceFuture,\n+                    userWatchedNamespaceFuture,\n+                    topicWatchedNamespaceFuture));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n-\n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForRole not required\");\n                 return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        null));\n+            }\n+\n+\n+            final String watchedNamespace;\n+\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                watchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+\n+            if (!namespace.equals(watchedNamespace)) {\n+                watchedNamespaceFuture = roleBindingOperations.reconcile(\n                         watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, watchedNamespace));\n+            } else {\n+                watchedNamespaceFuture = Future.succeededFuture();\n             }\n-        }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+            // Create role binding for the the UI runs in (it needs to access the CA etc.)\n+            Future<ReconcileResult<RoleBinding>> ownNamespaceFuture = roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace));\n+\n+            return withVoid(CompositeFuture.join(ownNamespaceFuture, watchedNamespaceFuture));\n+        }\n \n-                String watchedNamespace = namespace;\n+        Future<ReconciliationState> entityOperatorUserOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjcwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462702", "bodyText": "Also here I wonder if we should split this into 3 separate methods. Just a thought.", "author": "scholzj", "createdAt": "2020-12-21T00:55:18Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature\n+            final Future<ReconcileResult<Role>> ownNamespaceFuture = roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role);\n+\n+            final String userWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getUserOperator() != null\n+                    && entityOperator.getUserOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n+                userWatchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n+            } else {\n+                userWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> userWatchedNamespaceFuture;\n+            if (!namespace.equals(userWatchedNamespace)) {\n+                userWatchedNamespaceFuture = roleOperations.reconcile(\n+                        userWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(userWatchedNamespace));\n+            } else {\n+                userWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            final String topicWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getTopicOperator() != null\n+                    && entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                topicWatchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                topicWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> topicWatchedNamespaceFuture;\n+            if (!namespace.equals(topicWatchedNamespace)) {\n+                topicWatchedNamespaceFuture = roleOperations.reconcile(\n+                        topicWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(topicWatchedNamespace));\n+            } else {\n+                topicWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            return withVoid(CompositeFuture.join(\n+                    ownNamespaceFuture,\n+                    userWatchedNamespaceFuture,\n+                    topicWatchedNamespaceFuture));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n-\n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForRole not required\");\n                 return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        null));\n+            }\n+\n+\n+            final String watchedNamespace;\n+\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                watchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+\n+            if (!namespace.equals(watchedNamespace)) {\n+                watchedNamespaceFuture = roleBindingOperations.reconcile(\n                         watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, watchedNamespace));\n+            } else {\n+                watchedNamespaceFuture = Future.succeededFuture();\n             }\n-        }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+            // Create role binding for the the UI runs in (it needs to access the CA etc.)\n+            Future<ReconcileResult<RoleBinding>> ownNamespaceFuture = roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace));\n+\n+            return withVoid(CompositeFuture.join(ownNamespaceFuture, watchedNamespaceFuture));\n+        }\n \n-                String watchedNamespace = namespace;\n+        Future<ReconciliationState> entityOperatorUserOpRoleBindingForRole() {", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjgyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462821", "bodyText": "Same comment as I had for this method in KafkaAssemblyOperator.", "author": "scholzj", "createdAt": "2020-12-21T00:55:58Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -193,9 +195,19 @@ protected KafkaConnectStatus createStatus() {\n      * @return                  Future for tracking the asynchronous result of the ClusterRoleBinding reconciliation\n      */\n     Future<ReconcileResult<ClusterRoleBinding>> connectInitClusterRoleBinding(String namespace, String name, KafkaConnectCluster connectCluster) {\n+        if (!rbacScope.canUseClusterRoles()) {\n+            log.debug(\"Using STRIMZI_RBAC_SCOPE set to namespace requires user to apply ClusterRole and ClusterRoleBinding manually\");\n+            return Future.succeededFuture();\n+        }", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDI0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546464243", "bodyText": "How much temporary is this? Is it still needed?", "author": "scholzj", "createdAt": "2020-12-21T01:05:30Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/kafka/KafkaST.java", "diffHunk": "@@ -721,6 +723,9 @@ void testRemoveUserOperatorFromEntityOperator() {\n \n     @Test\n     void testRemoveUserAndTopicOperatorsFromEntityOperator() {\n+        // TODO temporary fix", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY0MTE3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546641179", "bodyText": "I was going to fix this in a followup, this PR is getting so stupidly big now is all.\nTo fix some of these tests require large re-architecting/refactoring to the system tests", "author": "samuel-hawker", "createdAt": "2020-12-21T10:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY0NTQzMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546645431", "bodyText": "I think that is fine with me ... although I'm not sure what your plan is ... I think the assume works fine there. In any case maybe you can change these comments to make them more self-explanatory. Right now it is not clear if it is something forgotten or something planned for further PRs etc.", "author": "scholzj", "createdAt": "2020-12-21T11:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDU4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546464583", "bodyText": "I do not think this makes sense. You are basically turning this into testMultipleInternal when running it without the node-ports. Should this just use Assume and skip the test in the namespaced mode?", "author": "scholzj", "createdAt": "2020-12-21T01:07:33Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/kafka/listeners/MultipleListenersST.java", "diffHunk": "@@ -71,10 +72,12 @@ void testCombinationOfInternalAndExternalListeners() {\n         List<GenericKafkaListener> multipleDifferentListeners = new ArrayList<>();\n \n         List<GenericKafkaListener> internalListeners = testCases.get(KafkaListenerType.INTERNAL);\n-        List<GenericKafkaListener> nodeportListeners = testCases.get(KafkaListenerType.NODEPORT);\n-\n         multipleDifferentListeners.addAll(internalListeners);\n-        multipleDifferentListeners.addAll(nodeportListeners);\n+\n+        if (!Environment.isNamespaceRbacScope()) {\n+            List<GenericKafkaListener> nodeportListeners = testCases.get(KafkaListenerType.NODEPORT);\n+            multipleDifferentListeners.addAll(nodeportListeners);\n+        }", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NTE4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546465180", "bodyText": "I wonder how well the status of the node port listener is really tested if this is all you need to get it passing. Because I guess it means there are no asserts for the status part related to the NodePort. So do we really need this? Should we just delete this and remove the @Tag(NODEPORT_SUPPORTED) annotation where applicable?\nWDYT @Frawless?", "author": "scholzj", "createdAt": "2020-12-21T01:11:27Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/operators/CustomResourceStatusST.java", "diffHunk": "@@ -449,16 +451,25 @@ void deployTestSpecificResources() throws Exception {\n                             .withType(KafkaListenerType.INTERNAL)\n                             .withTls(true)\n                         .endGenericKafkaListener()\n-                        .addNewGenericKafkaListener()\n-                            .withName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-                            .withPort(9094)\n-                            .withType(KafkaListenerType.NODEPORT)\n-                            .withTls(false)\n-                        .endGenericKafkaListener()\n                     .endListeners()\n                 .endKafka()\n-            .endSpec()\n-            .done();\n+            .endSpec();\n+\n+        if (!Environment.isNamespaceRbacScope()) {\n+            kafka.editSpec()\n+                    .editKafka()\n+                        .editListeners()\n+                            .addNewGenericKafkaListener()\n+                                .withName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n+                                .withPort(9094)\n+                                .withType(KafkaListenerType.NODEPORT)\n+                                .withTls(false)\n+                            .endGenericKafkaListener()\n+                        .endListeners()\n+                    .endKafka()\n+                .endSpec();\n+        }", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQxNTgwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r551415802", "bodyText": "Or we can enhance the test for some additional checks, but I think to remove nodePort part is better since we take data from Kafka status in different tests.", "author": "Frawless", "createdAt": "2021-01-04T16:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NTUxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546465518", "bodyText": "Again, lot of these temporary fixes ... it is not clear how temporary they are and if they should still be here.", "author": "scholzj", "createdAt": "2020-12-21T01:13:42Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "diffHunk": "@@ -111,6 +113,9 @@\n \n     @Test\n     void testProducerService() {\n+        // TODO temporary fix", "originalCommit": "1197db8f8d587cb73d38667f1f9409693d2ca591", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "df47107973e40fa27b1e58676f4f3fba47ef3aa3", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/df47107973e40fa27b1e58676f4f3fba47ef3aa3", "message": "feat: Roles RBAC Scope\n\nRole operator tests\nRole permissions\nClusterOperatorConfig changes\nAdd Assembly tests\nSystem tests\nAdd new envar docs\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:50Z", "type": "commit"}, {"oid": "8fea0d48da19a36bd5bc8748e2d220113ec76204", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8fea0d48da19a36bd5bc8748e2d220113ec76204", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:50Z", "type": "commit"}, {"oid": "aa90b9924ac185f698b616e538b402fd57d51a0f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/aa90b9924ac185f698b616e538b402fd57d51a0f", "message": "feat: Commit generated files\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:50Z", "type": "commit"}, {"oid": "bea6a1ba796ebf6b6aee6be15cf62942fb7c995e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/bea6a1ba796ebf6b6aee6be15cf62942fb7c995e", "message": "feat: Review comments + STs\n\nFix Acceptance test pipeline\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:50Z", "type": "commit"}, {"oid": "0e83d50f6bf401636f933d492fa912d1b63bba2f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0e83d50f6bf401636f933d492fa912d1b63bba2f", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "9f9f160d38955c63b6189ca3e090433a727828a2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9f9f160d38955c63b6189ca3e090433a727828a2", "message": "feat: Use roles not clusterroles for EO\n\nTo reduce maintained code paths always use roles\n+ rolebindings for the EO\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "dbe856aecbe2562a6b4f2785a9d1bf82a4ea3056", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dbe856aecbe2562a6b4f2785a9d1bf82a4ea3056", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "db4d676df795a547e7979e43aa7b44f53afb8f7b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/db4d676df795a547e7979e43aa7b44f53afb8f7b", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "3320a44f88e80c99336ed6bd3ec133809bb463e6", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3320a44f88e80c99336ed6bd3ec133809bb463e6", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "c5819597562a1b29c37c3dc7cf50ece1a784bdb9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c5819597562a1b29c37c3dc7cf50ece1a784bdb9", "message": "feat: Disable tests to fix in followup PR\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "21c14c1ae61f167400f713cfec09d071449f009a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/21c14c1ae61f167400f713cfec09d071449f009a", "message": "feat: Review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T09:25:51Z", "type": "commit"}, {"oid": "3c7830c6783a60408f45f87b9f7fe6c3fd98f63e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3c7830c6783a60408f45f87b9f7fe6c3fd98f63e", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T10:06:32Z", "type": "forcePushed"}, {"oid": "33bc4aac331763689446eb5c342442299f9c8ac5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/33bc4aac331763689446eb5c342442299f9c8ac5", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T11:46:03Z", "type": "commit"}, {"oid": "33bc4aac331763689446eb5c342442299f9c8ac5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/33bc4aac331763689446eb5c342442299f9c8ac5", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-12-24T11:46:03Z", "type": "forcePushed"}, {"oid": "53989c6be5f2c14cab2b1b3cb24759c774f40742", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/53989c6be5f2c14cab2b1b3cb24759c774f40742", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2021-01-04T15:31:54Z", "type": "forcePushed"}, {"oid": "54484d35c16a1f15265f5aef0c358377a3922712", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/54484d35c16a1f15265f5aef0c358377a3922712", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2021-01-04T16:10:42Z", "type": "commit"}, {"oid": "54484d35c16a1f15265f5aef0c358377a3922712", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/54484d35c16a1f15265f5aef0c358377a3922712", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2021-01-04T16:10:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MTA3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r552041072", "bodyText": "Any reason why we're not just using a YAMLMapper here? That would probably avoid the need for yaml, since it can take an InputStream to parse.", "author": "tombentley", "createdAt": "2021-01-05T16:24:34Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +358,49 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    @Override\n+    protected String getRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String getRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    /**\n+     * Read the entity operator ClusterRole, and use the rules to create a new Role.\n+     * This is done to avoid duplication of the rules set defined in source code.\n+     *\n+     * @param namespace the namespace this role will be located\n+     *\n+     * @return role for the entity operator\n+     */\n+    public Role generateRole(String namespace) {\n+        List<PolicyRule> rules;\n+\n+        try (BufferedReader br = new BufferedReader(\n+                new InputStreamReader(\n+                    Main.class.getResourceAsStream(\"/cluster-roles/031-ClusterRole-strimzi-entity-operator.yaml\"),\n+                    StandardCharsets.UTF_8)\n+            )\n+        ) {\n+            String yaml = br.lines().collect(Collectors.joining(System.lineSeparator()));\n+            ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());\n+            ClusterRole cr = yamlReader.readValue(yaml, ClusterRole.class);", "originalCommit": "c7325eddf3cc8da29a5319c660f9662bd512ecb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NTE0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r552045147", "bodyText": "Oh, well I copied this bit from a similar bit of code in the System tests - not really messed with YAML too much in Java, so didn't know about the alternative!", "author": "samuel-hawker", "createdAt": "2021-01-05T16:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MTA3Mg=="}], "type": "inlineReview"}, {"oid": "813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "message": "feat: Add role watch permissions for delete\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2021-01-06T09:13:29Z", "type": "commit"}, {"oid": "813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "message": "feat: Add role watch permissions for delete\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2021-01-06T09:13:29Z", "type": "forcePushed"}]}