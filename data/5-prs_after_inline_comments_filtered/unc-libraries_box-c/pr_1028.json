{"pr_number": 1028, "pr_title": "Allow for file rollback if transfer is interrupted or fails", "pr_createdAt": "2020-06-24T19:58:01Z", "pr_url": "https://github.com/UNC-Libraries/box-c/pull/1028", "timeline": [{"oid": "a39367c69ba260d2c5ba3c60797008a210221327", "url": "https://github.com/UNC-Libraries/box-c/commit/a39367c69ba260d2c5ba3c60797008a210221327", "message": "Allow for file rollback if transfer is interrupted or fails", "committedDate": "2020-06-24T20:10:55Z", "type": "commit"}, {"oid": "a39367c69ba260d2c5ba3c60797008a210221327", "url": "https://github.com/UNC-Libraries/box-c/commit/a39367c69ba260d2c5ba3c60797008a210221327", "message": "Allow for file rollback if transfer is interrupted or fails", "committedDate": "2020-06-24T20:10:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1MjE5Ng==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445152196", "bodyText": "Since we are starting from a valid URI (destUri) and adding components to it which are pretty tightly controlled and would represent a programming error if it produced an invalid uri, I think it would be fine to use URI.create and skip the error handling. The copy/move operation won't have taken place before the two calls of this method, so it should be just as safe without the rollback logic here, in which case you should be able to also remove the oldFileURI param from the method.\nOne other thing, it might be simpler to have this method take and produce a Paths, since I don't think you need the URI representation of new or old for any other purpose.", "author": "bbpennel", "createdAt": "2020-06-24T20:27:53Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +70,83 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        URI oldFileUri = createFileURI(destUri, \"old\", currentTime, null);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n+            Path destinationPath = Paths.get(destUri);\n+            URI newFileUri = createFileURI(destUri, \"new\", currentTime, oldFileUri);\n \n+            // Rename old file .old extension\n+            if (allowOverwrite && Files.exists(destinationPath)) {\n+                Files.move(destinationPath, Paths.get(oldFileUri));\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.copy(Paths.get(sourceFileUri), Paths.get(newFileUri),\n                         allowOverwrite ? COPY_ALLOW_OVERWRITE : COPY_NO_OVERWRITE);\n             } else {\n-                Files.move(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.move(Paths.get(sourceFileUri), Paths.get(newFileUri),\n                         allowOverwrite ? MOVE_ALLOW_OVERWRITE : MOVE_NO_OVERWRITE);\n             }\n+\n+            // Rename new file from .new extension\n+            Files.move(Paths.get(newFileUri), destinationPath);\n+\n+            // Delete old file\n+            Files.deleteIfExists(Paths.get(oldFileUri));\n         } catch (FileAlreadyExistsException e) {\n+            rollBackOldFile(oldFileUri, destUri);\n             throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n                     + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n         } catch (IOException e) {\n+            rollBackOldFile(oldFileUri, destUri);\n             throw new BinaryTransferException(\"Failed to transfer \" + sourceFileUri\n                     + \" to destination \" + destination.getId(), e);\n         }\n \n         return destUri;\n     }\n \n+    private URI createFileURI(URI destUri, String type, long currentTime, URI oldFileURI) {\n+        URI fileUri;\n+\n+        try {\n+            fileUri = new URI(destUri + \".\" + type + \"-\" + currentTime);", "originalCommit": "a39367c69ba260d2c5ba3c60797008a210221327", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NDg0Ng==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445154846", "bodyText": "you don't need to move the current file to old until after the new file is written. Waiting as long as possible to rename the current file should minimize the amount of time that there is no current file. Having no current file would make it so that reads would fail", "author": "bbpennel", "createdAt": "2020-06-24T20:32:58Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +70,83 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        URI oldFileUri = createFileURI(destUri, \"old\", currentTime, null);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n+            Path destinationPath = Paths.get(destUri);\n+            URI newFileUri = createFileURI(destUri, \"new\", currentTime, oldFileUri);\n \n+            // Rename old file .old extension", "originalCommit": "a39367c69ba260d2c5ba3c60797008a210221327", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1ODg2Mw==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445158863", "bodyText": "Since the new file will be written to a file with the .new-<nano> extension, you should be able to remove COPY_ALLOW_OVERWRITE and MOVE_ALLOW_OVERWRITE since it should be almost impossible to produce a naming collision, and if there is one then we would want it to fail one of the writes.\nInstead, I would suggest checking !allowOverwrite && Files.exists(destinationPath) before it starts doing any copies or moves, and throw the BinaryAlreadyExistsException right away. You might want to record the results of Files.exists(destinationPath) once since i think you're going to need to know that info for this purpose and for deciding if you need to move the current file to old.", "author": "bbpennel", "createdAt": "2020-06-24T20:40:48Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +70,83 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        URI oldFileUri = createFileURI(destUri, \"old\", currentTime, null);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n+            Path destinationPath = Paths.get(destUri);\n+            URI newFileUri = createFileURI(destUri, \"new\", currentTime, oldFileUri);\n \n+            // Rename old file .old extension\n+            if (allowOverwrite && Files.exists(destinationPath)) {\n+                Files.move(destinationPath, Paths.get(oldFileUri));\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.copy(Paths.get(sourceFileUri), Paths.get(newFileUri),", "originalCommit": "a39367c69ba260d2c5ba3c60797008a210221327", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MjQxNA==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445162414", "bodyText": "You can likely pass Paths in here instead of URIs", "author": "bbpennel", "createdAt": "2020-06-24T20:47:39Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +70,83 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        URI oldFileUri = createFileURI(destUri, \"old\", currentTime, null);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n+            Path destinationPath = Paths.get(destUri);\n+            URI newFileUri = createFileURI(destUri, \"new\", currentTime, oldFileUri);\n \n+            // Rename old file .old extension\n+            if (allowOverwrite && Files.exists(destinationPath)) {\n+                Files.move(destinationPath, Paths.get(oldFileUri));\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.copy(Paths.get(sourceFileUri), Paths.get(newFileUri),\n                         allowOverwrite ? COPY_ALLOW_OVERWRITE : COPY_NO_OVERWRITE);\n             } else {\n-                Files.move(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.move(Paths.get(sourceFileUri), Paths.get(newFileUri),\n                         allowOverwrite ? MOVE_ALLOW_OVERWRITE : MOVE_NO_OVERWRITE);\n             }\n+\n+            // Rename new file from .new extension\n+            Files.move(Paths.get(newFileUri), destinationPath);\n+\n+            // Delete old file\n+            Files.deleteIfExists(Paths.get(oldFileUri));\n         } catch (FileAlreadyExistsException e) {\n+            rollBackOldFile(oldFileUri, destUri);\n             throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n                     + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n         } catch (IOException e) {\n+            rollBackOldFile(oldFileUri, destUri);\n             throw new BinaryTransferException(\"Failed to transfer \" + sourceFileUri\n                     + \" to destination \" + destination.getId(), e);\n         }\n \n         return destUri;\n     }\n \n+    private URI createFileURI(URI destUri, String type, long currentTime, URI oldFileURI) {\n+        URI fileUri;\n+\n+        try {\n+            fileUri = new URI(destUri + \".\" + type + \"-\" + currentTime);\n+            return fileUri;\n+        } catch (URISyntaxException e) {\n+            if (oldFileURI != null) {\n+                rollBackOldFile(oldFileURI, destUri);\n+            }\n+\n+            throw new BinaryTransferException(\"Failed to to create temp uri \"\n+                    + destUri + \".\" + type + \" for transfer \" + destUri\n+                    + \" to destination \" + destination.getId(), e);\n+        }\n+    }\n+\n+    /**\n+     * Roll back the file name if an error is thrown\n+     * @param oldFileUri\n+     * @param destUri\n+     */\n+    private void rollBackOldFile(URI oldFileUri, URI destUri) {", "originalCommit": "a39367c69ba260d2c5ba3c60797008a210221327", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mjk1NQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445162955", "bodyText": "After this you should also check to see if the new file exists, and delete it if it does, so we don't end up with leftover new files.", "author": "bbpennel", "createdAt": "2020-06-24T20:48:45Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +70,83 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        URI oldFileUri = createFileURI(destUri, \"old\", currentTime, null);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n+            Path destinationPath = Paths.get(destUri);\n+            URI newFileUri = createFileURI(destUri, \"new\", currentTime, oldFileUri);\n \n+            // Rename old file .old extension\n+            if (allowOverwrite && Files.exists(destinationPath)) {\n+                Files.move(destinationPath, Paths.get(oldFileUri));\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.copy(Paths.get(sourceFileUri), Paths.get(newFileUri),\n                         allowOverwrite ? COPY_ALLOW_OVERWRITE : COPY_NO_OVERWRITE);\n             } else {\n-                Files.move(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.move(Paths.get(sourceFileUri), Paths.get(newFileUri),\n                         allowOverwrite ? MOVE_ALLOW_OVERWRITE : MOVE_NO_OVERWRITE);\n             }\n+\n+            // Rename new file from .new extension\n+            Files.move(Paths.get(newFileUri), destinationPath);\n+\n+            // Delete old file\n+            Files.deleteIfExists(Paths.get(oldFileUri));\n         } catch (FileAlreadyExistsException e) {\n+            rollBackOldFile(oldFileUri, destUri);\n             throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n                     + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n         } catch (IOException e) {\n+            rollBackOldFile(oldFileUri, destUri);\n             throw new BinaryTransferException(\"Failed to transfer \" + sourceFileUri\n                     + \" to destination \" + destination.getId(), e);\n         }\n \n         return destUri;\n     }\n \n+    private URI createFileURI(URI destUri, String type, long currentTime, URI oldFileURI) {\n+        URI fileUri;\n+\n+        try {\n+            fileUri = new URI(destUri + \".\" + type + \"-\" + currentTime);\n+            return fileUri;\n+        } catch (URISyntaxException e) {\n+            if (oldFileURI != null) {\n+                rollBackOldFile(oldFileURI, destUri);\n+            }\n+\n+            throw new BinaryTransferException(\"Failed to to create temp uri \"\n+                    + destUri + \".\" + type + \" for transfer \" + destUri\n+                    + \" to destination \" + destination.getId(), e);\n+        }\n+    }\n+\n+    /**\n+     * Roll back the file name if an error is thrown\n+     * @param oldFileUri\n+     * @param destUri\n+     */\n+    private void rollBackOldFile(URI oldFileUri, URI destUri) {\n+        Path oldPath = Paths.get(oldFileUri);\n+\n+        if (Files.exists(oldPath)) {", "originalCommit": "a39367c69ba260d2c5ba3c60797008a210221327", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "47d51e18822f16220887b19fb370e73e51bb4e74", "url": "https://github.com/UNC-Libraries/box-c/commit/47d51e18822f16220887b19fb370e73e51bb4e74", "message": "* Rearrange where .old file is added\n* Add test", "committedDate": "2020-06-25T14:21:39Z", "type": "commit"}, {"oid": "47d51e18822f16220887b19fb370e73e51bb4e74", "url": "https://github.com/UNC-Libraries/box-c/commit/47d51e18822f16220887b19fb370e73e51bb4e74", "message": "* Rearrange where .old file is added\n* Add test", "committedDate": "2020-06-25T14:21:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgwNDIwNQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445804205", "bodyText": "this should be outside of the if since the new file can exist when there is no old file.", "author": "bbpennel", "createdAt": "2020-06-25T19:58:16Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +59,69 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        Path oldFilePath = createFilePath(destUri, \"old\", currentTime);\n+        Path newFilePath = createFilePath(destUri, \"new\", currentTime);\n+        Path destinationPath = Paths.get(destUri);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n \n+            boolean destFileExists = Files.exists(destinationPath);\n+\n+            if (!allowOverwrite && destFileExists) {\n+                throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n+                        + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n-                        allowOverwrite ? COPY_ALLOW_OVERWRITE : COPY_NO_OVERWRITE);\n+                Files.copy(Paths.get(sourceFileUri), newFilePath);\n             } else {\n-                Files.move(Paths.get(sourceFileUri), Paths.get(destUri),\n-                        allowOverwrite ? MOVE_ALLOW_OVERWRITE : MOVE_NO_OVERWRITE);\n+                Files.move(Paths.get(sourceFileUri), newFilePath);\n+            }\n+\n+            // Rename old file to .old extension\n+            if (destFileExists) {\n+                Files.move(destinationPath, oldFilePath);\n             }\n-        } catch (FileAlreadyExistsException e) {\n-            throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n-                    + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n+            // Rename new file from .new extension\n+            Files.move(newFilePath, destinationPath);\n+            // Delete old file\n+            Files.deleteIfExists(oldFilePath);\n         } catch (IOException e) {\n+            rollBackOldFile(oldFilePath, newFilePath, destinationPath);\n             throw new BinaryTransferException(\"Failed to transfer \" + sourceFileUri\n                     + \" to destination \" + destination.getId(), e);\n         }\n \n         return destUri;\n     }\n \n+    private Path createFilePath(URI destUri, String type, long currentTime) {\n+            URI fileUri = URI.create(destUri + \".\" + type + \"-\" + currentTime);\n+            return Paths.get(fileUri);\n+    }\n+\n+    /**\n+     * Roll back the file name if an error is thrown\n+     * @param oldFilePath\n+     * @param destPath\n+     */\n+    private void rollBackOldFile(Path oldFilePath, Path newFilePath, Path destPath) {\n+        if (Files.exists(oldFilePath)) {\n+            try {\n+                Files.move(oldFilePath, destPath);\n+                Files.deleteIfExists(newFilePath);", "originalCommit": "47d51e18822f16220887b19fb370e73e51bb4e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgwNDYxNQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445804615", "bodyText": "I believe we still want to include the COPY_ATTRIBUTES option here", "author": "bbpennel", "createdAt": "2020-06-25T19:59:07Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +59,69 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        Path oldFilePath = createFilePath(destUri, \"old\", currentTime);\n+        Path newFilePath = createFilePath(destUri, \"new\", currentTime);\n+        Path destinationPath = Paths.get(destUri);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n \n+            boolean destFileExists = Files.exists(destinationPath);\n+\n+            if (!allowOverwrite && destFileExists) {\n+                throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n+                        + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n-                        allowOverwrite ? COPY_ALLOW_OVERWRITE : COPY_NO_OVERWRITE);\n+                Files.copy(Paths.get(sourceFileUri), newFilePath);", "originalCommit": "47d51e18822f16220887b19fb370e73e51bb4e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgwNjgzOA==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r445806838", "bodyText": "There's actually already a transferFileAlreadyExists test which you could extend to check that no extra files are left over. For a test that could fail part way through, from my previous comment\n\nOne test would be to write a file to a directory, then call file.setReadOnly() on that file, then try to overwrite the file (with replace allowed). It should fail partway through, then you will want to verify that the current file still exists, and that there are no extra files in the directory. You'll might need to set file.setWriteable(true) afterwards so that you can delete the file when the test ends, but i haven't verified that.", "author": "bbpennel", "createdAt": "2020-06-25T20:03:37Z", "path": "persistence/src/test/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClientTest.java", "diffHunk": "@@ -163,6 +163,22 @@ public void transferReplaceFileAlreadyExists() throws Exception {\n         assertFalse(\"Source file should not exist after transfer\", sourceFile.toFile().exists());\n     }\n \n+    @Test\n+    public void rollbackOnTransferInterruption() throws Exception {\n+        String existingContent = \"I exist\";\n+\n+        Files.createDirectories(binDestPath.getParent());", "originalCommit": "47d51e18822f16220887b19fb370e73e51bb4e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "495ba7a0fa8b55a872f0436be9e6a75776c57b01", "url": "https://github.com/UNC-Libraries/box-c/commit/495ba7a0fa8b55a872f0436be9e6a75776c57b01", "message": "* Add rollback test\n* Reorganize how file rollback works", "committedDate": "2020-06-26T14:33:20Z", "type": "commit"}, {"oid": "e010c153cf9765558aa6140b814a138495f8f1de", "url": "https://github.com/UNC-Libraries/box-c/commit/e010c153cf9765558aa6140b814a138495f8f1de", "message": "Log a warning for deletion errors of .old file.", "committedDate": "2020-06-26T15:05:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI3NzEyNQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r446277125", "bodyText": "I think we only need COPY_NO_OVERWRITE at this point, an overwrite shouldn't occur and if it does we would want it to fail, which is what would happen in the move case", "author": "bbpennel", "createdAt": "2020-06-26T16:10:23Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -69,30 +70,77 @@ public URI transferReplaceExisting(PID binPid, URI sourceFileUri) {\n \n     public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n+        long currentTime = System.nanoTime();\n+        Path oldFilePath = createFilePath(destUri, \"old\", currentTime);\n+        Path newFilePath = createFilePath(destUri, \"new\", currentTime);\n+        Path destinationPath = Paths.get(destUri);\n \n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             Files.createDirectories(parentPath);\n \n+            boolean destFileExists = Files.exists(destinationPath);\n+\n+            if (!allowOverwrite && destFileExists) {\n+                throw new BinaryAlreadyExistsException(\"Failed to transfer \" + sourceFileUri\n+                        + \", a binary already exists in \" + destination.getId() + \" at path \" + destUri);\n+            }\n+\n+            // Copy/move new file\n             if (source.isReadOnly()) {\n-                Files.copy(Paths.get(sourceFileUri), Paths.get(destUri),\n+                Files.copy(Paths.get(sourceFileUri), newFilePath,\n                         allowOverwrite ? COPY_ALLOW_OVERWRITE : COPY_NO_OVERWRITE);", "originalCommit": "e010c153cf9765558aa6140b814a138495f8f1de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI3ODMxNg==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r446278316", "bodyText": "You will also need to update the StreamToFSTransferClient with the roughly same safe write procedure.", "author": "bbpennel", "createdAt": "2020-06-26T16:12:40Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClient.java", "diffHunk": "@@ -49,8 +50,8 @@\n \n     private static final CopyOption[] COPY_NO_OVERWRITE = { COPY_ATTRIBUTES };\n     private static final CopyOption[] COPY_ALLOW_OVERWRITE = { COPY_ATTRIBUTES, REPLACE_EXISTING };\n-    private static final CopyOption[] MOVE_NO_OVERWRITE = { };\n-    private static final CopyOption[] MOVE_ALLOW_OVERWRITE = { REPLACE_EXISTING };\n+\n+    private static final Logger log = LoggerFactory.getLogger(FSToFSTransferClient.class);\n \n     public FSToFSTransferClient(IngestSource source, StorageLocation destination) {", "originalCommit": "e010c153cf9765558aa6140b814a138495f8f1de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI3ODkwMQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r446278901", "bodyText": "you can just delete the file here rather than waiting for exit", "author": "bbpennel", "createdAt": "2020-06-26T16:13:53Z", "path": "persistence/src/test/java/edu/unc/lib/dl/persist/services/transfer/FSToFSTransferClientTest.java", "diffHunk": "@@ -163,6 +164,30 @@ public void transferReplaceFileAlreadyExists() throws Exception {\n         assertFalse(\"Source file should not exist after transfer\", sourceFile.toFile().exists());\n     }\n \n+    @Test\n+    public void rollbackOnTransferInterruption() throws Exception {\n+        String existingContent = \"I exist\";\n+        Path parentPath = binDestPath.getParent();\n+        Files.createDirectories(parentPath);\n+\n+        createFile(binDestPath, existingContent);\n+        Path sourceFile = createSourceFile();\n+\n+        File destFile = binDestPath.toFile();\n+        File parentDir = parentPath.toFile();\n+        parentDir.setReadOnly();\n+\n+        try {\n+            client.transferReplaceExisting(binPid, sourceFile.toUri());\n+        } catch (BinaryTransferException e) {\n+            assertTrue(\"Original file should be present\", destFile.exists());\n+            assertEquals(1, binDestPath.getParent().toFile().listFiles().length);\n+        } finally {\n+            parentDir.setWritable(true);\n+            destFile.deleteOnExit();", "originalCommit": "e010c153cf9765558aa6140b814a138495f8f1de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "57593b266fb52993da8c5ff0bf77bd9cb922d094", "url": "https://github.com/UNC-Libraries/box-c/commit/57593b266fb52993da8c5ff0bf77bd9cb922d094", "message": "* Add helper class\n* Add safe write to StreamToFSTransferClient", "committedDate": "2020-06-26T17:56:03Z", "type": "commit"}, {"oid": "57593b266fb52993da8c5ff0bf77bd9cb922d094", "url": "https://github.com/UNC-Libraries/box-c/commit/57593b266fb52993da8c5ff0bf77bd9cb922d094", "message": "* Add helper class\n* Add safe write to StreamToFSTransferClient", "committedDate": "2020-06-26T17:56:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM1NDM3NQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r446354375", "bodyText": "I think you could move Path newFilePath = FileTransferHelpers.createFilePath(destUri, \"new\", currentTime); up from line 107 to be next to the Path oldFilePath initialization at line 80, and remove tmpPath here. I think tmpPath was trying to solve the same thing that createFilePath is doing. createTempFile comes with more protections against duplicate file names, but we would probably end up with a super long file name between the nano-time and the createTempFile generated suffix.", "author": "bbpennel", "createdAt": "2020-06-26T18:51:12Z", "path": "persistence/src/main/java/edu/unc/lib/dl/persist/services/transfer/StreamToFSTransferClient.java", "diffHunk": "@@ -65,24 +69,43 @@ public URI transferReplaceExisting(PID binPid, InputStream sourceStream) {\n     protected URI writeStream(PID binPid, InputStream sourceStream, boolean allowOverwrite) {\n         URI destUri = destination.getStorageUri(binPid);\n         Path destPath = Paths.get(destUri);\n+        boolean destFileExists = destPath.toFile().exists();\n \n-        if (!allowOverwrite && destPath.toFile().exists()) {\n+        if (!allowOverwrite && destFileExists) {\n             throw new BinaryAlreadyExistsException(\"Failed to write stream, a binary already exists in \"\n                      + destination.getId() + \" at path \" + destUri);\n         }\n \n+        long currentTime = System.nanoTime();\n+        Path oldFilePath = FileTransferHelpers.createFilePath(destUri, \"old\", currentTime);\n+\n         try {\n             // Fill in parent directories if they are not present\n             Path parentPath = Paths.get(destUri).getParent();\n             createDirectories(parentPath);\n \n             // Write content to temp file in case of interruption\n-            Path tmpPath = createTempFile(parentPath, null, \".new\");\n+            Path tmpPath = createTempFile(parentPath, null, \".new-\" + currentTime);", "originalCommit": "57593b266fb52993da8c5ff0bf77bd9cb922d094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM1NzE5MA==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r446357190", "bodyText": "Hmm, I'm a little confused, it seems like its using a mocked stream and then overwriting the file at the destination on the next line? Could you just merge these two lines into\nInputStream sourceStream = toStream(ORIGINAL_CONTENT);\n?", "author": "bbpennel", "createdAt": "2020-06-26T18:57:21Z", "path": "persistence/src/test/java/edu/unc/lib/dl/persist/services/transfer/StreamToFSTransferClientTest.java", "diffHunk": "@@ -139,6 +143,30 @@ public void transferReplaceExisting_ExistingFile_WriteFails() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void rollbackOnTransferInterruption() throws Exception {\n+        String existingContent = \"I exist\";\n+\n+        Files.createDirectories(binDestPath.getParent());\n+        createFile(binDestPath, existingContent);\n+        File destFile = binDestPath.toFile();\n+        File parentDir = binDestPath.getParent().toFile();\n+        parentDir.setReadOnly();\n+\n+        InputStream sourceStream = mock(InputStream.class);", "originalCommit": "57593b266fb52993da8c5ff0bf77bd9cb922d094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM1OTAxOQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1028#discussion_r446359019", "bodyText": "since you're adding this helper method, you should probably update the existing ExistingFile tests to use it since they are all doing it themselves with stuff like FileUtils.copyInputStreamToFile(toStream(ORIGINAL_CONTENT), binDestPath.toFile());", "author": "bbpennel", "createdAt": "2020-06-26T19:01:44Z", "path": "persistence/src/test/java/edu/unc/lib/dl/persist/services/transfer/StreamToFSTransferClientTest.java", "diffHunk": "@@ -147,4 +175,9 @@ protected void assertContent(Path path, String content) throws Exception {\n     protected InputStream toStream(String content) {\n         return new ByteArrayInputStream(content.getBytes());\n     }\n+\n+    private Path createFile(Path filePath, String content) throws Exception {", "originalCommit": "57593b266fb52993da8c5ff0bf77bd9cb922d094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fcee96db67d05f0df1aa64c8ed371c46aa58433", "url": "https://github.com/UNC-Libraries/box-c/commit/6fcee96db67d05f0df1aa64c8ed371c46aa58433", "message": "* Update how files are created\n* Use test helper across tests", "committedDate": "2020-06-26T19:47:08Z", "type": "commit"}, {"oid": "76c4fb38a10a931885f060271d43f9d5df93f3c2", "url": "https://github.com/UNC-Libraries/box-c/commit/76c4fb38a10a931885f060271d43f9d5df93f3c2", "message": "Perform cleanup of incomplete file transfers at shutdown in case of an unexpected jvm exit", "committedDate": "2020-06-30T21:08:54Z", "type": "commit"}, {"oid": "76c4fb38a10a931885f060271d43f9d5df93f3c2", "url": "https://github.com/UNC-Libraries/box-c/commit/76c4fb38a10a931885f060271d43f9d5df93f3c2", "message": "Perform cleanup of incomplete file transfers at shutdown in case of an unexpected jvm exit", "committedDate": "2020-06-30T21:08:54Z", "type": "forcePushed"}]}