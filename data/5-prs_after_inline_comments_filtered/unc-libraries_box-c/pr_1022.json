{"pr_number": 1022, "pr_title": "BXC-2687 - Deposit SHA1s", "pr_createdAt": "2020-06-18T20:03:45Z", "pr_url": "https://github.com/UNC-Libraries/box-c/pull/1022", "timeline": [{"oid": "1d6beac33e76716e1a4ac4b9a7d9b509ab103a85", "url": "https://github.com/UNC-Libraries/box-c/commit/1d6beac33e76716e1a4ac4b9a7d9b509ab103a85", "message": "Add deposit job to generate and verify checksums. Remove this functionality from the techmd deposit job. Add utilities related to fixity", "committedDate": "2020-06-18T16:17:15Z", "type": "commit"}, {"oid": "76dd025f6a1ff4cd176b5abebae0019548acfec3", "url": "https://github.com/UNC-Libraries/box-c/commit/76dd025f6a1ff4cd176b5abebae0019548acfec3", "message": "Prevent rollback of deposit model for jobs where we don't want to lose progress. Add resumption for fixity check job", "committedDate": "2020-06-18T18:05:28Z", "type": "commit"}, {"oid": "9d019308401b887f723e7c9e86ad98256d0db29d", "url": "https://github.com/UNC-Libraries/box-c/commit/9d019308401b887f723e7c9e86ad98256d0db29d", "message": "Read inputstream in chunks during digest calculation. Add debug statements", "committedDate": "2020-06-18T20:01:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MjIyMw==", "url": "https://github.com/UNC-Libraries/box-c/pull/1022#discussion_r442482223", "bodyText": "What is the purpose of reading through the file here? I don't see \"is\" used anywhere else.", "author": "lfarrell", "createdAt": "2020-06-18T20:24:13Z", "path": "persistence/src/main/java/edu/unc/lib/dl/util/MultiDigestInputStreamWrapper.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright 2008 The University of North Carolina at Chapel Hill\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package edu.unc.lib.dl.util;\n+\n+import static org.apache.commons.codec.binary.Hex.encodeHexString;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.DigestInputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import edu.unc.lib.dl.exceptions.InvalidChecksumException;\n+import edu.unc.lib.dl.exceptions.RepositoryException;\n+import edu.unc.lib.dl.exceptions.UnsupportedAlgorithmException;\n+\n+/**\n+ * Wrapper for an InputStream that allows for the computation and evaluation\n+ * of multiple digests at once.\n+ *\n+ * @author bbpennel\n+ */\n+public class MultiDigestInputStreamWrapper {\n+    private final InputStream sourceStream;\n+\n+    private final Map<DigestAlgorithm, String> algToDigest;\n+\n+    private final Map<DigestAlgorithm, DigestInputStream> algToDigestStream;\n+\n+    private boolean streamRetrieved;\n+\n+    private Map<DigestAlgorithm, String> computedDigests;\n+\n+    /**\n+     * Construct a MultiDigestInputStreamWrapper\n+     *\n+     * @param sourceStream the original source input stream\n+     * @param digests map of provided digests for the input stream\n+     * @param wantDigests list of additional digest algorithms to compute for the input stream\n+     */\n+    public MultiDigestInputStreamWrapper(InputStream sourceStream, Map<DigestAlgorithm, String> digests,\n+            Collection<DigestAlgorithm> wantDigests) {\n+        this.sourceStream = sourceStream;\n+        algToDigest = digests;\n+        algToDigestStream = new HashMap<>();\n+\n+        // Merge the list of wanted digest algorithms with set of provided digests\n+        if (wantDigests != null) {\n+            for (DigestAlgorithm wantDigest : wantDigests) {\n+                if (!algToDigest.containsKey(wantDigest)) {\n+                    algToDigest.put(wantDigest, null);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get the InputStream wrapped to produce the requested digests\n+     *\n+     * @return wrapped input stream\n+     */\n+    public InputStream getInputStream() {\n+        streamRetrieved = true;\n+        InputStream digestStream = sourceStream;\n+        for (DigestAlgorithm algorithm : algToDigest.keySet()) {\n+            try {\n+                // Progressively wrap the original stream in layers of digest streams\n+                digestStream = new DigestInputStream(\n+                        digestStream, MessageDigest.getInstance(algorithm.getName()));\n+            } catch (final NoSuchAlgorithmException e) {\n+                throw new UnsupportedAlgorithmException(\"Unsupported digest algorithm: \" + algorithm, e);\n+            }\n+\n+            algToDigestStream.put(algorithm, (DigestInputStream) digestStream);\n+        }\n+        return digestStream;\n+    }\n+\n+    /**\n+     * After consuming the inputstream, verify that all of the computed digests\n+     * matched the provided digests.\n+     *\n+     * Note: the wrapped InputStream will be consumed if it has not already been read.\n+     *\n+     * @throws InvalidChecksumException thrown if any of the digests did not match\n+     */\n+    public void checkFixity() throws InvalidChecksumException {\n+        calculateDigests();\n+\n+        algToDigest.forEach((algorithm, originalDigest) -> {\n+            // Skip any algorithms which were calculated but no digest was provided for verification\n+            if (originalDigest == null) {\n+                return;\n+            }\n+            final String computed = computedDigests.get(algorithm);\n+\n+            if (!originalDigest.equalsIgnoreCase(computed)) {\n+                throw new InvalidChecksumException(String.format(\n+                        \"Checksum mismatch, computed %s digest %s did not match expected value %s\",\n+                        algorithm, computed, originalDigest));\n+            }\n+        });\n+\n+    }\n+\n+    /**\n+     * Returns the list of digests calculated for the wrapped InputStream\n+     *\n+     * Note: the wrapped InputStream will be consumed if it has not already been read.\n+     *\n+     * @return list of digests calculated from the wrapped InputStream, in URN format.\n+     */\n+    public Map<DigestAlgorithm, String> getDigests() {\n+        calculateDigests();\n+\n+        return computedDigests;\n+    }\n+\n+    private void calculateDigests() {\n+        if (computedDigests != null) {\n+            return;\n+        }\n+\n+        if (!streamRetrieved) {\n+            // Stream not previously consumed, consume it now in order to calculate digests\n+            try (final InputStream is = getInputStream()) {", "originalCommit": "1d6beac33e76716e1a4ac4b9a7d9b509ab103a85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgyMDU0Ng==", "url": "https://github.com/UNC-Libraries/box-c/pull/1022#discussion_r442820546", "bodyText": "Its because the input stream is wrapped in a DigestInputStream\nhttps://github.com/UNC-Libraries/Carolina-Digital-Repository/pull/1022/files#diff-7e1c346f26b46834efa5d9ed91646b62R83-R90\nWhen you read the contents of the stream, it calculates one or more digests. You could consume the contents of the stream for some other purpose, like writing the stream to a file or something, and it would still calculate the digests. That is why this block is wrapped in if (!streamRetrieved), so that it won't try to re-read the stream. But if we had not already read the stream at the time that digests are needed, then we have to read it. This is the case for the FixityCheckJob since it is loading the files just for the sake of checksumming.", "author": "bbpennel", "createdAt": "2020-06-19T12:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MjIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NDI1MQ==", "url": "https://github.com/UNC-Libraries/box-c/pull/1022#discussion_r442484251", "bodyText": "There are multiple spaces here.", "author": "lfarrell", "createdAt": "2020-06-18T20:28:30Z", "path": "deposit/src/test/java/edu/unc/lib/deposit/validate/FixityCheckJobTest.java", "diffHunk": "@@ -63,6 +67,8 @@\n \n     private File stagingDir;\n \n+", "originalCommit": "76dd025f6a1ff4cd176b5abebae0019548acfec3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9c618108787d68fc19e26f551b2b5a99068af7b", "url": "https://github.com/UNC-Libraries/box-c/commit/e9c618108787d68fc19e26f551b2b5a99068af7b", "message": "Remove blank lines", "committedDate": "2020-06-19T12:50:21Z", "type": "commit"}]}