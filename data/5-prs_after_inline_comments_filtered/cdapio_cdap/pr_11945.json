{"pr_number": 11945, "pr_title": "[CDAP-15633] Add main class that will run on Dataproc driver", "pr_createdAt": "2020-03-10T16:21:07Z", "pr_url": "https://github.com/cdapio/cdap/pull/11945", "timeline": [{"oid": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "url": "https://github.com/cdapio/cdap/commit/17da0f6b9524fcdbe14a43e04d7c49156179fc30", "message": "[CDAP-15633] Add main class that will run on Dataproc driver", "committedDate": "2020-03-10T17:45:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4MjQ2OA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390482468", "bodyText": "I think you need to start the ZKClientService explicitly before it can be used.", "author": "chtyim", "createdAt": "2020-03-10T17:22:07Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocRuntimeEnvProvider.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.hadoop.yarn.conf.YarnConfiguration;\n+import org.apache.twill.api.TwillRunner;\n+import org.apache.twill.discovery.DiscoveryService;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.apache.twill.discovery.ZKDiscoveryService;\n+import org.apache.twill.filesystem.FileContextLocationFactory;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.zookeeper.InMemoryZKServer;\n+import org.apache.twill.yarn.YarnTwillRunnerService;\n+import org.apache.twill.zookeeper.RetryStrategies;\n+import org.apache.twill.zookeeper.ZKClientService;\n+import org.apache.twill.zookeeper.ZKClientServices;\n+import org.apache.twill.zookeeper.ZKClients;\n+\n+import java.io.Closeable;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Dataproc runtime job environment provider. This class will provide implementation of {@link TwillRunner},\n+ * {@link DiscoveryService} and {@link DiscoveryServiceClient} to the runtime job.\n+ * All the public methods in this class are called through reflection from {@link DataprocJobMain}.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DataprocRuntimeEnvProvider implements Closeable {\n+  private static final String TWILL_ZK_SERVER_LOCALHOST = \"twill.zk.server.localhost\";\n+  private static final String ZK_QUORUM = \"zookeeper.quorum\";\n+  private ZKDiscoveryService zkDiscoveryService;\n+  private YarnTwillRunnerService yarnTwillRunnerService;\n+  private InMemoryZKServer server;\n+  private String connectionStr;\n+\n+  /**\n+   * This method initializes the dataproc runtime environment.\n+   *\n+   * @throws Exception any exception while initializing the environment.\n+   */\n+  public void initialize() throws Exception {\n+    System.setProperty(TWILL_ZK_SERVER_LOCALHOST, \"false\");\n+    server = InMemoryZKServer.builder().build();\n+    server.startAndWait();\n+\n+    InetSocketAddress resolved = resolve(server.getLocalAddress());\n+    connectionStr = resolved.getHostString() + \":\" + resolved.getPort();\n+\n+    zkDiscoveryService = new ZKDiscoveryService(ZKClientServices.delegate(", "originalCommit": "761e4a9ee1399410201f8da67bc8e34961a0366d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4Mzk1MQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390483951", "bodyText": "Call it zkServer.", "author": "chtyim", "createdAt": "2020-03-10T17:24:22Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocRuntimeEnvProvider.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.hadoop.yarn.conf.YarnConfiguration;\n+import org.apache.twill.api.TwillRunner;\n+import org.apache.twill.discovery.DiscoveryService;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.apache.twill.discovery.ZKDiscoveryService;\n+import org.apache.twill.filesystem.FileContextLocationFactory;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.zookeeper.InMemoryZKServer;\n+import org.apache.twill.yarn.YarnTwillRunnerService;\n+import org.apache.twill.zookeeper.RetryStrategies;\n+import org.apache.twill.zookeeper.ZKClientService;\n+import org.apache.twill.zookeeper.ZKClientServices;\n+import org.apache.twill.zookeeper.ZKClients;\n+\n+import java.io.Closeable;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Dataproc runtime job environment provider. This class will provide implementation of {@link TwillRunner},\n+ * {@link DiscoveryService} and {@link DiscoveryServiceClient} to the runtime job.\n+ * All the public methods in this class are called through reflection from {@link DataprocJobMain}.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DataprocRuntimeEnvProvider implements Closeable {\n+  private static final String TWILL_ZK_SERVER_LOCALHOST = \"twill.zk.server.localhost\";\n+  private static final String ZK_QUORUM = \"zookeeper.quorum\";\n+  private ZKDiscoveryService zkDiscoveryService;\n+  private YarnTwillRunnerService yarnTwillRunnerService;\n+  private InMemoryZKServer server;", "originalCommit": "761e4a9ee1399410201f8da67bc8e34961a0366d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDEyNQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390484125", "bodyText": "Better have the type as TwillRunnerService twillRunnerService", "author": "chtyim", "createdAt": "2020-03-10T17:24:39Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocRuntimeEnvProvider.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.hadoop.yarn.conf.YarnConfiguration;\n+import org.apache.twill.api.TwillRunner;\n+import org.apache.twill.discovery.DiscoveryService;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.apache.twill.discovery.ZKDiscoveryService;\n+import org.apache.twill.filesystem.FileContextLocationFactory;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.zookeeper.InMemoryZKServer;\n+import org.apache.twill.yarn.YarnTwillRunnerService;\n+import org.apache.twill.zookeeper.RetryStrategies;\n+import org.apache.twill.zookeeper.ZKClientService;\n+import org.apache.twill.zookeeper.ZKClientServices;\n+import org.apache.twill.zookeeper.ZKClients;\n+\n+import java.io.Closeable;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Dataproc runtime job environment provider. This class will provide implementation of {@link TwillRunner},\n+ * {@link DiscoveryService} and {@link DiscoveryServiceClient} to the runtime job.\n+ * All the public methods in this class are called through reflection from {@link DataprocJobMain}.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DataprocRuntimeEnvProvider implements Closeable {\n+  private static final String TWILL_ZK_SERVER_LOCALHOST = \"twill.zk.server.localhost\";\n+  private static final String ZK_QUORUM = \"zookeeper.quorum\";\n+  private ZKDiscoveryService zkDiscoveryService;\n+  private YarnTwillRunnerService yarnTwillRunnerService;", "originalCommit": "761e4a9ee1399410201f8da67bc8e34961a0366d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5Njg2Mg==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390496862", "bodyText": "This doesn't need to be a provider. It can just implements the RuntimeJobEnvironment directly.", "author": "chtyim", "createdAt": "2020-03-10T17:44:15Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocRuntimeEnvProvider.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.hadoop.yarn.conf.YarnConfiguration;\n+import org.apache.twill.api.TwillRunner;\n+import org.apache.twill.discovery.DiscoveryService;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.apache.twill.discovery.ZKDiscoveryService;\n+import org.apache.twill.filesystem.FileContextLocationFactory;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.zookeeper.InMemoryZKServer;\n+import org.apache.twill.yarn.YarnTwillRunnerService;\n+import org.apache.twill.zookeeper.RetryStrategies;\n+import org.apache.twill.zookeeper.ZKClientService;\n+import org.apache.twill.zookeeper.ZKClientServices;\n+import org.apache.twill.zookeeper.ZKClients;\n+\n+import java.io.Closeable;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Dataproc runtime job environment provider. This class will provide implementation of {@link TwillRunner},\n+ * {@link DiscoveryService} and {@link DiscoveryServiceClient} to the runtime job.\n+ * All the public methods in this class are called through reflection from {@link DataprocJobMain}.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DataprocRuntimeEnvProvider implements Closeable {", "originalCommit": "761e4a9ee1399410201f8da67bc8e34961a0366d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5NzIzMg==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390497232", "bodyText": "This is not needed since you are using the .class.getName in the main class.", "author": "chtyim", "createdAt": "2020-03-10T17:44:51Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocRuntimeEnvProvider.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.hadoop.yarn.conf.YarnConfiguration;\n+import org.apache.twill.api.TwillRunner;\n+import org.apache.twill.discovery.DiscoveryService;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.apache.twill.discovery.ZKDiscoveryService;\n+import org.apache.twill.filesystem.FileContextLocationFactory;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.zookeeper.InMemoryZKServer;\n+import org.apache.twill.yarn.YarnTwillRunnerService;\n+import org.apache.twill.zookeeper.RetryStrategies;\n+import org.apache.twill.zookeeper.ZKClientService;\n+import org.apache.twill.zookeeper.ZKClientServices;\n+import org.apache.twill.zookeeper.ZKClients;\n+\n+import java.io.Closeable;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Dataproc runtime job environment provider. This class will provide implementation of {@link TwillRunner},\n+ * {@link DiscoveryService} and {@link DiscoveryServiceClient} to the runtime job.\n+ * All the public methods in this class are called through reflection from {@link DataprocJobMain}.\n+ */\n+@SuppressWarnings(\"unused\")", "originalCommit": "761e4a9ee1399410201f8da67bc8e34961a0366d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NDk1Mg==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390574952", "bodyText": "I added it so that all the methods under this class have warnings suppressed.", "author": "CuriousVini", "createdAt": "2020-03-10T19:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5NzIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5ODcxMA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390498710", "bodyText": "Can you add a javadoc for this? Is it both expanding the jar and adding all content into the Deque?", "author": "chtyim", "createdAt": "2020-03-10T17:47:13Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final String RUNTIME_JOB_JAR = \"runtime.job.jar\";\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment provider class and create instance of it\n+      String runtimeProviderClassName = DataprocRuntimeEnvProvider.class.getName();\n+      Class<?> envProviderClass = newCL.loadClass(runtimeProviderClassName);\n+      Object newEnvProviderInstance = envProviderClass.newInstance();\n+\n+      try {\n+        // call initialize() method on envProviderClass\n+        Method initializeMethod = envProviderClass.getMethod(\"initialize\");\n+        System.out.println(\"Invoking initialize() on \" + runtimeProviderClassName);\n+        initializeMethod.invoke(newEnvProviderInstance);\n+\n+        // call getRuntimeJobEnvironment() method on envProviderClass\n+        Method getRuntimeEnvMethod = envProviderClass.getMethod(\"getRuntimeJobEnvironment\");\n+        System.out.println(\"Invoking getRuntimeJobEnvironment() \" + runtimeProviderClassName);\n+        Object runtimeEnv = getRuntimeEnvMethod.invoke(newEnvProviderInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        System.out.println(\"Invoking run() on \" + runtimeJobClassName);\n+        method.invoke(runner.newInstance(), runtimeEnv);\n+\n+      } finally {\n+        // call close() method on envProviderClass\n+        Method closeMethod = envProviderClass.getMethod(\"close\");\n+        System.out.println(\"Invoking close() \" + runtimeProviderClassName);\n+        closeMethod.invoke(newEnvProviderInstance);\n+      }\n+\n+      System.out.println(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));\n+    Deque<URL> queue = new LinkedList<>(urlList);\n+    for (URL url : classpath) {\n+      if (url.toString().endsWith(\".jar\")) {\n+        addAllDeps(url, queue);\n+        queue.addFirst(url);\n+      } else {\n+        queue.addLast(url);\n+      }\n+    }\n+    System.out.println(\"Classpath URLs: \" + queue);\n+    return queue;\n+  }\n+\n+  private static URL[] createClasspath(File appJarDir, File twillJarDir, File resourceJarDir) throws IOException {\n+    List<URL> urls = new ArrayList<>();\n+\n+    List<File> libJarFiles = listJarFiles(new File(appJarDir, \"lib\"), new ArrayList<>());\n+    Collections.sort(listJarFiles(new File(twillJarDir, \"lib\"), libJarFiles), Comparator.comparing(File::getName));\n+\n+    // Add the app jar and twill jar directories\n+    for (File dir : Arrays.asList(appJarDir, twillJarDir)) {\n+      urls.add(dir.toURI().toURL());\n+      urls.add(new File(dir, \"classes\").toURI().toURL());\n+    }\n+\n+    // add resources\n+    urls.add(new File(resourceJarDir, \"resources\").toURI().toURL());\n+\n+    // Add all lib jars\n+    for (File jarFile : libJarFiles) {\n+      urls.add(jarFile.toURI().toURL());\n+    }\n+\n+    // add runtime job jar launcher jar to submit runtime job. This jar will have implementation of runtime job and\n+    // dependent classes\n+    urls.add(new File(RUNTIME_JOB_JAR).toURI().toURL());\n+\n+    return urls.toArray(new URL[urls.size()]);\n+  }\n+\n+  private static List<File> listJarFiles(File dir, List<File> result) {\n+    File[] files = dir.listFiles();\n+    if (files == null || files.length == 0) {\n+      return result;\n+    }\n+    for (File file : files) {\n+      if (file.getName().endsWith(\".jar\")) {\n+        result.add(file);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static void addAllDeps(URL jarURL, Deque<URL> urls) throws IOException {", "originalCommit": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NTE3MQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390575171", "bodyText": "Yes. I will add javadoc for more clarity", "author": "CuriousVini", "createdAt": "2020-03-10T19:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5ODcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5OTg1Ng==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390499856", "bodyText": "It's better to have this directory passed to this method. We need to cleanup all directories created by this job after the job finished. It will be easier if you have one parent temp directory created in the main.", "author": "chtyim", "createdAt": "2020-03-10T17:48:58Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final String RUNTIME_JOB_JAR = \"runtime.job.jar\";\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment provider class and create instance of it\n+      String runtimeProviderClassName = DataprocRuntimeEnvProvider.class.getName();\n+      Class<?> envProviderClass = newCL.loadClass(runtimeProviderClassName);\n+      Object newEnvProviderInstance = envProviderClass.newInstance();\n+\n+      try {\n+        // call initialize() method on envProviderClass\n+        Method initializeMethod = envProviderClass.getMethod(\"initialize\");\n+        System.out.println(\"Invoking initialize() on \" + runtimeProviderClassName);\n+        initializeMethod.invoke(newEnvProviderInstance);\n+\n+        // call getRuntimeJobEnvironment() method on envProviderClass\n+        Method getRuntimeEnvMethod = envProviderClass.getMethod(\"getRuntimeJobEnvironment\");\n+        System.out.println(\"Invoking getRuntimeJobEnvironment() \" + runtimeProviderClassName);\n+        Object runtimeEnv = getRuntimeEnvMethod.invoke(newEnvProviderInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        System.out.println(\"Invoking run() on \" + runtimeJobClassName);\n+        method.invoke(runner.newInstance(), runtimeEnv);\n+\n+      } finally {\n+        // call close() method on envProviderClass\n+        Method closeMethod = envProviderClass.getMethod(\"close\");\n+        System.out.println(\"Invoking close() \" + runtimeProviderClassName);\n+        closeMethod.invoke(newEnvProviderInstance);\n+      }\n+\n+      System.out.println(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));\n+    Deque<URL> queue = new LinkedList<>(urlList);\n+    for (URL url : classpath) {\n+      if (url.toString().endsWith(\".jar\")) {\n+        addAllDeps(url, queue);\n+        queue.addFirst(url);\n+      } else {\n+        queue.addLast(url);\n+      }\n+    }\n+    System.out.println(\"Classpath URLs: \" + queue);\n+    return queue;\n+  }\n+\n+  private static URL[] createClasspath(File appJarDir, File twillJarDir, File resourceJarDir) throws IOException {\n+    List<URL> urls = new ArrayList<>();\n+\n+    List<File> libJarFiles = listJarFiles(new File(appJarDir, \"lib\"), new ArrayList<>());\n+    Collections.sort(listJarFiles(new File(twillJarDir, \"lib\"), libJarFiles), Comparator.comparing(File::getName));\n+\n+    // Add the app jar and twill jar directories\n+    for (File dir : Arrays.asList(appJarDir, twillJarDir)) {\n+      urls.add(dir.toURI().toURL());\n+      urls.add(new File(dir, \"classes\").toURI().toURL());\n+    }\n+\n+    // add resources\n+    urls.add(new File(resourceJarDir, \"resources\").toURI().toURL());\n+\n+    // Add all lib jars\n+    for (File jarFile : libJarFiles) {\n+      urls.add(jarFile.toURI().toURL());\n+    }\n+\n+    // add runtime job jar launcher jar to submit runtime job. This jar will have implementation of runtime job and\n+    // dependent classes\n+    urls.add(new File(RUNTIME_JOB_JAR).toURI().toURL());\n+\n+    return urls.toArray(new URL[urls.size()]);\n+  }\n+\n+  private static List<File> listJarFiles(File dir, List<File> result) {\n+    File[] files = dir.listFiles();\n+    if (files == null || files.length == 0) {\n+      return result;\n+    }\n+    for (File file : files) {\n+      if (file.getName().endsWith(\".jar\")) {\n+        result.add(file);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static void addAllDeps(URL jarURL, Deque<URL> urls) throws IOException {\n+    Path tempDir = Files.createTempDirectory(\"expanded.jar\");", "originalCommit": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwMTM5Mw==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390501393", "bodyText": "You can do\nOptional.ofNullable(dir.listFiles(file -> file.getName().endsWith(\".jar\")))\n  .ifPresent(files -> Collections.addAll(result, files));\nreturn result;", "author": "chtyim", "createdAt": "2020-03-10T17:51:28Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final String RUNTIME_JOB_JAR = \"runtime.job.jar\";\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment provider class and create instance of it\n+      String runtimeProviderClassName = DataprocRuntimeEnvProvider.class.getName();\n+      Class<?> envProviderClass = newCL.loadClass(runtimeProviderClassName);\n+      Object newEnvProviderInstance = envProviderClass.newInstance();\n+\n+      try {\n+        // call initialize() method on envProviderClass\n+        Method initializeMethod = envProviderClass.getMethod(\"initialize\");\n+        System.out.println(\"Invoking initialize() on \" + runtimeProviderClassName);\n+        initializeMethod.invoke(newEnvProviderInstance);\n+\n+        // call getRuntimeJobEnvironment() method on envProviderClass\n+        Method getRuntimeEnvMethod = envProviderClass.getMethod(\"getRuntimeJobEnvironment\");\n+        System.out.println(\"Invoking getRuntimeJobEnvironment() \" + runtimeProviderClassName);\n+        Object runtimeEnv = getRuntimeEnvMethod.invoke(newEnvProviderInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        System.out.println(\"Invoking run() on \" + runtimeJobClassName);\n+        method.invoke(runner.newInstance(), runtimeEnv);\n+\n+      } finally {\n+        // call close() method on envProviderClass\n+        Method closeMethod = envProviderClass.getMethod(\"close\");\n+        System.out.println(\"Invoking close() \" + runtimeProviderClassName);\n+        closeMethod.invoke(newEnvProviderInstance);\n+      }\n+\n+      System.out.println(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));\n+    Deque<URL> queue = new LinkedList<>(urlList);\n+    for (URL url : classpath) {\n+      if (url.toString().endsWith(\".jar\")) {\n+        addAllDeps(url, queue);\n+        queue.addFirst(url);\n+      } else {\n+        queue.addLast(url);\n+      }\n+    }\n+    System.out.println(\"Classpath URLs: \" + queue);\n+    return queue;\n+  }\n+\n+  private static URL[] createClasspath(File appJarDir, File twillJarDir, File resourceJarDir) throws IOException {\n+    List<URL> urls = new ArrayList<>();\n+\n+    List<File> libJarFiles = listJarFiles(new File(appJarDir, \"lib\"), new ArrayList<>());\n+    Collections.sort(listJarFiles(new File(twillJarDir, \"lib\"), libJarFiles), Comparator.comparing(File::getName));\n+\n+    // Add the app jar and twill jar directories\n+    for (File dir : Arrays.asList(appJarDir, twillJarDir)) {\n+      urls.add(dir.toURI().toURL());\n+      urls.add(new File(dir, \"classes\").toURI().toURL());\n+    }\n+\n+    // add resources\n+    urls.add(new File(resourceJarDir, \"resources\").toURI().toURL());\n+\n+    // Add all lib jars\n+    for (File jarFile : libJarFiles) {\n+      urls.add(jarFile.toURI().toURL());\n+    }\n+\n+    // add runtime job jar launcher jar to submit runtime job. This jar will have implementation of runtime job and\n+    // dependent classes\n+    urls.add(new File(RUNTIME_JOB_JAR).toURI().toURL());\n+\n+    return urls.toArray(new URL[urls.size()]);\n+  }\n+\n+  private static List<File> listJarFiles(File dir, List<File> result) {\n+    File[] files = dir.listFiles();\n+    if (files == null || files.length == 0) {\n+      return result;\n+    }\n+    for (File file : files) {\n+      if (file.getName().endsWith(\".jar\")) {", "originalCommit": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwNzIxMQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390507211", "bodyText": "Can you add some javadoc even for private method to at least tell what's the contract of the method is?", "author": "chtyim", "createdAt": "2020-03-10T18:00:13Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final String RUNTIME_JOB_JAR = \"runtime.job.jar\";\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment provider class and create instance of it\n+      String runtimeProviderClassName = DataprocRuntimeEnvProvider.class.getName();\n+      Class<?> envProviderClass = newCL.loadClass(runtimeProviderClassName);\n+      Object newEnvProviderInstance = envProviderClass.newInstance();\n+\n+      try {\n+        // call initialize() method on envProviderClass\n+        Method initializeMethod = envProviderClass.getMethod(\"initialize\");\n+        System.out.println(\"Invoking initialize() on \" + runtimeProviderClassName);\n+        initializeMethod.invoke(newEnvProviderInstance);\n+\n+        // call getRuntimeJobEnvironment() method on envProviderClass\n+        Method getRuntimeEnvMethod = envProviderClass.getMethod(\"getRuntimeJobEnvironment\");\n+        System.out.println(\"Invoking getRuntimeJobEnvironment() \" + runtimeProviderClassName);\n+        Object runtimeEnv = getRuntimeEnvMethod.invoke(newEnvProviderInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        System.out.println(\"Invoking run() on \" + runtimeJobClassName);\n+        method.invoke(runner.newInstance(), runtimeEnv);\n+\n+      } finally {\n+        // call close() method on envProviderClass\n+        Method closeMethod = envProviderClass.getMethod(\"close\");\n+        System.out.println(\"Invoking close() \" + runtimeProviderClassName);\n+        closeMethod.invoke(newEnvProviderInstance);\n+      }\n+\n+      System.out.println(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));\n+    Deque<URL> queue = new LinkedList<>(urlList);\n+    for (URL url : classpath) {\n+      if (url.toString().endsWith(\".jar\")) {\n+        addAllDeps(url, queue);\n+        queue.addFirst(url);\n+      } else {\n+        queue.addLast(url);\n+      }\n+    }\n+    System.out.println(\"Classpath URLs: \" + queue);\n+    return queue;\n+  }\n+\n+  private static URL[] createClasspath(File appJarDir, File twillJarDir, File resourceJarDir) throws IOException {", "originalCommit": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4ODE3MA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390588170", "bodyText": "sure.", "author": "CuriousVini", "createdAt": "2020-03-10T20:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwNzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwNzMwMQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390507301", "bodyText": "Use LOG instead.", "author": "chtyim", "createdAt": "2020-03-10T18:00:22Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final String RUNTIME_JOB_JAR = \"runtime.job.jar\";\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment provider class and create instance of it\n+      String runtimeProviderClassName = DataprocRuntimeEnvProvider.class.getName();\n+      Class<?> envProviderClass = newCL.loadClass(runtimeProviderClassName);\n+      Object newEnvProviderInstance = envProviderClass.newInstance();\n+\n+      try {\n+        // call initialize() method on envProviderClass\n+        Method initializeMethod = envProviderClass.getMethod(\"initialize\");\n+        System.out.println(\"Invoking initialize() on \" + runtimeProviderClassName);\n+        initializeMethod.invoke(newEnvProviderInstance);\n+\n+        // call getRuntimeJobEnvironment() method on envProviderClass\n+        Method getRuntimeEnvMethod = envProviderClass.getMethod(\"getRuntimeJobEnvironment\");\n+        System.out.println(\"Invoking getRuntimeJobEnvironment() \" + runtimeProviderClassName);\n+        Object runtimeEnv = getRuntimeEnvMethod.invoke(newEnvProviderInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        System.out.println(\"Invoking run() on \" + runtimeJobClassName);\n+        method.invoke(runner.newInstance(), runtimeEnv);\n+\n+      } finally {\n+        // call close() method on envProviderClass\n+        Method closeMethod = envProviderClass.getMethod(\"close\");\n+        System.out.println(\"Invoking close() \" + runtimeProviderClassName);\n+        closeMethod.invoke(newEnvProviderInstance);\n+      }\n+\n+      System.out.println(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));\n+    Deque<URL> queue = new LinkedList<>(urlList);\n+    for (URL url : classpath) {\n+      if (url.toString().endsWith(\".jar\")) {\n+        addAllDeps(url, queue);\n+        queue.addFirst(url);\n+      } else {\n+        queue.addLast(url);\n+      }\n+    }\n+    System.out.println(\"Classpath URLs: \" + queue);", "originalCommit": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NjIyMg==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390576222", "bodyText": "I followed the pattern similar to RemoteLauncher#main(). But I will change it to use logger.", "author": "CuriousVini", "createdAt": "2020-03-10T20:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwNzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwNzUxOA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390507518", "bodyText": "Use LOG", "author": "chtyim", "createdAt": "2020-03-10T18:00:42Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final String RUNTIME_JOB_JAR = \"runtime.job.jar\";\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment provider class and create instance of it\n+      String runtimeProviderClassName = DataprocRuntimeEnvProvider.class.getName();\n+      Class<?> envProviderClass = newCL.loadClass(runtimeProviderClassName);\n+      Object newEnvProviderInstance = envProviderClass.newInstance();\n+\n+      try {\n+        // call initialize() method on envProviderClass\n+        Method initializeMethod = envProviderClass.getMethod(\"initialize\");\n+        System.out.println(\"Invoking initialize() on \" + runtimeProviderClassName);\n+        initializeMethod.invoke(newEnvProviderInstance);\n+\n+        // call getRuntimeJobEnvironment() method on envProviderClass\n+        Method getRuntimeEnvMethod = envProviderClass.getMethod(\"getRuntimeJobEnvironment\");\n+        System.out.println(\"Invoking getRuntimeJobEnvironment() \" + runtimeProviderClassName);\n+        Object runtimeEnv = getRuntimeEnvMethod.invoke(newEnvProviderInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        System.out.println(\"Invoking run() on \" + runtimeJobClassName);\n+        method.invoke(runner.newInstance(), runtimeEnv);\n+\n+      } finally {\n+        // call close() method on envProviderClass\n+        Method closeMethod = envProviderClass.getMethod(\"close\");\n+        System.out.println(\"Invoking close() \" + runtimeProviderClassName);\n+        closeMethod.invoke(newEnvProviderInstance);\n+      }\n+\n+      System.out.println(\"Runtime job completed.\");", "originalCommit": "17da0f6b9524fcdbe14a43e04d7c49156179fc30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NjI5OA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390576298", "bodyText": "same as above.", "author": "CuriousVini", "createdAt": "2020-03-10T20:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwNzUxOA=="}], "type": "inlineReview"}, {"oid": "e93c9fbcd5eff0914b3bbae67b5aaf489c013b70", "url": "https://github.com/cdapio/cdap/commit/e93c9fbcd5eff0914b3bbae67b5aaf489c013b70", "message": "Addressing comments", "committedDate": "2020-03-10T23:56:06Z", "type": "forcePushed"}, {"oid": "8ae501ee42dff42e2b9a71d538d6163e4fc0b031", "url": "https://github.com/cdapio/cdap/commit/8ae501ee42dff42e2b9a71d538d6163e4fc0b031", "message": "Addressing comments", "committedDate": "2020-03-11T00:19:49Z", "type": "forcePushed"}, {"oid": "d1a874008e77cdcc2d5f876013c941f92b405ff9", "url": "https://github.com/cdapio/cdap/commit/d1a874008e77cdcc2d5f876013c941f92b405ff9", "message": "Addressing comments", "committedDate": "2020-03-11T00:51:28Z", "type": "forcePushed"}, {"oid": "3e330a3516d263e2719e00b26af4f8d66b597341", "url": "https://github.com/cdapio/cdap/commit/3e330a3516d263e2719e00b26af4f8d66b597341", "message": "Addressing comments", "committedDate": "2020-03-11T04:28:21Z", "type": "forcePushed"}, {"oid": "aa0be2aa2f91be5eeb326797b8cfd233fae081ad", "url": "https://github.com/cdapio/cdap/commit/aa0be2aa2f91be5eeb326797b8cfd233fae081ad", "message": "Use expanded jar to formulate classpath", "committedDate": "2020-03-11T09:41:20Z", "type": "forcePushed"}, {"oid": "4dc207b21917feb68f2c8ef8267cbb87fa45d811", "url": "https://github.com/cdapio/cdap/commit/4dc207b21917feb68f2c8ef8267cbb87fa45d811", "message": "Use expanded jar to formulate classpath", "committedDate": "2020-03-11T09:42:46Z", "type": "forcePushed"}, {"oid": "1634a5bdc06389a49a3591a41d5c75bbf1c849d4", "url": "https://github.com/cdapio/cdap/commit/1634a5bdc06389a49a3591a41d5c75bbf1c849d4", "message": "Use expanded jar to formulate classpath", "committedDate": "2020-03-11T16:28:04Z", "type": "forcePushed"}, {"oid": "e6eea12bba65527f603720ca437765782da7d8db", "url": "https://github.com/cdapio/cdap/commit/e6eea12bba65527f603720ca437765782da7d8db", "message": "Use expanded jar to formulate classpath", "committedDate": "2020-03-11T16:34:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc1MDA3NQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390750075", "bodyText": "This is unnecessary. You can pass Arrays.asList(urls) to the LinkedList constructor directly", "author": "chtyim", "createdAt": "2020-03-11T05:16:04Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jar\");\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl, tempDir);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl, Path tempDir) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));", "originalCommit": "3e330a3516d263e2719e00b26af4f8d66b597341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc1MTA0Nw==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r390751047", "bodyText": "You can use List.sort. It's simpler", "author": "chtyim", "createdAt": "2020-03-11T05:20:47Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jar\");\n+    Deque<URL> queue = getClasspath((URLClassLoader) cl, tempDir);\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(queue.toArray(new URL[0]), cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  private static Deque<URL> getClasspath(URLClassLoader cl, Path tempDir) throws IOException {\n+    File appJarDir = new File(Constants.Files.APPLICATION_JAR);\n+    File twillJarDir = new File(Constants.Files.TWILL_JAR);\n+    File resourceJarDir = new File(Constants.Files.RESOURCES_JAR);\n+    URL[] classpath = createClasspath(appJarDir, twillJarDir, resourceJarDir);\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>(Arrays.asList(urls));\n+    Deque<URL> queue = new LinkedList<>(urlList);\n+\n+    for (URL url : classpath) {\n+      if (url.toString().endsWith(\".jar\")) {\n+        addAllDeps(tempDir, url, queue);\n+        queue.addFirst(url);\n+      } else {\n+        queue.addLast(url);\n+      }\n+    }\n+    LOG.info(\"Classpath URLs: {}\", queue);\n+    return queue;\n+  }\n+\n+  /**\n+   * This method will first populate a list of {@link File} under the given directory that has \".jar\" as extension.\n+   * After that it will sort the jars from twill and jars from application together.\n+   */\n+  private static URL[] createClasspath(File appJarDir, File twillJarDir, File resourceJarDir) throws IOException {\n+    List<URL> urls = new ArrayList<>();\n+\n+    List<File> libJarFiles = listJarFiles(new File(appJarDir, \"lib\"), new ArrayList<>());\n+    Collections.sort(listJarFiles(new File(twillJarDir, \"lib\"), libJarFiles), Comparator.comparing(File::getName));", "originalCommit": "3e330a3516d263e2719e00b26af4f8d66b597341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyNzg5NA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r391127894", "bodyText": "Use Arrays.asList.", "author": "chtyim", "createdAt": "2020-03-11T17:09:15Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jars\");\n+    URL[] urls = getClasspath((URLClassLoader) cl, tempDir.toFile());\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(urls, cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  /**\n+   * This method will generate class path by adding following to urls to front of default classpath:\n+   *\n+   * expanded.resource.jar\n+   * expanded.application.jar\n+   * expanded.application.jar/lib/*.jar\n+   * expanded.application.jar/classes\n+   * expanded.twill.jar\n+   * expanded.twill.jar/lib/*.jar\n+   * expanded.twill.jar/classes\n+   *\n+   */\n+  private static URL[] getClasspath(URLClassLoader cl, File tempDir) throws IOException {\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>();\n+    for (String file : ImmutableList.of(Constants.Files.RESOURCES_JAR,", "originalCommit": "df325884e7924df7545c5dc8d84a978d1f12f338", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMzk2NQ==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r391133965", "bodyText": "For this case, probably better just log instead of throwing. As this could fail the job even the hadoop job succeeded.", "author": "chtyim", "createdAt": "2020-03-11T17:18:27Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jars\");\n+    URL[] urls = getClasspath((URLClassLoader) cl, tempDir.toFile());\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(urls, cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  /**\n+   * This method will generate class path by adding following to urls to front of default classpath:\n+   *\n+   * expanded.resource.jar\n+   * expanded.application.jar\n+   * expanded.application.jar/lib/*.jar\n+   * expanded.application.jar/classes\n+   * expanded.twill.jar\n+   * expanded.twill.jar/lib/*.jar\n+   * expanded.twill.jar/classes\n+   *\n+   */\n+  private static URL[] getClasspath(URLClassLoader cl, File tempDir) throws IOException {\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>();\n+    for (String file : ImmutableList.of(Constants.Files.RESOURCES_JAR,\n+                                        Constants.Files.APPLICATION_JAR,\n+                                        Constants.Files.TWILL_JAR)) {\n+      File jar = new File(file);\n+      File jarDir = new File(tempDir, \"expanded.\" + file);\n+      expand(jar, jarDir);\n+      // add url for dir\n+      urlList.add(jarDir.toURI().toURL());\n+      if (file.equals(Constants.Files.RESOURCES_JAR)) {\n+        continue;\n+      }\n+      urlList.addAll(createClassPathURLs(jarDir));\n+    }\n+\n+    urlList.addAll(Arrays.asList(urls));\n+\n+    LOG.info(\"Classpath URLs: {}\", Arrays.toString(urlList.toArray()));\n+    return urlList.toArray(new URL[0]);\n+  }\n+\n+  /**\n+   * Expands jar into destination directory.\n+   */\n+  private static void expand(File jarFile, File destDir) throws IOException {\n+    try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarFile)))) {\n+      Path targetPath = destDir.toPath();\n+      Files.createDirectories(targetPath);\n+\n+      ZipEntry entry;\n+      while ((entry = zipIn.getNextEntry()) != null) {\n+        Path output = targetPath.resolve(entry.getName());\n+\n+        if (entry.isDirectory()) {\n+          Files.createDirectories(output);\n+        } else {\n+          Files.createDirectories(output.getParent());\n+          Files.copy(zipIn, output);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static List<URL> createClassPathURLs(File dir) {\n+    try {\n+      List<URL> urls = new ArrayList<>();\n+      // add jar urls from lib under dir\n+      addJarURLs(new File(dir, \"lib\"), urls);\n+      // add classes under dir\n+      urls.add(new File(dir, \"classes\").toURI().toURL());\n+      return urls;\n+    } catch (MalformedURLException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static void addJarURLs(File dir, List<URL> result) throws MalformedURLException {\n+    Optional<File[]> files = Optional.ofNullable(dir.listFiles(f -> f.getName().endsWith(\".jar\")));\n+    if (files.isPresent()) {\n+      for (File file : files.get()) {\n+        result.add(file.toURI().toURL());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Recursively deletes all the contents of the directory and the directory itself.\n+   */\n+  private static void deleteDirectoryContents(File file) throws IOException {\n+    if (file.isDirectory()) {\n+      File[] entries = file.listFiles();\n+      if (entries != null) {\n+        for (File entry : entries) {\n+          deleteDirectoryContents(entry);\n+        }\n+      }\n+    }\n+    if (!file.delete()) {\n+      throw new IOException(\"Failed to delete \" + file);", "originalCommit": "df325884e7924df7545c5dc8d84a978d1f12f338", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzNjQ4NA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r391136484", "bodyText": "If you are checking isPresent, it will as well be simpler not to use Optional, but rather just if (files != null)", "author": "chtyim", "createdAt": "2020-03-11T17:22:18Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jars\");\n+    URL[] urls = getClasspath((URLClassLoader) cl, tempDir.toFile());\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(urls, cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  /**\n+   * This method will generate class path by adding following to urls to front of default classpath:\n+   *\n+   * expanded.resource.jar\n+   * expanded.application.jar\n+   * expanded.application.jar/lib/*.jar\n+   * expanded.application.jar/classes\n+   * expanded.twill.jar\n+   * expanded.twill.jar/lib/*.jar\n+   * expanded.twill.jar/classes\n+   *\n+   */\n+  private static URL[] getClasspath(URLClassLoader cl, File tempDir) throws IOException {\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>();\n+    for (String file : ImmutableList.of(Constants.Files.RESOURCES_JAR,\n+                                        Constants.Files.APPLICATION_JAR,\n+                                        Constants.Files.TWILL_JAR)) {\n+      File jar = new File(file);\n+      File jarDir = new File(tempDir, \"expanded.\" + file);\n+      expand(jar, jarDir);\n+      // add url for dir\n+      urlList.add(jarDir.toURI().toURL());\n+      if (file.equals(Constants.Files.RESOURCES_JAR)) {\n+        continue;\n+      }\n+      urlList.addAll(createClassPathURLs(jarDir));\n+    }\n+\n+    urlList.addAll(Arrays.asList(urls));\n+\n+    LOG.info(\"Classpath URLs: {}\", Arrays.toString(urlList.toArray()));\n+    return urlList.toArray(new URL[0]);\n+  }\n+\n+  /**\n+   * Expands jar into destination directory.\n+   */\n+  private static void expand(File jarFile, File destDir) throws IOException {\n+    try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarFile)))) {\n+      Path targetPath = destDir.toPath();\n+      Files.createDirectories(targetPath);\n+\n+      ZipEntry entry;\n+      while ((entry = zipIn.getNextEntry()) != null) {\n+        Path output = targetPath.resolve(entry.getName());\n+\n+        if (entry.isDirectory()) {\n+          Files.createDirectories(output);\n+        } else {\n+          Files.createDirectories(output.getParent());\n+          Files.copy(zipIn, output);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static List<URL> createClassPathURLs(File dir) {\n+    try {\n+      List<URL> urls = new ArrayList<>();\n+      // add jar urls from lib under dir\n+      addJarURLs(new File(dir, \"lib\"), urls);\n+      // add classes under dir\n+      urls.add(new File(dir, \"classes\").toURI().toURL());\n+      return urls;\n+    } catch (MalformedURLException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static void addJarURLs(File dir, List<URL> result) throws MalformedURLException {\n+    Optional<File[]> files = Optional.ofNullable(dir.listFiles(f -> f.getName().endsWith(\".jar\")));\n+    if (files.isPresent()) {", "originalCommit": "df325884e7924df7545c5dc8d84a978d1f12f338", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE0MDE1Mw==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r391140153", "bodyText": "Why wrapping? Just throw is out is better", "author": "chtyim", "createdAt": "2020-03-11T17:27:33Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jars\");\n+    URL[] urls = getClasspath((URLClassLoader) cl, tempDir.toFile());\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(urls, cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  /**\n+   * This method will generate class path by adding following to urls to front of default classpath:\n+   *\n+   * expanded.resource.jar\n+   * expanded.application.jar\n+   * expanded.application.jar/lib/*.jar\n+   * expanded.application.jar/classes\n+   * expanded.twill.jar\n+   * expanded.twill.jar/lib/*.jar\n+   * expanded.twill.jar/classes\n+   *\n+   */\n+  private static URL[] getClasspath(URLClassLoader cl, File tempDir) throws IOException {\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>();\n+    for (String file : ImmutableList.of(Constants.Files.RESOURCES_JAR,\n+                                        Constants.Files.APPLICATION_JAR,\n+                                        Constants.Files.TWILL_JAR)) {\n+      File jar = new File(file);\n+      File jarDir = new File(tempDir, \"expanded.\" + file);\n+      expand(jar, jarDir);\n+      // add url for dir\n+      urlList.add(jarDir.toURI().toURL());\n+      if (file.equals(Constants.Files.RESOURCES_JAR)) {\n+        continue;\n+      }\n+      urlList.addAll(createClassPathURLs(jarDir));\n+    }\n+\n+    urlList.addAll(Arrays.asList(urls));\n+\n+    LOG.info(\"Classpath URLs: {}\", Arrays.toString(urlList.toArray()));\n+    return urlList.toArray(new URL[0]);\n+  }\n+\n+  /**\n+   * Expands jar into destination directory.\n+   */\n+  private static void expand(File jarFile, File destDir) throws IOException {\n+    try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarFile)))) {\n+      Path targetPath = destDir.toPath();\n+      Files.createDirectories(targetPath);\n+\n+      ZipEntry entry;\n+      while ((entry = zipIn.getNextEntry()) != null) {\n+        Path output = targetPath.resolve(entry.getName());\n+\n+        if (entry.isDirectory()) {\n+          Files.createDirectories(output);\n+        } else {\n+          Files.createDirectories(output.getParent());\n+          Files.copy(zipIn, output);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static List<URL> createClassPathURLs(File dir) {\n+    try {\n+      List<URL> urls = new ArrayList<>();\n+      // add jar urls from lib under dir\n+      addJarURLs(new File(dir, \"lib\"), urls);\n+      // add classes under dir\n+      urls.add(new File(dir, \"classes\").toURI().toURL());\n+      return urls;\n+    } catch (MalformedURLException e) {\n+      throw new RuntimeException(e);", "originalCommit": "df325884e7924df7545c5dc8d84a978d1f12f338", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE0MDUxMA==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r391140510", "bodyText": "toArray() too many times. Just log with the list.", "author": "chtyim", "createdAt": "2020-03-11T17:28:07Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jars\");\n+    URL[] urls = getClasspath((URLClassLoader) cl, tempDir.toFile());\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(urls, cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        try {\n+          // make sure directory is cleaned before exiting\n+          deleteDirectoryContents(tempDir.toFile());\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to delete temporary directory {}. \", tempDir, e);\n+        }\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  /**\n+   * This method will generate class path by adding following to urls to front of default classpath:\n+   *\n+   * expanded.resource.jar\n+   * expanded.application.jar\n+   * expanded.application.jar/lib/*.jar\n+   * expanded.application.jar/classes\n+   * expanded.twill.jar\n+   * expanded.twill.jar/lib/*.jar\n+   * expanded.twill.jar/classes\n+   *\n+   */\n+  private static URL[] getClasspath(URLClassLoader cl, File tempDir) throws IOException {\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>();\n+    for (String file : ImmutableList.of(Constants.Files.RESOURCES_JAR,\n+                                        Constants.Files.APPLICATION_JAR,\n+                                        Constants.Files.TWILL_JAR)) {\n+      File jar = new File(file);\n+      File jarDir = new File(tempDir, \"expanded.\" + file);\n+      expand(jar, jarDir);\n+      // add url for dir\n+      urlList.add(jarDir.toURI().toURL());\n+      if (file.equals(Constants.Files.RESOURCES_JAR)) {\n+        continue;\n+      }\n+      urlList.addAll(createClassPathURLs(jarDir));\n+    }\n+\n+    urlList.addAll(Arrays.asList(urls));\n+\n+    LOG.info(\"Classpath URLs: {}\", Arrays.toString(urlList.toArray()));", "originalCommit": "df325884e7924df7545c5dc8d84a978d1f12f338", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE5NzI1Mw==", "url": "https://github.com/cdapio/cdap/pull/11945#discussion_r391197253", "bodyText": "Can dir be null at all?", "author": "chtyim", "createdAt": "2020-03-11T19:02:29Z", "path": "cdap-runtime-ext-dataproc/src/main/java/io/cdap/cdap/runtime/spi/runtimejob/DataprocJobMain.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.runtime.spi.runtimejob;\n+\n+import org.apache.twill.internal.Constants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * Main class that will be called from dataproc driver.\n+ */\n+public class DataprocJobMain {\n+  private static final Logger LOG = LoggerFactory.getLogger(DataprocJobMain.class);\n+\n+  /**\n+   * Main method to setup classpath and call the RuntimeJob.run() method.\n+   *\n+   * @param args the name of implementation of RuntimeJob class\n+   * @throws Exception any exception while running the job\n+   */\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 1) {\n+      throw new RuntimeException(\"An implementation of RuntimeJob classname should be provided as an argument.\");\n+    }\n+    String runtimeJobClassName = args[0];\n+\n+    ClassLoader cl = DataprocJobMain.class.getClassLoader();\n+    if (!(cl instanceof URLClassLoader)) {\n+      throw new RuntimeException(\"Classloader is expected to be an instance of URLClassLoader\");\n+    }\n+\n+    // get classpath\n+    Path tempDir = Files.createTempDirectory(\"expanded.jars\");\n+    URL[] urls = getClasspath((URLClassLoader) cl, tempDir.toFile());\n+\n+    // create new URL classloader with provided classpath\n+    try (URLClassLoader newCL = new URLClassLoader(urls, cl.getParent())) {\n+      Thread.currentThread().setContextClassLoader(newCL);\n+\n+      // load environment class and create instance of it\n+      String dataprocEnvClassName = DataprocRuntimeEnvironment.class.getName();\n+      Class<?> dataprocEnvClass = newCL.loadClass(dataprocEnvClassName);\n+      Object newDataprocEnvInstance = dataprocEnvClass.newInstance();\n+\n+      try {\n+        // call initialize() method on dataprocEnvClass\n+        Method initializeMethod = dataprocEnvClass.getMethod(\"initialize\");\n+        LOG.info(\"Invoking initialize() on {}\", dataprocEnvClassName);\n+        initializeMethod.invoke(newDataprocEnvInstance);\n+\n+        // call run() method on runtimeJobClass\n+        Class<?> runEnvCls = newCL.loadClass(RuntimeJobEnvironment.class.getName());\n+        Class<?> runner = newCL.loadClass(runtimeJobClassName);\n+        Method method = runner.getMethod(\"run\", runEnvCls);\n+        LOG.info(\"Invoking run() on {}\", runtimeJobClassName);\n+        method.invoke(runner.newInstance(), newDataprocEnvInstance);\n+\n+      } finally {\n+        // call destroy() method on envProviderClass\n+        Method closeMethod = dataprocEnvClass.getMethod(\"destroy\");\n+        LOG.info(\"Invoking destroy() on {}\", runtimeJobClassName);\n+        closeMethod.invoke(newDataprocEnvInstance);\n+        // make sure directory is cleaned before exiting\n+        deleteDirectoryContents(tempDir.toFile());\n+      }\n+\n+      LOG.info(\"Runtime job completed.\");\n+    }\n+  }\n+\n+  /**\n+   * This method will generate class path by adding following to urls to front of default classpath:\n+   *\n+   * expanded.resource.jar\n+   * expanded.application.jar\n+   * expanded.application.jar/lib/*.jar\n+   * expanded.application.jar/classes\n+   * expanded.twill.jar\n+   * expanded.twill.jar/lib/*.jar\n+   * expanded.twill.jar/classes\n+   *\n+   */\n+  private static URL[] getClasspath(URLClassLoader cl, File tempDir) throws IOException {\n+    URL[] urls = cl.getURLs();\n+    List<URL> urlList = new ArrayList<>();\n+    for (String file : Arrays.asList(Constants.Files.RESOURCES_JAR, Constants.Files.APPLICATION_JAR,\n+                                     Constants.Files.TWILL_JAR)) {\n+      File jar = new File(file);\n+      File jarDir = new File(tempDir, \"expanded.\" + file);\n+      expand(jar, jarDir);\n+      // add url for dir\n+      urlList.add(jarDir.toURI().toURL());\n+      if (file.equals(Constants.Files.RESOURCES_JAR)) {\n+        continue;\n+      }\n+      urlList.addAll(createClassPathURLs(jarDir));\n+    }\n+\n+    urlList.addAll(Arrays.asList(urls));\n+\n+    LOG.info(\"Classpath URLs: {}\", urlList);\n+    return urlList.toArray(new URL[0]);\n+  }\n+\n+  /**\n+   * Expands jar into destination directory.\n+   */\n+  private static void expand(File jarFile, File destDir) throws IOException {\n+    try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarFile)))) {\n+      Path targetPath = destDir.toPath();\n+      Files.createDirectories(targetPath);\n+\n+      ZipEntry entry;\n+      while ((entry = zipIn.getNextEntry()) != null) {\n+        Path output = targetPath.resolve(entry.getName());\n+\n+        if (entry.isDirectory()) {\n+          Files.createDirectories(output);\n+        } else {\n+          Files.createDirectories(output.getParent());\n+          Files.copy(zipIn, output);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static List<URL> createClassPathURLs(File dir) throws MalformedURLException {\n+    List<URL> urls = new ArrayList<>();\n+    // add jar urls from lib under dir\n+    addJarURLs(new File(dir, \"lib\"), urls);\n+    // add classes under dir\n+    urls.add(new File(dir, \"classes\").toURI().toURL());\n+    return urls;\n+  }\n+\n+  private static void addJarURLs(File dir, List<URL> result) throws MalformedURLException {\n+    if (dir == null || dir.listFiles() == null) {", "originalCommit": "c0e8a944a9b14eff46d94e2a1c7322b4b198a7da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8da208dea41e91f5f7b26d80fbf7eb2196a02225", "url": "https://github.com/cdapio/cdap/commit/8da208dea41e91f5f7b26d80fbf7eb2196a02225", "message": "[CDAP-15633] Add main class that will run on Dataproc driver", "committedDate": "2020-03-11T19:08:06Z", "type": "commit"}, {"oid": "8da208dea41e91f5f7b26d80fbf7eb2196a02225", "url": "https://github.com/cdapio/cdap/commit/8da208dea41e91f5f7b26d80fbf7eb2196a02225", "message": "[CDAP-15633] Add main class that will run on Dataproc driver", "committedDate": "2020-03-11T19:08:06Z", "type": "forcePushed"}]}