{"pr_number": 11925, "pr_title": "CDAP-16386 fix merged operations fll", "pr_createdAt": "2020-03-06T02:09:28Z", "pr_url": "https://github.com/cdapio/cdap/pull/11925", "timeline": [{"oid": "58454c2a30286f45e5df85cb0a5746005a7f8219", "url": "https://github.com/cdapio/cdap/commit/58454c2a30286f45e5df85cb0a5746005a7f8219", "message": "CDAP-16386 fix merged operations fll", "committedDate": "2020-03-06T21:55:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NjU0OA==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389196548", "bodyText": "extra space after =", "author": "albertshau", "createdAt": "2020-03-06T23:48:18Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -86,15 +87,17 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n \n   private Map<String, Operation> computeProcessedOperations() {\n     Map<String, Operation> processedOperations = new HashMap<>();\n+    // this stores information about all the outputs on a merge stage, the key is the prefix of the merge\n+    Map<String, List<String>> mergedOutputs = new HashMap<>();\n     for (String stageName : topologicalOrder) {\n       Set<String> stageInputs = stageDag.getNodeInputs(stageName);\n       if (stageInputs.size() > 1 && !noMergeRequiredStages.contains(stageName)) {\n-        addMergeOperation(stageInputs, processedOperations);\n+        addMergeOperation(stageInputs, processedOperations, mergedOutputs);\n       }\n       List<FieldOperation> fieldOperations = stageOperations.get(stageName);\n       for (FieldOperation fieldOperation : fieldOperations) {\n         Operation newOperation = null;\n-        String newOperationName =  prefixedOperationName(stageName, fieldOperation.getName());\n+        String newOperationName =  prefixedName(stageName, fieldOperation.getName());", "originalCommit": "58454c2a30286f45e5df85cb0a5746005a7f8219", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5ODE0NQ==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389198145", "bodyText": "I don't understand what this represents. What is a merge stage? What is a prefix of a merge?", "author": "albertshau", "createdAt": "2020-03-06T23:55:50Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -86,15 +87,17 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n \n   private Map<String, Operation> computeProcessedOperations() {\n     Map<String, Operation> processedOperations = new HashMap<>();\n+    // this stores information about all the outputs on a merge stage, the key is the prefix of the merge\n+    Map<String, List<String>> mergedOutputs = new HashMap<>();", "originalCommit": "58454c2a30286f45e5df85cb0a5746005a7f8219", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0MDM3Mw==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389540373", "bodyText": "Removed this to reduce complication", "author": "yaojiefeng", "createdAt": "2020-03-09T09:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5ODE0NQ=="}], "type": "inlineReview"}, {"oid": "81b89f5ac567ec2cb887295d3fa3cb108fff239d", "url": "https://github.com/cdapio/cdap/commit/81b89f5ac567ec2cb887295d3fa3cb108fff239d", "message": "add comments and remove the unnessary map", "committedDate": "2020-03-09T10:06:06Z", "type": "forcePushed"}, {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "url": "https://github.com/cdapio/cdap/commit/c8e29358a07aee38221b6ab3de01fcd72931d5ad", "message": "add comments and remove duplicate origins in parenet stages", "committedDate": "2020-03-09T11:33:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTAzMg==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389959032", "bodyText": "we should get rid of them. Multiple inputs going into a non-joiner is a no-op since nothing changes in the data. It should not generate a new operation.", "author": "albertshau", "createdAt": "2020-03-09T21:00:51Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -47,8 +48,16 @@\n  * converting it into the form the platform expects. This includes prefixing operation names\n  * to make sure they are unique across all the plugins, adding implicit merge operations when\n  * stage has more than one input etc.\n+ * The platform operation requires each operation to specify the previous operation name and the operation name has\n+ * to be unique. Therefore this class will prefix each operation name with the stage name, i.e,\n+ * {stage-name}.{original-name}. When a stage has multiple input stages except Joiner, implicit merge operations are\n+ * generated in order for future stages to look up the previous operations.\n+ *\n+ * TODO: CDAP-16395 revisit this class to see if we can get rid of the merge operations since user will be confused\n+ * about it. If we cannot, should just make this class more understandable.", "originalCommit": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MjQ5Mw==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389972493", "bodyText": "Yea, we should remove it, but in 6.2 it is too risky. It is better we do it early in next release.", "author": "yaojiefeng", "createdAt": "2020-03-09T21:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTI4OQ==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389959289", "bodyText": "transform3 -> t3 (to match the diagram)", "author": "albertshau", "createdAt": "2020-03-09T21:01:20Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:", "originalCommit": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2MTE5MQ==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389961191", "bodyText": "with this example, stageInputs = <t1, t2> and processedOperations contains operations for src1, src2, t1, and t2?", "author": "albertshau", "createdAt": "2020-03-09T21:05:26Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c", "originalCommit": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3NTk3MA==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389975970", "bodyText": "Yes, updated the javadoc", "author": "yaojiefeng", "createdAt": "2020-03-09T21:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2MTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2OTg3Ng==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389969876", "bodyText": "can you add some comments describing what the key and values are. An example would help as well.", "author": "albertshau", "createdAt": "2020-03-09T21:23:42Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();", "originalCommit": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3ODc1Nw==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389978757", "bodyText": "Added comments", "author": "yaojiefeng", "createdAt": "2020-03-09T21:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2OTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MDM3Ng==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389970376", "bodyText": "this makes it look like it's still a many to many operation. Would be better to change the Map<String, List<InputField>> into a Map<String, Set>` so that it is clear there is only ever one output, which is the fieldName.", "author": "albertshau", "createdAt": "2020-03-09T21:24:48Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();\n+    // create the map that contains the field name of the current stages and the parent stages to the origins\n     for (String inputStage : sortedInputs) {\n       List<String> parentStages = findParentStages(inputStage);\n+      // traverse in a reverse order of parent stages since the parent stages will contain the closest parent\n+      // at the end of the list\n+      Collections.reverse(parentStages);\n+      // this stores the visited field, if we already know the field from the previous parent, do not\n+      // add other origin of this field\n+      Set<String> visitedField = new HashSet<>();\n       for (String parentStage : parentStages) {\n+        // get the map of all the outputs to the origin map from a stage\n         Map<String, String> fieldOrigins = stageOutputsWithOrigins.get(parentStage);\n         for (Map.Entry<String, String> fieldOrigin : fieldOrigins.entrySet()) {\n-          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldOrigin.getKey()));\n+          String fieldName = fieldOrigin.getKey();\n+          if (visitedField.contains(fieldName)) {\n+            continue;\n+          }\n+          List<InputField> inputFields = fieldNameMap.computeIfAbsent(fieldName, k -> new ArrayList<>());\n+          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldName));\n+          visitedField.add(fieldName);\n         }\n       }\n     }\n \n-    Set<String> outputs = new LinkedHashSet<>();\n-    for (InputField inputField : inputFields) {\n-      outputs.add(inputField.getName());\n-    }\n-    TransformOperation merge = new TransformOperation(mergeOperationName, mergeDescription, inputFields,\n-                                                      new ArrayList<>(outputs));\n-    processedOperations.put(merge.getName(), merge);\n+    fieldNameMap.forEach((fieldName, inputFields) -> {\n+      String mergeName = prefixedName(mergeOperationNamePrefix, fieldName);\n+      if (processedOperations.containsKey(mergeName)) {\n+        // it is possible that same stages act as an input to multiple stages.\n+        // we should still only add single merge operation for them\n+        return;\n+      }\n+\n+      Set<String> outputs = new LinkedHashSet<>();", "originalCommit": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3NTUzMA==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389975530", "bodyText": "Changed this to a  Map<String, List<String>> , where the value is list of origins of the field, a list better matches the API since the transform operation expects a list instead of a set", "author": "yaojiefeng", "createdAt": "2020-03-09T21:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MDM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MDUzNg==", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389970536", "bodyText": "I think it's more understandable for this to be Collections.singletonList(fieldName)", "author": "albertshau", "createdAt": "2020-03-09T21:25:10Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();\n+    // create the map that contains the field name of the current stages and the parent stages to the origins\n     for (String inputStage : sortedInputs) {\n       List<String> parentStages = findParentStages(inputStage);\n+      // traverse in a reverse order of parent stages since the parent stages will contain the closest parent\n+      // at the end of the list\n+      Collections.reverse(parentStages);\n+      // this stores the visited field, if we already know the field from the previous parent, do not\n+      // add other origin of this field\n+      Set<String> visitedField = new HashSet<>();\n       for (String parentStage : parentStages) {\n+        // get the map of all the outputs to the origin map from a stage\n         Map<String, String> fieldOrigins = stageOutputsWithOrigins.get(parentStage);\n         for (Map.Entry<String, String> fieldOrigin : fieldOrigins.entrySet()) {\n-          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldOrigin.getKey()));\n+          String fieldName = fieldOrigin.getKey();\n+          if (visitedField.contains(fieldName)) {\n+            continue;\n+          }\n+          List<InputField> inputFields = fieldNameMap.computeIfAbsent(fieldName, k -> new ArrayList<>());\n+          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldName));\n+          visitedField.add(fieldName);\n         }\n       }\n     }\n \n-    Set<String> outputs = new LinkedHashSet<>();\n-    for (InputField inputField : inputFields) {\n-      outputs.add(inputField.getName());\n-    }\n-    TransformOperation merge = new TransformOperation(mergeOperationName, mergeDescription, inputFields,\n-                                                      new ArrayList<>(outputs));\n-    processedOperations.put(merge.getName(), merge);\n+    fieldNameMap.forEach((fieldName, inputFields) -> {\n+      String mergeName = prefixedName(mergeOperationNamePrefix, fieldName);\n+      if (processedOperations.containsKey(mergeName)) {\n+        // it is possible that same stages act as an input to multiple stages.\n+        // we should still only add single merge operation for them\n+        return;\n+      }\n+\n+      Set<String> outputs = new LinkedHashSet<>();\n+      for (InputField inputField : inputFields) {\n+        outputs.add(inputField.getName());\n+      }\n+\n+      TransformOperation merge = new TransformOperation(mergeName, mergeDescription, inputFields,\n+                                                        new ArrayList<>(outputs));", "originalCommit": "c8e29358a07aee38221b6ab3de01fcd72931d5ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64a6c3cc302ab872ba58712032c9b8db8346a661", "url": "https://github.com/cdapio/cdap/commit/64a6c3cc302ab872ba58712032c9b8db8346a661", "message": "CDAP-16386 CDAP-16392 fix merged operations fll and joiner fll", "committedDate": "2020-03-09T23:42:39Z", "type": "commit"}, {"oid": "64a6c3cc302ab872ba58712032c9b8db8346a661", "url": "https://github.com/cdapio/cdap/commit/64a6c3cc302ab872ba58712032c9b8db8346a661", "message": "CDAP-16386 CDAP-16392 fix merged operations fll and joiner fll", "committedDate": "2020-03-09T23:42:39Z", "type": "forcePushed"}]}