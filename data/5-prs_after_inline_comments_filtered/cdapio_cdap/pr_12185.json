{"pr_number": 12185, "pr_title": "CDAP-16708 add API for autojoiner", "pr_createdAt": "2020-05-19T00:07:59Z", "pr_url": "https://github.com/cdapio/cdap/pull/12185", "timeline": [{"oid": "ad1ec9a0ffdbfdb17015f5d67e28b19eb224b8db", "url": "https://github.com/cdapio/cdap/commit/ad1ec9a0ffdbfdb17015f5d67e28b19eb224b8db", "message": "CDAP-16708 add API for autojoiner\n\nAdd a new set of classes for AutoJoiner, which can be used instead\nof the current Joiner interface. This new API leaves all of the\nimplementation details up to the application, which will allow the\napp to perform the join in better ways. For example, in the Spark\nprogram, it will allow using broadcast joins.\n\nPlugin developers are responsible for returning a JoinDefinition\nbased on information about incoming stages.\n\nThis change includes the JoinDefinition as well as all the classes\nrequired to create a definition. It also includes validation logic\nto make sure the plugin cannot create a definition that tries to\njoin on a field that doesn't exist, or tries to join on fields\nthat have mismatched types, or any other type of error.", "committedDate": "2020-05-19T00:15:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MTIyNw==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427091227", "bodyText": "For boolean field, use isDropNullKeys().", "author": "chtyim", "createdAt": "2020-05-19T07:37:47Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean shouldDropNullKeys() {", "originalCommit": "ad1ec9a0ffdbfdb17015f5d67e28b19eb224b8db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MzQ3Nw==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427093477", "bodyText": "No need to have else after a throw inside the if block.", "author": "chtyim", "createdAt": "2020-05-19T07:41:52Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean shouldDropNullKeys() {\n+      return dropNullKeys;\n+    }\n+\n+    @Override\n+    public void validate(List<JoinStage> joinStages) {\n+      super.validate(joinStages);\n+\n+      Map<String, JoinStage> stageMap = joinStages.stream()\n+        .collect(Collectors.toMap(JoinStage::getStageName, s -> s));\n+\n+      for (JoinKey joinKey : keys) {\n+        String joinStageName = joinKey.getStageName();\n+        JoinStage joinStage = stageMap.get(joinStageName);\n+        // check that the stage for each key is in the list of stages\n+        if (joinStage == null) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Stage '%s' is not a join input.\",\n+            joinStageName, joinStageName));\n+        }\n+        // this happens if the schema for that stage is unknown.\n+        // for example, because of macros could not be evaluated yet.\n+        if (joinStage.getSchema() == null) {\n+          continue;\n+        }\n+        Set<String> fields = joinStage.getSchema().getFields().stream()\n+          .map(Schema.Field::getName)\n+          .collect(Collectors.toSet());\n+\n+        // check that the key fields for each key is in fields for that stage\n+        // for example, when joining on A.id = B.uid, check that 'id' is in the fields for stage A and 'uid' for stage B\n+        Set<String> keysCopy = new HashSet<>(joinKey.getFields());\n+        keysCopy.removeAll(fields);\n+        if (keysCopy.size() == 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Field '%s' does not exist in the stage.\",\n+            joinStageName, keysCopy.iterator().next()));\n+        } else if (keysCopy.size() > 1) {", "originalCommit": "ad1ec9a0ffdbfdb17015f5d67e28b19eb224b8db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTc5NA==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427441794", "bodyText": "this is an else-if, since it's also possible the set is empty, in which case it's valid. I can restructure this a little to make it more clear", "author": "albertshau", "createdAt": "2020-05-19T16:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MzQ3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NzU1MA==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427447550", "bodyText": "I mean it's cleaner to write:\nif (keyCopy.size() == 1) {\n  throw\n}\nif (keyCopy.size() > 1) {\n  throw\n}", "author": "chtyim", "createdAt": "2020-05-19T16:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5NzQyOA==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427097428", "bodyText": "Just call it required (so that the getter is isRequired).", "author": "chtyim", "createdAt": "2020-05-19T07:48:45Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinStage.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an input stage to the auto join.\n+ */\n+public class JoinStage {\n+  private final String stageName;\n+  private final Schema schema;\n+  private final boolean isRequired;", "originalCommit": "ad1ec9a0ffdbfdb17015f5d67e28b19eb224b8db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5NzU3MQ==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427097571", "bodyText": "Call it broadcast.", "author": "chtyim", "createdAt": "2020-05-19T07:48:59Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinStage.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an input stage to the auto join.\n+ */\n+public class JoinStage {\n+  private final String stageName;\n+  private final Schema schema;\n+  private final boolean isRequired;\n+  private final boolean shouldBroadcast;", "originalCommit": "ad1ec9a0ffdbfdb17015f5d67e28b19eb224b8db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzODM1Nw==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427538357", "bodyText": "Prefer to call this JoinField.", "author": "chtyim", "createdAt": "2020-05-19T19:12:14Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/Field.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.annotation.Beta;\n+\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The name of a field and an optional alias to rename it to.\n+ */\n+@Beta\n+public class Field {", "originalCommit": "519f12991e865ed26a7f91dc4e5c1e9d665c794e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzOTUwMQ==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427539501", "bodyText": "Better match the method name with the variable. setDropNullKeys.", "author": "chtyim", "createdAt": "2020-05-19T19:14:22Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean isDropNullKeys() {\n+      return dropNullKeys;\n+    }\n+\n+    @Override\n+    public void validate(List<JoinStage> joinStages) {\n+      super.validate(joinStages);\n+\n+      Map<String, JoinStage> stageMap = joinStages.stream()\n+        .collect(Collectors.toMap(JoinStage::getStageName, s -> s));\n+\n+      for (JoinKey joinKey : keys) {\n+        String joinStageName = joinKey.getStageName();\n+        JoinStage joinStage = stageMap.get(joinStageName);\n+        // check that the stage for each key is in the list of stages\n+        if (joinStage == null) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Stage '%s' is not a join input.\",\n+            joinStageName, joinStageName));\n+        }\n+        // this happens if the schema for that stage is unknown.\n+        // for example, because of macros could not be evaluated yet.\n+        if (joinStage.getSchema() == null) {\n+          continue;\n+        }\n+        Set<String> fields = joinStage.getSchema().getFields().stream()\n+          .map(Schema.Field::getName)\n+          .collect(Collectors.toSet());\n+\n+        // check that the key fields for each key is in fields for that stage\n+        // for example, when joining on A.id = B.uid, check that 'id' is in the fields for stage A and 'uid' for stage B\n+        Set<String> keysCopy = new HashSet<>(joinKey.getFields());\n+        keysCopy.removeAll(fields);\n+        if (keysCopy.size() == 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Field '%s' does not exist in the stage.\",\n+            joinStageName, keysCopy.iterator().next()));\n+        }\n+        if (keysCopy.size() > 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Fields %s do not exist in the stage.\",\n+            joinStageName, String.join(\", \", keysCopy)));\n+        }\n+      }\n+\n+      // check that the keys have the same type.\n+\n+      Iterator<JoinKey> keyIter = keys.iterator();\n+      JoinKey key1 = keyIter.next();\n+      // stage is guaranteed to be exist because of above validation\n+      Schema schema1 = stageMap.get(key1.getStageName()).getSchema();\n+      if (schema1 == null) {\n+        return;\n+      }\n+      while (keyIter.hasNext()) {\n+        JoinKey otherKey = keyIter.next();\n+        Schema otherSchema = stageMap.get(otherKey.getStageName()).getSchema();\n+        if (otherSchema == null) {\n+          continue;\n+        }\n+        Iterator<String> fieldIter = otherKey.getFields().iterator();\n+        for (String key1Field : key1.getFields()) {\n+          // guaranteed to be non-null because of earlier validation\n+          Schema key1Schema = schema1.getField(key1Field).getSchema();\n+          key1Schema = key1Schema.isNullable() ? key1Schema.getNonNullable() : key1Schema;\n+          Schema.Type key1Type = key1Schema.getType();\n+\n+          // don't need to check hasNext() because already verified they are all the same length\n+          String otherField = fieldIter.next();\n+          Schema otherFieldSchema = otherSchema.getField(otherField).getSchema();\n+          otherFieldSchema = otherFieldSchema.isNullable() ? otherFieldSchema.getNonNullable() : otherFieldSchema;\n+          Schema.Type otherType = otherFieldSchema.getType();\n+\n+          if (key1Type != otherType) {\n+            throw new InvalidJoinConditionException(String.format(\n+              \"Type mismatch on join keys. '%s'.'%s' is of type '%s' while '%s'.'%s' is of type '%s'.\",\n+              key1.getStageName(), key1Field, key1Schema.getDisplayName(),\n+              otherKey.getStageName(), otherField, otherFieldSchema.getDisplayName()));\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Builds an OnKeys condition.\n+     */\n+    public static class Builder {\n+      private final Set<JoinKey> keys;\n+      private boolean dropNullKeys;\n+\n+      private Builder() {\n+        this.keys = new HashSet<>();\n+        this.dropNullKeys = false;\n+      }\n+\n+      public Builder addKey(JoinKey key) {\n+        this.keys.add(key);\n+        return this;\n+      }\n+\n+      public Builder setKeys(Collection<JoinKey> keys) {\n+        this.keys.clear();\n+        this.keys.addAll(keys);\n+        return this;\n+      }\n+\n+      public Builder setShouldDropNullKeys(boolean dropNullKeys) {", "originalCommit": "519f12991e865ed26a7f91dc4e5c1e9d665c794e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0Mzg5NQ==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427543895", "bodyText": "I think it's better to iterate through the numFioeldsToStages to use all stages to form the error message. E.g. if the map is like this:\n{\n  1: [\"s1\"],\n  2: [\"s2\"],\n  3: [\"s3\"]\n}\n\nIt's better to show all the stages with the number of join fields that they declared.", "author": "chtyim", "createdAt": "2020-05-19T19:22:06Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean isDropNullKeys() {\n+      return dropNullKeys;\n+    }\n+\n+    @Override\n+    public void validate(List<JoinStage> joinStages) {\n+      super.validate(joinStages);\n+\n+      Map<String, JoinStage> stageMap = joinStages.stream()\n+        .collect(Collectors.toMap(JoinStage::getStageName, s -> s));\n+\n+      for (JoinKey joinKey : keys) {\n+        String joinStageName = joinKey.getStageName();\n+        JoinStage joinStage = stageMap.get(joinStageName);\n+        // check that the stage for each key is in the list of stages\n+        if (joinStage == null) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Stage '%s' is not a join input.\",\n+            joinStageName, joinStageName));\n+        }\n+        // this happens if the schema for that stage is unknown.\n+        // for example, because of macros could not be evaluated yet.\n+        if (joinStage.getSchema() == null) {\n+          continue;\n+        }\n+        Set<String> fields = joinStage.getSchema().getFields().stream()\n+          .map(Schema.Field::getName)\n+          .collect(Collectors.toSet());\n+\n+        // check that the key fields for each key is in fields for that stage\n+        // for example, when joining on A.id = B.uid, check that 'id' is in the fields for stage A and 'uid' for stage B\n+        Set<String> keysCopy = new HashSet<>(joinKey.getFields());\n+        keysCopy.removeAll(fields);\n+        if (keysCopy.size() == 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Field '%s' does not exist in the stage.\",\n+            joinStageName, keysCopy.iterator().next()));\n+        }\n+        if (keysCopy.size() > 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Fields %s do not exist in the stage.\",\n+            joinStageName, String.join(\", \", keysCopy)));\n+        }\n+      }\n+\n+      // check that the keys have the same type.\n+\n+      Iterator<JoinKey> keyIter = keys.iterator();\n+      JoinKey key1 = keyIter.next();\n+      // stage is guaranteed to be exist because of above validation\n+      Schema schema1 = stageMap.get(key1.getStageName()).getSchema();\n+      if (schema1 == null) {\n+        return;\n+      }\n+      while (keyIter.hasNext()) {\n+        JoinKey otherKey = keyIter.next();\n+        Schema otherSchema = stageMap.get(otherKey.getStageName()).getSchema();\n+        if (otherSchema == null) {\n+          continue;\n+        }\n+        Iterator<String> fieldIter = otherKey.getFields().iterator();\n+        for (String key1Field : key1.getFields()) {\n+          // guaranteed to be non-null because of earlier validation\n+          Schema key1Schema = schema1.getField(key1Field).getSchema();\n+          key1Schema = key1Schema.isNullable() ? key1Schema.getNonNullable() : key1Schema;\n+          Schema.Type key1Type = key1Schema.getType();\n+\n+          // don't need to check hasNext() because already verified they are all the same length\n+          String otherField = fieldIter.next();\n+          Schema otherFieldSchema = otherSchema.getField(otherField).getSchema();\n+          otherFieldSchema = otherFieldSchema.isNullable() ? otherFieldSchema.getNonNullable() : otherFieldSchema;\n+          Schema.Type otherType = otherFieldSchema.getType();\n+\n+          if (key1Type != otherType) {\n+            throw new InvalidJoinConditionException(String.format(\n+              \"Type mismatch on join keys. '%s'.'%s' is of type '%s' while '%s'.'%s' is of type '%s'.\",\n+              key1.getStageName(), key1Field, key1Schema.getDisplayName(),\n+              otherKey.getStageName(), otherField, otherFieldSchema.getDisplayName()));\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Builds an OnKeys condition.\n+     */\n+    public static class Builder {\n+      private final Set<JoinKey> keys;\n+      private boolean dropNullKeys;\n+\n+      private Builder() {\n+        this.keys = new HashSet<>();\n+        this.dropNullKeys = false;\n+      }\n+\n+      public Builder addKey(JoinKey key) {\n+        this.keys.add(key);\n+        return this;\n+      }\n+\n+      public Builder setKeys(Collection<JoinKey> keys) {\n+        this.keys.clear();\n+        this.keys.addAll(keys);\n+        return this;\n+      }\n+\n+      public Builder setShouldDropNullKeys(boolean dropNullKeys) {\n+        this.dropNullKeys = dropNullKeys;\n+        return this;\n+      }\n+\n+      public OnKeys build() {\n+        if (keys.size() < 2) {\n+          throw new InvalidJoinConditionException(\"Must specify a join key for each input stage.\");\n+        }\n+        Map<Integer, Set<String>> numFieldsToStages = new HashMap<>();\n+        for (JoinKey joinKey : keys) {\n+          int numFields = joinKey.getFields().size();\n+          Set<String> stages = numFieldsToStages.computeIfAbsent(numFields, k -> new HashSet<>());\n+          stages.add(joinKey.getStageName());\n+        }\n+        // this means there are stages with different number of fields.\n+        // it's the equivalent of trying to join on A.id = B.id and A.name = [null]\n+        if (numFieldsToStages.size() > 1) {\n+          Iterator<Integer> keyIter = numFieldsToStages.keySet().iterator();", "originalCommit": "519f12991e865ed26a7f91dc4e5c1e9d665c794e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NDA1NA==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427544054", "bodyText": "Remove extra new line.", "author": "chtyim", "createdAt": "2020-05-19T19:22:21Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean isDropNullKeys() {\n+      return dropNullKeys;\n+    }\n+\n+    @Override\n+    public void validate(List<JoinStage> joinStages) {\n+      super.validate(joinStages);\n+\n+      Map<String, JoinStage> stageMap = joinStages.stream()\n+        .collect(Collectors.toMap(JoinStage::getStageName, s -> s));\n+\n+      for (JoinKey joinKey : keys) {\n+        String joinStageName = joinKey.getStageName();\n+        JoinStage joinStage = stageMap.get(joinStageName);\n+        // check that the stage for each key is in the list of stages\n+        if (joinStage == null) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Stage '%s' is not a join input.\",\n+            joinStageName, joinStageName));\n+        }\n+        // this happens if the schema for that stage is unknown.\n+        // for example, because of macros could not be evaluated yet.\n+        if (joinStage.getSchema() == null) {\n+          continue;\n+        }\n+        Set<String> fields = joinStage.getSchema().getFields().stream()\n+          .map(Schema.Field::getName)\n+          .collect(Collectors.toSet());\n+\n+        // check that the key fields for each key is in fields for that stage\n+        // for example, when joining on A.id = B.uid, check that 'id' is in the fields for stage A and 'uid' for stage B\n+        Set<String> keysCopy = new HashSet<>(joinKey.getFields());\n+        keysCopy.removeAll(fields);\n+        if (keysCopy.size() == 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Field '%s' does not exist in the stage.\",\n+            joinStageName, keysCopy.iterator().next()));\n+        }\n+        if (keysCopy.size() > 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Fields %s do not exist in the stage.\",\n+            joinStageName, String.join(\", \", keysCopy)));\n+        }\n+      }\n+\n+      // check that the keys have the same type.\n+\n+      Iterator<JoinKey> keyIter = keys.iterator();\n+      JoinKey key1 = keyIter.next();\n+      // stage is guaranteed to be exist because of above validation\n+      Schema schema1 = stageMap.get(key1.getStageName()).getSchema();\n+      if (schema1 == null) {\n+        return;\n+      }\n+      while (keyIter.hasNext()) {\n+        JoinKey otherKey = keyIter.next();\n+        Schema otherSchema = stageMap.get(otherKey.getStageName()).getSchema();\n+        if (otherSchema == null) {\n+          continue;\n+        }\n+        Iterator<String> fieldIter = otherKey.getFields().iterator();\n+        for (String key1Field : key1.getFields()) {\n+          // guaranteed to be non-null because of earlier validation\n+          Schema key1Schema = schema1.getField(key1Field).getSchema();\n+          key1Schema = key1Schema.isNullable() ? key1Schema.getNonNullable() : key1Schema;\n+          Schema.Type key1Type = key1Schema.getType();\n+\n+          // don't need to check hasNext() because already verified they are all the same length\n+          String otherField = fieldIter.next();\n+          Schema otherFieldSchema = otherSchema.getField(otherField).getSchema();\n+          otherFieldSchema = otherFieldSchema.isNullable() ? otherFieldSchema.getNonNullable() : otherFieldSchema;\n+          Schema.Type otherType = otherFieldSchema.getType();\n+\n+          if (key1Type != otherType) {\n+            throw new InvalidJoinConditionException(String.format(\n+              \"Type mismatch on join keys. '%s'.'%s' is of type '%s' while '%s'.'%s' is of type '%s'.\",\n+              key1.getStageName(), key1Field, key1Schema.getDisplayName(),\n+              otherKey.getStageName(), otherField, otherFieldSchema.getDisplayName()));\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Builds an OnKeys condition.\n+     */\n+    public static class Builder {\n+      private final Set<JoinKey> keys;\n+      private boolean dropNullKeys;\n+\n+      private Builder() {\n+        this.keys = new HashSet<>();\n+        this.dropNullKeys = false;\n+      }\n+\n+      public Builder addKey(JoinKey key) {\n+        this.keys.add(key);\n+        return this;\n+      }\n+\n+      public Builder setKeys(Collection<JoinKey> keys) {\n+        this.keys.clear();\n+        this.keys.addAll(keys);\n+        return this;\n+      }\n+\n+      public Builder setShouldDropNullKeys(boolean dropNullKeys) {\n+        this.dropNullKeys = dropNullKeys;\n+        return this;\n+      }\n+\n+      public OnKeys build() {\n+        if (keys.size() < 2) {\n+          throw new InvalidJoinConditionException(\"Must specify a join key for each input stage.\");\n+        }\n+        Map<Integer, Set<String>> numFieldsToStages = new HashMap<>();\n+        for (JoinKey joinKey : keys) {\n+          int numFields = joinKey.getFields().size();\n+          Set<String> stages = numFieldsToStages.computeIfAbsent(numFields, k -> new HashSet<>());\n+          stages.add(joinKey.getStageName());\n+        }\n+        // this means there are stages with different number of fields.\n+        // it's the equivalent of trying to join on A.id = B.id and A.name = [null]\n+        if (numFieldsToStages.size() > 1) {\n+          Iterator<Integer> keyIter = numFieldsToStages.keySet().iterator();\n+          int num1 = keyIter.next();\n+          String stage1 = numFieldsToStages.get(num1).iterator().next();\n+          int num2 = keyIter.next();\n+          String stage2 = numFieldsToStages.get(num2).iterator().next();\n+          String message = String.format(\"Must join on the same number of fields for each stage. \" +\n+                                           \"Stage '%s' has %d fields while stage '%s' has %d fields.\",\n+                                         stage1, num1, stage2, num2);\n+          throw new InvalidJoinConditionException(message);\n+        }\n+        return new OnKeys(keys, dropNullKeys);\n+      }\n+    }\n+  }\n+", "originalCommit": "519f12991e865ed26a7f91dc4e5c1e9d665c794e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1MTU5Ng==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427551596", "bodyText": "Good refactor these three lines as a private method:\n  Schema.Type key1Type = getFieldType(schema1, key1Field);\n  Schema.Type otherKeyType = getFieldType(otherSchema, fieldIter.next());\n  if (key1Type != otherKeyType) {\n     ...\n  }", "author": "chtyim", "createdAt": "2020-05-19T19:36:06Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean isDropNullKeys() {\n+      return dropNullKeys;\n+    }\n+\n+    @Override\n+    public void validate(List<JoinStage> joinStages) {\n+      super.validate(joinStages);\n+\n+      Map<String, JoinStage> stageMap = joinStages.stream()\n+        .collect(Collectors.toMap(JoinStage::getStageName, s -> s));\n+\n+      for (JoinKey joinKey : keys) {\n+        String joinStageName = joinKey.getStageName();\n+        JoinStage joinStage = stageMap.get(joinStageName);\n+        // check that the stage for each key is in the list of stages\n+        if (joinStage == null) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Stage '%s' is not a join input.\",\n+            joinStageName, joinStageName));\n+        }\n+        // this happens if the schema for that stage is unknown.\n+        // for example, because of macros could not be evaluated yet.\n+        if (joinStage.getSchema() == null) {\n+          continue;\n+        }\n+        Set<String> fields = joinStage.getSchema().getFields().stream()\n+          .map(Schema.Field::getName)\n+          .collect(Collectors.toSet());\n+\n+        // check that the key fields for each key is in fields for that stage\n+        // for example, when joining on A.id = B.uid, check that 'id' is in the fields for stage A and 'uid' for stage B\n+        Set<String> keysCopy = new HashSet<>(joinKey.getFields());\n+        keysCopy.removeAll(fields);\n+        if (keysCopy.size() == 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Field '%s' does not exist in the stage.\",\n+            joinStageName, keysCopy.iterator().next()));\n+        }\n+        if (keysCopy.size() > 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Fields %s do not exist in the stage.\",\n+            joinStageName, String.join(\", \", keysCopy)));\n+        }\n+      }\n+\n+      // check that the keys have the same type.\n+\n+      Iterator<JoinKey> keyIter = keys.iterator();\n+      JoinKey key1 = keyIter.next();\n+      // stage is guaranteed to be exist because of above validation\n+      Schema schema1 = stageMap.get(key1.getStageName()).getSchema();\n+      if (schema1 == null) {\n+        return;\n+      }\n+      while (keyIter.hasNext()) {\n+        JoinKey otherKey = keyIter.next();\n+        Schema otherSchema = stageMap.get(otherKey.getStageName()).getSchema();\n+        if (otherSchema == null) {\n+          continue;\n+        }\n+        Iterator<String> fieldIter = otherKey.getFields().iterator();\n+        for (String key1Field : key1.getFields()) {\n+          // guaranteed to be non-null because of earlier validation\n+          Schema key1Schema = schema1.getField(key1Field).getSchema();", "originalCommit": "519f12991e865ed26a7f91dc4e5c1e9d665c794e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a568b1cf8cf58a8aae24f5e649902d4e4c7fb1f9", "url": "https://github.com/cdapio/cdap/commit/a568b1cf8cf58a8aae24f5e649902d4e4c7fb1f9", "message": "CDAP-16708 add API for autojoiner\n\nAdd a new set of classes for AutoJoiner, which can be used instead\nof the current Joiner interface. This new API leaves all of the\nimplementation details up to the application, which will allow the\napp to perform the join in better ways. For example, in the Spark\nprogram, it will allow using broadcast joins.\n\nPlugin developers are responsible for returning a JoinDefinition\nbased on information about incoming stages.\n\nThis change includes the JoinDefinition as well as all the classes\nrequired to create a definition. It also includes validation logic\nto make sure the plugin cannot create a definition that tries to\njoin on a field that doesn't exist, or tries to join on fields\nthat have mismatched types, or any other type of error.", "committedDate": "2020-05-19T21:08:49Z", "type": "commit"}, {"oid": "a568b1cf8cf58a8aae24f5e649902d4e4c7fb1f9", "url": "https://github.com/cdapio/cdap/commit/a568b1cf8cf58a8aae24f5e649902d4e4c7fb1f9", "message": "CDAP-16708 add API for autojoiner\n\nAdd a new set of classes for AutoJoiner, which can be used instead\nof the current Joiner interface. This new API leaves all of the\nimplementation details up to the application, which will allow the\napp to perform the join in better ways. For example, in the Spark\nprogram, it will allow using broadcast joins.\n\nPlugin developers are responsible for returning a JoinDefinition\nbased on information about incoming stages.\n\nThis change includes the JoinDefinition as well as all the classes\nrequired to create a definition. It also includes validation logic\nto make sure the plugin cannot create a definition that tries to\njoin on a field that doesn't exist, or tries to join on fields\nthat have mismatched types, or any other type of error.", "committedDate": "2020-05-19T21:08:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTYwNg==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427609606", "bodyText": "should we also compare logical types?", "author": "CuriousVini", "createdAt": "2020-05-19T21:25:52Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/JoinCondition.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.data.schema.Schema;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A condition to join on.\n+ *\n+ * Currently joins can only be performed on equality on a set of fields from each stage.\n+ */\n+public class JoinCondition {\n+  private final Op op;\n+\n+  private JoinCondition(Op op) {\n+    this.op = op;\n+  }\n+\n+  public Op getOp() {\n+    return op;\n+  }\n+\n+  /**\n+   * Validate that is condition is valid to use when joining the given stages.\n+   *\n+   * @param joinStages the stages that will be joined on this condition\n+   * @throws InvalidJoinConditionException if the condition is invalid\n+   */\n+  public void validate(List<JoinStage> joinStages) {\n+    // no-op\n+  }\n+\n+  /**\n+   * Condition operation.\n+   */\n+  public enum Op {\n+    EQUAL_TO\n+  }\n+\n+  public static OnKeys.Builder onKeys() {\n+    return new OnKeys.Builder();\n+  }\n+\n+  /**\n+   * Join on multiple keys from each stage.\n+   */\n+  public static class OnKeys extends JoinCondition {\n+    private final Set<JoinKey> keys;\n+    private final boolean dropNullKeys;\n+\n+    private OnKeys(Set<JoinKey> keys, boolean dropNullKeys) {\n+      super(Op.EQUAL_TO);\n+      this.keys = Collections.unmodifiableSet(new HashSet<>(keys));\n+      this.dropNullKeys = dropNullKeys;\n+    }\n+\n+    public Set<JoinKey> getKeys() {\n+      return keys;\n+    }\n+\n+    public boolean isDropNullKeys() {\n+      return dropNullKeys;\n+    }\n+\n+    @Override\n+    public void validate(List<JoinStage> joinStages) {\n+      super.validate(joinStages);\n+\n+      Map<String, JoinStage> stageMap = joinStages.stream()\n+        .collect(Collectors.toMap(JoinStage::getStageName, s -> s));\n+\n+      for (JoinKey joinKey : keys) {\n+        String joinStageName = joinKey.getStageName();\n+        JoinStage joinStage = stageMap.get(joinStageName);\n+        // check that the stage for each key is in the list of stages\n+        if (joinStage == null) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Stage '%s' is not a join input.\",\n+            joinStageName, joinStageName));\n+        }\n+        // this happens if the schema for that stage is unknown.\n+        // for example, because of macros could not be evaluated yet.\n+        if (joinStage.getSchema() == null) {\n+          continue;\n+        }\n+        Set<String> fields = joinStage.getSchema().getFields().stream()\n+          .map(Schema.Field::getName)\n+          .collect(Collectors.toSet());\n+\n+        // check that the key fields for each key is in fields for that stage\n+        // for example, when joining on A.id = B.uid, check that 'id' is in the fields for stage A and 'uid' for stage B\n+        Set<String> keysCopy = new HashSet<>(joinKey.getFields());\n+        keysCopy.removeAll(fields);\n+        if (keysCopy.size() == 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Field '%s' does not exist in the stage.\",\n+            joinStageName, keysCopy.iterator().next()));\n+        }\n+        if (keysCopy.size() > 1) {\n+          throw new InvalidJoinConditionException(String.format(\n+            \"Join key for stage '%s' is invalid. Fields %s do not exist in the stage.\",\n+            joinStageName, String.join(\", \", keysCopy)));\n+        }\n+      }\n+\n+      // check that the keys have the same type.\n+\n+      Iterator<JoinKey> keyIter = keys.iterator();\n+      JoinKey key1 = keyIter.next();\n+      // stage is guaranteed to be exist because of above validation\n+      Schema schema1 = stageMap.get(key1.getStageName()).getSchema();\n+      if (schema1 == null) {\n+        return;\n+      }\n+      while (keyIter.hasNext()) {\n+        JoinKey otherKey = keyIter.next();\n+        Schema otherSchema = stageMap.get(otherKey.getStageName()).getSchema();\n+        if (otherSchema == null) {\n+          continue;\n+        }\n+        Iterator<String> fieldIter = otherKey.getFields().iterator();\n+        for (String key1Field : key1.getFields()) {\n+          Schema key1Schema = getNonNullableFieldSchema(schema1, key1Field);\n+\n+          // don't need to check hasNext() because already verified they are all the same length\n+          String otherField = fieldIter.next();\n+          Schema otherFieldSchema = getNonNullableFieldSchema(otherSchema, otherField);\n+\n+          if (key1Schema.getType() != otherFieldSchema.getType()) {", "originalCommit": "a568b1cf8cf58a8aae24f5e649902d4e4c7fb1f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1MzIyMQ==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427653221", "bodyText": "I thought about that and wavered back and forth.\nIn the end, I decided to allow it because it is actually able to join if the physical types are the same, regardless of the logical types. It probably makes sense for the plugin to check this and disallow, but didn't want to restrict it in the app.", "author": "albertshau", "createdAt": "2020-05-19T23:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1NDUwMg==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427654502", "bodyText": "I see. sg \ud83d\udc4d", "author": "CuriousVini", "createdAt": "2020-05-19T23:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMDE2Mg==", "url": "https://github.com/cdapio/cdap/pull/12185#discussion_r427610162", "bodyText": "nice!", "author": "CuriousVini", "createdAt": "2020-05-19T21:26:54Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-api/src/main/java/io/cdap/cdap/etl/api/join/AutoJoiner.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.etl.api.join;\n+\n+import io.cdap.cdap.api.annotation.Beta;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Joins data from two or more input stages together.\n+ *\n+ * For example, the following represents a left outer join on 'purchases'.'user_id' = 'users'.'id':\n+ *\n+ * <pre>\n+ *   {@code\n+ *     JoinDefinition define(AutoJoinerContext context) {", "originalCommit": "a568b1cf8cf58a8aae24f5e649902d4e4c7fb1f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}