{"pr_number": 12233, "pr_title": "[CDAP-16835] REST API for upgrading Application and support for config upgrade for DataPipelineApp.", "pr_createdAt": "2020-06-01T00:45:15Z", "pr_url": "https://github.com/cdapio/cdap/pull/12233", "timeline": [{"oid": "bd786d9e66f86ac643fde9e7f109fb561f7c8259", "url": "https://github.com/cdapio/cdap/commit/bd786d9e66f86ac643fde9e7f109fb561f7c8259", "message": "Changes for upgrade api", "committedDate": "2020-06-03T04:43:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MDk5MQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435050991", "bodyText": "Why response with 200 OK if the operation failed?", "author": "chtyim", "createdAt": "2020-06-04T07:35:14Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MTU3MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435051570", "bodyText": "Don't use map as response for batch request. Response with array of objects. This is better to preserve the same ordering as the request.", "author": "chtyim", "createdAt": "2020-06-04T07:36:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    }\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   *\n+   * The response will be map of Application ID to {@link ApplicationUpdateDetails} object, which either indicates a", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MjMwNA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435052304", "bodyText": "Mark fields as final whenever possible.", "author": "chtyim", "createdAt": "2020-06-04T07:37:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MjQxNQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435052415", "bodyText": "Make a defensive copy.", "author": "chtyim", "createdAt": "2020-06-04T07:38:05Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MzI3MQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435053271", "bodyText": "The type may not be a Class. Use TypeToken.of(configType).getRawType() to make sure you get a Class.", "author": "chtyim", "createdAt": "2020-06-04T07:39:40Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MzkyOQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435053929", "bodyText": "No need to have this local file. You can just return directly at the place where you construct the new instance.", "author": "chtyim", "createdAt": "2020-06-04T07:41:01Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1NDUxNg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435054516", "bodyText": "When writing doc for a method, please with the method javadoc syntax instead of line comment.", "author": "chtyim", "createdAt": "2020-06-04T07:42:08Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1NjE1OA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435056158", "bodyText": "It is better not to have this logic in this class, but rather an argument to this class (e.g. boolean allowSnapshot)", "author": "chtyim", "createdAt": "2020-06-04T07:45:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))\n+               || pluginArtifactNamespace.equals(input.getParent())) &&\n+               (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+      }\n+    };\n+\n+    try {\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+          artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                        Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                        pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzMjkwOQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435432909", "bodyText": "don't need the Schema.unionOf() right now if we're just making it null", "author": "albertshau", "createdAt": "2020-06-04T17:38:31Z", "path": "cdap-api/src/main/java/io/cdap/cdap/internal/io/AbstractSchemaGenerator.java", "diffHunk": "@@ -69,7 +69,10 @@\n     simpleSchemas.put(byte[].class, Schema.of(Schema.Type.BYTES));\n     simpleSchemas.put(ByteBuffer.class, Schema.of(Schema.Type.BYTES));\n \n-        // Some extra ones for some common build-in types. Need corresponding handling in DatumReader/Writer\n+    // TODO: Convert Object class mapping to union of all simple schema types.\n+    simpleSchemas.put(Object.class, Schema.unionOf(Schema.of(Schema.Type.NULL)));", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTEzOQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435435139", "bodyText": "Does upgradeApplication() throw NotFoundException, BadRequestException, etc? If so, this isn't guaranteed to be an internal error.\nIt seems like you can just let the exception propagate and not catch it here at all.", "author": "albertshau", "createdAt": "2020-06-04T17:42:18Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTY4MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435435680", "bodyText": "the current code can't actually throw all of these exceptions (your IDE should flag this as a warning)", "author": "albertshau", "createdAt": "2020-06-04T17:43:09Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTkyNQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435435925", "bodyText": "is it really always an internal error here? For example, can't the upgrade fail because the new pipeline is invalid in some way (in which case it would be a 400 instead of a 500)?", "author": "albertshau", "createdAt": "2020-06-04T17:43:33Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    }\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   *\n+   * The response will be map of Application ID to {@link ApplicationUpdateDetails} object, which either indicates a\n+   * success (200) or failure for each of the requested application. The failure also indicates reason for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    Map<ApplicationId, ApplicationUpdateDetails> details = new HashMap<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.put(appId, applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetails errorDetail = new ApplicationUpdateDetails(\n+            new ServiceException(\"Upgrade failed due to internal error.\", null,", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4NTY0NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435485645", "bodyText": "So if the upgrade failed due to something like \"New pipeline invalid\", that will not throw exception but the \"error\" will be in the ApplicationUpdateDetail object returned by applicationLifecycleService.upgradeApplication.", "author": "pandyajay10", "createdAt": "2020-06-04T19:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNjI4Mw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435436283", "bodyText": "this should only error log if it really is an internal error. Failure to update because of invalid input should not result in an error log.", "author": "albertshau", "createdAt": "2020-06-04T17:44:06Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    }\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   *\n+   * The response will be map of Application ID to {@link ApplicationUpdateDetails} object, which either indicates a\n+   * success (200) or failure for each of the requested application. The failure also indicates reason for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    Map<ApplicationId, ApplicationUpdateDetails> details = new HashMap<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.put(appId, applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetails errorDetail = new ApplicationUpdateDetails(\n+            new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                                 HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+\n+        details.put(appId, errorDetail);\n+        LOG.error(\"Upgrading application {} failed due to exception \", appId, e);", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzOTA4OQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435439089", "bodyText": "can use closure syntax (your IDE should have a way to auto-convert this for you too):\npredicate = input -> {\n  return ...\n}", "author": "albertshau", "createdAt": "2020-06-04T17:48:36Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4OTUwNA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435489504", "bodyText": "Cool! I didn't bet an eye there before.", "author": "pandyajay10", "createdAt": "2020-06-04T19:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzOTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0MzAwNQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435443005", "bodyText": "the number of parentheses makes this hard to understand, can you break it up into multiple lines?", "author": "albertshau", "createdAt": "2020-06-04T17:55:03Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))\n+               || pluginArtifactNamespace.equals(input.getParent())) &&\n+               (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5MTgyMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435491823", "bodyText": "Done.. let me know if it still not clear. Also simplified it a bit.", "author": "pandyajay10", "createdAt": "2020-06-04T19:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0MzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0MzMwNg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435443306", "bodyText": "pluginScope should be annotated as @Nullable if it is allowed to be null. Though it seems like it shouldn't be allowed, the caller should default it themselves to an appropriate value.", "author": "albertshau", "createdAt": "2020-06-04T17:55:33Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5MjA0NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435492044", "bodyText": "Agree... removed the null usage there.", "author": "pandyajay10", "createdAt": "2020-06-04T19:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0MzMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NDgwMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435444803", "bodyText": "exceptions getting plugins should not be swallowed and ignored. They need to be propagated up and result in update failure.\nyou probably need to update the interface and potentially add new exception classes to the cdap-api.", "author": "albertshau", "createdAt": "2020-06-04T17:58:03Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))\n+               || pluginArtifactNamespace.equals(input.getParent())) &&\n+               (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+      }\n+    };\n+\n+    try {\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+          artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                        Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                        pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (Exception e) {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjY4NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435542684", "bodyText": "I agree. Right now I log and throw exception above.. it will result in upgrade failure for sure now. But for now, I am catching and throwing generic exception. I will follow up with new upgrade related exception class in cdap-api in a follow up PR after tracing down all potential exceptions (I tried to do it right now but thought it might be better and cleaner to do it in follow up) if that works for now. Let me know your thoughts.", "author": "pandyajay10", "createdAt": "2020-06-04T20:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NDgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjIxMQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435446211", "bodyText": "remove", "author": "albertshau", "createdAt": "2020-06-04T18:00:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjM4NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435446384", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T18:00:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NzMzOA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435447338", "bodyText": "it's basically never a good idea to throw a generic Exception in an internal method, as it makes it impossible for the caller to handle errors properly. Can this throw more specific exceptions?\nWe have a lot of bad existing code that does this, so if it may not be possible right now,\nbut you should at least add javadocs about the more specific exceptions that you know it can throw.", "author": "albertshau", "createdAt": "2020-06-04T18:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUzMDA5NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435530095", "bodyText": "Added a few that I could trace down.", "author": "pandyajay10", "createdAt": "2020-06-04T20:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0ODAxMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435448010", "bodyText": "indentation should be 2 spaces. Same comment for rest of PR", "author": "albertshau", "createdAt": "2020-06-04T18:03:45Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MzExNw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435543117", "bodyText": "Sorry for that. I lost the intellij settings and things reset to previous state. Planning to set it up again. I tried to manually catch as much I could find for now. Looking for more.", "author": "pandyajay10", "createdAt": "2020-06-04T20:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0ODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDE4NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435450184", "bodyText": "should not log a warning. This is a normal, expected situation from app-fabric's point of view, caused by bad user input.", "author": "albertshau", "createdAt": "2020-06-04T18:07:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5OTA5Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435499092", "bodyText": "Changed it to info.", "author": "pandyajay10", "createdAt": "2020-06-04T19:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDg0Mw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435450843", "bodyText": "should limit 1 with descending order", "author": "albertshau", "createdAt": "2020-06-04T18:08:41Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTQ1NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435451454", "bodyText": "this is possible if the user deleted the artifact manually (we allow them to delete the artifact even if it is being used by apps). This should not be an internal error, it should result in an ApplicationUpdateDetail being returned.", "author": "albertshau", "createdAt": "2020-06-04T18:09:54Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTQzMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435601430", "bodyText": "should update this comment", "author": "albertshau", "createdAt": "2020-06-04T23:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTg3Mw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435451873", "bodyText": "don't throw InternalError. This is a java language error meant for fatal java issues. You should almost never have to throw an Error in normal code.", "author": "albertshau", "createdAt": "2020-06-04T18:10:38Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwNTkxNA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435505914", "bodyText": "Makes sense.", "author": "pandyajay10", "createdAt": "2020-06-04T19:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MzAzMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435453033", "bodyText": "I don't think this should be possible, did you see this during testing?", "author": "albertshau", "createdAt": "2020-06-04T18:12:42Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwNjYwOA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435506608", "bodyText": "No I didn't see this, but I saw this being used in update method above so copied it. Removed it fir now.", "author": "pandyajay10", "createdAt": "2020-06-04T19:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MzgzMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435453833", "bodyText": "this is not possible, you passed the artifact name to artifactRepository.getArtifactSummaries() earlier.", "author": "albertshau", "createdAt": "2020-06-04T18:14:13Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NDYyOQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435454629", "bodyText": "seems like these should all result in an object being returned, and not in an exception being thrown.", "author": "albertshau", "createdAt": "2020-06-04T18:15:35Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwODI1Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435508252", "bodyText": "Done. Makes sense.", "author": "pandyajay10", "createdAt": "2020-06-04T19:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NTE3Ng==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435455176", "bodyText": "current name -> current scope\nthough this seems like a confusing message, the user is not going to know what this means. Also, can this even happen? Isn't the namespace passed to the getArtifactSummaries() call?", "author": "albertshau", "createdAt": "2020-06-04T18:16:35Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwOTE1NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435509155", "bodyText": "I agree with you user wont be able to do anything about this hence I threw internal error before. It shouldn't happen you are right but that was just for safety check. Seems redundant so removed it.", "author": "pandyajay10", "createdAt": "2020-06-04T19:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NzY4Nw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435457687", "bodyText": "E -> e", "author": "albertshau", "createdAt": "2020-06-04T18:20:46Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1OTMzMg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435459332", "bodyText": "also, I thought there was some boolean that can be used to check if update is supported?\nUnsupportedOperationException can be thrown by other things (for example, trying to write to an UnmodifiableMap), so it's better to base this off the API", "author": "albertshau", "createdAt": "2020-06-04T18:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NzY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1OTUzMg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435459532", "bodyText": "there will never be an error if it sucessful right?", "author": "albertshau", "createdAt": "2020-06-04T18:22:51Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MDY5NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435460695", "bodyText": "should not have these 1 line methods", "author": "albertshau", "createdAt": "2020-06-04T18:24:13Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/ArtifactSelectorConfig.java", "diffHunk": "@@ -85,4 +87,22 @@ public String toString() {\n       \", version='\" + version + '\\'' +\n       '}';\n   }\n+\n+  public io.cdap.cdap.api.artifact.ArtifactVersion getApiArtifactVersion() {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MTY5MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435461690", "bodyText": "don't need this, can just always pass Collections.emptyList() in the build() method", "author": "albertshau", "createdAt": "2020-06-04T18:25:25Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLBatchConfig.java", "diffHunk": "@@ -181,9 +204,12 @@ public static ETLBatchConfig forSystemService() {\n     private Engine engine;\n     private List<ETLStage> endingActions;\n     private Integer maxConcurrentRuns;\n+    // Only used for upgrade purpose.\n+    private List<String> comments;", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MjUxOQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435462519", "bodyText": "why do these need to be made protected?", "author": "albertshau", "createdAt": "2020-06-04T18:26:19Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLConfig.java", "diffHunk": "@@ -41,20 +41,23 @@\n // though not marked nullable, fields can be null since these objects are created through gson deserialization\n @SuppressWarnings(\"ConstantConditions\")\n public class ETLConfig extends Config implements UpgradeableConfig {\n-  private final String description;\n-  private final Set<ETLStage> stages;\n-  private final Set<Connection> connections;\n-  private final Resources resources;\n-  private final Resources driverResources;\n-  private final Resources clientResources;\n-  private final Boolean stageLoggingEnabled;\n-  private final Boolean processTimingEnabled;\n-  private final Integer numOfRecordsPreview;\n-  private final Map<String, String> properties;\n+  protected final String description;", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNzYwMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435517603", "bodyText": "So that we dont have to use default getter and setter which are setting default value when null. But for upgrade config, we want to serialize and deserialize without considering/changing values to default. If its null in original, it should be null in result.", "author": "pandyajay10", "createdAt": "2020-06-04T20:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MjUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMDQxMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435520410", "bodyText": "And I needed to use them in ETLBatchConfig class so.", "author": "pandyajay10", "createdAt": "2020-06-04T20:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2Mjk0MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435462940", "bodyText": "Details -> Detail", "author": "albertshau", "createdAt": "2020-06-04T18:27:02Z", "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetails.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetails {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MzI0MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435463240", "bodyText": "do we need both an error field and this field? Seems like we could just have a 'message' field since the status code indicates where it succeeded or failed", "author": "albertshau", "createdAt": "2020-06-04T18:27:24Z", "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetails.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetails {\n+\n+  private final int statusCode;\n+  private final String error;\n+  private final String updateDetails;", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxOTk5NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435519995", "bodyText": "Intially I had just one field \"message\" which included but once I was testing it out, I thought of  adding a human readable status code too which made it better IMO so I kept it. Statuscode itself is sufficient but was not very non-eng friendly is my thought. Let me know wdyt.", "author": "pandyajay10", "createdAt": "2020-06-04T20:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MzI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjUyMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435466523", "bodyText": "InvalidArtifactException is used when there is something wrong with the artifact itself, which is not the case here.\nThe ApplicationSpecification is looked up earlier, this should never happen right? If not, can throw an IllegalStateException, and add a comment that this should never happen.", "author": "albertshau", "createdAt": "2020-06-04T18:32:14Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {\n+      String errorMessage = String.format(\"Upgrade failed for application %s as artifact %s does not support upgrade.\",\n+                                          appId, newArtifact);\n+      return new ApplicationUpdateDetails(new NotImplementedException(errorMessage));\n+    }\n+  }\n+\n+  // Updates an application config by applying given update actions. The app should know how to apply these actions\n+  // to its config.\n+  private ApplicationUpdateDetails updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTI2Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435521262", "bodyText": "Done.", "author": "pandyajay10", "createdAt": "2020-06-04T20:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2ODg1MQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435468851", "bodyText": "should not log an error", "author": "albertshau", "createdAt": "2020-06-04T18:35:36Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {\n+      String errorMessage = String.format(\"Upgrade failed for application %s as artifact %s does not support upgrade.\",\n+                                          appId, newArtifact);\n+      return new ApplicationUpdateDetails(new NotImplementedException(errorMessage));\n+    }\n+  }\n+\n+  // Updates an application config by applying given update actions. The app should know how to apply these actions\n+  // to its config.\n+  private ApplicationUpdateDetails updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+        Artifacts.toProtoArtifactId(namespaceId, artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =\n+        artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                     classLoaderImpersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+        new DefaultApplicationUpdateContext(namespaceId, applicationId, artifactDetail.getDescriptor().getArtifactId(),\n+                                            artifactRepository, currentConfigStr, updateActions);\n+\n+    // Run config update logic for the application to generate updated config.\n+    try {\n+      Object appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+      if (!(appMain instanceof Application)) {\n+        throw new IllegalStateException(\n+            String.format(\"Application main class is of invalid type: %s\",\n+                          appMain.getClass().getName()));\n+      }\n+      Application app = (Application) appMain;\n+      Type configType = Artifacts.getConfigType(app.getClass());\n+      try {\n+        ApplicationUpdateResult<?> updateResult = app.updateConfig(updateContext);\n+        updatedAppConfig = GSON.toJson(updateResult.getNewConfig(), configType);\n+      } catch (UnsupportedOperationException ex) {\n+        String errorMessage = String.format(\"application of type %s does not support update.\",\n+                                            appMain.getClass().getName());\n+        LOG.error(\"Application update failed due to \" + errorMessage);", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2OTQzMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435469433", "bodyText": "what are the different exception that can be thrown here? Not all exceptions have a cause", "author": "albertshau", "createdAt": "2020-06-04T18:36:14Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {\n+      String errorMessage = String.format(\"Upgrade failed for application %s as artifact %s does not support upgrade.\",\n+                                          appId, newArtifact);\n+      return new ApplicationUpdateDetails(new NotImplementedException(errorMessage));\n+    }\n+  }\n+\n+  // Updates an application config by applying given update actions. The app should know how to apply these actions\n+  // to its config.\n+  private ApplicationUpdateDetails updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+        Artifacts.toProtoArtifactId(namespaceId, artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =\n+        artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                     classLoaderImpersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+        new DefaultApplicationUpdateContext(namespaceId, applicationId, artifactDetail.getDescriptor().getArtifactId(),\n+                                            artifactRepository, currentConfigStr, updateActions);\n+\n+    // Run config update logic for the application to generate updated config.\n+    try {\n+      Object appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+      if (!(appMain instanceof Application)) {\n+        throw new IllegalStateException(\n+            String.format(\"Application main class is of invalid type: %s\",\n+                          appMain.getClass().getName()));\n+      }\n+      Application app = (Application) appMain;\n+      Type configType = Artifacts.getConfigType(app.getClass());\n+      try {\n+        ApplicationUpdateResult<?> updateResult = app.updateConfig(updateContext);\n+        updatedAppConfig = GSON.toJson(updateResult.getNewConfig(), configType);\n+      } catch (UnsupportedOperationException ex) {\n+        String errorMessage = String.format(\"application of type %s does not support update.\",\n+                                            appMain.getClass().getName());\n+        LOG.error(\"Application update failed due to \" + errorMessage);\n+        throw ex;\n+      }\n+    } catch (Exception ex) {", "originalCommit": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTU4NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435599584", "bodyText": "indentation should be 2 spaces", "author": "albertshau", "createdAt": "2020-06-04T23:05:13Z", "path": "cdap-api/src/main/java/io/cdap/cdap/api/app/Application.java", "diffHunk": "@@ -46,7 +46,8 @@ default boolean isUpdateSupported() {\n    * @param applicationUpdateContext Used to access methods helpful for operations like upgrading plugin version for\n    * config.\n    */\n-  default ApplicationUpdateResult<T> updateConfig(ApplicationUpdateContext applicationUpdateContext) {\n+  default ApplicationUpdateResult<T> updateConfig(ApplicationUpdateContext applicationUpdateContext)\n+      throws Exception {", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTgwOQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435599809", "bodyText": "javadoc should include @throws and describe what will happen if an exception is thrown.", "author": "albertshau", "createdAt": "2020-06-04T23:05:57Z", "path": "cdap-api/src/main/java/io/cdap/cdap/api/app/Application.java", "diffHunk": "@@ -46,7 +46,8 @@ default boolean isUpdateSupported() {\n    * @param applicationUpdateContext Used to access methods helpful for operations like upgrading plugin version for\n    * config.", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTkxNg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435599916", "bodyText": "don't put TODOs in the api", "author": "albertshau", "createdAt": "2020-06-04T23:06:18Z", "path": "cdap-api/src/main/java/io/cdap/cdap/api/app/ApplicationUpdateContext.java", "diffHunk": "@@ -62,12 +62,14 @@\n    *         Returns empty list if no artifact for the plugin found.\n    */\n   default List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n-                                              @Nullable ArtifactVersionRange pluginRange) {\n+                                              @Nullable ArtifactVersionRange pluginRange) throws Exception {\n     return getPluginArtifacts(pluginType, pluginName, pluginScope, pluginRange, Integer.MAX_VALUE);\n   }\n \n   /**\n    * Gets list of plugin artifacts based on given parameters in sorted in ascending order by version.\n+   * Returns plugin artifacts using given filters in ascending order.\n+   * TODO: Pass ArtifactSortOrder as argument for better flexibility.", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDI2Ng==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435600266", "bodyText": "doesn't need to be final", "author": "albertshau", "createdAt": "2020-06-04T23:07:34Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,56 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDMxMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435600310", "bodyText": "doesn't need to be final", "author": "albertshau", "createdAt": "2020-06-04T23:07:43Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,56 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName) throws Exception {", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDc4MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435600780", "bodyText": "is this the right exception?", "author": "albertshau", "createdAt": "2020-06-04T23:09:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzODA2OA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435638068", "bodyText": "Comes from toJSON method used during json serialization in updateInternal method.", "author": "pandyajay10", "createdAt": "2020-06-05T01:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjM5Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602392", "bodyText": "This is a confusing error message because the user didn't request any artifact version, all they did was make an upgrade call. Would be better to say something like:\nThe current artifact has a version higher than any existing artifact.", "author": "albertshau", "createdAt": "2020-06-04T23:14:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjU5Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602592", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T23:15:20Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjY4Mw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602683", "bodyText": "remove inline comment", "author": "albertshau", "createdAt": "2020-06-04T23:15:40Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjgyNA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602824", "bodyText": "indentation, variables are not lined up", "author": "albertshau", "createdAt": "2020-06-04T23:16:02Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjk1Nw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602957", "bodyText": "this can't be null right?", "author": "albertshau", "createdAt": "2020-06-04T23:16:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMzQxNA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435603414", "bodyText": "also, shouldn't need to pass in namespace, app, or version is ApplicationId is passed in.", "author": "albertshau", "createdAt": "2020-06-04T23:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDEwNg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604106", "bodyText": "the type is a java classname that will likely just confused people. You can just say that the application does not support updates.", "author": "albertshau", "createdAt": "2020-06-04T23:20:22Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules,\n+                                                             String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(namespaceId, artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =\n+      artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                   classLoaderImpersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+      new DefaultApplicationUpdateContext(namespaceId, applicationId, artifactDetail.getDescriptor().getArtifactId(),\n+                                          artifactRepository, currentConfigStr, updateActions);\n+\n+    // Run config update logic for the application to generate updated config.\n+    Object appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+    if (!(appMain instanceof Application)) {\n+      throw new IllegalStateException(\n+        String.format(\"Application main class is of invalid type: %s\",\n+                      appMain.getClass().getName()));\n+    }\n+    Application app = (Application) appMain;\n+    Type configType = Artifacts.getConfigType(app.getClass());\n+    if (!app.isUpdateSupported()) {\n+      String status = String.format(\"%s failed.\", userAction);\n+      String errorMessage = String.format(\"application of type %s does not support update.\",", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDUwMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604503", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T23:21:44Z", "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/DataPipelineApp.java", "diffHunk": "@@ -76,4 +78,17 @@ public void configure() {\n       schedule(scheduleBuilder.triggerByTime(timeSchedule));\n     }\n   }\n+\n+  @Override\n+  public boolean isUpdateSupported() {\n+    return true;\n+  }\n+\n+  @Override\n+  public ApplicationUpdateResult<ETLBatchConfig> updateConfig(ApplicationUpdateContext updateContext)\n+      throws Exception {", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDYyMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604623", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T23:22:14Z", "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/test/java/io/cdap/cdap/datapipeline/DataPipelineTest.java", "diffHunk": "@@ -3493,4 +3520,175 @@ private long getMetric(ApplicationId appId, String metric) {\n                                                Constants.Metrics.Tag.WORKFLOW, SmartWorkflow.NAME);\n     return getMetricsManager().getTotalMetric(tags, \"user.\" + metric);\n   }\n+\n+  /* Unit test tests upgrade for a deployed application.\n+     1. Deploy an application with older application artifact (1.0.0) and older filter plugin version (1.0.0).\n+     2. Add new version of application artifact (1.0.1) and filter plugin artifact (1.1.0).\n+     3. Upgrade the older deployed application.\n+     4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+        in its config.\n+   */\n+  @Test\n+  public void testSimpleUpgradePipelines() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"1.0.0\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version should be upgraded to desired version in SYSTEM scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"1.1.0\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+   1. Deploy an application with older application artifact (1.0.0) and older filter plugin version with range\n+      [1.0.0-1.0.5).\n+   2. Add multiple versions of same application artifact with latest being (1.2.0).\n+   3. Bind newer version of filter plugin 1.1.0 with it.\n+   3. Upgrade the older deployed application.\n+   4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+      in its config. Also verify that plugin version range for filter stage is changed to use newest version of plugin.\n+ */\n+  @Test\n+  public void testUpgradePipelinesWithPluginRange() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,1.0.5)\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version range should be upgraded to include latest plugin version in SYSTEM\n+    // scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"[1.0.0,1.1.0]\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+ 1. Deploy an application with older application artifact (1.0.0) and filter plugin version with range\n+    [1.0.0-2.0.0) to make sure latest version of plugin should be included in it.\n+ 2. Add multiple versions of same application artifact with latest being (1.2.0).\n+ 3. Bind newer version of filter plugin 1.1.0 with it.\n+ 3. Upgrade the older deployed application.\n+ 4. Verify that after upgrading, application artifact uses latest version in its config.\n+    But plugin range is not updated as latest version of plugin is still included in the range.\n+*/\n+  @Test\n+  public void testUpgradePipelinesWithNoChangeInPluginRange() throws Exception {\n+    // Since filter plugin is not going to upgrade due to its range, the scope of filter plugin still stays USER.\n+    // Add a filter plugin in DEFAULT namespace in the proposed range for upgraded artifact version.\n+    // Needed to make deployment successful.\n+    addPluginArtifact(NamespaceId.DEFAULT.artifact(\"test-plugins\", \"1.1.0\"), UPGRADE_APP_ARTIFACT_ID_2,\n+                      PluggableFilterTransform.class);\n+\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,2.0.0)\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDY1Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604652", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T23:22:20Z", "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/test/java/io/cdap/cdap/datapipeline/DataPipelineTest.java", "diffHunk": "@@ -3493,4 +3520,175 @@ private long getMetric(ApplicationId appId, String metric) {\n                                                Constants.Metrics.Tag.WORKFLOW, SmartWorkflow.NAME);\n     return getMetricsManager().getTotalMetric(tags, \"user.\" + metric);\n   }\n+\n+  /* Unit test tests upgrade for a deployed application.\n+     1. Deploy an application with older application artifact (1.0.0) and older filter plugin version (1.0.0).\n+     2. Add new version of application artifact (1.0.1) and filter plugin artifact (1.1.0).\n+     3. Upgrade the older deployed application.\n+     4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+        in its config.\n+   */\n+  @Test\n+  public void testSimpleUpgradePipelines() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"1.0.0\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version should be upgraded to desired version in SYSTEM scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"1.1.0\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+   1. Deploy an application with older application artifact (1.0.0) and older filter plugin version with range\n+      [1.0.0-1.0.5).\n+   2. Add multiple versions of same application artifact with latest being (1.2.0).\n+   3. Bind newer version of filter plugin 1.1.0 with it.\n+   3. Upgrade the older deployed application.\n+   4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+      in its config. Also verify that plugin version range for filter stage is changed to use newest version of plugin.\n+ */\n+  @Test\n+  public void testUpgradePipelinesWithPluginRange() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,1.0.5)\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version range should be upgraded to include latest plugin version in SYSTEM\n+    // scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"[1.0.0,1.1.0]\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+ 1. Deploy an application with older application artifact (1.0.0) and filter plugin version with range\n+    [1.0.0-2.0.0) to make sure latest version of plugin should be included in it.\n+ 2. Add multiple versions of same application artifact with latest being (1.2.0).\n+ 3. Bind newer version of filter plugin 1.1.0 with it.\n+ 3. Upgrade the older deployed application.\n+ 4. Verify that after upgrading, application artifact uses latest version in its config.\n+    But plugin range is not updated as latest version of plugin is still included in the range.\n+*/\n+  @Test\n+  public void testUpgradePipelinesWithNoChangeInPluginRange() throws Exception {\n+    // Since filter plugin is not going to upgrade due to its range, the scope of filter plugin still stays USER.\n+    // Add a filter plugin in DEFAULT namespace in the proposed range for upgraded artifact version.\n+    // Needed to make deployment successful.\n+    addPluginArtifact(NamespaceId.DEFAULT.artifact(\"test-plugins\", \"1.1.0\"), UPGRADE_APP_ARTIFACT_ID_2,\n+                      PluggableFilterTransform.class);\n+\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,2.0.0)\");", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDgwMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604800", "bodyText": "indentation (same with rest of test classes)", "author": "albertshau", "createdAt": "2020-06-04T23:22:48Z", "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/test/java/io/cdap/cdap/datapipeline/DataPipelineTest.java", "diffHunk": "@@ -3493,4 +3520,175 @@ private long getMetric(ApplicationId appId, String metric) {\n                                                Constants.Metrics.Tag.WORKFLOW, SmartWorkflow.NAME);\n     return getMetricsManager().getTotalMetric(tags, \"user.\" + metric);\n   }\n+\n+  /* Unit test tests upgrade for a deployed application.\n+     1. Deploy an application with older application artifact (1.0.0) and older filter plugin version (1.0.0).\n+     2. Add new version of application artifact (1.0.1) and filter plugin artifact (1.1.0).\n+     3. Upgrade the older deployed application.\n+     4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+        in its config.\n+   */\n+  @Test\n+  public void testSimpleUpgradePipelines() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"1.0.0\");", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTI2MQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435605261", "bodyText": "don't think this should exist here either. The caller should make sure they handle the null scope case.", "author": "albertshau", "createdAt": "2020-06-04T23:24:28Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/ArtifactSelectorConfig.java", "diffHunk": "@@ -85,4 +87,9 @@ public String toString() {\n       \", version='\" + version + '\\'' +\n       '}';\n   }\n+\n+  public io.cdap.cdap.api.artifact.ArtifactScope getApiArtifactScope() {", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTUwNg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435605506", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T23:25:15Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLConfig.java", "diffHunk": "@@ -74,6 +77,18 @@ protected ETLConfig(Set<ETLStage> stages, Set<Connection> connections,\n     this.source = null;\n     this.sinks = new ArrayList<>();\n     this.transforms = new ArrayList<>();\n+    this.comments = new ArrayList<>();\n+  }\n+\n+  protected ETLConfig(Set<ETLStage> stages, Set<Connection> connections,\n+      Resources resources, Resources driverResources, Resources clientResources,", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjQ3NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435606474", "bodyText": "if it can return null, the method should be annotated with @Nullable", "author": "albertshau", "createdAt": "2020-06-04T23:28:41Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjg0Mw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435606843", "bodyText": "if they've explicitly given a range with an upper bound, is it really correct to increase that range?\nTo me, it makes more sense to choose the highest artifact within that range.", "author": "albertshau", "createdAt": "2020-06-04T23:30:03Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNTIzMQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435615231", "bodyText": "it would be useful to give a couple inputs and outputs", "author": "albertshau", "createdAt": "2020-06-04T23:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0ODE4OQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435648189", "bodyText": "If we dont change the range (or plan to change the range), than in that case we would never touch ranged version here right? Than we leave it to deploy to pick the highest version of plugin available in the range. Then even if a new version of plugin (outside current range) is introduced it wont get picked up.\nIMO, we should increase the range so new plugin gets picked up. There are boundary cases with scoping that we need to figure out, but unless we upgrade the range, not sure how a new plugin can get picked up. Feel free to correct me if I am missing something.", "author": "pandyajay10", "createdAt": "2020-06-05T01:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzQyMg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435607422", "bodyText": "there are too many levels of nesting in this method. If the parsing is the only thing that can throw an exception, you remove one level of nesting by doing:\nArtifactVersionRange currentVersionRange;\ntry {\n  currentVersionRange = ...\n} catch (...) {\n  ...\n}\n\n// rest of logic", "author": "albertshau", "createdAt": "2020-06-04T23:32:00Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    try {\n+      ArtifactVersionRange currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+      if (!currentVersionRange.isExactVersion()) {\n+        // Current plugin version is version range.\n+        if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+          // Do nothing and return as is. Note that plugin scope will not change.\n+          // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+          return null;\n+        } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {\n+          // Current lower version is higher than newer latest version. This should not happen.\n+          LOG.warn(\"Invalid new plugin artifact {} for upgrade for upgrading plugin {} \", newPlugin, plugin);\n+          return null;\n+        } else {\n+          // Increase the upper bound to latest available version.\n+          ArtifactVersionRange newVersionRange =\n+            new ArtifactVersionRange(currentVersionRange.getLower(), currentVersionRange.isLowerInclusive(),\n+                                     newPlugin.getVersion(), /*isUpperInclusive=*/true);\n+          return newVersionRange.getVersionString();\n+        }\n+      } else if (currentVersionRange.isExactVersion()\n+          && currentVersionRange.getLower().compareTo(newPlugin.getVersion()) < 0) {\n+        // Current version is a fixed version and new version is higher than current.\n+        return newPlugin.getVersion().getVersion();\n+      } else {\n+        // Should not happen. Safety check.\n+        return null;\n+      }\n+    } catch (Exception e) {\n+      LOG.warn(\"Issue in parsing version string for plugin, ignoring stage for upgrade {}\", plugin, e);", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0Mzk2OA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435643968", "bodyText": "I agree. I simplified it further a bit.", "author": "pandyajay10", "createdAt": "2020-06-05T01:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxMjQ0Nw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435612447", "bodyText": "when you have a bunch of these ifs, it's more readable to put the short checks at the top and remove a level of nesting. Something like:\nif (currentVersionRange.isExactVersion()) {\n  if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) < 0) {\n    return newPlugin.getVersion().getVersion();\n  }\n  return null;\n}\n.. other logic", "author": "albertshau", "createdAt": "2020-06-04T23:38:24Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    try {\n+      ArtifactVersionRange currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+      if (!currentVersionRange.isExactVersion()) {\n+        // Current plugin version is version range.\n+        if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+          // Do nothing and return as is. Note that plugin scope will not change.\n+          // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+          return null;\n+        } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {\n+          // Current lower version is higher than newer latest version. This should not happen.\n+          LOG.warn(\"Invalid new plugin artifact {} for upgrade for upgrading plugin {} \", newPlugin, plugin);\n+          return null;\n+        } else {\n+          // Increase the upper bound to latest available version.\n+          ArtifactVersionRange newVersionRange =\n+            new ArtifactVersionRange(currentVersionRange.getLower(), currentVersionRange.isLowerInclusive(),\n+                                     newPlugin.getVersion(), /*isUpperInclusive=*/true);\n+          return newVersionRange.getVersionString();\n+        }\n+      } else if (currentVersionRange.isExactVersion()", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNDkwMQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435614901", "bodyText": "this message is confusing and not very useful. Imagine seeing this in a log file, you won't be able to do anything with it. It doesn't mention which pipeline or which stage within the pipeline.", "author": "albertshau", "createdAt": "2020-06-04T23:41:19Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    try {\n+      ArtifactVersionRange currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+      if (!currentVersionRange.isExactVersion()) {\n+        // Current plugin version is version range.\n+        if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+          // Do nothing and return as is. Note that plugin scope will not change.\n+          // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+          return null;\n+        } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {\n+          // Current lower version is higher than newer latest version. This should not happen.\n+          LOG.warn(\"Invalid new plugin artifact {} for upgrade for upgrading plugin {} \", newPlugin, plugin);", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0NjcwMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435646700", "bodyText": "Agree. Also changed above error message. Although the name of the application is currently not known to ETLStage or UpdateContext so only added stage name. Will figure out what is a good way to include app name in the context as cdap-api does not have appId in it.", "author": "pandyajay10", "createdAt": "2020-06-05T01:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNTUyNg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435615526", "bodyText": "indentation", "author": "albertshau", "createdAt": "2020-06-04T23:42:04Z", "path": "cdap-client/src/main/java/io/cdap/cdap/client/ApplicationClient.java", "diffHunk": "@@ -230,6 +230,25 @@ public ApplicationDetail get(ApplicationId appId)\n     return ObjectResponse.fromJsonBody(response, new TypeToken<List<PluginInstanceDetail>>() { }).getResponseObject();\n   }\n \n+  /**\n+   * Upgrades an application.\n+   *\n+   * @param app the application to delete\n+   * @throws ApplicationNotFoundException if the application with the given ID was not found\n+   * @throws IOException if a network error occurred\n+   * @throws UnauthenticatedException if the request is not authorized successfully in the gateway server\n+   */\n+  public void upgradeApplication(ApplicationId app)\n+      throws ApplicationNotFoundException, IOException, UnauthenticatedException, UnauthorizedException {", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjY5MQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435616691", "bodyText": "this should match what is given as the input except have additional fields for status code and message. The javadoc for the REST API seems to indicate the input is an 'appId' variable of type string.", "author": "albertshau", "createdAt": "2020-06-04T23:43:44Z", "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetail.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetail {\n+\n+  private final int statusCode;\n+  private final String error;\n+  private final String updateDetails;\n+  private final ApplicationId applicationId;", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzU5NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435617595", "bodyText": "looking at some of the other batch endpoints, they return lists of objects like BatchProgramResult. There, appId is a flat field. It also only has an 'error' string and nothing like 'updateDetails'. If the operation is successful, there is no message.", "author": "albertshau", "createdAt": "2020-06-04T23:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0OTY5Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435649692", "bodyText": "Done.", "author": "pandyajay10", "createdAt": "2020-06-05T01:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzY4Ng==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435617686", "bodyText": "should be POST", "author": "albertshau", "createdAt": "2020-06-04T23:47:35Z", "path": "cdap-client/src/main/java/io/cdap/cdap/client/ApplicationClient.java", "diffHunk": "@@ -230,6 +230,25 @@ public ApplicationDetail get(ApplicationId appId)\n     return ObjectResponse.fromJsonBody(response, new TypeToken<List<PluginInstanceDetail>>() { }).getResponseObject();\n   }\n \n+  /**\n+   * Upgrades an application.\n+   *\n+   * @param app the application to delete\n+   * @throws ApplicationNotFoundException if the application with the given ID was not found\n+   * @throws IOException if a network error occurred\n+   * @throws UnauthenticatedException if the request is not authorized successfully in the gateway server\n+   */\n+  public void upgradeApplication(ApplicationId app)\n+      throws ApplicationNotFoundException, IOException, UnauthenticatedException, UnauthorizedException {\n+    String path = String.format(\"apps/%s/upgrade\", app.getApplication());\n+    HttpResponse response = restClient.execute(HttpMethod.DELETE,", "originalCommit": "38f869607e99cdae1ea124f79938408db5d73617", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNjU5OQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435706599", "bodyText": "This implementation definitely need to change before releasing. Looping in handler one by one is never a good idea (query and update storage one by one). Please open a JIRA and mark a TODO here.", "author": "chtyim", "createdAt": "2020-06-05T06:02:51Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,56 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    ApplicationUpdateDetail detail = applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   * The response will be an array of {@link ApplicationUpdateDetail} object, which either indicates a success (200) or\n+   * failure for each of the requested application in the same order as the request. The failure also indicates reason\n+   * for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    List<ApplicationUpdateDetail> details = new ArrayList<>();\n+    for (ApplicationId appId : appIds) {", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNzM0Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435707342", "bodyText": "Make a copy instead of just wrapping the incoming list:\nCollections.unmodifiableList(new ArrayList<>(updateActions));", "author": "chtyim", "createdAt": "2020-06-05T06:05:32Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNzcwMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435707703", "bodyText": "As I mentioned in previous comment, this casting is not safe. You have to do:\n((Class<C>) TypeToken.of(configType).getRawType()).newInstance;", "author": "chtyim", "createdAt": "2020-06-05T06:06:57Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNzkzNw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435707937", "bodyText": "No need to have else since the if block always terminate the flow (either returning or throwing)", "author": "chtyim", "createdAt": "2020-06-05T06:07:41Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjc3NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435722775", "bodyText": "Don't log and throw, as this can easily create repeated logs of exceptions.", "author": "chtyim", "createdAt": "2020-06-05T06:51:51Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        return GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",\n+                pluginName, pluginType, pluginScope, applicationId);\n+      return Collections.emptyList();\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed to get plugin details for artifact {} for plugin {} of type {}\",", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MzQxMg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436063412", "bodyText": "Making it debug for now as the only this class actually knows about appId (as this block is being called from ETLStage which does not know about appId). I am thinking of where to pass appID but it is slightly tricky as cdap-api does know about applicationID.", "author": "pandyajay10", "createdAt": "2020-06-05T17:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjk5NQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435722995", "bodyText": "Is the plugin not exists expected to happen?", "author": "chtyim", "createdAt": "2020-06-05T06:52:26Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        return GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MjI0Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436062242", "bodyText": "This is because we are only looking for plugins in SYSTEM scope (even though current plugin is in USER scope). So there can be a case that the scope we are looking for does not have this plugin at all.", "author": "pandyajay10", "createdAt": "2020-06-05T17:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjA4MA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256080", "bodyText": "If it is commonly expected to happen, log with trace instead of debug.", "author": "chtyim", "createdAt": "2020-06-06T10:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTUxMw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435735513", "bodyText": "The alignment is off.", "author": "chtyim", "createdAt": "2020-06-05T07:22:58Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,132 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MTA4OA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435741088", "bodyText": "You have to close this to avoid resource leakage by using a try block. The returned type is CloseableClassLoader.", "author": "chtyim", "createdAt": "2020-06-05T07:34:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,132 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(appId.getParent(), artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =", "originalCommit": "63e082e95b8094724cfda1ca78c771dca283cbb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTc1Nw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436255757", "bodyText": "Is internal error the only type of error we reported back? Typically we at least differentiate client error (e.g. 404) vs server side one.", "author": "chtyim", "createdAt": "2020-06-06T09:57:52Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,58 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    ApplicationUpdateDetail detail = applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   * The response will be an array of {@link ApplicationUpdateDetail} object, which either indicates a success (200) or\n+   * failure for each of the requested application in the same order as the request. The failure also indicates reason\n+   * for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    // TODO: (CDAP-16910) Improve batch API performance as each application upgrade is an event independent of each\n+    //  other.\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    List<ApplicationUpdateDetail> details = new ArrayList<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.add(applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetail errorDetail =\n+          new ApplicationUpdateDetail(appId, new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                                                                   HttpResponseStatus.INTERNAL_SERVER_ERROR));", "originalCommit": "3cb06762cacc6c8536c6384380a6e60bf112cabc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NzM4OA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436857388", "bodyText": "We do report back other errors but other known errors come from upgradeApplication function like 404 etc. Only errors which could not be handled/known by upgradeApplication will be responded with  InternalError. These are the errors that customers typically cant do anything about.", "author": "pandyajay10", "createdAt": "2020-06-08T17:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTc4MQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436255781", "bodyText": "Typically don't log if the exception is caused by client side error", "author": "chtyim", "createdAt": "2020-06-06T09:58:09Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,58 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    ApplicationUpdateDetail detail = applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   * The response will be an array of {@link ApplicationUpdateDetail} object, which either indicates a success (200) or\n+   * failure for each of the requested application in the same order as the request. The failure also indicates reason\n+   * for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    // TODO: (CDAP-16910) Improve batch API performance as each application upgrade is an event independent of each\n+    //  other.\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    List<ApplicationUpdateDetail> details = new ArrayList<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.add(applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetail errorDetail =\n+          new ApplicationUpdateDetail(appId, new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                                                                   HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+        details.add(errorDetail);\n+        LOG.debug(\"Upgrading application {} failed due to exception \", appId, e);", "originalCommit": "3cb06762cacc6c8536c6384380a6e60bf112cabc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTkwMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436255900", "bodyText": "nit: is not supported", "author": "chtyim", "createdAt": "2020-06-06T10:00:20Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(new ArrayList<>(updateActions));\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +", "originalCommit": "3cb06762cacc6c8536c6384380a6e60bf112cabc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjEwMQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256101", "bodyText": "Don't log and throw. It can cause multiple exceptions being logged.", "author": "chtyim", "createdAt": "2020-06-06T10:04:22Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(new ArrayList<>(updateActions));\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) TypeToken.of(configType).getRawType()).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    }\n+\n+    try {\n+      return GSON.fromJson(configString, configType);\n+    } catch (JsonSyntaxException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                         + \" syntax.\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",\n+                pluginName, pluginType, pluginScope, applicationId);\n+      return Collections.emptyList();\n+    } catch (Exception e) {\n+      LOG.debug(\"Failed to get plugin details for artifact {} for plugin {} of type {}\",", "originalCommit": "3cb06762cacc6c8536c6384380a6e60bf112cabc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjI0Mw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256243", "bodyText": "You need to close this classloader after done using any instances created from it. The createArtifactClassLoader returns a CloseableClassLoader, which you can use try (resource) block to easily close it out.", "author": "chtyim", "createdAt": "2020-06-06T10:06:16Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,138 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                      artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(appId.getParent(), artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+      new DefaultApplicationUpdateContext(appId.getParent(), appId, artifactDetail.getDescriptor().getArtifactId(),\n+                                          artifactRepository, currentConfigStr, updateActions);\n+\n+    Object appMain;\n+    try {\n+      ClassLoader artifactClassLoader =", "originalCommit": "3cb06762cacc6c8536c6384380a6e60bf112cabc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjMxMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256310", "bodyText": "Why need to change?", "author": "chtyim", "createdAt": "2020-06-06T10:07:32Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLBatchConfig.java", "diffHunk": "@@ -43,7 +44,7 @@\n   private final List<ETLStage> postActions;\n   // for backwards compatibility\n   private final List<ETLStage> actions;\n-  private final boolean service;\n+  private final Boolean service;", "originalCommit": "3cb06762cacc6c8536c6384380a6e60bf112cabc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2ODg1NA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436868854", "bodyText": "This is due to compatibility with etl config sent from UI. For example, if original ETLConfig does not set service field (service=null), resulting json after upgrade also should not have that service field. But if it was primitive boolean, it sets it as false. Hence changed it to use wrapper class.", "author": "pandyajay10", "createdAt": "2020-06-08T17:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzEwNQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436907105", "bodyText": "But isn't that we want the default value to be false anyway?", "author": "chtyim", "createdAt": "2020-06-08T18:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxOTYwMQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436919601", "bodyText": "Synced up offline. This is needed to minimize the changes between original ETLConfig and upgraded config to not confuse users.", "author": "pandyajay10", "createdAt": "2020-06-08T18:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNDQyNQ==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436914425", "bodyText": "So when an Exception will be thrown versus when the failure will be in the returned ApplicationUpdateDetail? Generally it is not a good idea to have two ways to communicate errors. It is probably better for this method to always throw exception (e.g. ApplicationNotFoundException, ArtifcatNotFoundException... etc), and the caller to this method to handle it in different way (e.g. if it is called from the http handler, exceptions get caught and wrapped into ApplicationUpdateDetail for response)", "author": "chtyim", "createdAt": "2020-06-08T18:39:10Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +363,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap", "originalCommit": "f00409bd92e6701851f07a04bf4d21f9b52c1064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MTM5Nw==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436951397", "bodyText": "The reason why I have designed it like this is due to the case that application upgrade can fail due to variety of reason which is known only to the function, not the callee (we can implement exception for each of them but that seems unnecessary). Common errors like update not supported for this app and uncommon errors like (no app artifact found for the upgrade) and eventually no plugin candidate found will also throw exception. (once we ignore scope). Hence upgradeApplication can create ApplicationUpdateDetail object based on different update failure cases that can happen and users can in theory do something about it. If upgradeApplication still throws exception that means its an internal error and it is not possible for users to do anything about it.\nIMO, it will not be scalable to only throw exceptions and let caller create object on different kind of exception as we would than need to create different exception classes for each cases which might not be needed.\ntl;dr, if upgradeApplication returns ApplicationUpdateDetail object, it is either success or a failure which is understandable by customers else throw internal error.", "author": "pandyajay10", "createdAt": "2020-06-08T19:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNDQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTg4Mg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436915882", "bodyText": "You can't close the ClassLoader here since the appMain is still being in use. You can only close a ClassLoader after all classes/instances created from it are no longer in use.", "author": "chtyim", "createdAt": "2020-06-08T18:41:50Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +363,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                      artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(appId.getParent(), artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+      new DefaultApplicationUpdateContext(appId.getParent(), appId, artifactDetail.getDescriptor().getArtifactId(),\n+                                          artifactRepository, currentConfigStr, updateActions);\n+\n+    Object appMain;\n+    try {\n+      try (CloseableClassLoader artifactClassLoader =\n+        artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                     classLoaderImpersonator)) {\n+        appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+      }", "originalCommit": "f00409bd92e6701851f07a04bf4d21f9b52c1064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzMDIxMg==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436930212", "bodyText": "No need to have else after an if block returns", "author": "chtyim", "createdAt": "2020-06-08T19:05:18Z", "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +105,122 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(), ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  @Nullable\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    ArtifactVersionRange currentVersionRange = null;\n+    try {\n+      currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+    } catch (Exception e) {\n+      LOG.warn(\"Issue in parsing version string for plugin {}, ignoring stage {} for upgrade.\", plugin, name, e);\n+      return null;\n+    }\n+\n+    if (currentVersionRange.isExactVersion()) {\n+      if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) < 0) {\n+        // Current version is a fixed version and new version is higher than current.\n+        return newPlugin.getVersion().getVersion();\n+      }\n+      return null;\n+    }\n+\n+    if (!currentVersionRange.isExactVersion()) {\n+      // Current plugin version is version range.\n+      if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+        // Do nothing and return as is. Note that plugin scope will not change.\n+        // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+        return null;\n+      } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {", "originalCommit": "f00409bd92e6701851f07a04bf4d21f9b52c1064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNDM0OA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r437034348", "bodyText": "Instead of catching it here, I think it is better to add the handling to the HttpExceptionHandler.", "author": "chtyim", "createdAt": "2020-06-08T22:23:57Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,71 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    try {\n+      applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      ApplicationUpdateDetail updateDetail = new ApplicationUpdateDetail(appId, \"upgrade successful.\");\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(updateDetail));\n+    } catch (UnsupportedOperationException e) {", "originalCommit": "5820f801fcd894c460f13204a361f84c792b2aab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MzUxMA==", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r437043510", "bodyText": "Better use instanceof instead of checking the class name in this case.", "author": "chtyim", "createdAt": "2020-06-08T22:50:04Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/HttpExceptionHandler.java", "diffHunk": "@@ -64,6 +64,12 @@ public void handle(Throwable t, HttpRequest request, HttpResponder responder) {\n         responder.sendString(HttpResponseStatus.CONFLICT, cause.getMessage());\n         return;\n       }\n+\n+      if (cause.getClass().getName().endsWith(\"UnsupportedOperationException\")) {", "originalCommit": "0a569b9e28525399c68892b1c7eae05e010e253f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2744762c84df3f36ae78cac6082e829134e16f4", "url": "https://github.com/cdapio/cdap/commit/d2744762c84df3f36ae78cac6082e829134e16f4", "message": "Fixing artifact test", "committedDate": "2020-06-09T01:05:30Z", "type": "forcePushed"}, {"oid": "ffaa13ba408e9935cd7388ef740ae2947f2f886e", "url": "https://github.com/cdapio/cdap/commit/ffaa13ba408e9935cd7388ef740ae2947f2f886e", "message": "Add new API in application interface for upgrading application config.\nAdd logic for DataPipelineApp to upgrade ETLBatchConfig. Add REST API\nendpoints for upgrading applications.", "committedDate": "2020-06-09T16:26:14Z", "type": "commit"}, {"oid": "ffaa13ba408e9935cd7388ef740ae2947f2f886e", "url": "https://github.com/cdapio/cdap/commit/ffaa13ba408e9935cd7388ef740ae2947f2f886e", "message": "Add new API in application interface for upgrading application config.\nAdd logic for DataPipelineApp to upgrade ETLBatchConfig. Add REST API\nendpoints for upgrading applications.", "committedDate": "2020-06-09T16:26:14Z", "type": "forcePushed"}]}