{"pr_number": 12886, "pr_title": "Capability framework with changes for enabling capability", "pr_createdAt": "2020-12-07T18:23:19Z", "pr_url": "https://github.com/cdapio/cdap/pull/12886", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NjkyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537746923", "bodyText": "Remove CAPABILITY_ prefix since the inner class name already has it.", "author": "chtyim", "createdAt": "2020-12-07T18:53:28Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1495,4 +1495,22 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for capability management\n+   */\n+  public static final class Capability {\n+    /**\n+     * External config directory path key\n+     */\n+    public static final String CAPABILITY_CONFIG_EXTERNAL_DIR = \"capability.config.external.dir\";", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NzM3Mw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537747373", "bodyText": "Remove comment", "author": "chtyim", "createdAt": "2020-12-07T18:54:10Z", "path": "cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.AllProgramsApp;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+\n+/**\n+ * Test for {@link CapabilityManagementService}\n+ */\n+public class CapabilityManagementServiceTest extends CapabilityBaseTest {\n+\n+  private static final String VERSION = \"1.0.0\";\n+  private static final String APP_NAME = AllProgramsApp.NAME;\n+  private static final String NAMESPACE = \"default\";\n+  private static final String PROGRAM_NAME = AllProgramsApp.NoOpService.NAME;\n+  private static final Class<AllProgramsApp> APP_CLASS = AllProgramsApp.class;\n+  private static LocationFactory locationFactory;\n+  private static CapabilityManagementService capabilityManagementService;\n+  private static CapabilityManager capabilityManager;\n+  private static CConfiguration cConfiguration;\n+  //private static String externalConfigPath;", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0ODcxNQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537748715", "bodyText": "Why extends from AppFabricTestBase. Generally a simpler unit-test that directly test against the class is more preferrable.", "author": "chtyim", "createdAt": "2020-12-07T18:56:13Z", "path": "cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityBaseTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.io.Files;\n+import io.cdap.cdap.AllProgramsApp;\n+import io.cdap.cdap.common.id.Id;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.test.AppJarHelper;\n+import io.cdap.cdap.internal.app.services.http.AppFabricTestBase;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.junit.BeforeClass;\n+\n+import java.io.File;\n+\n+/**\n+ * Base class with common setup and methods for testing capability feature\n+ */\n+public class CapabilityBaseTest extends AppFabricTestBase {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MTcyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537751723", "bodyText": "We already have a Program class. It is better not to have the same class name even it in different package.", "author": "chtyim", "createdAt": "2020-12-07T18:59:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/Program.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with fields for requesting Programs that should be started for a capability\n+ */\n+public class Program {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDI5NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540474294", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T20:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Mjk1Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537752952", "bodyText": "Why need this class? Seems unnecessary.", "author": "chtyim", "createdAt": "2020-12-07T19:01:09Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzUyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537753523", "bodyText": "final fields.", "author": "chtyim", "createdAt": "2020-12-07T19:02:03Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzY5Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537753696", "bodyText": "static fields before non-static fields.", "author": "chtyim", "createdAt": "2020-12-07T19:02:17Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzgwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537753808", "bodyText": "Remove public for injected constructor.", "author": "chtyim", "createdAt": "2020-12-07T19:02:27Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NDA0Mw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537754043", "bodyText": "this.scheduleInterval to be consistent.", "author": "chtyim", "createdAt": "2020-12-07T19:02:47Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NTAwNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537755007", "bodyText": "Is this accurate? You are not rethrowing, right?", "author": "chtyim", "createdAt": "2020-12-07T19:04:27Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NjEyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537756123", "bodyText": "should be try (Reader reader = ...) { } to have the file reader closed", "author": "chtyim", "createdAt": "2020-12-07T19:06:11Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.\n+      LOG.error(\"Error while scanning capability config directory \", exception);\n+    }\n+  }\n+\n+  private void scanConfigDirectory() throws FileNotFoundException {\n+    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n+    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n+    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n+    //TODO should each config run in its own thread ?\n+    for (File configFile : DirUtils.listFiles(destDir)) {\n+      CapabilityConfig capabilityConfig = parseConfig(configFile);\n+      if (toDelete.contains(configFile)) {\n+        handleDelete(capabilityConfig, configFile);\n+        continue;\n+      }\n+      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n+    }\n+  }\n+\n+  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n+    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityManager.isCapabilityPresent(capability)) {\n+      return;\n+    }\n+    //capability deleted. Remove the file\n+    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n+    configFile.delete();\n+  }\n+\n+  private Set<File> diffAndCopy(File srcDir, File destDir) {\n+    List<File> srcFiles = DirUtils.listFiles(srcDir);\n+    //copy the new files and replace\n+    srcFiles.stream().\n+      forEach(file -> {\n+        try {\n+          Files\n+            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n+                  StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException exception) {\n+          throw new RuntimeException(exception);\n+        }\n+      });\n+    //find the files to remove\n+    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n+      .filter(file -> matchName(file, srcFiles))\n+      .collect(Collectors.toSet());\n+    return destFilesToRemove;\n+  }\n+\n+  private boolean matchName(File file, List<File> files) {\n+    return files.stream()\n+      .map(File::getName)\n+      .noneMatch(fileName -> fileName.equals(file.getName()));\n+  }\n+\n+  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n+    Reader reader = new FileReader(configFile);", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NzQ0MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537757441", "bodyText": "Use a simple for-loop is better in this case. Wrapping all IOException as RuntimeException is bad.", "author": "chtyim", "createdAt": "2020-12-07T19:08:14Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.\n+      LOG.error(\"Error while scanning capability config directory \", exception);\n+    }\n+  }\n+\n+  private void scanConfigDirectory() throws FileNotFoundException {\n+    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n+    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n+    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n+    //TODO should each config run in its own thread ?\n+    for (File configFile : DirUtils.listFiles(destDir)) {\n+      CapabilityConfig capabilityConfig = parseConfig(configFile);\n+      if (toDelete.contains(configFile)) {\n+        handleDelete(capabilityConfig, configFile);\n+        continue;\n+      }\n+      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n+    }\n+  }\n+\n+  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n+    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityManager.isCapabilityPresent(capability)) {\n+      return;\n+    }\n+    //capability deleted. Remove the file\n+    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n+    configFile.delete();\n+  }\n+\n+  private Set<File> diffAndCopy(File srcDir, File destDir) {\n+    List<File> srcFiles = DirUtils.listFiles(srcDir);\n+    //copy the new files and replace\n+    srcFiles.stream().", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Nzc4NQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537757785", "bodyText": "Don't use string format to create new file path. Use new File(destDir, file.getName) instead.", "author": "chtyim", "createdAt": "2020-12-07T19:08:48Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.\n+      LOG.error(\"Error while scanning capability config directory \", exception);\n+    }\n+  }\n+\n+  private void scanConfigDirectory() throws FileNotFoundException {\n+    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n+    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n+    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n+    //TODO should each config run in its own thread ?\n+    for (File configFile : DirUtils.listFiles(destDir)) {\n+      CapabilityConfig capabilityConfig = parseConfig(configFile);\n+      if (toDelete.contains(configFile)) {\n+        handleDelete(capabilityConfig, configFile);\n+        continue;\n+      }\n+      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n+    }\n+  }\n+\n+  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n+    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityManager.isCapabilityPresent(capability)) {\n+      return;\n+    }\n+    //capability deleted. Remove the file\n+    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n+    configFile.delete();\n+  }\n+\n+  private Set<File> diffAndCopy(File srcDir, File destDir) {\n+    List<File> srcFiles = DirUtils.listFiles(srcDir);\n+    //copy the new files and replace\n+    srcFiles.stream().\n+      forEach(file -> {\n+        try {\n+          Files\n+            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTg5Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537761897", "bodyText": "Use isEmpty", "author": "chtyim", "createdAt": "2020-12-07T19:15:26Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityEnableExecutor.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.deploy.pipeline.ApplicationWithPrograms;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.proto.ApplicationDetail;\n+import io.cdap.cdap.proto.ProgramStatus;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Executor for enabling a capability\n+ */\n+public class CapabilityEnableExecutor implements CapabilityActionExecutor {\n+\n+  private CapabilityManager capabilityManager;\n+  private final ApplicationLifecycleService appLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private static final Gson GSON = new Gson();\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private static final Set<Class<? extends Exception>> nonRetryableExceptions =\n+    new HashSet<>(\n+      Arrays.asList(UnauthorizedException.class, InvalidArtifactException.class\n+      ));\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityEnableExecutor.class);\n+\n+  @Inject\n+  CapabilityEnableExecutor(CapabilityManager capabilityManager, ApplicationLifecycleService appLifecycleService,\n+                           ProgramLifecycleService programLifecycleService) {\n+    this.capabilityManager = capabilityManager;\n+    this.appLifecycleService = appLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  @Override\n+  public void execute(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    LOG.debug(\"Enabling capability {}\", capability);\n+    try {\n+      deployAllApps(capability, capabilityConfig.getApplications());\n+      startAllPrograms(capability, capabilityConfig.getPrograms());\n+      capabilityManager.updateStatus(capability, CapabilityStatus.ENABLED);\n+    } catch (Exception exception) {\n+      capabilityManager.updateStatus(capability, CapabilityStatus.UNKNOWN);\n+      LOG.error(\"Enabling capability {} failed.\", capability, exception);\n+    }\n+  }\n+\n+  private void deployAllApps(String capability, List<Application> applications) throws Exception {\n+    if (applications == null || applications.size() == 0) {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MjE5Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537762197", "bodyText": "Is applications nullable?", "author": "chtyim", "createdAt": "2020-12-07T19:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MTgyOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538791828", "bodyText": "final", "author": "chtyim", "createdAt": "2020-12-08T20:43:04Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MjQ2MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538792461", "bodyText": "Use an AtomicReference<Map...> to do atomic replacement of map in the set method.", "author": "chtyim", "createdAt": "2020-12-08T20:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzQ3NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917474", "bodyText": "done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MjgzMA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538792830", "bodyText": "Call it setProgramsEnabled. This means renaming the field too.", "author": "chtyim", "createdAt": "2020-12-08T20:44:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzQ0MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917440", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Mzc1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538793758", "bodyText": "Put the default value into cdap-default.xml instead.", "author": "chtyim", "createdAt": "2020-12-08T20:46:29Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzM4Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917387", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Mzc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5NDA5MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538794091", "bodyText": "debug", "author": "chtyim", "createdAt": "2020-12-08T20:46:57Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538797994", "bodyText": "It is better to loop by the ProgramId and call ProgramRuntimeService.list(ProgramId) on each of them", "author": "chtyim", "createdAt": "2020-12-08T20:53:16Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception exception) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", exception);\n+    }\n+  }\n+\n+  private void reconcileServices() {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.enabledServices);\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2OTMwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538869308", "bodyText": "Listing with program id will return only the enabled services runs. We also need to identify the services to stop, so using listAll for service here.", "author": "greeshmaswaminathan", "createdAt": "2020-12-08T22:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MjE4Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538872187", "bodyText": "Since you are listing all runs, you can collect the list of extra runs to stop in here. Also, always collect the ProgramRunId to pin point to which runs to run.", "author": "chtyim", "createdAt": "2020-12-08T22:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzI5OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917299", "bodyText": "Done. Changes in #12886", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMDE3Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538800177", "bodyText": "I think this doesn't handle the case where there are two runs of the same programId, in which we want to stop the extra ones.", "author": "chtyim", "createdAt": "2020-12-08T20:55:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception exception) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", exception);\n+    }\n+  }\n+\n+  private void reconcileServices() {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.enabledServices);\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2OTc2Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538869762", "bodyText": "Stopping additional runs are handled separately.", "author": "greeshmaswaminathan", "createdAt": "2020-12-08T22:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMjc4Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538802782", "bodyText": "Usually we just use ex as the variable name for exception.", "author": "chtyim", "createdAt": "2020-12-08T20:58:31Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception exception) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", exception);\n+    }\n+  }\n+\n+  private void reconcileServices() {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.enabledServices);\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n+      ProgramId programId = runtimeInfo.getProgramId();\n+      if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n+        //We care only about system services\n+        continue;\n+      }\n+      if (!enabledServices.contains(programId)) {\n+        servicesToStop.add(programId);\n+      } else {\n+        servicesRunning.add(programId);\n+      }\n+    }\n+    Set<ProgramId> servicesToStart = enabledServices.stream()\n+      .filter(programId -> !servicesRunning.contains(programId))\n+      .collect(Collectors.toSet());\n+    startServices(servicesToStart, enabledServicesMap);\n+    stopServices(servicesToStop);\n+    //prune additional runs if any\n+    pruneAdditionalRuns(enabledServices);\n+  }\n+\n+  private void startServices(Set<ProgramId> servicesToStart, Map<ProgramId, Map<String, String>> enabledServicesMap) {\n+    for (ProgramId programId : servicesToStart) {\n+      Map<String, String> overrides = enabledServicesMap.get(programId);\n+      LOG.debug(\"Starting program {} with args {}\", programId, overrides);\n+      try {\n+        programLifecycleService.start(programId, overrides, false);\n+      } catch (Exception exception) {", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzE0Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917147", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMjc4Mg=="}], "type": "inlineReview"}, {"oid": "5818e0d644b15fb787210d97e1eb0fb675d66228", "url": "https://github.com/cdapio/cdap/commit/5818e0d644b15fb787210d97e1eb0fb675d66228", "message": "Capability framework wih changes for enabling capability", "committedDate": "2020-12-10T20:26:07Z", "type": "forcePushed"}, {"oid": "292338c543bbd45ae87b1a19e6c9cfa9f4447e3d", "url": "https://github.com/cdapio/cdap/commit/292338c543bbd45ae87b1a19e6c9cfa9f4447e3d", "message": "Capability framework wih changes for enabling capability", "committedDate": "2020-12-10T20:43:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYyNTM0Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540625347", "bodyText": "No need to have binding. Just new it in the CapabilityManager", "author": "chtyim", "createdAt": "2020-12-11T01:35:56Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +303,9 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n+      bind(CapabilityManager.class).in(Scopes.SINGLETON);\n       bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n+      bind(MetadataSearchClient.class).in(Scopes.SINGLETON);", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTY3Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481676", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYyNTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MjMyNA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540842324", "bodyText": "Shouldn't call pipeline. CDAP platform itself has no concept of pipeline. Call it stopAllPrograms", "author": "chtyim", "createdAt": "2020-12-11T10:22:06Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+    refreshCapabilities();\n+  }\n+\n+  /**\n+   * Apply capabilities based on the configuration files on disk\n+   */\n+  private void refreshCapabilities() {\n+    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n+    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n+    try {\n+      readLock.lock();\n+      for (File configFile : DirUtils.listFiles(dataDir)) {\n+        try (Reader reader = new FileReader(configFile)) {\n+          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n+        } catch (IOException ex) {\n+          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+    refreshCapabilities(allCapabilityConfigs);\n+  }\n+\n+  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n+    //collect all programs to be enabled\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    Set<String> enabledCapabilities = new HashSet<>();\n+    for (CapabilityConfig config : capabilityConfigs) {\n+      String capability = config.getCapability();\n+      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n+      switch (config.getType()) {\n+        case ENABLE:\n+          deployAllApps(capability, config.getApplications());\n+          config.getPrograms().forEach(systemProgram -> enabledPrograms\n+            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+          enabledCapabilities.add(capability);\n+          break;\n+        case DISABLE:\n+          disableCapability(capability);\n+          break;\n+        case DELETE:\n+          deleteCapability(config);\n+          break;\n+        default:\n+          LOG.error(\"Unknown capability action {} \", config.getType());\n+          break;\n+      }\n+    }\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    enabledCapabilities.forEach(this::enableCapability);\n+  }\n+\n+  /**\n+   * Returns the list of applications that are having metadata tagged with the capability\n+   *\n+   * @param namespace  Namespace for which applications should be listed\n+   * @param capability Capability by which to filter\n+   * @param cursor     Optional cursor from a previous response\n+   * @param offset     Offset from where to start\n+   * @param limit      Limit of records to fetch\n+   * @return\n+   * @throws IOException - Exception from meta data search if any\n+   */\n+  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n+                                                     int offset, int limit) throws IOException {\n+    String capabilityTag = String.format(CAPABILITY, capability);\n+    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n+      .addNamespace(namespace.getNamespace())\n+      .addType(APPLICATION)\n+      .setScope(MetadataScope.SYSTEM)\n+      .setCursor(cursor)\n+      .setOffset(offset)\n+      .setLimit(limit)\n+      .build();\n+    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n+    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n+      .map(MetadataSearchResultRecord::getMetadataEntity)\n+      .map(this::getApplicationId)\n+      .collect(Collectors.toSet());\n+    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n+                              searchResponse.getOffset(), searchResponse.getLimit(),\n+                              searchResponse.getTotal());\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n+  }\n+\n+  @Nullable\n+  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n+    List<String> cursors = searchResponse.getCursors();\n+    if (cursors == null || cursors.isEmpty()) {\n+      return null;\n+    }\n+    return cursors.get(0);\n+  }\n+\n+  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n+    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n+                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n+                             metadataEntity.getValue(MetadataEntity.VERSION));\n+  }\n+\n+  private void enableCapability(String capability) {\n+    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n+    LOG.debug(\"Capability {} enabled.\", capability);\n+  }\n+\n+  private void disableCapability(String capability) {\n+    //mark as disabled to prevent further runs\n+    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n+    //stop pipelines\n+    try {\n+      stopPipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //programs(services) will be stopped by SystemProgramManagementService\n+    LOG.debug(\"Capability {} disabled.\", capability);\n+  }\n+\n+  private void deleteCapability(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n+      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n+      return;\n+    }\n+    //delete pipelines\n+    try {\n+      deletePipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //delete applications\n+    for (SystemApplication application : capabilityConfig.getApplications()) {\n+      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n+                                                      application.getVersion());\n+      try {\n+        applicationLifecycleService.removeApplication(applicationId);\n+      } catch (Exception exception) {\n+        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n+      }\n+    }\n+    capabilityStatusMap.remove(capability);\n+    LOG.debug(\"Capability {} deleted.\", capability);\n+  }\n+\n+  private void deletePipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopPipelines(String capability) throws Exception {", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTY5OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481698", "bodyText": "Renamed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MjMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDkwMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540844903", "bodyText": "Is everything exception retryable?", "author": "chtyim", "createdAt": "2020-12-11T10:26:28Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+    refreshCapabilities();\n+  }\n+\n+  /**\n+   * Apply capabilities based on the configuration files on disk\n+   */\n+  private void refreshCapabilities() {\n+    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n+    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n+    try {\n+      readLock.lock();\n+      for (File configFile : DirUtils.listFiles(dataDir)) {\n+        try (Reader reader = new FileReader(configFile)) {\n+          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n+        } catch (IOException ex) {\n+          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+    refreshCapabilities(allCapabilityConfigs);\n+  }\n+\n+  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n+    //collect all programs to be enabled\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    Set<String> enabledCapabilities = new HashSet<>();\n+    for (CapabilityConfig config : capabilityConfigs) {\n+      String capability = config.getCapability();\n+      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n+      switch (config.getType()) {\n+        case ENABLE:\n+          deployAllApps(capability, config.getApplications());\n+          config.getPrograms().forEach(systemProgram -> enabledPrograms\n+            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+          enabledCapabilities.add(capability);\n+          break;\n+        case DISABLE:\n+          disableCapability(capability);\n+          break;\n+        case DELETE:\n+          deleteCapability(config);\n+          break;\n+        default:\n+          LOG.error(\"Unknown capability action {} \", config.getType());\n+          break;\n+      }\n+    }\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    enabledCapabilities.forEach(this::enableCapability);\n+  }\n+\n+  /**\n+   * Returns the list of applications that are having metadata tagged with the capability\n+   *\n+   * @param namespace  Namespace for which applications should be listed\n+   * @param capability Capability by which to filter\n+   * @param cursor     Optional cursor from a previous response\n+   * @param offset     Offset from where to start\n+   * @param limit      Limit of records to fetch\n+   * @return\n+   * @throws IOException - Exception from meta data search if any\n+   */\n+  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n+                                                     int offset, int limit) throws IOException {\n+    String capabilityTag = String.format(CAPABILITY, capability);\n+    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n+      .addNamespace(namespace.getNamespace())\n+      .addType(APPLICATION)\n+      .setScope(MetadataScope.SYSTEM)\n+      .setCursor(cursor)\n+      .setOffset(offset)\n+      .setLimit(limit)\n+      .build();\n+    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n+    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n+      .map(MetadataSearchResultRecord::getMetadataEntity)\n+      .map(this::getApplicationId)\n+      .collect(Collectors.toSet());\n+    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n+                              searchResponse.getOffset(), searchResponse.getLimit(),\n+                              searchResponse.getTotal());\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n+  }\n+\n+  @Nullable\n+  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n+    List<String> cursors = searchResponse.getCursors();\n+    if (cursors == null || cursors.isEmpty()) {\n+      return null;\n+    }\n+    return cursors.get(0);\n+  }\n+\n+  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n+    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n+                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n+                             metadataEntity.getValue(MetadataEntity.VERSION));\n+  }\n+\n+  private void enableCapability(String capability) {\n+    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n+    LOG.debug(\"Capability {} enabled.\", capability);\n+  }\n+\n+  private void disableCapability(String capability) {\n+    //mark as disabled to prevent further runs\n+    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n+    //stop pipelines\n+    try {\n+      stopPipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //programs(services) will be stopped by SystemProgramManagementService\n+    LOG.debug(\"Capability {} disabled.\", capability);\n+  }\n+\n+  private void deleteCapability(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n+      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n+      return;\n+    }\n+    //delete pipelines\n+    try {\n+      deletePipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //delete applications\n+    for (SystemApplication application : capabilityConfig.getApplications()) {\n+      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n+                                                      application.getVersion());\n+      try {\n+        applicationLifecycleService.removeApplication(applicationId);\n+      } catch (Exception exception) {\n+        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n+      }\n+    }\n+    capabilityStatusMap.remove(capability);\n+    LOG.debug(\"Capability {} deleted.\", capability);\n+  }\n+\n+  private void deletePipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopPipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::stopPrograms);\n+  }\n+\n+  private void deployAllApps(String capability, List<SystemApplication> applications) {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::deployApp);\n+    }\n+  }\n+\n+  private void deployApp(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    try {\n+      if (isAppDeployed(applicationId)) {\n+        //Already deployed.\n+        LOG.debug(\"Application {} is already deployed\", applicationId);\n+        return;\n+      }\n+      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+      applicationLifecycleService\n+        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+    } catch (Exception ex) {\n+      throw new RetryableException(ex);", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0ODgwMQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541148801", "bodyText": "We could restrict it to not retry for UnauthorizedException, InvalidArtifactException . Only retrying for ArtifactNotFoundException may not be sufficient I think. Not sure what the exception is in case system is not fully ready.", "author": "greeshmaswaminathan", "createdAt": "2020-12-11T18:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTc1Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481757", "bodyText": "Added some checks for exceptions.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzA4OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540847088", "bodyText": "This check seems unnecessary. Why not just let the getApplications get called again and have it return empty set if there is no more apps?", "author": "chtyim", "createdAt": "2020-12-11T10:29:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+    refreshCapabilities();\n+  }\n+\n+  /**\n+   * Apply capabilities based on the configuration files on disk\n+   */\n+  private void refreshCapabilities() {\n+    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n+    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n+    try {\n+      readLock.lock();\n+      for (File configFile : DirUtils.listFiles(dataDir)) {\n+        try (Reader reader = new FileReader(configFile)) {\n+          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n+        } catch (IOException ex) {\n+          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+    refreshCapabilities(allCapabilityConfigs);\n+  }\n+\n+  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n+    //collect all programs to be enabled\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    Set<String> enabledCapabilities = new HashSet<>();\n+    for (CapabilityConfig config : capabilityConfigs) {\n+      String capability = config.getCapability();\n+      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n+      switch (config.getType()) {\n+        case ENABLE:\n+          deployAllApps(capability, config.getApplications());\n+          config.getPrograms().forEach(systemProgram -> enabledPrograms\n+            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+          enabledCapabilities.add(capability);\n+          break;\n+        case DISABLE:\n+          disableCapability(capability);\n+          break;\n+        case DELETE:\n+          deleteCapability(config);\n+          break;\n+        default:\n+          LOG.error(\"Unknown capability action {} \", config.getType());\n+          break;\n+      }\n+    }\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    enabledCapabilities.forEach(this::enableCapability);\n+  }\n+\n+  /**\n+   * Returns the list of applications that are having metadata tagged with the capability\n+   *\n+   * @param namespace  Namespace for which applications should be listed\n+   * @param capability Capability by which to filter\n+   * @param cursor     Optional cursor from a previous response\n+   * @param offset     Offset from where to start\n+   * @param limit      Limit of records to fetch\n+   * @return\n+   * @throws IOException - Exception from meta data search if any\n+   */\n+  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n+                                                     int offset, int limit) throws IOException {\n+    String capabilityTag = String.format(CAPABILITY, capability);\n+    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n+      .addNamespace(namespace.getNamespace())\n+      .addType(APPLICATION)\n+      .setScope(MetadataScope.SYSTEM)\n+      .setCursor(cursor)\n+      .setOffset(offset)\n+      .setLimit(limit)\n+      .build();\n+    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n+    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n+      .map(MetadataSearchResultRecord::getMetadataEntity)\n+      .map(this::getApplicationId)\n+      .collect(Collectors.toSet());\n+    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n+                              searchResponse.getOffset(), searchResponse.getLimit(),\n+                              searchResponse.getTotal());\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n+  }\n+\n+  @Nullable\n+  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n+    List<String> cursors = searchResponse.getCursors();\n+    if (cursors == null || cursors.isEmpty()) {\n+      return null;\n+    }\n+    return cursors.get(0);\n+  }\n+\n+  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n+    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n+                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n+                             metadataEntity.getValue(MetadataEntity.VERSION));\n+  }\n+\n+  private void enableCapability(String capability) {\n+    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n+    LOG.debug(\"Capability {} enabled.\", capability);\n+  }\n+\n+  private void disableCapability(String capability) {\n+    //mark as disabled to prevent further runs\n+    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n+    //stop pipelines\n+    try {\n+      stopPipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //programs(services) will be stopped by SystemProgramManagementService\n+    LOG.debug(\"Capability {} disabled.\", capability);\n+  }\n+\n+  private void deleteCapability(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n+      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n+      return;\n+    }\n+    //delete pipelines\n+    try {\n+      deletePipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //delete applications\n+    for (SystemApplication application : capabilityConfig.getApplications()) {\n+      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n+                                                      application.getVersion());\n+      try {\n+        applicationLifecycleService.removeApplication(applicationId);\n+      } catch (Exception exception) {\n+        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n+      }\n+    }\n+    capabilityStatusMap.remove(capability);\n+    LOG.debug(\"Capability {} deleted.\", capability);\n+  }\n+\n+  private void deletePipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopPipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::stopPrograms);\n+  }\n+\n+  private void deployAllApps(String capability, List<SystemApplication> applications) {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::deployApp);\n+    }\n+  }\n+\n+  private void deployApp(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    try {\n+      if (isAppDeployed(applicationId)) {\n+        //Already deployed.\n+        LOG.debug(\"Application {} is already deployed\", applicationId);\n+        return;\n+      }\n+      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+      applicationLifecycleService\n+        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+    } catch (Exception ex) {\n+      throw new RetryableException(ex);\n+    }\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (results.getEntities().size() > 0) {\n+        //call consumer for each entity\n+        results.getEntities().forEach(consumer);\n+        if (results.getEntities().size() < limit) {", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTc4Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481786", "bodyText": "Removed", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTA4OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541109089", "bodyText": "Seems like this class doesn't need to be a service. I am imagining there is a higher level service for watching/scanning for file changes, in which we can have it to manage the lifecycle of the systemProgramManagementService.", "author": "chtyim", "createdAt": "2020-12-11T17:29:10Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTkwNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481906", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExOTA0OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541119049", "bodyText": "I think the exception should be surfaced to the caller, right? Otherwise it's possible changes was detected but never be applied and no one is retrying it.", "author": "chtyim", "createdAt": "2020-12-11T17:45:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTk0OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481948", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExOTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMTczMQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542721731", "bodyText": "Do we need all these to be public bindings? It is better to have capability related bindings in its own private module and add to appropriate injector creation.", "author": "chtyim", "createdAt": "2020-12-14T20:05:04Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +306,12 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n+      bind(CapabilityApplier.class).in(Scopes.SINGLETON);", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzU0Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544853542", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMzE5MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542723190", "bodyText": "Do we allow all capability to be used in preview?", "author": "chtyim", "createdAt": "2020-12-14T20:06:32Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java", "diffHunk": "@@ -194,6 +196,8 @@ protected void configure() {\n \n     bind(PreferencesFetcher.class).toProvider(preferencesFetcherProvider);\n     expose(PreferencesFetcher.class);\n+\n+    bind(CapabilityReader.class).to(NoopCapabilityReader.class);", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2MDQzMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544760432", "bodyText": "We didn't consider preview till now. Should we block for preview ?", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T02:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzM4OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544853389", "bodyText": "Modified to use same the full reader implementation.", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMzE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczNjMxMA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542736310", "bodyText": "This seems like an internal class to capability? If that's the case, make it package private", "author": "chtyim", "createdAt": "2020-12-14T20:18:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzExNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544853116", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczNjMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczOTIxOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542739218", "bodyText": "Takes Collection<? extends CapabilityConfig> instead.", "author": "chtyim", "createdAt": "2020-12-14T20:21:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityChecker,\n+                    CapabilityWriter capabilityWriter) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityChecker;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) throws Exception {", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1Mjc3Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544852777", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczOTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMjg3OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544732879", "bodyText": "Have this class also implements the HttpErrorStatusProvider interface to respond with appropriate HTTP status when a capability is not available during app deploy / program start time.", "author": "chtyim", "createdAt": "2020-12-17T01:00:00Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityNotAvailableException.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+/**\n+ * CapabilityNotAvailableException indicating that the capability is disabled\n+ */\n+public class CapabilityNotAvailableException extends Exception {", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MjcxNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544852717", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMjg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMzg5OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544733899", "bodyText": "Are we always hiding apps when capability is disable?", "author": "chtyim", "createdAt": "2020-12-17T01:02:43Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -224,6 +229,12 @@ protected void shutDown() throws Exception {\n     List<ApplicationDetail> result = new ArrayList<>();\n     for (Map.Entry<ApplicationId, ApplicationSpecification> entry : appSpecs.entrySet()) {\n       ApplicationDetail applicationDetail = ApplicationDetail.fromSpec(entry.getValue(), owners.get(entry.getKey()));\n+      try {\n+        capabilityReader.ensureApplicationEnabled(namespace.getNamespace(), applicationDetail.getName());", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczOTI5MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544739290", "bodyText": "Also, if the appClass.getRequirements().getCapabilities() already tells what capability an app needs, then why we need the ensureApplicationEnabled method?", "author": "chtyim", "createdAt": "2020-12-17T01:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMzg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MjY0MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544852641", "bodyText": "Changed to use capabilities from  appspec", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNDk0OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544734949", "bodyText": "You can simplify it to\nboolean allEnabled = appClass.getRequirements().getCapabilities().stream().allMatch(capabilityReader::isEnabled);\nif (!allEnabled) {\n  throw ...\n}", "author": "chtyim", "createdAt": "2020-12-17T01:05:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -896,7 +907,12 @@ private ApplicationWithPrograms deployApp(NamespaceId namespaceId, @Nullable Str\n       throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n                                                        artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n     }\n-\n+    Set<String> capabilities = appClass.getRequirements().getCapabilities();\n+    for (String capability : capabilities) {\n+      if (!capabilityReader.isEnabled(capability)) {", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3MDI0OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544770249", "bodyText": "didnt use stream API because of needing to wrap IOException as a RuntimeException", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T02:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNDk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNjg4NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544736884", "bodyText": "Unused?", "author": "chtyim", "createdAt": "2020-12-17T01:10:57Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ProgramLifecycleService.java", "diffHunk": "@@ -478,6 +481,19 @@ public RunId run(ProgramId programId, Map<String, String> overrides, boolean deb\n     return runs;\n   }\n \n+  /**\n+   * Stop all active programs for the given application\n+   * @param applicationId\n+   * @throws Exception\n+   */\n+  public void stopAll(ApplicationId applicationId) throws Exception {\n+    Set<RunId> runs = new HashSet<>();", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTk2OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851968", "bodyText": "Removed", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNjg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0MTkzOQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544741939", "bodyText": "for identity function, use Function.identity() instead", "author": "chtyim", "createdAt": "2020-12-17T01:24:43Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityChecker,\n+                    CapabilityWriter capabilityWriter) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityChecker;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, capabilityStatusRecord -> capabilityStatusRecord));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability,\n+                                capabilityOperationRecord -> capabilityOperationRecord));", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTkxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851912", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0MTkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDE2MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544744160", "bodyText": "Why take the status as string in the constructor? It's better to take the enum directly.", "author": "chtyim", "createdAt": "2020-12-17T01:30:49Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Configuration for applying an action for a capability\n+ */\n+public class CapabilityConfig {\n+\n+  private final String label;\n+  private final CapabilityStatus status;\n+  private final String capability;\n+  private final List<SystemApplication> applications;\n+  private final List<SystemProgram> programs;\n+\n+  public CapabilityConfig(String label, String status, String capability,\n+                          @Nullable List<SystemApplication> applications, @Nullable List<SystemProgram> programs) {\n+    this.label = label;\n+    this.status = CapabilityStatus.valueOf(status);", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTg2NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851864", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDQ0Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544744442", "bodyText": "Should requires empty list instead of null.", "author": "chtyim", "createdAt": "2020-12-17T01:31:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Configuration for applying an action for a capability\n+ */\n+public class CapabilityConfig {\n+\n+  private final String label;\n+  private final CapabilityStatus status;\n+  private final String capability;\n+  private final List<SystemApplication> applications;\n+  private final List<SystemProgram> programs;\n+\n+  public CapabilityConfig(String label, String status, String capability,\n+                          @Nullable List<SystemApplication> applications, @Nullable List<SystemProgram> programs) {", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NTMxNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544745316", "bodyText": "Also, take a Collection<? extends SystemApplication> is better.", "author": "chtyim", "createdAt": "2020-12-17T01:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTgwNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851806", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NTM4OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544745388", "bodyText": "Do a defensive copy of the incoming collection.", "author": "chtyim", "createdAt": "2020-12-17T01:34:22Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Configuration for applying an action for a capability\n+ */\n+public class CapabilityConfig {\n+\n+  private final String label;\n+  private final CapabilityStatus status;\n+  private final String capability;\n+  private final List<SystemApplication> applications;\n+  private final List<SystemProgram> programs;\n+\n+  public CapabilityConfig(String label, String status, String capability,\n+                          @Nullable List<SystemApplication> applications, @Nullable List<SystemProgram> programs) {\n+    this.label = label;\n+    this.status = CapabilityStatus.valueOf(status);\n+    this.capability = capability;\n+    this.applications = (applications == null) ? Collections.emptyList() : applications;", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTc2Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851766", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1OTkzNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545459937", "bodyText": "Can you create a class instead of using inner class?", "author": "chtyim", "createdAt": "2020-12-17T23:01:01Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +306,20 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n+      install(new PrivateModule() {", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDQwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545554408", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1OTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ2NDY0Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545464646", "bodyText": "Seeing this loop couple times. Seems likes you can refactor it into the CapabilityReader instead. E.g. CapabilityReader.isAllEnabled(Collection<String> capabilities).", "author": "chtyim", "createdAt": "2020-12-17T23:09:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/deploy/pipeline/LocalArtifactLoaderStage.java", "diffHunk": "@@ -124,6 +132,14 @@ public void process(AppDeploymentInfo deploymentInfo) throws Exception {\n       applicationId = deploymentInfo.getNamespaceId().app(specification.getName(), appVersion);\n     }\n     authorizationEnforcer.enforce(applicationId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    for (Map.Entry<String, Plugin> pluginEntry : specification.getPlugins().entrySet()) {\n+      Set<String> capabilities = pluginEntry.getValue().getPluginClass().getRequirements().getCapabilities();\n+      for (String capability : capabilities) {", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDM2OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545554369", "bodyText": "Added a method that checks all and throws exception if not enabled. This is to ensure we can capture/propagate the disabled capability.", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ2NDY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTQ1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545489458", "bodyText": "I think this class should take the CapabilityStatusStore instead of separate reader and writer.", "author": "chtyim", "createdAt": "2020-12-18T00:14:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDAxNQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545554015", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTk3Mw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545489973", "bodyText": "The getCapabilityOperations should be only in the store class/interface. Generally think of the store as the internal class, while reader and writer are public. Since operation is internal to capability implementation, there is no need to expose it to either reader/writer interface", "author": "chtyim", "createdAt": "2020-12-18T00:15:51Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,\n+                    CapabilityWriter capabilityWriter, DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityReader;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1Mzk2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545553967", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MTY2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545491667", "bodyText": "You don't need try catch to determine if it can be retried or not. The Retrie.callWithRetries method can take a Predicate<Exception> to determine if the exception is retryable or not.", "author": "chtyim", "createdAt": "2020-12-18T00:20:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,\n+                    CapabilityWriter capabilityWriter, DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityReader;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityWriter\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityWriter\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithMetadata(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithMetadata(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithMetadata(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityWriter.deleteCapability(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithMetadata(String capability) throws Exception {\n+    doForAllAppsWithMetadata(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopAllProgramsWithMetadata(String capability) throws Exception {\n+    doForAllAppsWithMetadata(capability, this::stopAllRunningProgramsForApp);\n+  }\n+\n+  private void deployAllSystemApps(String capability, List<SystemApplication> applications) throws Exception {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::retryableDeployApp);\n+    }\n+  }\n+\n+  private void retryableDeployApp(SystemApplication application) throws Exception {\n+    ApplicationId applicationId = getApplicationId(application);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    try {\n+      if (isAppDeployed(applicationId)) {\n+        //Already deployed.\n+        LOG.debug(\"Application {} is already deployed\", applicationId);\n+        return;\n+      }\n+      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+      applicationLifecycleService\n+        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+    } catch (Exception ex) {\n+      checkForRetry(ex);\n+      throw new RetryableException(ex);\n+    }\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllAppsWithMetadata(String capability, CheckedConsumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (!results.getEntities().isEmpty()) {\n+        //call consumer for each entity\n+        for (ApplicationId entity : results.getEntities()) {\n+          consumer.accept(entity);\n+        }\n+        offset += limit;\n+        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n+      }\n+    }\n+  }\n+\n+  private void stopAllRunningProgramsForApp(ApplicationId applicationId) {\n+    try {\n+      doWithRetry(applicationId, this::retryableStopRunningPrograms);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n+    }\n+  }\n+\n+  private void retryableStopRunningPrograms(ApplicationId applicationId) throws Exception {\n+    try {\n+      programLifecycleService.stopAll(applicationId);\n+    } catch (Exception ex) {\n+      checkForRetry(ex);\n+      throw new RetryableException(ex);\n+    }\n+  }\n+\n+  private void deleteAppWithRetry(ApplicationId applicationId) throws Exception {\n+    doWithRetry(applicationId, this::retryableDeleteApp);\n+  }\n+\n+  private void retryableDeleteApp(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.removeApplication(applicationId);\n+    } catch (Exception ex) {\n+      checkForRetry(ex);", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzYyOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545553628", "bodyText": "Thanks, could remove lot of unnecessary methods.", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MjE0Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545492147", "bodyText": "The method signature has nothing to do with metadata. Metadata is the implementation detail. You better call this deleteAllAppsWithCapability.", "author": "chtyim", "createdAt": "2020-12-18T00:22:18Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,\n+                    CapabilityWriter capabilityWriter, DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityReader;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityWriter\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityWriter\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithMetadata(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithMetadata(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithMetadata(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityWriter.deleteCapability(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithMetadata(String capability) throws Exception {", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzQyNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545553427", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MjE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMDQ4MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546110481", "bodyText": "please try to avoid installing module like this. Put it in AppFabricServiceMain, MasterServiceMain, and StandaloneMain", "author": "chtyim", "createdAt": "2020-12-18T21:58:55Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +301,7 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n+      install(new CapabilityModule());", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzU1MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207550", "bodyText": "Moved to individual getModules() for AppFabricServiceRuntimeModule since several classes in Appfabric has dependency on CapabilityReader.", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTU4OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546111588", "bodyText": "this is not an efficient implementation. You should be able to make one query to the storage, instead of querying them one by one.", "author": "chtyim", "createdAt": "2020-12-18T22:02:09Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) throws IOException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> keyField = Collections\n+        .singleton(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      Collection<String> returnField = Collections.singleton(StoreDefinition.CapabilitiesStore.STATUS_FIELD);\n+      Optional<StructuredRow> result = capabilityTable.read(keyField, returnField);\n+      return result.map(structuredRow -> CapabilityStatus\n+        .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase())).orElse(null);\n+    }, IOException.class);\n+  }\n+\n+  @Override\n+  public boolean isEnabled(String capability) throws IOException {\n+    return getStatus(capability) == CapabilityStatus.ENABLED;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    for (String capability : capabilities) {\n+      if (!isEnabled(capability)) {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzQwNA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207404", "bodyText": "changed to single query.", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMzQ1Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546113452", "bodyText": "Repeated logic as in the LocalArtifactLoaderStage class? Consider moving it into CapabilityReader.checkAllEnabled(ApplicationSpecification spec).", "author": "chtyim", "createdAt": "2020-12-18T22:06:47Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -224,13 +228,27 @@ protected void shutDown() throws Exception {\n     List<ApplicationDetail> result = new ArrayList<>();\n     for (Map.Entry<ApplicationId, ApplicationSpecification> entry : appSpecs.entrySet()) {\n       ApplicationDetail applicationDetail = ApplicationDetail.fromSpec(entry.getValue(), owners.get(entry.getKey()));\n+      try {\n+        ensureApplicationEnabled(entry.getValue());\n+      } catch (CapabilityNotAvailableException ex) {\n+        LOG.debug(\"Application {} is ignored due to exception.\", applicationDetail.getName(), ex);\n+        continue;\n+      }\n       if (predicate.test(applicationDetail)) {\n         result.add(filterApplicationDetail(entry.getKey(), applicationDetail));\n       }\n     }\n     return result;\n   }\n \n+  private void ensureApplicationEnabled(ApplicationSpecification appSpec) throws IOException,\n+    CapabilityNotAvailableException {\n+    for (Map.Entry<String, Plugin> pluginEntry : appSpec.getPlugins().entrySet()) {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzM2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207367", "bodyText": "Moved", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMzQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTM3OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546115378", "bodyText": "So this call and the previous call are in different transaction, is it ok? E.g. if the status changed to ENABLED, but the operation was not deleted.", "author": "chtyim", "createdAt": "2020-12-18T22:12:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODc1MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546178751", "bodyText": "Should not be a problem. Next attempt, this will be noticed as ongoing operation , but since the config is same , action will not be applied and the operation entry will get deleted.", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T02:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjM2OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546116368", "bodyText": "Seems unnecessary to have this one line method.", "author": "chtyim", "createdAt": "2020-12-18T22:15:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithCapability(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithCapability(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithCapability(String capability) throws Exception {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjQxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546116412", "bodyText": "Same as above.", "author": "chtyim", "createdAt": "2020-12-18T22:15:35Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithCapability(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithCapability(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithCapability(String capability) throws Exception {\n+    doForAllAppsWithCapability(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopAllProgramsWithCapability(String capability) throws Exception {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzM1MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207350", "bodyText": "Removed", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjY3MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546116670", "bodyText": "Just call it stopAllPrograms(ApplicationId appId). It is clear enough what is it doing.", "author": "chtyim", "createdAt": "2020-12-18T22:16:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithCapability(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithCapability(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithCapability(String capability) throws Exception {\n+    doForAllAppsWithCapability(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopAllProgramsWithCapability(String capability) throws Exception {\n+    doForAllAppsWithCapability(capability, this::stopAllRunningProgramsForApp);\n+  }\n+\n+  private void deployAllSystemApps(String capability, List<SystemApplication> applications) throws Exception {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::retryableDeployApp);\n+    }\n+  }\n+\n+  private void retryableDeployApp(SystemApplication application) throws Exception {\n+    ApplicationId applicationId = getApplicationId(application);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    if (isAppDeployed(applicationId)) {\n+      //Already deployed.\n+      LOG.debug(\"Application {} is already deployed\", applicationId);\n+      return;\n+    }\n+    String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+    applicationLifecycleService\n+      .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                 application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllAppsWithCapability(String capability, CheckedConsumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (!results.getEntities().isEmpty()) {\n+        //call consumer for each entity\n+        for (ApplicationId entity : results.getEntities()) {\n+          consumer.accept(entity);\n+        }\n+        offset += limit;\n+        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n+      }\n+    }\n+  }\n+\n+  private void stopAllRunningProgramsForApp(ApplicationId applicationId) {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzMyNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207326", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1MjA4NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546552084", "bodyText": "Instead of exposing the status and the operations separated, they should be returned by one call (and via one query to DB). It should return something like Map<String, CapabilityRecord>, with CapabilityRecord contains the status and list of operations.", "author": "chtyim", "createdAt": "2020-12-21T07:39:28Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0Njc1NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946754", "bodyText": "Fixed to make it single method. Will be part of single txn.", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1MjA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1NzgxNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546557817", "bodyText": "Shouldn't check. Just force stopping regardless. In fact, deleteCapabilities should be calling disableCapabilities, followed by deleting app since all operations should be idempotent.", "author": "chtyim", "createdAt": "2020-12-21T07:55:52Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      doForAllAppsWithCapability(capability,\n+                                 applicationId -> doWithRetry(applicationId, programLifecycleService::stopAll));\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NjgxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946812", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1NzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1OTY3MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546559671", "bodyText": "Does it need to be public?", "author": "chtyim", "createdAt": "2020-12-21T08:00:47Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      doForAllAppsWithCapability(capability,\n+                                 applicationId -> doWithRetry(applicationId, programLifecycleService::stopAll));\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        doForAllAppsWithCapability(capability,\n+                                   applicationId -> doWithRetry(applicationId, programLifecycleService::stopAll));\n+      }\n+      //remove all applications having capability metadata.\n+      doForAllAppsWithCapability(capability,\n+                                 applicationId -> doWithRetry(applicationId,\n+                                                              applicationLifecycleService::removeApplication));\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        doWithRetry(applicationId, applicationLifecycleService::removeApplication);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deployAllSystemApps(String capability, List<SystemApplication> applications) throws Exception {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::deployApp);\n+    }\n+  }\n+\n+  private void deployApp(SystemApplication application) throws Exception {\n+    ApplicationId applicationId = getApplicationId(application);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    if (isAppDeployed(applicationId)) {\n+      //Already deployed.\n+      LOG.debug(\"Application {} is already deployed\", applicationId);\n+      return;\n+    }\n+    String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+    applicationLifecycleService\n+      .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                 application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllAppsWithCapability(String capability, CheckedConsumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (!results.getEntities().isEmpty()) {\n+        //call consumer for each entity\n+        for (ApplicationId entity : results.getEntities()) {\n+          consumer.accept(entity);\n+        }\n+        offset += limit;\n+        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n+      }\n+    }\n+  }\n+\n+  private <T> void doWithRetry(T argument, CheckedConsumer<T> consumer) throws Exception {\n+    Retries.callWithRetries(() -> {\n+      consumer.accept(argument);\n+      return null;\n+    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)), this::shouldRetry);\n+  }\n+\n+  private boolean shouldRetry(Throwable throwable) {\n+    return !(throwable instanceof UnauthorizedException ||\n+      throwable instanceof InvalidArtifactException ||\n+      throwable instanceof ArtifactNotFoundException);\n+  }\n+\n+  /**\n+   * Consumer functional interface that can throw exception\n+   *\n+   * @param <T>\n+   */\n+  @FunctionalInterface\n+  public interface CheckedConsumer<T> {", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0Njg2Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946862", "bodyText": "Made private", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1OTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ3MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546560471", "bodyText": "No need to call super method.", "author": "chtyim", "createdAt": "2020-12-21T08:02:45Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Scan service for capability configurations\n+ */\n+public class CapabilityManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+  private static final Gson GSON = new Gson();\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final CapabilityApplier capabilityApplier;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+\n+  @Inject\n+  CapabilityManagementService(CConfiguration cConf, CapabilityApplier capabilityApplier,\n+                              SystemProgramManagementService systemProgramManagementService) {\n+    super(RetryStrategies\n+            .fixDelay(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES), TimeUnit.MINUTES));\n+    this.cConf = cConf;\n+    this.capabilityApplier = capabilityApplier;\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.scheduleIntervalInMillis = TimeUnit.MINUTES\n+      .toMillis(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES));\n+  }\n+\n+  @Override\n+  protected void doStartUp() throws Exception {\n+    super.doStartUp();", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NjkyNA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946924", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ5Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546560496", "bodyText": "No need to call super method.", "author": "chtyim", "createdAt": "2020-12-21T08:02:50Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Scan service for capability configurations\n+ */\n+public class CapabilityManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+  private static final Gson GSON = new Gson();\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final CapabilityApplier capabilityApplier;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+\n+  @Inject\n+  CapabilityManagementService(CConfiguration cConf, CapabilityApplier capabilityApplier,\n+                              SystemProgramManagementService systemProgramManagementService) {\n+    super(RetryStrategies\n+            .fixDelay(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES), TimeUnit.MINUTES));\n+    this.cConf = cConf;\n+    this.capabilityApplier = capabilityApplier;\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.scheduleIntervalInMillis = TimeUnit.MINUTES\n+      .toMillis(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES));\n+  }\n+\n+  @Override\n+  protected void doStartUp() throws Exception {\n+    super.doStartUp();\n+    systemProgramManagementService.start();\n+  }\n+\n+  @Override\n+  protected void doShutdown() throws Exception {\n+    super.doShutdown();", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0Njk2NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946964", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTIzNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546561237", "bodyText": "It is a better habit to keep naming consistent in the same class. E.g. it is called allConfigs here, while it is called capabilityConfigList from the method above. It is better to consistently calling it capabilityConfigs (plural of the collection type)", "author": "chtyim", "createdAt": "2020-12-21T08:04:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Scan service for capability configurations\n+ */\n+public class CapabilityManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+  private static final Gson GSON = new Gson();\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final CapabilityApplier capabilityApplier;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+\n+  @Inject\n+  CapabilityManagementService(CConfiguration cConf, CapabilityApplier capabilityApplier,\n+                              SystemProgramManagementService systemProgramManagementService) {\n+    super(RetryStrategies\n+            .fixDelay(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES), TimeUnit.MINUTES));\n+    this.cConf = cConf;\n+    this.capabilityApplier = capabilityApplier;\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.scheduleIntervalInMillis = TimeUnit.MINUTES\n+      .toMillis(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES));\n+  }\n+\n+  @Override\n+  protected void doStartUp() throws Exception {\n+    super.doStartUp();\n+    systemProgramManagementService.start();\n+  }\n+\n+  @Override\n+  protected void doShutdown() throws Exception {\n+    super.doShutdown();\n+    systemProgramManagementService.stopAndWait();\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    LOG.debug(\"Scanning capability config directory.\");\n+    List<CapabilityConfig> capabilityConfigList = scanConfigDirectory();\n+    //apply all the config\n+    capabilityApplier.apply(capabilityConfigList);\n+    return scheduleIntervalInMillis;\n+  }\n+\n+  private List<CapabilityConfig> scanConfigDirectory() throws IOException {\n+    File configDir = new File(cConf.get(Constants.Capability.CONFIG_DIR));\n+    List<CapabilityConfig> allConfigs = new ArrayList<>();", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzAwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947008", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTkzMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546561932", "bodyText": "You can move this to the CapabilityReader interface as the default implementation.", "author": "chtyim", "createdAt": "2020-12-21T08:06:29Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) throws IOException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> keyField = Collections\n+        .singleton(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      Collection<String> returnField = Collections.singleton(StoreDefinition.CapabilitiesStore.STATUS_FIELD);\n+      Optional<StructuredRow> result = capabilityTable.read(keyField, returnField);\n+      return result.map(structuredRow -> CapabilityStatus\n+        .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase())).orElse(null);\n+    }, IOException.class);\n+  }\n+\n+  @Override\n+  public boolean isEnabled(String capability) throws IOException {\n+    return getStatus(capability) == CapabilityStatus.ENABLED;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      List<List<Field<?>>> multiKeys = new ArrayList<>();\n+      capabilities.forEach(capability -> {\n+        multiKeys\n+          .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability)));\n+      });\n+      Map<String, String> capabilityMap = capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+      for (String capability : capabilities) {\n+        if (!capabilityMap.containsKey(capability) || CapabilityStatus\n+          .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n+          throw new CapabilityNotAvailableException(capability);\n+        }\n+      }\n+    }, IOException.class, CapabilityNotAvailableException.class);\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(ApplicationSpecification appSpec) throws IOException, CapabilityNotAvailableException {\n+    Set<String> capabilities = appSpec.getPlugins().entrySet().stream()", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzEwMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947102", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MzQ1Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546563452", "bodyText": "This method seems like no longer used. Please remove it.", "author": "chtyim", "createdAt": "2020-12-21T08:10:17Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * CapabilityReader interface with methods based on current capability status\n+ */\n+public interface CapabilityReader {\n+\n+  /**\n+   * Returns the status of capability.\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  CapabilityStatus getStatus(String capability) throws IOException;\n+\n+  /**\n+   * Return boolean indicating whether the capability is enabled\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  boolean isEnabled(String capability) throws IOException;", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzA1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947058", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MzQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTQxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546565412", "bodyText": "Move this loop outside of the transaction as it has nothing to do with it. You can use the one that takes TxCallable to return the capabilityMap from the transaction.", "author": "chtyim", "createdAt": "2020-12-21T08:15:16Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) throws IOException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> keyField = Collections\n+        .singleton(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      Collection<String> returnField = Collections.singleton(StoreDefinition.CapabilitiesStore.STATUS_FIELD);\n+      Optional<StructuredRow> result = capabilityTable.read(keyField, returnField);\n+      return result.map(structuredRow -> CapabilityStatus\n+        .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase())).orElse(null);\n+    }, IOException.class);\n+  }\n+\n+  @Override\n+  public boolean isEnabled(String capability) throws IOException {\n+    return getStatus(capability) == CapabilityStatus.ENABLED;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      List<List<Field<?>>> multiKeys = new ArrayList<>();\n+      capabilities.forEach(capability -> {\n+        multiKeys\n+          .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability)));\n+      });\n+      Map<String, String> capabilityMap = capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+      for (String capability : capabilities) {", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzE2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947167", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTU5OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546565599", "bodyText": "This method seems like not used. Please remove it.", "author": "chtyim", "createdAt": "2020-12-21T08:15:48Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * CapabilityReader interface with methods based on current capability status\n+ */\n+public interface CapabilityReader {\n+\n+  /**\n+   * Returns the status of capability.\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  CapabilityStatus getStatus(String capability) throws IOException;", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzIxNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947216", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NzM1NQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546567355", "bodyText": "Avoid expose method that backed by DB and have the caller looping and calling it in a tight loop. It's better to take a collection and returns a map/collection.", "author": "chtyim", "createdAt": "2020-12-21T08:20:02Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * CapabilityReader interface with methods based on current capability status\n+ */\n+public interface CapabilityReader {\n+\n+  /**\n+   * Returns the status of capability.\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  CapabilityStatus getStatus(String capability) throws IOException;\n+\n+  /**\n+   * Return boolean indicating whether the capability is enabled\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  boolean isEnabled(String capability) throws IOException;\n+\n+  /**\n+   * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   * @param capabilities\n+   * @return\n+   * @throws IOException\n+   */\n+  void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException;\n+\n+  /**\n+   * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   * @param appSpec\n+   * @return\n+   * @throws IOException\n+   */\n+  void checkAllEnabled(ApplicationSpecification appSpec) throws IOException, CapabilityNotAvailableException;\n+\n+  /**\n+   * Get the configuration for this capability if present\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  @Nullable\n+  CapabilityConfig getConfig(String capability) throws IOException;", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzI2Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947262", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NzM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDI3NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547000274", "bodyText": "I don't think it will throw the CapabilityNotAvailableException from the transaction, right?", "author": "chtyim", "createdAt": "2020-12-22T00:30:02Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    Map<String, String> capabilityMap = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+\n+    }, IOException.class, CapabilityNotAvailableException.class);", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzc3Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013772", "bodyText": "It doesn't, removed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDYzMA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547000630", "bodyText": "You can just use Collections.singleton(Fields.stirngField(....)) instead of creating an array list.", "author": "chtyim", "createdAt": "2020-12-22T00:31:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    Map<String, String> capabilityMap = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+\n+    }, IOException.class, CapabilityNotAvailableException.class);\n+    for (String capability : capabilities) {\n+      if (!capabilityMap.containsKey(capability) || CapabilityStatus\n+        .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n+        throw new CapabilityNotAvailableException(capability);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, CapabilityConfig> getConfigs(Collection<String> capabilities) throws IOException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class))\n+        );\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Returns list of all capability records\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  public Map<String, CapabilityRecord> getCapabilityRecords() throws IOException {\n+    Map<String, CapabilityRecord> capabilityRecordMap = new HashMap<>();\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      //query all operations\n+      Map<String, CapabilityOperationRecord> capabilityOperationMap = new HashMap<>();\n+      StructuredTable capabilityOperationTable = context\n+        .getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      CloseableIterator<StructuredRow> operationsResultIterator = capabilityOperationTable\n+        .scan(Range.all(), Integer.MAX_VALUE);\n+      operationsResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityOperationRecord capabilityOperationRecord = new CapabilityOperationRecord(\n+          capability, CapabilityAction\n+          .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.ACTION_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        capabilityOperationMap.put(capability, capabilityOperationRecord);\n+      });\n+      //query all capabilities\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      CloseableIterator<StructuredRow> capabilityResultIterator = capabilityTable.scan(Range.all(), Integer.MAX_VALUE);\n+      capabilityResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityStatusRecord capabilityStatusRecord = new CapabilityStatusRecord(\n+          capability,\n+          CapabilityStatus\n+            .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        //add to result and remove from operations map\n+        capabilityRecordMap\n+          .put(capability,\n+               new CapabilityRecord(capabilityStatusRecord, capabilityOperationMap.remove(capability)));\n+      });\n+      //add the remaining operations to result\n+      capabilityOperationMap.keySet().forEach(capability -> capabilityRecordMap\n+        .put(capability, new CapabilityRecord(null, capabilityOperationMap.get(capability))));\n+      return capabilityRecordMap;\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Add or update capability\n+   *\n+   * @param capability\n+   * @param status\n+   * @throws IOException\n+   */\n+  @Override\n+  public void addOrUpdateCapability(String capability, CapabilityStatus status,\n+                                    CapabilityConfig config) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.STATUS_FIELD, status.name().toLowerCase()));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.CONFIG_FIELD, GSON.toJson(config)));\n+      fields.add(Fields.longField(StoreDefinition.CapabilitiesStore.UPDATED_TIME_FIELD, System.currentTimeMillis()));\n+      capabilityTable.upsert(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Delete capability\n+   *\n+   * @param capability\n+   * @throws IOException\n+   */\n+  @Override\n+  public void deleteCapability(String capability) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzcyNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013727", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDY5Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547000697", "bodyText": "Same here. You can use Collections.singleton", "author": "chtyim", "createdAt": "2020-12-22T00:31:48Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    Map<String, String> capabilityMap = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+\n+    }, IOException.class, CapabilityNotAvailableException.class);\n+    for (String capability : capabilities) {\n+      if (!capabilityMap.containsKey(capability) || CapabilityStatus\n+        .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n+        throw new CapabilityNotAvailableException(capability);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, CapabilityConfig> getConfigs(Collection<String> capabilities) throws IOException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class))\n+        );\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Returns list of all capability records\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  public Map<String, CapabilityRecord> getCapabilityRecords() throws IOException {\n+    Map<String, CapabilityRecord> capabilityRecordMap = new HashMap<>();\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      //query all operations\n+      Map<String, CapabilityOperationRecord> capabilityOperationMap = new HashMap<>();\n+      StructuredTable capabilityOperationTable = context\n+        .getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      CloseableIterator<StructuredRow> operationsResultIterator = capabilityOperationTable\n+        .scan(Range.all(), Integer.MAX_VALUE);\n+      operationsResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityOperationRecord capabilityOperationRecord = new CapabilityOperationRecord(\n+          capability, CapabilityAction\n+          .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.ACTION_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        capabilityOperationMap.put(capability, capabilityOperationRecord);\n+      });\n+      //query all capabilities\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      CloseableIterator<StructuredRow> capabilityResultIterator = capabilityTable.scan(Range.all(), Integer.MAX_VALUE);\n+      capabilityResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityStatusRecord capabilityStatusRecord = new CapabilityStatusRecord(\n+          capability,\n+          CapabilityStatus\n+            .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        //add to result and remove from operations map\n+        capabilityRecordMap\n+          .put(capability,\n+               new CapabilityRecord(capabilityStatusRecord, capabilityOperationMap.remove(capability)));\n+      });\n+      //add the remaining operations to result\n+      capabilityOperationMap.keySet().forEach(capability -> capabilityRecordMap\n+        .put(capability, new CapabilityRecord(null, capabilityOperationMap.get(capability))));\n+      return capabilityRecordMap;\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Add or update capability\n+   *\n+   * @param capability\n+   * @param status\n+   * @throws IOException\n+   */\n+  @Override\n+  public void addOrUpdateCapability(String capability, CapabilityStatus status,\n+                                    CapabilityConfig config) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.STATUS_FIELD, status.name().toLowerCase()));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.CONFIG_FIELD, GSON.toJson(config)));\n+      fields.add(Fields.longField(StoreDefinition.CapabilitiesStore.UPDATED_TIME_FIELD, System.currentTimeMillis()));\n+      capabilityTable.upsert(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Delete capability\n+   *\n+   * @param capability\n+   * @throws IOException\n+   */\n+  @Override\n+  public void deleteCapability(String capability) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      capabilityTable.delete(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Adds or update capability operations\n+   *\n+   * @param capability\n+   * @param actionType\n+   * @param config\n+   * @throws IOException\n+   */\n+  public void addOrUpdateCapabilityOperation(String capability, CapabilityAction actionType,\n+                                             CapabilityConfig config) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.ACTION_FIELD, actionType.name().toLowerCase()));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.CONFIG_FIELD, GSON.toJson(config)));\n+      capabilityTable.upsert(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Deletes capability operations\n+   *\n+   * @param capability\n+   * @throws IOException\n+   */\n+  public void deleteCapabilityOperation(String capability) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzY5NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013694", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMTQ1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547001458", "bodyText": "I don't see this being used? If not, please remove it and also from the cdap-default.xml", "author": "chtyim", "createdAt": "2020-12-22T00:34:41Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1500,4 +1500,22 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for capability management\n+   */\n+  public static final class Capability {\n+    /**\n+     * Interval for scanning config\n+     */\n+    public static final String DIR_SCAN_INTERVAL_MINUTES = \"capability.dir.scan.interval.minutes\";\n+    /**\n+     * Capability config directory path key\n+     */\n+    public static final String CONFIG_DIR = \"capability.config.dir\";\n+    /**\n+     * Timeout for re-applying capabilities\n+     */\n+    public static final String APPLY_TIMEOUT_MINUTES = \"capability.apply.timeout.minutes\";", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzY2OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013669", "bodyText": "Removed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMTQ1OA=="}], "type": "inlineReview"}, {"oid": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "url": "https://github.com/cdapio/cdap/commit/e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "message": "Capability framework with changes for enabling, disabling and deleting capability\n\nDatabase is used for storing capability status and capability operation\n\nApp deployment, program start/run , schedule execution validates for enabled capability\n\nListing apps and plugins are filtered for enabled capability", "committedDate": "2020-12-22T00:52:11Z", "type": "forcePushed"}, {"oid": "5c7fcecab74b589114d8a56af85d65918abdb6af", "url": "https://github.com/cdapio/cdap/commit/5c7fcecab74b589114d8a56af85d65918abdb6af", "message": "Capability framework with changes for enabling, disabling and deleting capability\n\nDatabase is used for storing capability status and capability operation\n\nApp deployment, program start/run , schedule execution validates for enabled capability\n\nListing apps and plugins are filtered for enabled capability", "committedDate": "2020-12-22T01:06:52Z", "type": "commit"}, {"oid": "5c7fcecab74b589114d8a56af85d65918abdb6af", "url": "https://github.com/cdapio/cdap/commit/5c7fcecab74b589114d8a56af85d65918abdb6af", "message": "Capability framework with changes for enabling, disabling and deleting capability\n\nDatabase is used for storing capability status and capability operation\n\nApp deployment, program start/run , schedule execution validates for enabled capability\n\nListing apps and plugins are filtered for enabled capability", "committedDate": "2020-12-22T01:06:52Z", "type": "forcePushed"}]}