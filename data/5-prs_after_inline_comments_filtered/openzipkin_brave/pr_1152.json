{"pr_number": 1152, "pr_title": "Extracts WeakConcurrentMap from PendingSpans and uses for trackOrphans", "pr_createdAt": "2020-04-12T07:17:35Z", "pr_url": "https://github.com/openzipkin/brave/pull/1152", "timeline": [{"oid": "2134bf6843619f6bfdce4854b677775ad608efc5", "url": "https://github.com/openzipkin/brave/commit/2134bf6843619f6bfdce4854b677775ad608efc5", "message": "Extracts WeakConcurrentMap from PendingSpans and uses for trackOrphans\n\nThis formalizes that PendingSpans was derived from weaklockfree, pulling\nit up so that we can decouple orphan handling in the future.\n\nThis also fixes attribution which was in the source, but not NOTICE\nbefore.\n\nFinally, this does a fair amount of simplification on the orphan path.\nMost importantly, we pre-emptively fork the context as opposed to\ncopying most of its values for the orphan path.", "committedDate": "2020-04-12T08:32:14Z", "type": "forcePushed"}, {"oid": "2134bf6843619f6bfdce4854b677775ad608efc5", "url": "https://github.com/openzipkin/brave/commit/2134bf6843619f6bfdce4854b677775ad608efc5", "message": "Extracts WeakConcurrentMap from PendingSpans and uses for trackOrphans\n\nThis formalizes that PendingSpans was derived from weaklockfree, pulling\nit up so that we can decouple orphan handling in the future.\n\nThis also fixes attribution which was in the source, but not NOTICE\nbefore.\n\nFinally, this does a fair amount of simplification on the orphan path.\nMost importantly, we pre-emptively fork the context as opposed to\ncopying most of its values for the orphan path.", "committedDate": "2020-04-12T08:32:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2NjQ1NA==", "url": "https://github.com/openzipkin/brave/pull/1152#discussion_r407166454", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * While a lookup key will invoke equals against this, the visa versa is not true. This methos\n          \n          \n            \n                 * While a lookup key will invoke equals against this, the visa versa is not true. This method", "author": "codefromthecrypt", "createdAt": "2020-04-12T08:37:26Z", "path": "brave/src/main/java/brave/internal/weaklockfree/WeakConcurrentMap.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.weaklockfree;\n+\n+import brave.internal.Nullable;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * This borrows heavily from Rafael Winterhalter's {@code com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap}\n+ * with the following major changes:\n+ *\n+ * <p>The biggest change is this removes LatentKey. Instead it relies on keys known to have a\n+ * stable {@link #hashCode} and who are {@linkplain #equals(Object) equal to} a weak reference of\n+ * itself. We allow lookups using externally created contexts, yet don't want to incur overhead of\n+ * key allocation or classloader problems sharing keys with a thread local.\n+ *\n+ * <p>Other changes mostly remove features (to reduce the bytecode size) and address style:\n+ * <ul>\n+ *   <li>Inline expunction only as we have no thread to use anyway</li>\n+ *   <li>Removes methods we don't need such as iteration</li>\n+ *   <li>Stylistic changes including different javadoc and removal of private modifiers</li>\n+ *   <li>toString: derived only from keys</li>\n+ * </ul>\n+ *\n+ * <p>See https://github.com/raphw/weak-lock-free\n+ */\n+public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> {\n+  final ConcurrentMap<WeakKey<K>, V> target = new ConcurrentHashMap<>();\n+\n+  @Nullable public V getIfPresent(K key) {\n+    if (key == null) throw new NullPointerException(\"key == null\");\n+    expungeStaleEntries();\n+\n+    return target.get(key);\n+  }\n+\n+  /** Replaces the entry with the indicated key and returns the old value or {@code null}. */\n+  @Nullable public V putIfProbablyAbsent(K key, V value) {\n+    if (key == null) throw new NullPointerException(\"key == null\");\n+    if (value == null) throw new NullPointerException(\"value == null\");\n+    expungeStaleEntries();\n+\n+    return target.putIfAbsent(new WeakKey<>(key, this), value);\n+  }\n+\n+  /** Removes the entry with the indicated key and returns the old value or {@code null}. */\n+  @Nullable public V remove(K key) {\n+    if (key == null) throw new NullPointerException(\"key == null\");\n+    expungeStaleEntries();\n+\n+    return target.remove(key);\n+  }\n+\n+  /** Cleans all unused references. */\n+  protected void expungeStaleEntries() {\n+    Reference<?> reference;\n+    while ((reference = poll()) != null) {\n+      removeStaleEntry(reference);\n+    }\n+  }\n+\n+  protected V removeStaleEntry(Reference<?> reference) {\n+    return target.remove(reference);\n+  }\n+\n+  // This comment was directly verbatim from https://github.com/raphw/weak-lock-free/blob/dcbd2fa0d30571bb3ed187a42cb75323a5569d5b/src/main/java/com/blogspot/mydailyjava/weaklockfree/WeakConcurrentMap.java#L273-L302\n+  /*\n+   * Why this works:\n+   * ---------------\n+   *\n+   * Note that this map only supports reference equality for keys and uses system hash codes. Also, for the\n+   * WeakKey instances to function correctly, we are voluntarily breaking the Java API contract for\n+   * hashCode/equals of these instances.\n+   *\n+   *\n+   * System hash codes are immutable and can therefore be computed prematurely and are stored explicitly\n+   * within the WeakKey instances. This way, we always know the correct hash code of a key and always\n+   * end up in the correct bucket of our target map. This remains true even after the weakly referenced\n+   * key is collected.\n+   *\n+   * If we are looking up the value of the current key via WeakConcurrentMap::get or any other public\n+   * API method, we know that any value associated with this key must still be in the map as the mere\n+   * existence of this key makes it ineligible for garbage collection. Therefore, looking up a value\n+   * using another WeakKey wrapper guarantees a correct result.\n+   *\n+   * If we are looking up the map entry of a WeakKey after polling it from the reference queue, we know\n+   * that the actual key was already collected and calling WeakKey::get returns null for both the polled\n+   * instance and the instance within the map. Since we explicitly stored the identity hash code for the\n+   * referenced value, it is however trivial to identify the correct bucket. From this bucket, the first\n+   * weak key with a null reference is removed. Due to hash collision, we do not know if this entry\n+   * represents the weak key. However, we do know that the reference queue polls at least as many weak\n+   * keys as there are stale map entries within the target map. If no key is ever removed from the map\n+   * explicitly, the reference queue eventually polls exactly as many weak keys as there are stale entries.\n+   *\n+   * Therefore, we can guarantee that there is no memory leak.\n+   */\n+  static final class WeakKey<T> extends WeakReference<T> {\n+    final int hashCode;\n+\n+    WeakKey(T key, ReferenceQueue<? super T> queue) {\n+      super(key, queue);\n+      this.hashCode = key.hashCode(); // cache as hashCode is used for all future operations\n+    }\n+\n+    @Override public int hashCode() {\n+      return hashCode;\n+    }\n+\n+    @Override public String toString() {\n+      T value = get();\n+      return value != null ? value.toString() : \"ClearedReference()\";\n+    }\n+\n+    /**\n+     * While a lookup key will invoke equals against this, the visa versa is not true. This methos", "originalCommit": "2134bf6843619f6bfdce4854b677775ad608efc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c62d0c17267969cbc21faf1a41bbf19385f19260", "url": "https://github.com/openzipkin/brave/commit/c62d0c17267969cbc21faf1a41bbf19385f19260", "message": "typo", "committedDate": "2020-04-12T08:37:35Z", "type": "commit"}]}