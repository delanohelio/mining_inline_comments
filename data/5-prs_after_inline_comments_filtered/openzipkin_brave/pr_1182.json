{"pr_number": 1182, "pr_title": "Decouples state handling from codec: completes baggage header example", "pr_createdAt": "2020-04-29T15:53:43Z", "pr_url": "https://github.com/openzipkin/brave/pull/1182", "timeline": [{"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248", "url": "https://github.com/openzipkin/brave/commit/870f1c84f6b9632d23905e4b02a3d901489a8248", "message": "Decouples state handling from codec: completes baggage header example\n\nThis finishes integration of the baggage header example. We still have a\nlot to think about before making dynamic baggage public. For example, we\nhad use cases such as tunneling over JMS (to use a single-header when\nspan.kind is messaging similar to what we do in B3Propagation).\n\nAt any rate, this is dramatically simplified in my opinion, and gets us\nvery close to completing both single header dynamic baggage and\nsecondary sampling.\n\nSee #693", "committedDate": "2020-04-29T15:49:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTIxMA==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417425210", "bodyText": "neat file 1:", "author": "codefromthecrypt", "createdAt": "2020-04-29T15:54:17Z", "path": "brave/src/test/java/brave/features/baggage/BaggageInSingleHeaderTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.baggage.BaggagePropagationConfig.SingleBaggageField;\n+import brave.internal.InternalBaggage;\n+import brave.propagation.B3Propagation;\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+import static brave.baggage.BaggagePropagation.newFactoryBuilder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+/** This is an internal feature until we settle on an encoding format. */\n+public class BaggageInSingleHeaderTest {", "originalCommit": "870f1c84f6b9632d23905e4b02a3d901489a8248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTM1Nw==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417425357", "bodyText": "neat file 2:", "author": "codefromthecrypt", "createdAt": "2020-04-29T15:54:28Z", "path": "brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.baggage.BaggagePropagationConfig;\n+import brave.internal.baggage.BaggageCodec;\n+import brave.internal.baggage.ExtraBaggageFields;\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This is a non-complete codec for the w3c (soon to be renamed to \"baggage\") header.\n+ *\n+ * <p>See https://github.com/w3c/correlation-context/blob/master/correlation_context/HTTP_HEADER_FORMAT.md\n+ */\n+final class SingleHeaderCodec implements BaggageCodec {", "originalCommit": "870f1c84f6b9632d23905e4b02a3d901489a8248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MTIwOQ==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417751209", "bodyText": "If we have a type parameter I think we need it on the BaggageCodec<R>. I checked out the branch and tried implementing this interface but the ony thing allowed when inherting instead of R is Object since anything else is outside the type's bounds.", "author": "anuraaga", "createdAt": "2020-04-30T04:48:28Z", "path": "brave/src/main/java/brave/internal/baggage/BaggageCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.internal.Nullable;\n+import brave.propagation.Propagation.Getter;\n+import brave.propagation.Propagation.Setter;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public interface BaggageCodec {\n+  /**\n+   * Use this when configuration results in no codec needed.\n+   */\n+  BaggageCodec NOOP = new BaggageCodec() {\n+    @Override public List<String> extractKeyNames() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override public List<String> injectKeyNames() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override public <R> boolean decode(ExtraBaggageFields extra, R request, String value) {\n+      return false;\n+    }\n+\n+    @Override public <R> String encode(ExtraBaggageFields extra, TraceContext context, R request) {\n+      return null;\n+    }\n+\n+    @Override public String toString() {\n+      return \"NoopBaggageCodec\";\n+    }\n+  };\n+\n+  /**\n+   * Ordered list of key names used during {@link Extractor#extract(Object)} with {@link\n+   * Getter#get(Object, Object)}.\n+   *\n+   * <p>{@link Getter#get(Object, Object)} will be called against these in order until a\n+   * non-{@code null} value result or there are no more keys.\n+   *\n+   * @since 5.12\n+   */\n+  List<String> extractKeyNames();\n+\n+  /**\n+   * Ordered list of key names used during {@link Injector#inject(TraceContext, Object)} with {@link\n+   * Setter#put(Object, Object, String)}.\n+   *\n+   * @since 5.12\n+   */\n+  List<String> injectKeyNames();\n+\n+  /**\n+   * Called on the first non-{@code null} value from an {@link #extractKeyNames() extract key}.\n+   * Decodes any field state from an extracted value or returns {@code null} if there were none.\n+   *\n+   * <p>Ex. When the state is a simple string, this will just use the request value directly.\n+   * {@linkplain ExtraBaggageFields#isDynamic() dynamic values} will need to perform some decoding,\n+   * such as splitting on comma and equals.\n+   *\n+   * @param <R> the type parameter of {@link Extractor#<R>}\n+   * @param extra holds {@link BaggageField} state.\n+   * @param request the parameter of {@link Extractor#extract(Object)}\n+   * @param value a non-{@code null} result of {@link Getter#get(Object, Object)}\n+   * @see #extractKeyNames()\n+   */\n+  <R> boolean decode(ExtraBaggageFields extra, R request, String value);", "originalCommit": "870f1c84f6b9632d23905e4b02a3d901489a8248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2MDU0MA==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417760540", "bodyText": "agreed. this  drifted and isn't currently useful. I had one version that was passing the setter..", "author": "codefromthecrypt", "createdAt": "2020-04-30T05:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MTIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjE2Ng==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417752166", "bodyText": "Formatting in a couplle files", "author": "anuraaga", "createdAt": "2020-04-30T04:52:14Z", "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static brave.internal.baggage.ExtraBaggageFields.equal;\n+\n+/** Handles {@link BaggageField} value storage with a map. */\n+final class DynamicBaggageState extends ExtraBaggageFields.State<Map<BaggageField, String>> {\n+  DynamicBaggageState(DynamicBaggageFieldsFactory factory, Map<BaggageField, String> parentState) {\n+    super(factory, parentState);\n+  }\n+\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  /** The list of fields present, regardless of value. */\n+  @Override public List<BaggageField> getAllFields() {\n+    return Collections.unmodifiableList(new ArrayList<>(state.keySet()));\n+  }\n+\n+  @Override public String getValue(BaggageField field) {\n+    return state.get(field);\n+  }\n+\n+  @Override public boolean updateValue(BaggageField field, String value) {\n+    synchronized (this) {\n+      Map<BaggageField, String> state = this.state;\n+      if (equal(value, state.get(field))) return false;\n+\n+      // We replace an existing value with null instead of deleting it. This way we know there was\n+      // a field value at some point (ex for reverting state).\n+      LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n+      mergedState.put(field, value);\n+      this.state = mergedState;\n+    }\n+    return true;\n+  }\n+\n+  @Override void putAllIfAbsent(ExtraBaggageFields parent) {\n+    Map<BaggageField, String> parentState = ((DynamicBaggageState) parent.internal).state;\n+\n+    for (BaggageField field : parentState.keySet()) {\n+      String thisValue = state.get(field);\n+      if (thisValue != null) continue; // extracted wins vs parent\n+      state.put(field, parentState.get(field));\n+    }\n+  }\n+\n+  // Implemented for equals when no baggage was extracted\n+  @Override public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof DynamicBaggageState)) return false;\n+    return state.equals(((DynamicBaggageState) o).state);\n+  }\n+\n+  @Override public int hashCode() {\n+    return state.hashCode();\n+  }\n+}", "originalCommit": "870f1c84f6b9632d23905e4b02a3d901489a8248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2MDgxMA==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417760810", "bodyText": "np. My formatter is actually correct now (I caused a lot of format problems when updating to an unknown version of intellij). regardless, I'll sweep for fuzz.. was a bit tired and didn't catch all of it last night.", "author": "codefromthecrypt", "createdAt": "2020-04-30T05:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjU5Mg==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417752592", "bodyText": "Is there any implicit guarantee this is mutable (not Collections.emptyMap())? There might be but it's not so clear.", "author": "anuraaga", "createdAt": "2020-04-30T04:54:00Z", "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static brave.internal.baggage.ExtraBaggageFields.equal;\n+\n+/** Handles {@link BaggageField} value storage with a map. */\n+final class DynamicBaggageState extends ExtraBaggageFields.State<Map<BaggageField, String>> {\n+  DynamicBaggageState(DynamicBaggageFieldsFactory factory, Map<BaggageField, String> parentState) {\n+    super(factory, parentState);\n+  }\n+\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  /** The list of fields present, regardless of value. */\n+  @Override public List<BaggageField> getAllFields() {\n+    return Collections.unmodifiableList(new ArrayList<>(state.keySet()));\n+  }\n+\n+  @Override public String getValue(BaggageField field) {\n+    return state.get(field);\n+  }\n+\n+  @Override public boolean updateValue(BaggageField field, String value) {\n+    synchronized (this) {\n+      Map<BaggageField, String> state = this.state;\n+      if (equal(value, state.get(field))) return false;\n+\n+      // We replace an existing value with null instead of deleting it. This way we know there was\n+      // a field value at some point (ex for reverting state).\n+      LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n+      mergedState.put(field, value);\n+      this.state = mergedState;\n+    }\n+    return true;\n+  }\n+\n+  @Override void putAllIfAbsent(ExtraBaggageFields parent) {\n+    Map<BaggageField, String> parentState = ((DynamicBaggageState) parent.internal).state;", "originalCommit": "870f1c84f6b9632d23905e4b02a3d901489a8248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MTI5Mg==", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417781292", "bodyText": "you found a bug thanks!", "author": "codefromthecrypt", "createdAt": "2020-04-30T06:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjU5Mg=="}], "type": "inlineReview"}, {"oid": "f2ad1323b95d8685f98f1085682d97634e799142", "url": "https://github.com/openzipkin/brave/commit/f2ad1323b95d8685f98f1085682d97634e799142", "message": "feedback", "committedDate": "2020-04-30T06:38:31Z", "type": "commit"}]}