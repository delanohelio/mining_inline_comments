{"pr_number": 1109, "pr_title": "Allows scope decorators to synchorize \"extra fields\" to logging context", "pr_createdAt": "2020-03-06T07:02:15Z", "pr_url": "https://github.com/openzipkin/brave/pull/1109", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTE4Nw==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388741187", "bodyText": "using a mutable array here is intentional. It allows a later change to implement immediate flushing #682", "author": "codefromthecrypt", "createdAt": "2020-03-06T07:03:34Z", "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,184 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.\n+     *\n+     * @since 5.11\n+     */\n+    public B addExtraField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      String lowercase = name.toLowerCase(Locale.ROOT); // contract of extra fields internally\n+      extraFields.add(lowercase);\n+      return (B) this;\n+    }\n+\n+    public abstract CurrentTraceContext.ScopeDecorator build();\n+  }\n+\n+  protected CorrelationFieldScopeDecorator(Builder<?> builder) {\n+    String[] extraFields = builder.extraFields.toArray(new String[0]);\n+    updaters = new Updater[4 + extraFields.length];\n+    updaters[0] = new TraceIdUpdater(this);\n+    updaters[1] = new ParentSpanIdUpdater(this);\n+    updaters[2] = new SpanIdUpdater(this);\n+    updaters[3] = new SampledUpdater(this);\n+    for (int i = 0; i < extraFields.length; i++) {\n+      updaters[4 + i] = new ExtraFieldUpdater(this, extraFields[i]);\n+    }\n+  }\n \n   /**\n    * When the input is not null \"traceId\", \"parentId\", \"spanId\" and \"sampled\" correlation properties\n    * are saved off and replaced with those of the current span. When the input is null, these\n    * properties are removed. Either way, \"traceId\", \"parentId\", \"spanId\" and \"sampled\" properties\n    * are restored on {@linkplain Scope#close()}.\n    */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    String previousTraceId = get(\"traceId\");\n-    String previousSpanId = get(\"spanId\");\n-    String previousParentId = get(\"parentId\");\n-    String previousSampled = get(\"sampled\");\n-\n-    if (currentSpan != null) {\n-      maybeReplaceTraceContext(\n-        currentSpan, previousTraceId, previousParentId, previousSpanId, previousSampled);\n-    } else {\n-      remove(\"traceId\");\n-      remove(\"parentId\");\n-      remove(\"spanId\");\n-      remove(\"sampled\");\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    String[] previousValues = new String[updaters.length];", "originalCommit": "4a290d9747b21c09563c9e91f8ef914076b6fc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3MzAxNQ==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388773015", "bodyText": "Not completely sure but I thought the immediate flushing would mean there are extra fields added, so doesn't it need to be expandable like a List?", "author": "anuraaga", "createdAt": "2020-03-06T08:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyNzk1NQ==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388827955", "bodyText": "actually the late thing is change in a value not change in the whitelist. so should be fine. this will be separate change anyway", "author": "codefromthecrypt", "createdAt": "2020-03-06T10:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNzcyMg==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r399617722", "bodyText": "yeah this is just late updates keys, set in the builder and immutable after. so the value holder needn't be expandable. If we change later to make this expandable, we would need to update this code, as would other code which assumes the list is fixed.", "author": "codefromthecrypt", "createdAt": "2020-03-28T04:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3NjAwNw==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388776007", "bodyText": "Small nit this is probably easier to read if the if/else pattern is consistent, currently this line seems particularly special for some reason.\nif (current != null) {\n  return update(previous, current);\n} else if (previous != null) {\n  decorator.remove(field);\n  return true;\n} else {\n  return false;\n}\nCould remove the elses if desired.", "author": "anuraaga", "createdAt": "2020-03-06T08:45:44Z", "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,176 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.\n+     *\n+     * @since 5.11\n+     */\n+    public B addExtraField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      String lowercase = name.toLowerCase(Locale.ROOT); // contract of extra fields internally\n+      extraFields.add(lowercase);\n+      return (B) this;\n+    }\n+\n+    public abstract CurrentTraceContext.ScopeDecorator build();\n+  }\n+\n+  protected CorrelationFieldScopeDecorator(Builder<?> builder) {\n+    String[] extraFields = builder.extraFields.toArray(new String[0]);\n+    updaters = new Updater[4 + extraFields.length];\n+    updaters[0] = new TraceIdUpdater(this);\n+    updaters[1] = new ParentSpanIdUpdater(this);\n+    updaters[2] = new SpanIdUpdater(this);\n+    updaters[3] = new SampledUpdater(this);\n+    for (int i = 0; i < extraFields.length; i++) {\n+      updaters[4 + i] = new ExtraFieldUpdater(this, extraFields[i]);\n+    }\n+  }\n \n   /**\n    * When the input is not null \"traceId\", \"parentId\", \"spanId\" and \"sampled\" correlation properties\n    * are saved off and replaced with those of the current span. When the input is null, these\n    * properties are removed. Either way, \"traceId\", \"parentId\", \"spanId\" and \"sampled\" properties\n    * are restored on {@linkplain Scope#close()}.\n    */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    String previousTraceId = get(\"traceId\");\n-    String previousSpanId = get(\"spanId\");\n-    String previousParentId = get(\"parentId\");\n-    String previousSampled = get(\"sampled\");\n-\n-    if (currentSpan != null) {\n-      maybeReplaceTraceContext(\n-        currentSpan, previousTraceId, previousParentId, previousSpanId, previousSampled);\n-    } else {\n-      remove(\"traceId\");\n-      remove(\"parentId\");\n-      remove(\"spanId\");\n-      remove(\"sampled\");\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    String[] previousValues = new String[updaters.length];\n+\n+    boolean changed = false;\n+    for (int i = 0; i < updaters.length; i++) {\n+      previousValues[i] = get(updaters[i].field);\n+      if (context != null) {\n+        if (updaters[i].update(context, previousValues[i])) {\n+          changed = true;\n+        }\n+      } else if (previousValues[i] != null) {\n+        remove(updaters[i].field);\n+        changed = true;\n+      }\n     }\n \n+    if (!changed) return scope;\n+\n     class CorrelationFieldCurrentTraceContextScope implements Scope {\n       @Override public void close() {\n         scope.close();\n-        replace(\"traceId\", previousTraceId);\n-        replace(\"parentId\", previousParentId);\n-        replace(\"spanId\", previousSpanId);\n-        replace(\"sampled\", previousSampled);\n+        for (int i = 0; i < updaters.length; i++) {\n+          replace(updaters[i].field, previousValues[i]);\n+        }\n       }\n     }\n     return new CorrelationFieldCurrentTraceContextScope();\n   }\n \n-  /**\n-   * Idempotently sets correlation properties to hex representation of trace identifiers in this\n-   * context.\n-   */\n-  void maybeReplaceTraceContext(\n-    TraceContext currentSpan,\n-    String previousTraceId,\n-    @Nullable String previousParentId,\n-    String previousSpanId,\n-    @Nullable String previousSampled\n-  ) {\n-    String traceId = currentSpan.traceIdString();\n-    if (!traceId.equals(previousTraceId)) put(\"traceId\", currentSpan.traceIdString());\n-\n-    String parentId = currentSpan.parentIdString();\n-    if (parentId == null) {\n-      remove(\"parentId\");\n-    } else {\n-      boolean sameParentId = parentId.equals(previousParentId);\n-      if (!sameParentId) put(\"parentId\", parentId);\n+  static final class ExtraFieldUpdater extends Updater {\n+    final Class<? extends PropagationFields<String, String>> propagationType;\n+\n+    ExtraFieldUpdater(CorrelationFieldScopeDecorator decorator, String name) {\n+      super(decorator, name);\n+      this.propagationType = InternalPropagation.instance.extraPropagationFieldsType();\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      String current = PropagationFields.get(context, field, propagationType);\n+      return updateNullable(previous, current);\n     }\n+  }\n \n-    String spanId = currentSpan.spanIdString();\n-    if (!spanId.equals(previousSpanId)) put(\"spanId\", spanId);\n+  static final class TraceIdUpdater extends Updater {\n+    TraceIdUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"traceId\");\n+    }\n \n-    Boolean sampled = currentSpan.sampled();\n-    if (sampled == null) {\n-      remove(\"sampled\");\n-    } else {\n-      String sampledString = sampled.toString();\n-      boolean sameSampled = sampledString.equals(previousSampled);\n-      if (!sameSampled) put(\"sampled\", sampledString);\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      return update(previous, context.traceIdString());\n+    }\n+  }\n+\n+  static final class ParentSpanIdUpdater extends Updater {\n+    ParentSpanIdUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"parentId\");\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      return updateNullable(previous, context.parentIdString());\n+    }\n+  }\n+\n+  static final class SpanIdUpdater extends Updater {\n+    SpanIdUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"spanId\");\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      return update(previous, context.spanIdString());\n+    }\n+  }\n+\n+  static final class SampledUpdater extends Updater {\n+    SampledUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"sampled\");\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      Boolean sampled = context.sampled();\n+      return updateNullable(previous, sampled != null ? sampled.toString() : null);\n+    }\n+  }\n+\n+  static abstract class Updater {\n+    final CorrelationFieldScopeDecorator decorator;\n+    final String field;\n+\n+    Updater(CorrelationFieldScopeDecorator decorator, String field) {\n+      this.decorator = decorator;\n+      this.field = field;\n+    }\n+\n+    /** Returns true if there was a change to the correlation field. */\n+    abstract boolean update(TraceContext context, @Nullable String previous);\n+\n+    boolean update(@Nullable String previous, String current) {\n+      if (!current.equals(previous)) {\n+        decorator.put(field, current);\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    boolean updateNullable(@Nullable String previous, @Nullable String current) {\n+      if (current != null) return update(previous, current);", "originalCommit": "2fb5c2374d62e0669f77a46606c92dcbe2140560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3ODMwOQ==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388778309", "bodyText": "Just want to confirm ExtraFieldPropagation is the only type of propagation this would ever make sense for?", "author": "anuraaga", "createdAt": "2020-03-06T08:50:53Z", "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,176 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.", "originalCommit": "2fb5c2374d62e0669f77a46606c92dcbe2140560", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyNjk2Ng==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388826966", "bodyText": "it might not be the only possible thing but it is what's often requested leading to the sleuth thing a couple years ago.", "author": "codefromthecrypt", "createdAt": "2020-03-06T10:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3ODMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNzg0OQ==", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r399617849", "bodyText": "after thinking about this, yeah I believe it is better to be explicit as we have nothing else and it is hard to predict when we could.", "author": "codefromthecrypt", "createdAt": "2020-03-28T04:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3ODMwOQ=="}], "type": "inlineReview"}, {"oid": "db45071c2524aec135ad037dc1d599e0976107e3", "url": "https://github.com/openzipkin/brave/commit/db45071c2524aec135ad037dc1d599e0976107e3", "message": "Allows scope decorators to synchorize \"extra fields\" to logging context\n\nThis pulls up a major feature currently only available in Sleuth:\n\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/289ec4755e6bcda77830a25c958c19fb1f5af7e2/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/log/Slf4jScopeDecorator.java#L111-L119\n\nEx.\n```java\ncurrentTraceContext = ThreadLocalCurrentTraceContext.newBuilder()\n  .addScopeDecorator(MDCScopeDecorator.newBuilder()\n    .addExtraField(\"user-id\") // this pushes the extra field into log scope\n    .build())\n  .build();\n```", "committedDate": "2020-03-28T04:30:03Z", "type": "commit"}, {"oid": "db45071c2524aec135ad037dc1d599e0976107e3", "url": "https://github.com/openzipkin/brave/commit/db45071c2524aec135ad037dc1d599e0976107e3", "message": "Allows scope decorators to synchorize \"extra fields\" to logging context\n\nThis pulls up a major feature currently only available in Sleuth:\n\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/289ec4755e6bcda77830a25c958c19fb1f5af7e2/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/log/Slf4jScopeDecorator.java#L111-L119\n\nEx.\n```java\ncurrentTraceContext = ThreadLocalCurrentTraceContext.newBuilder()\n  .addScopeDecorator(MDCScopeDecorator.newBuilder()\n    .addExtraField(\"user-id\") // this pushes the extra field into log scope\n    .build())\n  .build();\n```", "committedDate": "2020-03-28T04:30:03Z", "type": "forcePushed"}, {"oid": "89241811b0b8847249432918e35431fd263f2d8c", "url": "https://github.com/openzipkin/brave/commit/89241811b0b8847249432918e35431fd263f2d8c", "message": "Adds the ability to opt-out of fields", "committedDate": "2020-03-28T05:23:46Z", "type": "commit"}, {"oid": "1df20e9f9f131f145a5ad077adc56d504f964c57", "url": "https://github.com/openzipkin/brave/commit/1df20e9f9f131f145a5ad077adc56d504f964c57", "message": "fixes remove", "committedDate": "2020-03-28T06:09:16Z", "type": "commit"}, {"oid": "7c96ed13f322ac2a772354a698d925ebbc622224", "url": "https://github.com/openzipkin/brave/commit/7c96ed13f322ac2a772354a698d925ebbc622224", "message": "fixes stuff", "committedDate": "2020-03-28T07:05:09Z", "type": "commit"}, {"oid": "ef2eb455541f2bf8f61340551d829899f59d0664", "url": "https://github.com/openzipkin/brave/commit/ef2eb455541f2bf8f61340551d829899f59d0664", "message": "Rewrote to fast-path single element contexts", "committedDate": "2020-03-28T08:30:31Z", "type": "commit"}, {"oid": "64160e6b3403c3436f53e76b064b21c244d28f8d", "url": "https://github.com/openzipkin/brave/commit/64160e6b3403c3436f53e76b064b21c244d28f8d", "message": "license", "committedDate": "2020-03-28T08:34:59Z", "type": "commit"}, {"oid": "c8836da22f09f3fbe2bb2ffd2390cc397bfeb380", "url": "https://github.com/openzipkin/brave/commit/c8836da22f09f3fbe2bb2ffd2390cc397bfeb380", "message": "fuzz", "committedDate": "2020-03-28T08:37:08Z", "type": "commit"}]}