{"pr_number": 1203, "pr_title": "Adds RemoteGetter and RemoteSetter used for kind-based injection in B3Propagation", "pr_createdAt": "2020-05-10T14:18:14Z", "pr_url": "https://github.com/openzipkin/brave/pull/1203", "timeline": [{"oid": "77d5b6038ceb34d8fe6d0a63ac3dc17d6c6594f6", "url": "https://github.com/openzipkin/brave/commit/77d5b6038ceb34d8fe6d0a63ac3dc17d6c6594f6", "message": "Returns B3Propagation.Factory singleton when building default\n\nSimilar to how we unwrap when a builder results in no change, building\nB3Propagation.Factory can result in no difference than the singleton.\n\nBy re-using this, configuration frameworks can tell if there was no\nchange, at least tests are easier in sleuth now.", "committedDate": "2020-05-10T14:17:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY1MTg2Ng==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r422651866", "bodyText": "in a future change we can actually return a constant injector, as the formats won't change per call to inject. The advantage would be similar to other places where we have constant vs composite... even though the iteration across an array of size two is fast, it shouldn't be quicker than something with no array. By default, there's only one inject format per kind.", "author": "codefromthecrypt", "createdAt": "2020-05-10T14:20:47Z", "path": "brave/src/main/java/brave/propagation/B3Propagation.java", "diffHunk": "@@ -153,8 +165,20 @@ public FactoryBuilder injectFormats(Span.Kind kind, Format format1, Format forma\n     @Override public void inject(TraceContext context, R request) {\n       Format[] formats = factory.injectFormats;\n       if (request instanceof Request) {\n-        Span.Kind kind = ((Request) request).spanKind();\n-        formats = factory.kindToInjectFormats.get(kind);\n+        switch (((Request) request).spanKind()) {\n+          case CLIENT:\n+            formats = factory.clientInjectFormats;", "originalCommit": "77d5b6038ceb34d8fe6d0a63ac3dc17d6c6594f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY1NjMwMA==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r422656300", "bodyText": "oh... I have an idea that's much easier! Add a subtype in request!\nRequest.Setter extends Propagation.Setter\nexposes spanKind()\nWith this, we can hardwire B3 without needing reflection at runtime except the slow path for things that haven't extended Request.Setter yet.", "author": "codefromthecrypt", "createdAt": "2020-05-10T14:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY1MTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTMxOA==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r422985318", "bodyText": "ok I did this :)", "author": "codefromthecrypt", "createdAt": "2020-05-11T11:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY1MTg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY1MjU2MA==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r422652560", "bodyText": "I'm tempted to do generic foo in <R> TraceContext.Injector<R> injector(Setter<R, K> setter); to find out the bound of R.. (reflection look up the TypeVariable of the setter) if we could, and found it was a request, then we wouldn't have to do this runtime check!\nnot tempted now. just a nag for future.", "author": "codefromthecrypt", "createdAt": "2020-05-10T14:26:26Z", "path": "brave/src/main/java/brave/propagation/B3Propagation.java", "diffHunk": "@@ -153,8 +165,20 @@ public FactoryBuilder injectFormats(Span.Kind kind, Format format1, Format forma\n     @Override public void inject(TraceContext context, R request) {\n       Format[] formats = factory.injectFormats;\n       if (request instanceof Request) {\n-        Span.Kind kind = ((Request) request).spanKind();\n-        formats = factory.kindToInjectFormats.get(kind);\n+        switch (((Request) request).spanKind()) {", "originalCommit": "77d5b6038ceb34d8fe6d0a63ac3dc17d6c6594f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTQzOA==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r422985438", "bodyText": "done but not with reflection", "author": "codefromthecrypt", "createdAt": "2020-05-11T11:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY1MjU2MA=="}], "type": "inlineReview"}, {"oid": "b0b66e36a0813860b14975c9a91e50f084b32472", "url": "https://github.com/openzipkin/brave/commit/b0b66e36a0813860b14975c9a91e50f084b32472", "message": "Adds RemoteGetter and RemoteSetter", "committedDate": "2020-05-11T11:49:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NjA5MA==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r422986090", "bodyText": "This is an internal type exctracted from B3. I don't plan to do a huge amount of polishing on this in this PR as I'm at a severe time deficit. I will puts with it post merge though and any significant changes needed pre-merge", "author": "codefromthecrypt", "createdAt": "2020-05-11T11:54:52Z", "path": "brave/src/main/java/brave/internal/propagation/InjectorFactory.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.propagation;\n+\n+import brave.Request;\n+import brave.propagation.Propagation;\n+import brave.propagation.Propagation.RemoteSetter;\n+import brave.propagation.Propagation.Setter;\n+import brave.propagation.TraceContext;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public final class InjectorFactory {", "originalCommit": "b0b66e36a0813860b14975c9a91e50f084b32472", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ1MTk4Nw==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r423451987", "bodyText": "I lied.. polish is here now", "author": "codefromthecrypt", "createdAt": "2020-05-12T04:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NjA5MA=="}], "type": "inlineReview"}, {"oid": "de824fd3439144c46defc2fb7013d233e9f0a089", "url": "https://github.com/openzipkin/brave/commit/de824fd3439144c46defc2fb7013d233e9f0a089", "message": "javadoc", "committedDate": "2020-05-11T23:51:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQwNTI2MQ==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r423405261", "bodyText": "Don't think Arrays.asList does so probably want to check all the elements aren't null too", "author": "anuraaga", "createdAt": "2020-05-12T01:07:11Z", "path": "brave/src/main/java/brave/internal/propagation/InjectorFactory.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.propagation;\n+\n+import brave.Request;\n+import brave.Span;\n+import brave.propagation.Propagation;\n+import brave.propagation.Propagation.RemoteSetter;\n+import brave.propagation.Propagation.Setter;\n+import brave.propagation.TraceContext;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This is an internal type used to implement possibly multiple trace formats based on {@link\n+ * Span.Kind}. It isn't intended to be shared widely as it may change in practice.\n+ *\n+ * <p>When {@link RemoteSetter} is implemented, {@link #newInjector(Setter)} will create an\n+ * injector that is pre-configured for {@link RemoteSetter#spanKind()}. Otherwise, it will create an\n+ * injector that defers until {@link Injector#inject(TraceContext, Object)} is called.\n+ *\n+ * <p>A deferred injector checks if the {@code request} parameter is an instance of {@link\n+ * Request}, it considers {@link Request#spanKind()}. If so, it uses this for injection formats\n+ * accordingly. If not, a {@linkplain Builder#injectorFunction(InjectorFunction...) default\n+ * function} is used.\n+ *\n+ * <p><em>Note</em>: Instrumentation that have not been recently updated may be remote, but neither\n+ * implement {@link RemoteSetter} nor {@link Request}. In other words, lack of these types do not\n+ * mean the input is for a local span. However, this can be assumed for code in this repository, as\n+ * it is all up-to-date.\n+ *\n+ * <p>In Brave 6, we might make the assumption that local injection is when the inputs neither\n+ * implement {@link RemoteSetter} nor {@link Request}.\n+ */\n+public final class InjectorFactory {\n+  /** Like {@link TraceContext.Injector}, except the {@link Setter} is a parameter. */\n+  public interface InjectorFunction {\n+    InjectorFunction NOOP = new InjectorFunction() {\n+      @Override public List<String> keyNames() {\n+        return Collections.emptyList();\n+      }\n+\n+      @Override public <R> void inject(Setter<R, String> setter, TraceContext context, R request) {\n+      }\n+    };\n+\n+    /**\n+     * The distinct list of key names this can inject.\n+     *\n+     * @see Propagation#keys()\n+     */\n+    List<String> keyNames();\n+\n+    /** Like {@see TraceContext.Injector#inject} except the {@code setter} is explicit. */\n+    <R> void inject(Setter<R, String> setter, TraceContext context, R request);\n+  }\n+\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    InjectorFunction injectorFunction = InjectorFunction.NOOP;\n+    InjectorFunction clientInjectorFunction = InjectorFunction.NOOP;\n+    InjectorFunction producerInjectorFunction = InjectorFunction.NOOP;\n+    InjectorFunction consumerInjectorFunction = InjectorFunction.NOOP;\n+\n+    /**\n+     * The {@linkplain InjectorFunction injectors} to use when the {@link Setter} is not {@link\n+     * RemoteSetter} and the request parameter is not a {@link Request}.\n+     */\n+    public Builder injectorFunctions(InjectorFunction... injectorFunctions) {\n+      this.injectorFunction = injectorFunction(injectorFunctions);\n+      return this;\n+    }\n+\n+    /**\n+     * The {@linkplain InjectorFunction injectors} to use for {@link Span.Kind#CLIENT} contexts,\n+     * determined by either {@link RemoteSetter#spanKind()} or {@link Request#spanKind()}.\n+     */\n+    public Builder clientInjectorFunctions(InjectorFunction... injectorFunctions) {\n+      this.clientInjectorFunction = injectorFunction(injectorFunctions);\n+      return this;\n+    }\n+\n+    /**\n+     * The {@linkplain InjectorFunction injectors} to use for {@link Span.Kind#PRODUCER} contexts,\n+     * determined by either {@link RemoteSetter#spanKind()} or {@link Request#spanKind()}.\n+     */\n+    public Builder producerInjectorFunctions(InjectorFunction... injectorFunctions) {\n+      this.producerInjectorFunction = injectorFunction(injectorFunctions);\n+      return this;\n+    }\n+\n+    /**\n+     * The {@linkplain InjectorFunction injectors} to use for {@link Span.Kind#CONSUMER} contexts,\n+     * determined by either {@link RemoteSetter#spanKind()} or {@link Request#spanKind()}.\n+     *\n+     * <p>It may seem unusual at first to inject consumers, but this is how the trace context is\n+     * serialized for message processors that happen on other threads, or distributed stages (like\n+     * kafka-streams).\n+     */\n+    public Builder consumerInjectorFunctions(InjectorFunction... injectorFunctions) {\n+      this.consumerInjectorFunction = injectorFunction(injectorFunctions);\n+      return this;\n+    }\n+\n+    /** @throws IllegalArgumentException if all builder methods weren't called. */\n+    public InjectorFactory build() {\n+      if (injectorFunction == InjectorFunction.NOOP) {\n+        throw new IllegalArgumentException(\"injectorFunction == NOOP\");\n+      }\n+      if (clientInjectorFunction == InjectorFunction.NOOP) {\n+        throw new IllegalArgumentException(\"clientInjectorFunction == NOOP\");\n+      }\n+      if (producerInjectorFunction == InjectorFunction.NOOP) {\n+        throw new IllegalArgumentException(\"producerInjectorFunction == NOOP\");\n+      }\n+      if (consumerInjectorFunction == InjectorFunction.NOOP) {\n+        throw new IllegalArgumentException(\"consumerInjectorFunction == NOOP\");\n+      }\n+      return new InjectorFactory(this);\n+    }\n+\n+    Builder() {\n+    }\n+  }\n+\n+  final InjectorFunction injectorFunction;\n+  final InjectorFunction clientInjectorFunction, producerInjectorFunction, consumerInjectorFunction;\n+  final List<String> keyNames;\n+\n+  InjectorFactory(Builder builder) {\n+    injectorFunction = builder.injectorFunction;\n+    clientInjectorFunction = builder.clientInjectorFunction;\n+    producerInjectorFunction = builder.producerInjectorFunction;\n+    consumerInjectorFunction = builder.consumerInjectorFunction;\n+    Set<String> keyNames = new LinkedHashSet<>();\n+    // Add messaging first as their formats are likely the cheapest to extract\n+    keyNames.addAll(builder.consumerInjectorFunction.keyNames());\n+    keyNames.addAll(builder.producerInjectorFunction.keyNames());\n+    keyNames.addAll(builder.clientInjectorFunction.keyNames());\n+    keyNames.addAll(builder.injectorFunction.keyNames());\n+    this.keyNames = Collections.unmodifiableList(new ArrayList<>(keyNames));\n+  }\n+\n+  /**\n+   * The distinct list of key names this can inject.\n+   *\n+   * @see Propagation#keys()\n+   */\n+  public List<String> keyNames() {\n+    return keyNames;\n+  }\n+\n+  /**\n+   * Creates a potentially composite injector if the input is an instance of {@link RemoteSetter}.\n+   * Otherwise, a deferred injector is return that examples the request parameter to decide if it is\n+   * remote or not.\n+   */\n+  public <R> TraceContext.Injector<R> newInjector(Setter<R, String> setter) {\n+    if (setter == null) throw new NullPointerException(\"setter == null\");\n+    if (setter instanceof RemoteSetter) {\n+      RemoteSetter<?> remoteSetter = (RemoteSetter<?>) setter;\n+      switch (remoteSetter.spanKind()) {\n+        case CLIENT:\n+          return new Injector<>(setter, clientInjectorFunction);\n+        case PRODUCER:\n+          return new Injector<>(setter, producerInjectorFunction);\n+        case CONSUMER:\n+          return new Injector<>(setter, consumerInjectorFunction);\n+        default: // SERVER is nonsense as it cannot be injected\n+      }\n+    }\n+    return new DeferredInjector<>(setter, this);\n+  }\n+\n+  @Override public int hashCode() {\n+    int h = 1000003;\n+    h ^= injectorFunction.hashCode();\n+    h *= 1000003;\n+    h ^= clientInjectorFunction.hashCode();\n+    h *= 1000003;\n+    h ^= producerInjectorFunction.hashCode();\n+    h *= 1000003;\n+    h ^= consumerInjectorFunction.hashCode();\n+    return h;\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof InjectorFactory)) return false;\n+    InjectorFactory that = (InjectorFactory) o;\n+    return injectorFunction.equals(that.injectorFunction)\n+        && clientInjectorFunction.equals(that.clientInjectorFunction)\n+        && producerInjectorFunction.equals(that.producerInjectorFunction)\n+        && consumerInjectorFunction.equals(that.consumerInjectorFunction);\n+  }\n+\n+  @Override public String toString() {\n+    return \"InjectorFactory{injectorFunction=\" + injectorFunction\n+        + \", clientInjectorFunction=\" + clientInjectorFunction\n+        + \", producerInjectorFunction=\" + producerInjectorFunction\n+        + \", consumerInjectorFunction=\" + consumerInjectorFunction\n+        + \"}\";\n+  }\n+\n+  static final class DeferredInjector<R> implements TraceContext.Injector<R> {\n+    final Setter<R, String> setter;\n+    final InjectorFactory injectorFactory;\n+\n+    DeferredInjector(Setter<R, String> setter, InjectorFactory injectorFactory) {\n+      this.setter = setter;\n+      this.injectorFactory = injectorFactory;\n+    }\n+\n+    @Override public void inject(TraceContext context, R request) {\n+      if (request instanceof Request) {\n+        switch (((Request) request).spanKind()) {\n+          case CLIENT:\n+            injectorFactory.clientInjectorFunction.inject(setter, context, request);\n+            return;\n+          case PRODUCER:\n+            injectorFactory.producerInjectorFunction.inject(setter, context, request);\n+            return;\n+          case CONSUMER:\n+            injectorFactory.consumerInjectorFunction.inject(setter, context, request);\n+          default: // SERVER is nonsense as it cannot be injected\n+        }\n+      }\n+      injectorFactory.injectorFunction.inject(setter, context, request);\n+    }\n+\n+    @Override public int hashCode() {\n+      int h = 1000003;\n+      h ^= setter.hashCode();\n+      h *= 1000003;\n+      h ^= injectorFactory.hashCode();\n+      return h;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      if (o == this) return true;\n+      if (!(o instanceof DeferredInjector)) return false;\n+      DeferredInjector<?> that = (DeferredInjector<?>) o;\n+      return setter.equals(that.setter) && injectorFactory.equals(that.injectorFactory);\n+    }\n+\n+    @Override public String toString() {\n+      return \"DeferredInjector{setter=\" + setter + \", injectorFactory=\" + injectorFactory + \"}\";\n+    }\n+  }\n+\n+  static final class Injector<R> implements TraceContext.Injector<R> {\n+    final InjectorFunction injectorFunction;\n+    final Setter<R, String> setter;\n+\n+    Injector(Setter<R, String> setter, InjectorFunction injectorFunction) {\n+      this.injectorFunction = injectorFunction;\n+      this.setter = setter;\n+    }\n+\n+    @Override public void inject(TraceContext context, R request) {\n+      injectorFunction.inject(setter, context, request);\n+    }\n+\n+    @Override public int hashCode() {\n+      int h = 1000003;\n+      h ^= setter.hashCode();\n+      h *= 1000003;\n+      h ^= injectorFunction.hashCode();\n+      return h;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      if (o == this) return true;\n+      if (!(o instanceof Injector)) return false;\n+      Injector<?> that = (Injector<?>) o;\n+      return setter.equals(that.setter) && injectorFunction.equals(that.injectorFunction);\n+    }\n+\n+    @Override public String toString() {\n+      return \"Injector{setter=\" + setter + \", injectorFunction=\" + injectorFunction + \"}\";\n+    }\n+  }\n+\n+  static InjectorFunction injectorFunction(InjectorFunction... injectorFunctions) {\n+    if (injectorFunctions == null) throw new NullPointerException(\"injectorFunctions == null\");", "originalCommit": "de824fd3439144c46defc2fb7013d233e9f0a089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxNDA2Ng==", "url": "https://github.com/openzipkin/brave/pull/1203#discussion_r423414066", "bodyText": "sure thing", "author": "codefromthecrypt", "createdAt": "2020-05-12T01:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQwNTI2MQ=="}], "type": "inlineReview"}, {"oid": "909885bb5143023f35a46544074bdd0bd030fd5f", "url": "https://github.com/openzipkin/brave/commit/909885bb5143023f35a46544074bdd0bd030fd5f", "message": "final stuff", "committedDate": "2020-05-12T04:10:58Z", "type": "commit"}]}