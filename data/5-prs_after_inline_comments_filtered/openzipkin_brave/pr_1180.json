{"pr_number": 1180, "pr_title": "Decouples propagatation \"extra\" from remote key names", "pr_createdAt": "2020-04-29T04:27:09Z", "pr_url": "https://github.com/openzipkin/brave/pull/1180", "timeline": [{"oid": "50b448a4548f62764ef2f80e62d160e3e3519501", "url": "https://github.com/openzipkin/brave/commit/50b448a4548f62764ef2f80e62d160e3e3519501", "message": "Decouples propagatation \"extra\" from remote key names\n\nThis starts the process of decoupling internals of BaggagePropagation\nso that we can allow remote configuration independent of state handling.\n\nI also noticed we can simplify `TraceContext.extra()` structurally by\nbacking unmodifiable lists with Arrays.asList as opposed to ArrayList.", "committedDate": "2020-04-29T04:24:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MDQwNQ==", "url": "https://github.com/openzipkin/brave/pull/1180#discussion_r417060405", "bodyText": "a later PR will clear up this odd coupling. The PR starts the process..", "author": "codefromthecrypt", "createdAt": "2020-04-29T04:28:53Z", "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "diffHunk": "@@ -329,20 +368,24 @@ void inject(ExtraBaggageFields extraBaggageFields, R request) {\n     @Override public TraceContextOrSamplingFlags extract(R request) {\n       TraceContextOrSamplingFlags result = delegate.extract(request);\n \n-      // always allocate in case values are added late\n-      ExtraBaggageFields extraBaggageFields = propagation.factory.stateFactory.create();\n+      // Always allocate as fields could be local-only or have values added late\n+      ExtraBaggageFields extra = propagation.factory.extraFactory.create();\n+      TraceContextOrSamplingFlags.Builder builder = result.toBuilder().addExtra(extra);\n+\n+      if (propagation.factory.allKeyNames == null) return builder.build();\n+\n       for (RemoteHandlerWithKeys<K> handlerWithKeys : propagation.remoteHandlersWithKeys) {\n         for (K key : handlerWithKeys.keys) { // possibly multiple keys when prefixes are in use\n           String value = getter.get(request, key);\n           if (value != null) { // accept the first match\n-            if (extraBaggageFields.putRemoteValue(handlerWithKeys.handler, request, value)) {\n+            if (extra.putRemoteValue(handlerWithKeys.handler, request, value)) {", "originalCommit": "50b448a4548f62764ef2f80e62d160e3e3519501", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MDcxMw==", "url": "https://github.com/openzipkin/brave/pull/1180#discussion_r417060713", "bodyText": "I probably made this comment, it feels wrong :) anyway we can retouch this later.", "author": "codefromthecrypt", "createdAt": "2020-04-29T04:30:20Z", "path": "brave/src/main/java/brave/internal/Lists.java", "diffHunk": "@@ -14,30 +14,32 @@\n package brave.internal;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n public final class Lists {\n \n-  public static List<Object> ensureMutable(List<Object> list) {\n+  public static <E> List<E> ensureMutable(List<E> list) {\n     if (list instanceof ArrayList) return list;\n     int size = list.size();\n-    ArrayList<Object> mutable = new ArrayList<>(size);\n+    ArrayList<E> mutable = new ArrayList<>(size);\n     for (int i = 0; i < size; i++) {\n       mutable.add(list.get(i));\n     }\n     return mutable;\n   }\n \n-  public static List<Object> ensureImmutable(List<Object> list) {\n+  public static <E> List<E> ensureImmutable(List<E> list) {\n     if (list.isEmpty()) return Collections.emptyList();\n     // Faster to make a copy than check the type to see if it is already a singleton list\n     if (list.size() == 1) return Collections.singletonList(list.get(0));", "originalCommit": "50b448a4548f62764ef2f80e62d160e3e3519501", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MTQyNg==", "url": "https://github.com/openzipkin/brave/pull/1180#discussion_r417061426", "bodyText": "basically this implies reading the class name is worse than allocating a new wrapper.", "author": "codefromthecrypt", "createdAt": "2020-04-29T04:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2NzQ1OA==", "url": "https://github.com/openzipkin/brave/pull/1180#discussion_r417067458", "bodyText": "Yeah - feels like it might be true, but no need to feel eventually we can try benchmarking :)", "author": "anuraaga", "createdAt": "2020-04-29T04:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MDcxMw=="}], "type": "inlineReview"}]}