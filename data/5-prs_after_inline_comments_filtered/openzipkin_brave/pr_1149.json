{"pr_number": 1149, "pr_title": "Ensures currentSpan, toSpan and joinSpan use existing context references", "pr_createdAt": "2020-04-11T04:03:53Z", "pr_url": "https://github.com/openzipkin/brave/pull/1149", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407014227", "bodyText": "this one is very hard to grok, but basically if the input context is the same ids as the one garbage collected, but a different instance, it is effectively resurrection from the POV of the user (as they wouldn't know about ref swapping anyway). I can remove this or revise this comment if confusing", "author": "codefromthecrypt", "createdAt": "2020-04-11T04:06:29Z", "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)", "originalCommit": "cdb9635603615134033eb8fbd7498124285484fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzU2MQ==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027561", "bodyText": "IIUC Recreated would be more intuitive - not sure what it means to resurrect an object in Java", "author": "anuraaga", "createdAt": "2020-04-11T06:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyODU3NA==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407028574", "bodyText": "sgtm thanks", "author": "codefromthecrypt", "createdAt": "2020-04-11T07:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw=="}], "type": "inlineReview"}, {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "url": "https://github.com/openzipkin/brave/commit/0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "message": "Ensures currentSpan, toSpan and joinSpan use existing context references\n\nBefore, `Tracer.currentSpan`, `toSpan` and `joinSpan` either didn't\ndecorate external contexts (in no-op) or needlessly recreated context\ninstances when a span was already present in the pending map.i\n\nThis not only adds overhead, but interferes with our ability to track\nthe difference between a newly allocated span vs incidental changes to\nan existing one due to use of `currentSpan`, `toSpan` or `joinSpan`.\n\nThis change is necessary to support `SpanHandler` when powered by\nidentity maps.", "committedDate": "2020-04-11T06:16:52Z", "type": "commit"}, {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "url": "https://github.com/openzipkin/brave/commit/0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "message": "Ensures currentSpan, toSpan and joinSpan use existing context references\n\nBefore, `Tracer.currentSpan`, `toSpan` and `joinSpan` either didn't\ndecorate external contexts (in no-op) or needlessly recreated context\ninstances when a span was already present in the pending map.i\n\nThis not only adds overhead, but interferes with our ability to track\nthe difference between a newly allocated span vs incidental changes to\nan existing one due to use of `currentSpan`, `toSpan` or `joinSpan`.\n\nThis change is necessary to support `SpanHandler` when powered by\nidentity maps.", "committedDate": "2020-04-11T06:16:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzQ0NA==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027444", "bodyText": "maybe a one liner why not comparing to real span?", "author": "anuraaga", "createdAt": "2020-04-11T06:55:20Z", "path": "brave/src/main/java/brave/NoopSpan.java", "diffHunk": "@@ -92,10 +92,22 @@\n     return \"NoopSpan(\" + context + \")\";\n   }\n \n+  /**\n+   * This also matches equals against a lazy span. The rationale is least surprise to the user, as\n+   * code should not act differently given an instance of lazy or {@link NoopSpan}.\n+   */\n   @Override public boolean equals(Object o) {\n     if (o == this) return true;\n-    if (!(o instanceof NoopSpan)) return false;\n-    return context.equals(((NoopSpan) o).context);\n+    return isEqualToNoopOrLazySpan(context, o);\n+  }\n+\n+  static boolean isEqualToNoopOrLazySpan(TraceContext context, Object o) {", "originalCommit": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTE4Ng==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407029186", "bodyText": "added this for the two places it applies (here and over in real)\n  // We don't compare a RealSpan vs a NoopSpan as they can never equal each other.\n  // RealSpan's are always locally sampled and Noop ones are always not.", "author": "codefromthecrypt", "createdAt": "2020-04-11T07:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzU3Mg==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027572", "bodyText": "each other", "author": "anuraaga", "createdAt": "2020-04-11T06:57:12Z", "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)\n+    // * Ad-hoc usage of TraceContext.Builder (localRootId not set, as only settable internally)\n+    //\n+    // The first two scenarios are currently indistinguishable from eachother. If we had a way to", "originalCommit": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027920", "bodyText": "I don't think this type is exposed to users and can be leaked by them. Can't we use a normal reference?", "author": "anuraaga", "createdAt": "2020-04-11T07:01:07Z", "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "diffHunk": "@@ -15,17 +15,32 @@\n \n import brave.Clock;\n import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n \n-public final class PendingSpan {\n+/**\n+ * This includes a weak reference of the trace context, which allows externalized forms of the trace\n+ * context to be swapped for the one in use.\n+ *\n+ * <p>This is a weak reference to ensure that {@link PendingSpans} can clean up on GC.\n+ */\n+public final class PendingSpan extends WeakReference<TraceContext> {", "originalCommit": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyODgxOA==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407028818", "bodyText": "if we use a hard reference, it breaks PendingSpans. The keys used in PendingSpans include a weak reference to the trace context, if the value of the same entry has a hard reference, the weak keys are made useless as they can never be collected. Is there a good way to rephrase this?", "author": "codefromthecrypt", "createdAt": "2020-04-11T07:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTI5NA==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407029294", "bodyText": "I'll rephrase as it isn't clear that this type is a map entry value anyway..", "author": "codefromthecrypt", "createdAt": "2020-04-11T07:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTUxNA==", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407029514", "bodyText": "PTAL! thanks", "author": "codefromthecrypt", "createdAt": "2020-04-11T07:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA=="}], "type": "inlineReview"}, {"oid": "4845c462251924b941d0d2a018d7fd4a79ef9172", "url": "https://github.com/openzipkin/brave/commit/4845c462251924b941d0d2a018d7fd4a79ef9172", "message": "feedback", "committedDate": "2020-04-11T07:16:14Z", "type": "commit"}, {"oid": "e9608db6074c33a1ca7b2079b82e05c7e6eb7d0b", "url": "https://github.com/openzipkin/brave/commit/e9608db6074c33a1ca7b2079b82e05c7e6eb7d0b", "message": "try to clarify", "committedDate": "2020-04-11T07:19:08Z", "type": "commit"}]}