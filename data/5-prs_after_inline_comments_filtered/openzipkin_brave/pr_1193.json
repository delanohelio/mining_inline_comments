{"pr_number": 1193, "pr_title": "Adds EntrySplitter for use in w3c specs and secondary-sampling", "pr_createdAt": "2020-05-07T06:35:48Z", "pr_url": "https://github.com/openzipkin/brave/pull/1193", "timeline": [{"oid": "dc35dd5e35750dadd4a36df91dd217d074c3ba56", "url": "https://github.com/openzipkin/brave/commit/dc35dd5e35750dadd4a36df91dd217d074c3ba56", "message": "Adds EntrySplitter for use in w3c specs and secondary-sampling\n\nThis adds `EntrySplitter` to help handle complex formats such as W3C\ntrace-context efficiently. For example, this has flexible whitespace\nrules to comply with standards like 'tracestate' which require retaining\nleading whitespace.\n\nSee #693", "committedDate": "2020-05-07T06:33:23Z", "type": "commit"}, {"oid": "f87745c0bde93182927b1d54914eb412cdc150b9", "url": "https://github.com/openzipkin/brave/commit/f87745c0bde93182927b1d54914eb412cdc150b9", "message": "EOL before EOF", "committedDate": "2020-05-07T06:38:05Z", "type": "commit"}, {"oid": "1db905a488d02c9864a1dc0fcdeaa1be2932664d", "url": "https://github.com/openzipkin/brave/commit/1db905a488d02c9864a1dc0fcdeaa1be2932664d", "message": "fixes edge cases around single characters and OWS", "committedDate": "2020-05-07T13:21:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5ODI4OQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421498289", "bodyText": "@narayaruna look familiar? :)", "author": "codefromthecrypt", "createdAt": "2020-05-07T13:21:31Z", "path": "brave/src/test/java/brave/internal/codec/EntrySplitterTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.codec.EntrySplitter.Handler;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+public class EntrySplitterTest {\n+  EntrySplitter entrySplitter = EntrySplitter.newBuilder().shouldThrow(true).build();\n+  Map<String, String> map = new LinkedHashMap<>();\n+  Handler<Map<String, String>> parseIntoMap =\n+      (target, input, beginKey, endKey, beginValue, endValue) -> {\n+        String key = input.substring(beginKey, endKey);\n+        String value = input.substring(beginValue, endValue);\n+        target.put(key, value);\n+        return true;\n+      };\n+\n+  @Test public void parse() {\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=v2\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"v2\")\n+    );\n+  }\n+\n+  @Test public void parse_singleChars() {\n+    entrySplitter.parse(parseIntoMap, map, \"k=v,a=b\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k\", \"v\"),\n+        entry(\"a\", \"b\")\n+    );\n+  }\n+\n+  @Test public void parse_valuesAreRequired() {\n+    for (String missingValue : Arrays.asList(\"k1\", \"k1  \", \"k1=v1,k2\", \"k1   ,k2=v1\")) {\n+      assertThatThrownBy(() -> entrySplitter.parse(parseIntoMap, map, missingValue))\n+          .isInstanceOf(IllegalArgumentException.class)\n+          .hasMessage(\"Invalid input: missing key value separator '='\");\n+    }\n+    assertThat(map.isEmpty());\n+  }\n+\n+  @Test public void parse_emptyValuesOk() {\n+    for (String emptyValue : Arrays.asList(\"k1=\", \"k1 =\", \",k1=\", \",k1 =\", \"k1 =,\")) {\n+      entrySplitter.parse(parseIntoMap, map, emptyValue);\n+\n+      assertThat(map).containsExactly(entry(\"k1\", \"\"));\n+      map.clear();\n+    }\n+\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"\")\n+    );\n+  }\n+\n+  @Test public void keyValueSeparatorRequired_false() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \" authcache , gateway \");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** Parse Accept header style encoding as used in secondary sampling */\n+  @Test public void parse_onlyFirstKeyValueSeparator() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"ttl=1;spanId=19f84f102048e047\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** This shows you can nest parsers without unnecessary string allocation between stages. */\n+  @Test public void parse_nested() {\n+    EntrySplitter outerSplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    EntrySplitter innerSplitter = EntrySplitter.newBuilder()\n+        .entrySeparator(';')\n+        .keyValueSeparator('=')\n+        .shouldThrow(true)\n+        .build();\n+\n+    Map<String, Map<String, String>> keyToAttributes = new LinkedHashMap<>();\n+\n+    outerSplitter.parse((target, input, beginKey, endKey, beginValue, endValue) -> {\n+      String key = input.substring(beginKey, endKey);\n+      Map<String, String> attributes = new LinkedHashMap<>();\n+      if (beginValue == endValue) { // no string allocation at all\n+        attributes = Collections.emptyMap();\n+      } else { // no string allocation to pass to the inner parser\n+        attributes = new LinkedHashMap<>();\n+        innerSplitter.parse(parseIntoMap, attributes, input, beginValue, endValue);\n+      }\n+      target.put(key, attributes);\n+      return true;\n+    }, keyToAttributes, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");", "originalCommit": "1db905a488d02c9864a1dc0fcdeaa1be2932664d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyODg0Mw==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421528843", "bodyText": "added allocation free trace ID example from AWS", "author": "codefromthecrypt", "createdAt": "2020-05-07T14:02:45Z", "path": "brave/src/test/java/brave/internal/codec/EntrySplitterTest.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.codec.EntrySplitter.Handler;\n+import brave.propagation.TraceContext;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+public class EntrySplitterTest {\n+  EntrySplitter entrySplitter = EntrySplitter.newBuilder().shouldThrow(true).build();\n+  Map<String, String> map = new LinkedHashMap<>();\n+  Handler<Map<String, String>> parseIntoMap =\n+      (target, input, beginKey, endKey, beginValue, endValue) -> {\n+        String key = input.substring(beginKey, endKey);\n+        String value = input.substring(beginValue, endValue);\n+        target.put(key, value);\n+        return true;\n+      };\n+\n+  @Test public void parse() {\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=v2\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"v2\")\n+    );\n+  }\n+\n+  @Test public void parse_singleChars() {\n+    entrySplitter.parse(parseIntoMap, map, \"k=v,a=b\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k\", \"v\"),\n+        entry(\"a\", \"b\")\n+    );\n+  }\n+\n+  @Test public void parse_valuesAreRequired() {\n+    for (String missingValue : Arrays.asList(\"k1\", \"k1  \", \"k1=v1,k2\", \"k1   ,k2=v1\")) {\n+      assertThatThrownBy(() -> entrySplitter.parse(parseIntoMap, map, missingValue))\n+          .isInstanceOf(IllegalArgumentException.class)\n+          .hasMessage(\"Invalid input: missing key value separator '='\");\n+    }\n+    assertThat(map.isEmpty());\n+  }\n+\n+  @Test public void parse_emptyValuesOk() {\n+    for (String emptyValue : Arrays.asList(\"k1=\", \"k1 =\", \",k1=\", \",k1 =\", \"k1 =,\")) {\n+      entrySplitter.parse(parseIntoMap, map, emptyValue);\n+\n+      assertThat(map).containsExactly(entry(\"k1\", \"\"));\n+      map.clear();\n+    }\n+\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"\")\n+    );\n+  }\n+\n+  @Test public void keyValueSeparatorRequired_false() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \" authcache , gateway \");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** Parse Accept header style encoding as used in secondary sampling */\n+  @Test public void parse_onlyFirstKeyValueSeparator() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"ttl=1;spanId=19f84f102048e047\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** This shows you can nest parsers without unnecessary string allocation between stages. */\n+  @Test public void parse_nested() {\n+    EntrySplitter outerSplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    EntrySplitter innerSplitter = EntrySplitter.newBuilder()\n+        .entrySeparator(';')\n+        .keyValueSeparator('=')\n+        .shouldThrow(true)\n+        .build();\n+\n+    Map<String, Map<String, String>> keyToAttributes = new LinkedHashMap<>();\n+\n+    outerSplitter.parse((target, input, beginKey, endKey, beginValue, endValue) -> {\n+      String key = input.substring(beginKey, endKey);\n+      Map<String, String> attributes = new LinkedHashMap<>();\n+      if (beginValue == endValue) { // no string allocation at all\n+        attributes = Collections.emptyMap();\n+      } else { // no string allocation to pass to the inner parser\n+        attributes = new LinkedHashMap<>();\n+        innerSplitter.parse(parseIntoMap, attributes, input, beginValue, endValue);\n+      }\n+      target.put(key, attributes);\n+      return true;\n+    }, keyToAttributes, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");\n+\n+    Map<String, String> expectedAttributes = new LinkedHashMap<>();\n+    expectedAttributes.put(\"ttl\", \"1\");\n+    expectedAttributes.put(\"spanId\", \"19f84f102048e047\");\n+    assertThat(keyToAttributes).containsExactly(\n+        entry(\"authcache\", expectedAttributes),\n+        entry(\"gateway\", Collections.emptyMap())\n+    );\n+  }\n+\n+  @Test public void parse_emptyKeysNotOk() {\n+    for (String missingKey : Arrays.asList(\"=\", \"=v1\", \",=\", \",=v2\")) {\n+      assertThatThrownBy(() -> entrySplitter.parse(parseIntoMap, map, missingKey))\n+          .isInstanceOf(IllegalArgumentException.class)\n+          .hasMessage(\"Invalid input: no key before '='\");\n+    }\n+  }\n+\n+  /**\n+   * This is an example of how to parse without allocating strings. This is based on\n+   * https://github.com/openzipkin/zipkin-aws/blob/master/brave-propagation-aws/src/main/java/brave/propagation/aws/AWSPropagation.java\n+   */\n+  @Test public void example_parseAWSTraceId() {", "originalCommit": "64a3b61da2d5462936887801532344098b0b7c51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64a3b61da2d5462936887801532344098b0b7c51", "url": "https://github.com/openzipkin/brave/commit/64a3b61da2d5462936887801532344098b0b7c51", "message": "added aws example", "committedDate": "2020-05-07T14:02:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1MzMzMw==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421853333", "bodyText": "Does it look more sense to use IllegalArgumentException instead of NullPointerException?", "author": "samukce", "createdAt": "2020-05-07T23:35:57Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n+ * before or after delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new NullPointerException(\"maxEntries == 0\");", "originalCommit": "64a3b61da2d5462936887801532344098b0b7c51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2Nzk0MQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421867941", "bodyText": "good eye :)", "author": "codefromthecrypt", "createdAt": "2020-05-08T00:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1MzMzMw=="}], "type": "inlineReview"}, {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5", "url": "https://github.com/openzipkin/brave/commit/b322ab53fd32471d1f7a1eb8b36507837714faa5", "message": "now with javadoc on the builder", "committedDate": "2020-05-08T02:12:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5ODMyMA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421898320", "bodyText": "More real-world example might be better (or is this one real?)\ncondition=animal=cat", "author": "anuraaga", "createdAt": "2020-05-08T02:17:20Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}", "originalCommit": "b322ab53fd32471d1f7a1eb8b36507837714faa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyODI3MA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421928270", "bodyText": "heh it is real :) https://github.com/openzipkin-contrib/zipkin-secondary-sampling/blob/d3b6c1fc5f84269afb3785394cfd909ee37215bd/docs/design.md#the-sampling-field", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5ODMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyODQzOA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421928438", "bodyText": "but yeah for the sake of example, here it is fine to use like you said. less to think about", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzE0NQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421907145", "bodyText": "Should we validate the key value separator and entry separator are different chars?", "author": "anuraaga", "createdAt": "2020-05-08T02:52:14Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);", "originalCommit": "b322ab53fd32471d1f7a1eb8b36507837714faa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyODczNA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421928734", "bodyText": "yep good eye", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzMwNA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421907304", "bodyText": "To confirm my reading, this only happens at the end of the string, i.e., nextIsEnd == true? Because c can't be both the entry separator and key value separator.\nSince we have a comment, we could say // empty value at end of string: ex", "author": "anuraaga", "createdAt": "2020-05-08T02:52:55Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    int remainingEntries = maxEntries, beginKey = -1, endKey = -1, beginValue = -1;\n+    for (int i = beginIndex; i < endIndex; i++) {\n+      char c = input.charAt(i);\n+\n+      boolean nextIsEnd = i + 1 == endIndex;\n+      if (c == entrySeparator || nextIsEnd) { // finished an entry\n+        if (c == keyValueSeparator) {\n+          beginValue = i; // empty value: ex \"key=\" \"k1 =\"", "originalCommit": "b322ab53fd32471d1f7a1eb8b36507837714faa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyODk3MA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421928970", "bodyText": "will check.. worth it if true!", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzNjk1Mw==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421936953", "bodyText": "nextIsEnd entrySeparator can both be true. I updated the comment to clarify! thanks", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwODAxOA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421908018", "bodyText": "Again adding \"at end of string\" can help", "author": "anuraaga", "createdAt": "2020-05-08T02:55:43Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    int remainingEntries = maxEntries, beginKey = -1, endKey = -1, beginValue = -1;\n+    for (int i = beginIndex; i < endIndex; i++) {\n+      char c = input.charAt(i);\n+\n+      boolean nextIsEnd = i + 1 == endIndex;\n+      if (c == entrySeparator || nextIsEnd) { // finished an entry\n+        if (c == keyValueSeparator) {\n+          beginValue = i; // empty value: ex \"key=\" \"k1 =\"\n+        }\n+\n+        if (beginKey == -1 && beginValue == -1) {\n+          continue; // ignore empty entries, like \",,\"\n+        } else if (beginKey == -1) {\n+          return logOrThrow(missingKey, shouldThrow); // ex. \"=\" \",=\"\n+        } else if (nextIsEnd && beginValue == -1) { // ex \"k1\" \"k1 \" \"a=b\" \"..=,\"\n+          // We reached the end of a key-only entry, a single character entry or an empty entry", "originalCommit": "b322ab53fd32471d1f7a1eb8b36507837714faa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzNzEzNg==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421937136", "bodyText": "to be consistent with param names I went with end of input (as the string length can be longer than endIndex)", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwODAxOA=="}], "type": "inlineReview"}, {"oid": "b5a53e9b3ee92883c7d6cf587dcf79087d5800f0", "url": "https://github.com/openzipkin/brave/commit/b5a53e9b3ee92883c7d6cf587dcf79087d5800f0", "message": "feedback", "committedDate": "2020-05-08T04:38:26Z", "type": "commit"}, {"oid": "e1465475a426bc7a3292691f82c2cc497785a8e1", "url": "https://github.com/openzipkin/brave/commit/e1465475a426bc7a3292691f82c2cc497785a8e1", "message": "feedback", "committedDate": "2020-05-08T04:54:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzNzQ4OQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421937489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@code [(\"condition\", \"animal=cat7\")]}\n          \n          \n            \n                 * {@code [(\"condition\", \"animal=cat\")]}", "author": "codefromthecrypt", "createdAt": "2020-05-08T04:55:37Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat7\")]}", "originalCommit": "e1465475a426bc7a3292691f82c2cc497785a8e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f", "url": "https://github.com/openzipkin/brave/commit/da26e42e0b6315f8847c1a46da1b5c35b802346f", "message": "fat finger", "committedDate": "2020-05-08T04:55:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzOTExNQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421939115", "bodyText": "Validating in the setter is nicer but I guess it means we should default the values to 0 and replace with the actual defaults in build. Otherwise, it requires hoops to do the horrible, but not inconceivable, using = as entry separator and , as keyvalue separator.", "author": "anuraaga", "createdAt": "2020-05-08T05:01:44Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat\")]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      if (keyValueSeparator == entrySeparator) {\n+        throw new IllegalArgumentException(\"keyValueSeparator == entrySeparator\");", "originalCommit": "da26e42e0b6315f8847c1a46da1b5c35b802346f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0NTAwNQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421945005", "bodyText": "I'm convinced deferring is better :D", "author": "codefromthecrypt", "createdAt": "2020-05-08T05:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzOTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0OTIyMQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421949221", "bodyText": "Should we also use it as IllegalArgumentException in those argument validations here? When I pass an invalid argument to a method I expect the method raises some validation error about those instead off give feedback about the invalid arguments wrapped in an NPE error.", "author": "samukce", "createdAt": "2020-05-08T05:39:43Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat\")]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      if (keyValueSeparator == entrySeparator) {\n+        throw new IllegalArgumentException(\"keyValueSeparator == entrySeparator\");\n+      }\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    if (handler == null) throw new NullPointerException(\"handler == null\");\n+    if (target == null) throw new NullPointerException(\"target == null\");\n+    if (input == null) throw new NullPointerException(\"input == null\");", "originalCommit": "da26e42e0b6315f8847c1a46da1b5c35b802346f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MzQ1Mw==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421953453", "bodyText": "On this one I don't agree. the only reason we explicitly raise them here is to prevent confusion later when java would do it for you, but without a message.\nIf it were different, ex two Nullable params and one must be non-null, yeah that would be an IAE.\nMake sense?", "author": "codefromthecrypt", "createdAt": "2020-05-08T05:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0OTIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1NzQ4Nw==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421957487", "bodyText": "it makes senses but at the same time, it looks like we are translating the NPE to a more readable NPE. But in the end, the method doesn't work with one of those arguments is not null. So there is a dependency on this method works that is why I think the IAE makes more sense. Imagining to add @NotNull to the arguments so we would see a sort of Argument for @NotNull parameter 'b'.", "author": "samukce", "createdAt": "2020-05-08T06:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0OTIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1ODQ4NA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421958484", "bodyText": "I found it a bit weird a long time ago but think it's general convention to use NPE for these, codified into Java 8 with requireNonNull which throws NPE.", "author": "anuraaga", "createdAt": "2020-05-08T06:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0OTIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2MDU4OQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421960589", "bodyText": "argg.... there is not consistency between dosomething(@NotNull String a) x requireNonNull(a) oO\nSo, it's fine either way. no argument for now anymore. :)", "author": "samukce", "createdAt": "2020-05-08T06:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0OTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MTQwMw==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421951403", "bodyText": "We are implementing the builder pattern here but those fields are accessible externally in the package. Doing this we could use the builder in the wrong way as this usage for instance EntrySplitter.newBuilder().maxEntries = 0;. Do we have any motivation for this? Otherwise, we could set as private.", "author": "samukce", "createdAt": "2020-05-08T05:47:16Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;", "originalCommit": "da26e42e0b6315f8847c1a46da1b5c35b802346f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MzkxMQ==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421953911", "bodyText": "in Brave we try to be conscious of bytecode size as we cause bloat otherwise. That's why you'll see us almost never use the private modifier. We don't support other tools sharing the same package as we do, so it isn't a problem in practice.", "author": "codefromthecrypt", "createdAt": "2020-05-08T05:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1ODEwNA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421958104", "bodyText": "hmm, interesting. I will take a look at the readme that you sent. thanks for share. :)", "author": "samukce", "createdAt": "2020-05-08T06:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MTQwMw=="}], "type": "inlineReview"}, {"oid": "4bd7fc634f7880255017137a709452dd4cdad4b8", "url": "https://github.com/openzipkin/brave/commit/4bd7fc634f7880255017137a709452dd4cdad4b8", "message": "rationale", "committedDate": "2020-05-08T06:30:24Z", "type": "commit"}, {"oid": "dea88a92de3040e63942647814c3c5fdf376fa6c", "url": "https://github.com/openzipkin/brave/commit/dea88a92de3040e63942647814c3c5fdf376fa6c", "message": "emphasizes the android", "committedDate": "2020-05-08T06:43:15Z", "type": "commit"}, {"oid": "e0580c79a16cd5e670dcc7794e9bb1aac95a5d5b", "url": "https://github.com/openzipkin/brave/commit/e0580c79a16cd5e670dcc7794e9bb1aac95a5d5b", "message": "no donut", "committedDate": "2020-05-08T06:46:17Z", "type": "commit"}, {"oid": "a6881b5a5ee87cd161a7820b7615a0fa3a51837f", "url": "https://github.com/openzipkin/brave/commit/a6881b5a5ee87cd161a7820b7615a0fa3a51837f", "message": "defer on kv-entry splitter", "committedDate": "2020-05-08T06:53:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3NjEzMA==", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421976130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // \"...,k1\" and input[i] == 'y', we want i + 1, so that the key includes the 'y'\n          \n          \n            \n                      // \"...,k1\"  and input[i] == 'y', we want i + 1, so that the key includes the 'y'", "author": "codefromthecrypt", "createdAt": "2020-05-08T06:56:04Z", "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat\")]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    if (handler == null) throw new NullPointerException(\"handler == null\");\n+    if (target == null) throw new NullPointerException(\"target == null\");\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (beginIndex < 0) throw new IllegalArgumentException(\"beginIndex < 0\");\n+    if (endIndex > input.length()) throw new IllegalArgumentException(\"endIndex > input.length()\");\n+\n+    int remainingEntries = maxEntries, beginKey = -1, endKey = -1, beginValue = -1;\n+    for (int i = beginIndex; i < endIndex; i++) {\n+      char c = input.charAt(i);\n+\n+      boolean nextIsEnd = i + 1 == endIndex;\n+      if (c == entrySeparator || nextIsEnd) { // finished an entry\n+        if (c == keyValueSeparator) {\n+          beginValue = i; // key separator at end of the input. ex \"key=\" or \"k1 =\", but not \"k1\"\n+        }\n+\n+        if (beginKey == -1 && beginValue == -1) {\n+          continue; // ignore empty entries, like \",,\"\n+        } else if (beginKey == -1) {\n+          return logOrThrow(missingKey, shouldThrow); // ex. \"=\" \",=\"\n+        } else if (nextIsEnd && beginValue == -1) {\n+          // We reached the end of a key-only entry, a single character entry or an empty entry\n+          // at the end of the input. ex \"k1\" \"k1 \" \"a=b\" \"..=,\"\n+          beginValue = c == entrySeparator ? i + 1 : i;\n+        }\n+\n+        int endValue;\n+        if (endKey == -1) {\n+          if (keyValueSeparatorRequired && c != keyValueSeparator) {\n+            return logOrThrow(missingKeyValueSeparator, shouldThrow); // throw on \"k1\" \"k1=v2,k2\"\n+          }\n+\n+          // Even though we have an empty value, we need to handle whitespace and\n+          // boundary conditions.\n+          //\n+          // For example, using entry separator ',' and KV separator '=':\n+          // \"...,k1\" and input[i] == 'y', we want i + 1, so that the key includes the 'y'", "originalCommit": "a6881b5a5ee87cd161a7820b7615a0fa3a51837f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ce0e41dc8796c8388b6d515d0e6501bc07220b3", "url": "https://github.com/openzipkin/brave/commit/2ce0e41dc8796c8388b6d515d0e6501bc07220b3", "message": "make column pretty", "committedDate": "2020-05-08T06:56:18Z", "type": "commit"}]}