{"pr_number": 1148, "pr_title": "Adds SpanHandler", "pr_createdAt": "2020-04-10T10:32:28Z", "pr_url": "https://github.com/openzipkin/brave/pull/1148", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMjc1Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r406702757", "bodyText": "yay we can implement child_span_count in the future with a native brave SpanHandler for stackdriver\ncc @meltsufin @saturnism\nhttps://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.cloudtrace.v2#google.devtools.cloudtrace.v2.Span", "author": "codefromthecrypt", "createdAt": "2020-04-10T10:35:14Z", "path": "brave/src/test/java/brave/features/handler/CountingChildrenTest.java", "diffHunk": "@@ -103,7 +104,7 @@\n     assertThat(spans)\n       .extracting(Span::name, s -> s.tags().get(\"childCount\"))\n       .containsExactly(\n-        tuple(\"root1\", \"0\"), tuple(\"root1child1\", \"0\"), tuple(\"root1child2\", \"0\")\n+        tuple(\"root1\", \"2\"), tuple(\"root1child1\", \"0\"), tuple(\"root1child2\", \"0\")", "originalCommit": "b4bd7d0ae5ee4a81fb70a9958d7478506572b912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NzU2Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r406987563", "bodyText": "neat!", "author": "saturnism", "createdAt": "2020-04-10T23:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMjc1Nw=="}], "type": "inlineReview"}, {"oid": "09c5bf58f41e59b7342a653c9024718027ca9b27", "url": "https://github.com/openzipkin/brave/commit/09c5bf58f41e59b7342a653c9024718027ca9b27", "message": "WIP span handler", "committedDate": "2020-04-11T09:33:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTAwNQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407051005", "bodyText": "This is the important file", "author": "codefromthecrypt", "createdAt": "2020-04-11T11:12:40Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**", "originalCommit": "58e986d8c7b4bb3e3732f8184fa0eef4e5641e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjcxNg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407052716", "bodyText": "PS I plan to shade @raphw's https://github.com/raphw/weak-lock-free/blob/master/src/main/java/com/blogspot/mydailyjava/weaklockfree/WeakConcurrentMap.java into the core jar to support orphan tracker as it is much nicer to use a weak map instead of a hacky field. The code is small (won't make the jar too big), has the same bytecode level as us (Java 6) and stable. We can cite it in the NOTICE file.\nIf you think this is a bad idea, do scream at some point :D", "author": "codefromthecrypt", "createdAt": "2020-04-11T11:31:40Z", "path": "brave/src/main/java/brave/internal/recorder/OrphanTracker.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.recorder;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.InternalHandler;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+// TODO make a weak map of MutableSpan -> Throwable instead of a hacky field in MutableSpan", "originalCommit": "91900f1552c9be81a89bcc03443f77deffec30e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1ODk0OA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407158948", "bodyText": "I started to do this, then realized we had hacked this quite a bit in PendingSpans, and also shading adds a lot of complexity and also the class is quite bigger than ours anyway. I cleaned up our variant instead here #1152", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzMxOA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143318", "bodyText": "abstract? Even in NOOP we subclass it :)", "author": "anuraaga", "createdAt": "2020-04-12T04:16:15Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1OTM4MA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407159380", "bodyText": "sgtm", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzU1Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143556", "bodyText": "is incomplete", "author": "anuraaga", "createdAt": "2020-04-12T04:19:33Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>\n+   *   <li>{@link #onFlush} if this was intentionally reported incomplete</li>\n+   *   <li>{@link #onOrphan} if this was reported incomplete due to garbage collection</li>\n+   *   <li>{@link #onFinish} if this was reported complete</li>\n+   * </ol>\n+   *\n+   * <p>The {@code parent} can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#abandon()}.\n+   *\n+   * <p>This is useful when counting children. Decrement your counter when this occurs as the span\n+   * will not be reported.\n+   *\n+   * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error. Some\n+   * instrumentation speculatively create a span for possible outcomes such as retry.\n+   */\n+  public void onAbandon(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#flush()}.\n+   *\n+   * <p>Even though the span here will is incomplete (missing {@link MutableSpan#finishTimestamp()},", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzYxOQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143619", "bodyText": "One of the following will be called later when the created span is no longer in use.", "author": "anuraaga", "createdAt": "2020-04-12T04:20:13Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzY0Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143647", "bodyText": "Currently I was surprised since it reads like these are called right away", "author": "anuraaga", "createdAt": "2020-04-12T04:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzY3Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143672", "bodyText": "I guess it instead of this", "author": "anuraaga", "createdAt": "2020-04-12T04:21:02Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143942", "bodyText": "Not sure if it's necessarily better, but I was sort of expecting there to just be one implementation of SafeSpanListener and this would actually be a SpanListener. We could possibly make it public too since it could be helpful for users to be able to combine multiple listeners but don't have to right now.", "author": "anuraaga", "createdAt": "2020-04-12T04:24:49Z", "path": "brave/src/main/java/brave/internal/handler/SafeSpanListener.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+import java.util.Arrays;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/** This logs exceptions instead of raising an error, as the supplied listener could have bugs. */\n+public abstract class SafeSpanListener extends SpanListener {\n+  // Array ensures no iterators are created at runtime\n+  public static SpanListener create(SpanListener[] handlers) {\n+    if (handlers.length == 0) return SpanListener.NOOP;\n+    if (handlers.length == 1) return new Single(handlers[0]);\n+    return new Multiple(handlers);\n+  }\n+\n+  @Override\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+    try {\n+      doOnCreate(parent, context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling create {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onAbandon(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnAbandon(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling abandon {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onFlush(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnFlush(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling flush {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onOrphan(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnOrphan(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling orphan {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onFinish(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnFinish(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling finish {0}\", context, t);\n+    }\n+  }\n+\n+  abstract void doOnCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span);\n+\n+  abstract void doOnAbandon(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnFlush(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnOrphan(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnFinish(TraceContext context, MutableSpan span);\n+\n+  static final class Single extends SafeSpanListener {\n+    final SpanListener delegate;\n+\n+    Single(SpanListener delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    void doOnCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+      delegate.onCreate(parent, context, span);\n+    }\n+\n+    @Override void doOnAbandon(TraceContext context, MutableSpan span) {\n+      delegate.onAbandon(context, span);\n+    }\n+\n+    @Override void doOnFlush(TraceContext context, MutableSpan span) {\n+      delegate.onFlush(context, span);\n+    }\n+\n+    @Override void doOnOrphan(TraceContext context, MutableSpan span) {\n+      delegate.onOrphan(context, span);\n+    }\n+\n+    @Override void doOnFinish(TraceContext context, MutableSpan span) {\n+      delegate.onFinish(context, span);\n+    }\n+\n+    @Override public String toString() {\n+      return delegate.toString();\n+    }\n+  }\n+\n+  static final class Multiple extends SafeSpanListener {", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1OTMzNw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407159337", "bodyText": "I see what you mean.. good idea on only one safe thing.. I can go back and address the others.\nI don't think we're ready to support user-side compositing as it is unlikely they will do a better job than we would. Probably better for us to just say \"don't composite on your own\" then wait for a scream? (this would apply to the several other places we do similar compositing). Not doing user-level compositing also keeps the api sprawl down.. brave's already collecting quite a number of public types...", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDAwMw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407160003", "bodyText": "Not exposing a compositing listener to public unless we find a use for it in the future sgtm", "author": "anuraaga", "createdAt": "2020-04-12T07:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg=="}], "type": "inlineReview"}, {"oid": "dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "url": "https://github.com/openzipkin/brave/commit/dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "message": "WIP span handler", "committedDate": "2020-04-12T10:17:07Z", "type": "forcePushed"}, {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52", "url": "https://github.com/openzipkin/brave/commit/71413431db25b29d5724b7e0abb2e4be4802fc52", "message": "WIP span listener", "committedDate": "2020-04-12T10:36:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3OTQ1Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407179456", "bodyText": "note this now uses weak maps", "author": "codefromthecrypt", "createdAt": "2020-04-12T10:38:02Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenListener.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.weaklockfree.WeakConcurrentMap;\n+import brave.propagation.TraceContext;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenListener extends SpanListener {\n+\n+  protected abstract void onFinish(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final WeakConcurrentMap<TraceContext, TraceContext> childToParent = new WeakConcurrentMap<>();", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE4NjQ2Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407186467", "bodyText": "oops forgot to switch this back to https://github.com/raphw/weak-lock-free as an example shouldn't use our internal types..", "author": "codefromthecrypt", "createdAt": "2020-04-12T11:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3OTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3MjcyMw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Throwable caller, error;\n          \n          \n            \n              Throwable error;", "author": "codefromthecrypt", "createdAt": "2020-04-13T00:37:03Z", "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -72,7 +72,7 @@\n   ArrayList<String> tags;\n   /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n   ArrayList<Object> annotations;\n-  Throwable error;\n+  Throwable caller, error;", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3Mjg2MQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272861", "bodyText": "TODO move these changes to master as they aren't specific to this feature", "author": "codefromthecrypt", "createdAt": "2020-04-13T00:37:57Z", "path": "brave/src/main/java/brave/RealSpan.java", "diffHunk": "@@ -140,13 +140,12 @@\n   }\n \n   @Override public void finish() {\n-    finish(clock.currentTimeMicroseconds());\n+    finish(0L);", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3MjkwMA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272900", "bodyText": "TODO move this change to master as it isn't specific to this feature", "author": "codefromthecrypt", "createdAt": "2020-04-13T00:38:21Z", "path": "brave/src/main/java/brave/RealScopedSpan.java", "diffHunk": "@@ -74,8 +74,7 @@\n \n   @Override public void finish() {\n     scope.close();\n-    if (pendingSpans.remove(context) == null) return; // don't double-report\n-    state.finishTimestamp(clock.currentTimeMicroseconds());\n+    if (!pendingSpans.finish(context, 0L)) return; // don't double-report", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwODc4Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407608783", "bodyText": "nit: iirc this initial comment comes from an initial version where SpanHandler was extending FinishedSpanHandler. Could be updated to match rationale.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n          \n          \n            \n             * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n          \n          \n            \n             * or partitioning of data for backend that needs to see an entire {@linkplain\n          \n          \n            \n             * TraceContext#localRootId() local root}.\n          \n          \n            \n             * This hooks into the span life-cycle covering all state transitions, including\n          \n          \n            \n             * when a span is created, abandoned, finished, or orphan. This is particularly different than \n          \n          \n            \n             * {@link FinishedSpanHandler} that only considers finished spans.\n          \n          \n            \n             * \n          \n          \n            \n             * <p>The purpose of this type is to allow tracking of children,\n          \n          \n            \n             * or partitioning of data for backend that needs to see an entire {@linkplain\n          \n          \n            \n             * TraceContext#localRootId() local root}.", "author": "jeqo", "createdAt": "2020-04-13T17:37:34Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxMTU4Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407611582", "bodyText": "Would make sense to consider onStart as well? Not that I have a use-case in mind, just wondering if having onStart and onFinish could be useful.", "author": "jeqo", "createdAt": "2020-04-13T17:42:27Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxOTExMQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407819111", "bodyText": "spans are sometimes never started or their start timestamp overwritten (ex \"start\" is not a state in a state diagram, just field manipulation)\nTODO: add this to rationale", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxMTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407617993", "bodyText": "For me is becoming a bit hard to follow the sequence and implications of span state transitions, finished span handler, and now span listeners.\nAdding some docs/diagrams about this could be helpful for users. I can help with this if make sense :)", "author": "jeqo", "createdAt": "2020-04-13T17:53:53Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>\n+   *   <li>{@link #onFlush} if this was intentionally reported incomplete</li>\n+   *   <li>{@link #onOrphan} if this was reported incomplete due to garbage collection</li>\n+   *   <li>{@link #onFinish} if this was reported complete</li>\n+   * </ol>\n+   *\n+   * <p>The {@code parent} can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#abandon()}.\n+   *\n+   * <p>This is useful when counting children. Decrement your counter when this occurs as the span\n+   * will not be reported.\n+   *\n+   * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error. Some\n+   * instrumentation speculatively create a span for possible outcomes such as retry.\n+   */\n+  public void onAbandon(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#flush()}.\n+   *\n+   * <p>Even though the span here will is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+   * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+   */\n+  public void onFlush(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called when the trace context was garbage collected prior to completion.\n+   *\n+   * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if {@linkplain", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODk1MQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407818951", "bodyText": "your questions are helpful as I also feel uncomfortable.\nI'm wondering if the type shouldn't be called something else..\nWe are mostly talking about a binding between a trace context and a state object for the purpose of collection and when that binding is complete (for any reason). When there are\nonly two states it is simpler and no diagrams are needed.\nPlus we don't need to describe nuance (though we can in rationale), such as that spans are sometimes never started or their start timestamp overwritten (ex \"start\" is not a state in a state diagram, just field manipulation)\nEx\nSampledSpanListener {\n  enum Reason {\n    ABANDON,\n    FINISH,\n    FLUSH,\n    GC; // or ORPHAN which is the word we use more\n  }\n  void onBind(TraceContext, MutableSpan)\n  void onRelease(TraceContext, MutableSpan, Reason)\n}", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MzY4OQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407843689", "bodyText": "This interface does seem nicer since many use cases won't even care about the reason and it's more explicit that only one of those is called. That said, I don't know if conceptually it's so different, docs that would apply to the individual interface methods seem to just move into the Reason enum.\nAlso unsure of bind, the word isn't very intuitive for me. onStart / onEnd seem clear, with the caveat of end looking a lot like finish (but then again release I guess looks like GC \ud83e\udd23 ).\nWondering what happens if the methods return boolean? onBind can return secondary sampling decision (well maybe too late we already have a TraceContext), onRelease can replace FinishedSpanHandler so don't have to reason about that?", "author": "anuraaga", "createdAt": "2020-04-14T03:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NzQ1Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407847457", "bodyText": "I think the biggest difference the enum brings is that the state diagram becomes unambiguous.. whatever the begin hook has only one end hook and they are both always called. Those who care about the reason of the end can look at it. I agree docs will just move, but this obviates docs about a state diagram I think.\nnaming is not my favorite either.. was trying to avoid the word finish. I tried thinking through various things that suggest an association.\nex\nassociate/disassociate\nallocate/deallocate\nbind/unbind\nrandom words that just say start/stop\nbegin/end\nstart/finish (dangerous as conflated with span ops)\nI'm currently thinking..\nonSampled\nonCollected\nwrt to onCollected returning false, I think we could I guess yeah, just it would also imply that any finishedSpanListeners would need to be converted first to these in order to perform things like redaction. Another way is we can make this able to internally dispatch to finishedSpanHandlers... ex Whatever this is called exposes a factory that accepts a single (potentially composite) FinishedSpanHandler instance we give to it...", "author": "codefromthecrypt", "createdAt": "2020-04-14T03:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0ODI0Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407848246", "bodyText": "one possibility especially with the design as it is, is that we can deprecate FinishedSpanHandler. I feel one thing this design does is makes the relationships a whole lot more clear. So what would happen in this case is that we make a special SampledSpanListener that does a dispatch first to any FinishedSpanHandlers before calling its onCollected hook. that way we don't have to mention FinishedSpanHandler at all? It is a little sad that FinishedSpanHandler didn't live that long, but I feel this is becoming a much better conceptual model.", "author": "codefromthecrypt", "createdAt": "2020-04-14T03:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407625220", "bodyText": "@adriancole would you mind sharing the reasoning behind 0L instead of #currentTimeMicroseconds()", "author": "jeqo", "createdAt": "2020-04-13T18:06:24Z", "path": "brave/src/main/java/brave/RealSpan.java", "diffHunk": "@@ -140,13 +140,12 @@\n   }\n \n   @Override public void finish() {\n-    finish(clock.currentTimeMicroseconds());\n+    finish(0L);", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxOTM2OA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407819368", "bodyText": "to prevent overhead of using the clock when the span is already finished.", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxOTY3Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407819677", "bodyText": "TODO: comment", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyNDE5Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407824193", "bodyText": "fixed upstream", "author": "codefromthecrypt", "createdAt": "2020-04-14T02:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA=="}], "type": "inlineReview"}, {"oid": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "url": "https://github.com/openzipkin/brave/commit/b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "message": "Update brave/RATIONALE.md\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>", "committedDate": "2020-04-14T04:44:19Z", "type": "forcePushed"}, {"oid": "4912b1fca4cbe81528794f19c06290c668b54a57", "url": "https://github.com/openzipkin/brave/commit/4912b1fca4cbe81528794f19c06290c668b54a57", "message": "polish", "committedDate": "2020-04-15T08:02:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408722529", "bodyText": "eventhough nostalgia for SpanCollector SpanHandler may still be better name I admit as we can't move the MutableSpan out of this package without certain chaos...", "author": "codefromthecrypt", "createdAt": "2020-04-15T09:56:13Z", "path": "brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import brave.handler.FinishedSpanHandler;\n import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczNjY0Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408736646", "bodyText": "Also collector can cause confusion with server-side collectors.\nJust for reference, and to add one more alternative naming, in Kafka Clients interceptors have a similar function.", "author": "jeqo", "createdAt": "2020-04-15T10:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0OTU0Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408749542", "bodyText": "good point on collector being conflated (I think  I recall now we dodged the word collector in the first place due to this..)\npersonally I like handler better, as usually interceptor means getting in the middle of something. ex\nvoid intercept(thing, chain){\n  return chain.proceed(thing);\n}", "author": "codefromthecrypt", "createdAt": "2020-04-15T10:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNjE1OA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408836158", "bodyText": "Fair enough. I also prefer Handler instead of Listener..--naming is hard :)", "author": "jeqo", "createdAt": "2020-04-15T13:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMDUxOQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408900519", "bodyText": "for an enum Cause i would linguistically expect past-tense constants, ABANDONED - FINISHED etc ?", "author": "jorgheymans", "createdAt": "2020-04-15T14:47:03Z", "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTUwMQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195501", "bodyText": "sgtm thanks", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTc5Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408901792", "bodyText": "the other constants are named linear to their Span methods, why ORPHAN for gc collected, are there other use cases leading to ORPHAN besides gc ?", "author": "jorgheymans", "createdAt": "2020-04-15T14:48:29Z", "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {\n+    /**\n+     * Called on {@link Span#abandon()}.\n+     *\n+     * <p>This is useful when counting children. Decrement your counter when this occurs as the\n+     * span will not be reported.\n+     *\n+     * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error.\n+     * Some instrumentation speculatively create a span for possible outcomes such as retry.\n+     */\n+    ABANDON,\n+    /**\n+     * Called on {@link Span#finish()} and is the simplest cause to reason with. When {@link\n+     * MutableSpan#startTimestamp()} is present, you can assume with high confidence you have all\n+     * recorded data for this span.\n+     */\n+    FINISH,\n+    /**\n+     * Called on {@link Span#flush()}.\n+     *\n+     * <p>Even though the span here is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+     * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+     */\n+    FLUSH,\n+    /**\n+     * Called when the trace context was garbage collected prior to completion.\n+     *\n+     * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if empty.\n+     * Non-empty spans are reported to the tracing system unless a {@link FinishedSpanHandler}\n+     * returns false.\n+     *\n+     * @see FinishedSpanHandler#supportsOrphans()\n+     */\n+    ORPHAN", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTEyNQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195125", "bodyText": "well GC is the side affect of orphaning your span (ex by creating it and dropping a reference to it). I think that's why we named it orphan back then, but I can look up notes if you like.\nMain thing is the fact that it is GC'ed is only because someone orphaned it. If they held a reference it would not become GC'ed. Possibly I can clarify the description somewhere.", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNjU0Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408906542", "bodyText": "does this need to be duplicated from Cause ?\nCalled when data collection completes on its own is enough, and maybe link in the cause parameter to the enum.", "author": "jorgheymans", "createdAt": "2020-04-15T14:54:23Z", "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {\n+    /**\n+     * Called on {@link Span#abandon()}.\n+     *\n+     * <p>This is useful when counting children. Decrement your counter when this occurs as the\n+     * span will not be reported.\n+     *\n+     * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error.\n+     * Some instrumentation speculatively create a span for possible outcomes such as retry.\n+     */\n+    ABANDON,\n+    /**\n+     * Called on {@link Span#finish()} and is the simplest cause to reason with. When {@link\n+     * MutableSpan#startTimestamp()} is present, you can assume with high confidence you have all\n+     * recorded data for this span.\n+     */\n+    FINISH,\n+    /**\n+     * Called on {@link Span#flush()}.\n+     *\n+     * <p>Even though the span here is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+     * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+     */\n+    FLUSH,\n+    /**\n+     * Called when the trace context was garbage collected prior to completion.\n+     *\n+     * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if empty.\n+     * Non-empty spans are reported to the tracing system unless a {@link FinishedSpanHandler}\n+     * returns false.\n+     *\n+     * @see FinishedSpanHandler#supportsOrphans()\n+     */\n+    ORPHAN\n+  }\n+\n+  /** Use to avoid comparing against null references */\n+  SpanCollector NOOP = new SpanCollector() {\n+    @Override public void begin(TraceContext context, MutableSpan span, TraceContext parent) {\n+    }\n+\n+    @Override public boolean end(TraceContext context, MutableSpan span, Cause cause) {\n+      return true;\n+    }\n+\n+    @Override public String toString() {\n+      return \"NoopSpanCollector{}\";\n+    }\n+  };\n+\n+  /**\n+   * This is called when a span is sampled, but before it is started.\n+   *\n+   * @param context the trace context which is  {@link TraceContext#sampledLocal()}. This includes\n+   * identifiers and potentially {@link TraceContext#extra() extra propagated data} such as baggage\n+   * or extended sampling configuration.\n+   * @param span a mutable object that stores data recorded with span apis. Modifications are\n+   * visible to later collectors.\n+   * @param parent can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  void begin(TraceContext context, MutableSpan span, @Nullable TraceContext parent);\n+\n+  /**\n+   * Called when data collection completes for one of the following reasons:\n+   *\n+   * <p><ol>\n+   * <li>{@link Cause#ABANDON} if it was a speculative context</li>\n+   * <li>{@link Cause#FINISH} if it was reported complete</li>\n+   * <li>{@link Cause#FLUSH} if it was intentionally reported incomplete</li>\n+   * <li>{@link Cause#ORPHAN} if it was reported incomplete due to garbage collection</li>", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTMxMQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195311", "bodyText": "sgtm I can put this on the type docs of Cause, as I do think an overview helps, but possibly not here..", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNjU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNTU2Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408935567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Kick-out if the this was not a normal finish\n          \n          \n            \n                // Kick-out if this was not a normal finish", "author": "jorgheymans", "createdAt": "2020-04-15T15:31:55Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenCollector implements SpanCollector {\n+\n+  protected abstract void onFinish(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final WeakConcurrentMap<TraceContext, TraceContext> childToParent =\n+    new WeakConcurrentMap<>(false);\n+  final ParentToChildren parentToChildren = new ParentToChildren();\n+\n+  @Override\n+  public void begin(TraceContext context, MutableSpan span, @Nullable TraceContext parent) {\n+    if (!context.isLocalRoot()) { // a child\n+      childToParent.putIfProbablyAbsent(context, parent);\n+      parentToChildren.add(parent, span);\n+    }\n+  }\n+\n+  @Override public boolean end(TraceContext context, MutableSpan span, Cause cause) {\n+    // Kick-out if the this was not a normal finish", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjMwNQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408936305", "bodyText": "does this need a type level javadoc ?", "author": "jorgheymans", "createdAt": "2020-04-15T15:32:51Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenCollector implements SpanCollector {", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTQxNw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195417", "bodyText": "test class, but sure", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjMwNQ=="}], "type": "inlineReview"}, {"oid": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "url": "https://github.com/openzipkin/brave/commit/b4c7609e8fb6e635bd50367cba691e45c25468fc", "message": "typo", "committedDate": "2020-04-20T04:37:20Z", "type": "forcePushed"}, {"oid": "777176f8f0fe141126f09ae61876a3f736f19f5b", "url": "https://github.com/openzipkin/brave/commit/777176f8f0fe141126f09ae61876a3f736f19f5b", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-05-08T05:53:19Z", "type": "forcePushed"}, {"oid": "c029d571d2ee44e77d5e7035ab4a93585197a736", "url": "https://github.com/openzipkin/brave/commit/c029d571d2ee44e77d5e7035ab4a93585197a736", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-05-08T08:59:50Z", "type": "forcePushed"}, {"oid": "c029d571d2ee44e77d5e7035ab4a93585197a736", "url": "https://github.com/openzipkin/brave/commit/c029d571d2ee44e77d5e7035ab4a93585197a736", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-05-08T08:59:50Z", "type": "commit"}, {"oid": "c4ce99b43325bf3b330f5f517bb2819684b60308", "url": "https://github.com/openzipkin/brave/commit/c4ce99b43325bf3b330f5f517bb2819684b60308", "message": "deprecate and feedback", "committedDate": "2020-05-08T10:53:27Z", "type": "commit"}, {"oid": "91a49ee9163342cd2d9e5f216e3cf8675db56e56", "url": "https://github.com/openzipkin/brave/commit/91a49ee9163342cd2d9e5f216e3cf8675db56e56", "message": "more rationale", "committedDate": "2020-05-08T11:14:02Z", "type": "commit"}]}