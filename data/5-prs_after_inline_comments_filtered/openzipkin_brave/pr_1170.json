{"pr_number": 1170, "pr_title": "Makes Dubbo Error code words not numbers", "pr_createdAt": "2020-04-22T09:31:43Z", "pr_url": "https://github.com/openzipkin/brave/pull/1170", "timeline": [{"oid": "eaa0df891e052049d24ece2be78a1829599b4eb9", "url": "https://github.com/openzipkin/brave/commit/eaa0df891e052049d24ece2be78a1829599b4eb9", "message": "Makes Dubbo Error code words not numbers\n\nThis makes \"dubbo.error_code\" use the code name, like \"TIMEOUT_EXCEPTION\", as\nopposed to the code number like 2.\n\nThis primarily matches conventions being defined in #999, where we prefer error\ncode names over numbers. The below rationale is a copy/paste from the new\nRATIONALE.md for Dubbo, and helps explain the subtle points here vs HTTP status.\n\n---\n\nHTTP status codes are grouped by classification, and have existed so long that\nsupport teams can usually identify meaning by looking at a number like 401.\nBeing triple digits, it is relatively easy to search for what an HTTP status\nmeans.\n\nDubbo code numbers are more like enum ordinals. There's no grouping and it is\nnot easy to identify a problem quickly by seeing a number like 2 vs the code\nname \"TIMEOUT_EXCEPTION\". There is no generic documentation on Dubbo errors. If\ngiven only the number 2, a user unfamiliar with how Dubbo works internally will\nhave a hard time. For example, searching Dubbo's code base for \"2\" will return\nless relevant results than searching for \"TIMEOUT_EXCEPTION\".\n\nIt may seem that exception messages can overcome this problem, and they\ncertainly can when present. Also, exception messages can be localized. However,\nexception messages are not good for trace search because they are long and\ncontain variables.\n\nFor all these reasons, we use code names, not numbers, for Dubbo, as defined in\n`RpcException`'s constants (so that they are easy to search).", "committedDate": "2020-04-22T09:31:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNDg3NQ==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412834875", "bodyText": "I get where this is coming from. Just to share only one point I'm concerned about - if some servers in a fleet use a new version of instrumentation and others don't, the same exception shows up as name in some, int in others. It does seem quite rare though since why not bump instrumentation when bumping Dubbo? So all good here.", "author": "anuraaga", "createdAt": "2020-04-22T09:45:35Z", "path": "instrumentation/dubbo-rpc/src/main/java/brave/dubbo/rpc/DubboParser.java", "diffHunk": "@@ -69,19 +69,28 @@ static boolean parseRemoteIpAndPort(Span span) {\n   }\n \n   /**\n-   * We decided to not map Dubbo codes to human readable names like {@link\n-   * RpcException#BIZ_EXCEPTION} even though we defined \"rpc.error_code\" as a human readable name.\n-   *\n-   * <p>The reason was a comparison with HTTP status codes, and the choice was between returning\n-   * just numbers or reusing \"UNKNOWN_EXCEPTION\" which is defined in Dubbo for code \"0\" for any\n-   * unknown code. Returning numbers was the less bad option as it doesn't conflate code words.\n-   *\n-   * <p>Later, we can revert this back to code words, but once this gets into the RPC mapping for\n-   * Dubbo it will be hard to change.\n+   * This library is no-longer being released, so it should not have any maintenance on error codes.\n+   * The error codes here were defined in 2012.\n    */\n   @Nullable static String errorCode(Throwable error) {\n     if (error instanceof RpcException) {\n-      return String.valueOf(((RpcException) error).getCode());\n+      int code = ((RpcException) error).getCode();\n+      switch (code) {\n+        case RpcException.UNKNOWN_EXCEPTION:\n+          return \"UNKNOWN_EXCEPTION\";\n+        case RpcException.NETWORK_EXCEPTION:\n+          return \"NETWORK_EXCEPTION\";\n+        case RpcException.TIMEOUT_EXCEPTION:\n+          return \"TIMEOUT_EXCEPTION\";\n+        case RpcException.BIZ_EXCEPTION:\n+          return \"BIZ_EXCEPTION\";\n+        case RpcException.FORBIDDEN_EXCEPTION:\n+          return \"FORBIDDEN_EXCEPTION\";\n+        case RpcException.SERIALIZATION_EXCEPTION:\n+          return \"SERIALIZATION_EXCEPTION\";\n+        default:\n+          return String.valueOf(code);", "originalCommit": "eaa0df891e052049d24ece2be78a1829599b4eb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzOTk5MA==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412839990", "bodyText": "the only other option I can think of is using reflection in to lookup the symbols. Ex search for public static ints whose name ends in _EXCEPTION\nthat would make it no maintenance and since they are all public, unlikely to cause a weird crash.. wdyt?", "author": "codefromthecrypt", "createdAt": "2020-04-22T09:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MTMxNw==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412841317", "bodyText": "I will give it a try. we use one-time reflection in a lot of code, like servlet etc. we would have heard complaints by now if someone is unable to use reflection at all..", "author": "codefromthecrypt", "createdAt": "2020-04-22T09:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1NDQwMg==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412854402", "bodyText": "Thanks, that sounds like a nice approach!", "author": "anuraaga", "createdAt": "2020-04-22T10:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1NzgyOQ==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412857829", "bodyText": "couldn't use _EXCEPTION as they are not consistent :) we blindly trust int constants for now. It is unlikely to cause an issue I think and I agree this is better. thanks, rag!", "author": "codefromthecrypt", "createdAt": "2020-04-22T10:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNDg3NQ=="}], "type": "inlineReview"}, {"oid": "cbc774eb782dff63d1bc76010f4362988a488e99", "url": "https://github.com/openzipkin/brave/commit/cbc774eb782dff63d1bc76010f4362988a488e99", "message": "use reflection", "committedDate": "2020-04-22T10:18:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1OTE2OA==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412859168", "bodyText": "Nice", "author": "anuraaga", "createdAt": "2020-04-22T10:21:20Z", "path": "instrumentation/dubbo/src/main/java/brave/dubbo/DubboParser.java", "diffHunk": "@@ -25,6 +29,36 @@\n import org.apache.dubbo.rpc.support.RpcUtils;\n \n final class DubboParser {\n+  static final Map<Integer, String> ERROR_CODE_NUMBER_TO_NAME = errorCodeNumberToName();\n+\n+  /**\n+   * Dubbo adds error codes sometimes. For example, they added two in the last two years. If we did\n+   * a simple switch/case of each code, like {@link RpcException#BIZ_EXCEPTION}, new code names\n+   * would not be seen until an upgrade of Brave. That, or we'd have to fall back to a code number\n+   * until the upgrade of Brave converged.\n+   *\n+   * <p>This uses reflection instead, which is unlikely to fail as Dubbo's error codes are public\n+   * constants.\n+   */\n+  static Map<Integer, String> errorCodeNumberToName() {\n+    Map<Integer, String> result = new LinkedHashMap<>();\n+    for (Field field : RpcException.class.getDeclaredFields()) {\n+      if (Modifier.isStatic(field.getModifiers()) && field.getType() == int.class) {\n+        try {\n+          result.put((Integer) field.get(null), field.getName());\n+        } catch (Exception e) {\n+          assert false : e.getMessage(); // make all unit tests fail", "originalCommit": "cbc774eb782dff63d1bc76010f4362988a488e99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2MDE5MA==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412860190", "bodyText": "How about checking Modifier.isPublic too?", "author": "anuraaga", "createdAt": "2020-04-22T10:22:57Z", "path": "instrumentation/dubbo/src/main/java/brave/dubbo/DubboParser.java", "diffHunk": "@@ -25,6 +29,36 @@\n import org.apache.dubbo.rpc.support.RpcUtils;\n \n final class DubboParser {\n+  static final Map<Integer, String> ERROR_CODE_NUMBER_TO_NAME = errorCodeNumberToName();\n+\n+  /**\n+   * Dubbo adds error codes sometimes. For example, they added two in the last two years. If we did\n+   * a simple switch/case of each code, like {@link RpcException#BIZ_EXCEPTION}, new code names\n+   * would not be seen until an upgrade of Brave. That, or we'd have to fall back to a code number\n+   * until the upgrade of Brave converged.\n+   *\n+   * <p>This uses reflection instead, which is unlikely to fail as Dubbo's error codes are public\n+   * constants.\n+   */\n+  static Map<Integer, String> errorCodeNumberToName() {\n+    Map<Integer, String> result = new LinkedHashMap<>();\n+    for (Field field : RpcException.class.getDeclaredFields()) {\n+      if (Modifier.isStatic(field.getModifiers()) && field.getType() == int.class) {", "originalCommit": "cbc774eb782dff63d1bc76010f4362988a488e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2Njg0OA==", "url": "https://github.com/openzipkin/brave/pull/1170#discussion_r412866848", "bodyText": "yeah good idea. it makes more sense reading it now, also.", "author": "codefromthecrypt", "createdAt": "2020-04-22T10:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2MDE5MA=="}], "type": "inlineReview"}, {"oid": "995ba0ffe7e519158f928d8eddac7420ace6caa8", "url": "https://github.com/openzipkin/brave/commit/995ba0ffe7e519158f928d8eddac7420ace6caa8", "message": "public static final int", "committedDate": "2020-04-22T10:33:49Z", "type": "commit"}]}