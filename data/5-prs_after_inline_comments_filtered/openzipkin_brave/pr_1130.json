{"pr_number": 1130, "pr_title": "Exposes Baggage Apis", "pr_createdAt": "2020-03-28T11:29:42Z", "pr_url": "https://github.com/openzipkin/brave/pull/1130", "timeline": [{"oid": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "url": "https://github.com/openzipkin/brave/commit/7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "message": "Exposes CorrelationField and ExtraField Apis\n\nThis completes the most common requests around correlation fields by\ngeneralizing code in support for correlation fields, both synchronizing\nto logging context and also propagation (extra fields).\n\nNotably, this allows you to not only define constants for the fields you\nwant, but also decide if they are permissible for correlation.\n\nEx.\n\n```java\n // configure the field, permitting it to be used in correlation contexts\n static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n\n // Allow logging patterns like %X{traceId} %X{bp}\n loggingContext = new Log4J2Context();\n\n decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n                                           .addField(BUSINESS_PROCESS).build();\n\n tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n                                                        .flushValuesToContext(loggingContext)\n                                                        .addField(BUSINESS_PROCESS)\n                                                        .build())\n               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n                                                                  .addScopeDecorator(decorator)\n                                                                  .build())\n\n // Assume runtime code looks like this\n @SendTo(SourceChannels.OUTPUT)\n public void timerMessageSource() {\n   BUSINESS_PROCESS.setValue(\"accounting\");\n   // The logging expression %{bp} will show \"accounting\" in businessCode()\n   businessCode();\n }\n```", "committedDate": "2020-03-29T07:44:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MjEzMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399762131", "bodyText": "@jorgheymans  can you check this new type to see if it makes sense?", "author": "codefromthecrypt", "createdAt": "2020-03-29T08:04:33Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MjQ2OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399762468", "bodyText": "Random ideas spurred by the subtype builder pattern we came up with just as food for thought\n B3Propagation.FACTORY.withExtraFields()\nB3Propagation.FACTORY.toBuilder().addExtraField(", "author": "anuraaga", "createdAt": "2020-03-29T08:08:16Z", "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -79,7 +80,8 @@ protected TraceContext newTraceContext(SamplingFlags flags) {\n       .build();\n \n   protected final Propagation.Factory propagationFactory =\n-    ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, EXTRA_KEY);\n+    ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NTExMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399785111", "bodyText": "thanks for the thought although I don't really want to couple propagation to this type yet..\nright now there's a generic list thing in the context also, so I don't want to conflate the two.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MzU2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399763562", "bodyText": "It's so unrelated to this PR that I can't even comment on the line \ud83d\ude04\nBut since I happened to see it, to record it, in putAllIfAbsent, it's probably good to have synchronized(this) around the loop so 1) invocations of it are atomic, similar to put and 2) if put gets inlined the nested synchronization will go away and only happen once around the loop", "author": "anuraaga", "createdAt": "2020-03-29T08:18:44Z", "path": "brave/src/main/java/brave/internal/PredefinedPropagationFields.java", "diffHunk": "@@ -78,12 +78,12 @@ public String get(int index) {\n   }\n \n   public final void put(int index, String value) {\n-    if (index >= fieldNames.length) return;\n+    if (index >= names.length) return;\n \n     synchronized (this) {", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NTkxMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399785913", "bodyText": "drifted to ExtraFields but will comment now!\nputAllIfAbsent is protected and used before the input is returned anywhere. I'll add a javadoc comment. Regardless I made a path that doesn't synchronize even if it would be uncontended. Good idea.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Mzc4Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399763783", "bodyText": "Not exactly being able to parse this English, maybe something like A field which will also be used in a correlation context such as MDC.", "author": "anuraaga", "createdAt": "2020-03-29T08:20:53Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NTk5OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399785998", "bodyText": "better thanks", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Mzc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764141", "bodyText": "A bit uncertain what value comparison means here, I think it's more comparing a key?", "author": "anuraaga", "createdAt": "2020-03-29T08:24:21Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE3OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764179", "bodyText": "Though maybe at least for now just seal this so it's not subclassed by users?", "author": "anuraaga", "createdAt": "2020-03-29T08:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NjEwNw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399786107", "bodyText": "I reworded ptal. can't be sealed as we need it to be an interface for conditional use in ExtraField..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDM0Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764343", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns the correlation property of the specified name iff it is a string, or null\n          \n          \n            \n                 * Returns the correlation property of the specified name if it is set, or null\n          \n      \n    \n    \n  \n\nI think", "author": "anuraaga", "createdAt": "2020-03-29T08:26:17Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n+ * comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  @Nullable String getValue(TraceContext context);\n+\n+  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n+  abstract class Context { // abstract to allow optimized methods to be added later\n+    /**\n+     * Returns the correlation property of the specified name iff it is a string, or null", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4MzQ4OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399783489", "bodyText": "some contexts allow object values, so the main intent here is that it is not null and a string..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDYwNg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764606", "bodyText": "Totally randomly, this looks a lot like a new class in Armeria for customizing Context storage, which is inspired by gRPC.\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L77\nJust in case it's interesting. One feature that may be relevant is accepting a current value when doing remove - this can help catch instrumentation bugs if remove is being called from an unexpected place / thread.", "author": "anuraaga", "createdAt": "2020-03-29T08:28:36Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n+ * comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  @Nullable String getValue(TraceContext context);\n+\n+  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n+  abstract class Context { // abstract to allow optimized methods to be added later", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4MzY1MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399783650", "bodyText": "oh yeah I remember that. I didn't really want this to be a user type though. In fact, we can probably hide it again..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4MzcwNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399783705", "bodyText": "reason is that the context is very expensive part of the code, and having to re-look up the old value will just make it worse.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDk2NQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764965", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n          \n          \n            \n             * // Add the field \"region\", so it can be used as a log expression %X{region}\n          \n      \n    \n    \n  \n\nI think the example isn't our normal concept of \"extra fields\"", "author": "anuraaga", "createdAt": "2020-03-29T08:32:32Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NTE0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399765141", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n          \n          \n            \n             * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n          \n          \n            \n             *   .addField(awsRegion)\n          \n          \n            \n             *   .build();\n          \n          \n            \n             * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n          \n          \n            \n             * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n          \n          \n            \n             *   .addField(cloudRegion)\n          \n          \n            \n             *   .build();\n          \n      \n    \n    \n  \n\nProbably good to be more generic", "author": "anuraaga", "createdAt": "2020-03-29T08:34:01Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n+ * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(awsRegion)\n+ *   .build();", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NTQ5MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399765491", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>Defaults may include a field you aren't using, such as \"parentId\". For better\n          \n          \n            \n                 * <p>Defaults may include a field you aren't using, such as \"parentId\". For best", "author": "anuraaga", "createdAt": "2020-03-29T08:38:06Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n+ * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(awsRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(CorrelationFieldScopeDecorator.create(correlationContext))\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration. You can also configure {@link ExtraFieldPropagation.FactoryBuilder#flushValuesToContext(CorrelationField.Context)}\n+ * so that values updates reflect immediately in the {@link CorrelationField.Context}.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationField.Context\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  /**\n+   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n+   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n+   * CorrelationFields#SAMPLED}.\n+   *\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(CorrelationField.Context context) {\n+    return new Builder(context);\n+  }\n+\n+  /**\n+   * @see #newBuilder(CorrelationField.Context)\n+   * @since 5.11\n+   */\n+  public static ScopeDecorator create(CorrelationField.Context context) {\n+    return new Builder(context).build();\n+  }\n+\n+  public static final class Builder {\n+    final CorrelationField.Context context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,\n+      CorrelationFields.PARENT_ID,\n+      CorrelationFields.SPAN_ID,\n+      CorrelationFields.SAMPLED\n+    ));\n+\n+    Builder(CorrelationField.Context context) {\n+      if (context == null) throw new NullPointerException(\"context == null\");\n+      this.context = context;\n+    }\n+\n+    /**\n+     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n+     * ones you need}.\n+     *\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For better", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjI3MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766270", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!update(traceContext, field, previousValue)) {\n          \n          \n            \n                    return scope;\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  class SingleCorrelationFieldScope implements Scope {\n          \n          \n            \n                    @Override public void close() {\n          \n          \n            \n                      scope.close();\n          \n          \n            \n                      replace(field.name(), previousValue);\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n          \n            \n                  String currentValue = update(traceContext, field, previousValue);\n          \n          \n            \n                  if (currentValue == null) {\n          \n          \n            \n                    return scope;\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  class SingleCorrelationFieldScope implements Scope {\n          \n          \n            \n                    @Override public void close() {\n          \n          \n            \n                      scope.close();\n          \n          \n            \n                      replace(field.name(), previousValue, currentValue);\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nJust an example of what it might look like to pass current value in when closing a scope if it seems useful. replace would check to make sure the current value is currentValue since if it isn't, the scope was closed in the wrong order - happens in reactive apps sometimes \ud83d\ude22 But admittedly having a check like this only for correlation scopes and not our more important ones is probably not so helpful either.", "author": "anuraaga", "createdAt": "2020-03-29T08:45:54Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n+ * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(awsRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(CorrelationFieldScopeDecorator.create(correlationContext))\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration. You can also configure {@link ExtraFieldPropagation.FactoryBuilder#flushValuesToContext(CorrelationField.Context)}\n+ * so that values updates reflect immediately in the {@link CorrelationField.Context}.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationField.Context\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  /**\n+   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n+   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n+   * CorrelationFields#SAMPLED}.\n+   *\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(CorrelationField.Context context) {\n+    return new Builder(context);\n+  }\n+\n+  /**\n+   * @see #newBuilder(CorrelationField.Context)\n+   * @since 5.11\n+   */\n+  public static ScopeDecorator create(CorrelationField.Context context) {\n+    return new Builder(context).build();\n+  }\n+\n+  public static final class Builder {\n+    final CorrelationField.Context context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,\n+      CorrelationFields.PARENT_ID,\n+      CorrelationFields.SPAN_ID,\n+      CorrelationFields.SAMPLED\n+    ));\n+\n+    Builder(CorrelationField.Context context) {\n+      if (context == null) throw new NullPointerException(\"context == null\");\n+      this.context = context;\n+    }\n+\n+    /**\n+     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n+     * ones you need}.\n+     *\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For better\n+     * performance, only include the fields you use in your correlation expressions (such as log\n+     * formats).\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearFields() {\n+      this.fields.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addField(CorrelationField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n+      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** @throws IllegalArgumentException if no correlation fields were added. */\n+    public final CorrelationFieldScopeDecorator build() {\n+      int fieldCount = fields.size();\n+      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n+      if (fieldCount == 1) {\n+        return new Single(context, fields.iterator().next());\n+      }\n+      return new Multiple(context, fields);\n+    }\n+  }\n+\n+  final CorrelationField.Context context;\n+\n+  CorrelationFieldScopeDecorator(CorrelationField.Context context) {\n+    this.context = context;\n+  }\n+\n+  boolean update(@Nullable TraceContext traceContext, CorrelationField field,\n+    String previousValue) {\n+    String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n+    if (currentValue != null) {\n+      if (!currentValue.equals(previousValue)) {\n+        context.put(field.name(), currentValue);\n+        return true;\n+      }\n+    } else if (previousValue != null) {\n+      context.remove(field.name());\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  void replace(String name, @Nullable String value) {\n+    if (value != null) {\n+      context.put(name, value);\n+    } else {\n+      context.remove(name);\n+    }\n+  }\n+\n+  static final class Single extends CorrelationFieldScopeDecorator {\n+    final CorrelationField field;\n+\n+    Single(CorrelationField.Context context, CorrelationField field) {\n+      super(context);\n+      this.field = field;\n+    }\n+\n+    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n+      if (scope == Scope.NOOP) return scope;\n+\n+      String previousValue = context.get(field.name());\n+      if (!update(traceContext, field, previousValue)) {\n+        return scope;\n+      }\n+\n+      class SingleCorrelationFieldScope implements Scope {\n+        @Override public void close() {\n+          scope.close();\n+          replace(field.name(), previousValue);\n+        }\n+      }", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NjU5OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399786598", "bodyText": "made a comment elsewhere, but to read back the current value is expensive. also we allow late updates. finally we do want to clobber out of band updates because MDC can be used externally", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjQ1Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766457", "bodyText": "How about naming extract similar to the javadoc? I find it a bit confusing with two types of contexts, the correlation context and the trace context, so using get with correlation context and extract with trace context might be a good way to define the boundaries better", "author": "anuraaga", "createdAt": "2020-03-29T08:47:50Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n+ * comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  @Nullable String getValue(TraceContext context);", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4Njc5OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399786798", "bodyText": "I'd rather use returns because it shouldn't be expensive like extract is. correlation field is in-process. updated.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NDg4NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399964884", "bodyText": "FWIW, I didn't find the confusing pattern of gets this time, so using the internal type probably resolved my original confusion.", "author": "anuraaga", "createdAt": "2020-03-30T06:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Njc5MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766791", "bodyText": "Is this supposed to say #TRACE_ID. Though not sure I agree - some might find it enough to use this as a request ID in their systems without actually tying into tracing.", "author": "anuraaga", "createdAt": "2020-03-29T08:50:59Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #SPAN_ID} is also a correlation field.", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NzA0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399787041", "bodyText": "span id isn't a request id, but anyway would like to dodge a discussion :)\ntrying \"Used with {@link #TRACE_ID} to correlate a log line with a span.\"", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:56:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Njc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjgzMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766833", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n          \n          \n            \n               * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));", "author": "anuraaga", "createdAt": "2020-03-29T08:51:31Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #SPAN_ID} is also a correlation field.\n+   *\n+   * @see TraceContext#spanIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.spanIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n+   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n+   * typically reported to Zipkin.\n+   *\n+   * @see TraceContext#sampled()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SAMPLED = new BaseCorrelationField(\"sampled\") {\n+    @Override public String getValue(TraceContext context) {\n+      Boolean sampled = context.sampled();\n+      return sampled != null ? sampled.toString() : null;\n+    }\n+  };\n+\n+  /**\n+   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n+   *\n+   * <p>Ex.\n+   * <pre>{@code\n+   * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDQ3NQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784475", "bodyText": "heh I actually looked up a real variable :D fair enough though.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NzI4Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399767283", "bodyText": "What about doing instanceof CorrelationField? Matters less if we seal the interface though", "author": "anuraaga", "createdAt": "2020-03-29T08:55:12Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #SPAN_ID} is also a correlation field.\n+   *\n+   * @see TraceContext#spanIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.spanIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n+   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n+   * typically reported to Zipkin.\n+   *\n+   * @see TraceContext#sampled()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SAMPLED = new BaseCorrelationField(\"sampled\") {\n+    @Override public String getValue(TraceContext context) {\n+      Boolean sampled = context.sampled();\n+      return sampled != null ? sampled.toString() : null;\n+    }\n+  };\n+\n+  /**\n+   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n+   *\n+   * <p>Ex.\n+   * <pre>{@code\n+   * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+   * }</pre>\n+   *\n+   * @since 5.11\n+   */\n+  public static CorrelationField constant(String name, @Nullable String value) {\n+    return new ConstantCorrelationField(name, value);\n+  }\n+\n+  static final class ConstantCorrelationField extends BaseCorrelationField {\n+    final String value;\n+\n+    ConstantCorrelationField(String name, String value) {\n+      super(name);\n+      this.value = value;\n+    }\n+\n+    @Override public String getValue(TraceContext context) {\n+      return value;\n+    }\n+  }\n+\n+  static abstract class BaseCorrelationField implements CorrelationField {\n+    final String name;\n+\n+    BaseCorrelationField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      name = name.trim();\n+      if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+      this.name = name;\n+    }\n+\n+    @Override public String name() {\n+      return name;\n+    }\n+\n+    @Override public String toString() {\n+      return name;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      if (o == this) return true;\n+      if (!(o instanceof BaseCorrelationField)) return false;", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDM4MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784381", "bodyText": "sure.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NzI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3MDY4Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399870682", "bodyText": "I will try to seal it, handling extra field differently..", "author": "codefromthecrypt", "createdAt": "2020-03-29T23:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NzI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODA1MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399768050", "bodyText": "I guess these can delegate to the static methods instead of copy-paste", "author": "anuraaga", "createdAt": "2020-03-29T09:02:28Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .flushValuesToContext(loggingContext)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured\n+   * field.\n+   *\n+   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void setValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) setValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    String prefix;\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+    }\n+\n+    /**\n+     * @see #prefix()\n+     * @since 5.11\n+     */\n+    public Builder prefix(String prefix) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      this.prefix = prefix;\n+      return this;\n+    }\n+\n+    /**\n+     * @see #redacted()\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder {\n+    final Builder delegate;\n+\n+    CorrelationBuilder(Builder delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    /** @see Builder#prefix(String) */\n+    public CorrelationBuilder prefix(String prefix) {\n+      delegate.prefix(prefix);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      delegate.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(delegate);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+  }\n+\n+  final String prefix;\n+  final String name;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    prefix = builder.prefix;\n+    name = builder.name;\n+    redacted = builder.redacted;\n+  }\n+\n+  /** Extracts the value for this field in the context or null if unavailable. */\n+  @Nullable public String getValue(TraceContext context) {", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDA2OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784069", "bodyText": "this drifted after we now use the field type internally.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODQwNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399768405", "bodyText": "Think you may have accidentally lost the strict checker", "author": "anuraaga", "createdAt": "2020-03-29T09:05:55Z", "path": "brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java", "diffHunk": "@@ -37,12 +36,12 @@\n  * the core concepts.\n  */\n public class OpenTracingAdapterTest {\n+  static final ExtraField EXTRA_FIELD = ExtraField.newBuilder(\"user-id\").build();\n+\n   List<zipkin2.Span> spans = new ArrayList<>();\n   Tracing brave = Tracing.newBuilder()\n-    .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n-      .addScopeDecorator(StrictScopeDecorator.create())", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDY0Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784643", "bodyText": "not needed as not multi-threaded.. sorry I was cleaning up.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODY1MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399768651", "bodyText": "Since package name is log4j2 think this can just be Log4jContext", "author": "anuraaga", "createdAt": "2020-03-29T09:08:27Z", "path": "context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.context.log4j2;\n+\n+import brave.propagation.CorrelationField;\n+import org.apache.logging.log4j.ThreadContext;\n+\n+/** Integrates Log4j 2's {@link org.apache.logging.log4j.ThreadContext} */\n+public final class Log4j2Context extends CorrelationField.Context {", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDgyNw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784827", "bodyText": "I was going by the marketing on their website and kinda prefer the match on package name..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3NTI4Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400075287", "bodyText": "obviated as the type is hidden", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzOTg2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399839862", "bodyText": "remove 'the'", "author": "jorgheymans", "createdAt": "2020-03-29T19:10:30Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MDIyMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399840223", "bodyText": "'for a new request' rather ? otherwise the sentence looked incomplete at first sight - though grammatically correct", "author": "jorgheymans", "createdAt": "2020-03-29T19:13:40Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyMTYwMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399921602", "bodyText": "You can also update the value similarly, so that the new value will propagate downstream.\ncomment back if needed", "author": "codefromthecrypt", "createdAt": "2020-03-30T04:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MDIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTI5Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399841296", "bodyText": "this is already mentioned in brave's main README.md , any merit repeating the obvious here ? The security bits are very relevant but this applies to all public types in brave no ?", "author": "jorgheymans", "createdAt": "2020-03-29T19:23:45Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3MzkxNg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399873916", "bodyText": "The reason this is in the type doc is that this type specifically adds temptation to embed in your code, and readme doesn't inherit docs and visa versa (maybe asciidoc can help if someone can help with it)\nThat said, this doc was ignored on the type it was on last time, leading to this very change, heh!", "author": "codefromthecrypt", "createdAt": "2020-03-30T00:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTQyNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951425", "bodyText": "gotcha.", "author": "jorgheymans", "createdAt": "2020-03-30T06:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTQ4OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399841489", "bodyText": "if the paragraph about the infrastructure library gets removed consider merging this one and the it is generally not a good idea ... into one.", "author": "jorgheymans", "createdAt": "2020-03-29T19:25:19Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTk1OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399841959", "bodyText": "or drops if not a configured field what do you mean it's just a no-op call like ignored ? ignored if the key does not reference a configured field perhaps", "author": "jorgheymans", "createdAt": "2020-03-29T19:29:20Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3NDEwMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399874101", "bodyText": "thx", "author": "codefromthecrypt", "createdAt": "2020-03-30T00:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MjA0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399842041", "bodyText": "same comment as above", "author": "jorgheymans", "createdAt": "2020-03-29T19:29:54Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MjQ0NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399842444", "bodyText": "same drops comment as above", "author": "jorgheymans", "createdAt": "2020-03-29T19:33:18Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured\n+   * field.\n+   *\n+   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void setValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) setValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    String prefix;\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+    }\n+\n+    /**\n+     * @see #prefix()\n+     * @since 5.11\n+     */\n+    public Builder prefix(String prefix) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      this.prefix = prefix;\n+      return this;\n+    }\n+\n+    /**\n+     * @see #redacted()\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder {\n+    final Builder delegate;\n+\n+    CorrelationBuilder(Builder delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    /** @see Builder#prefix(String) */\n+    public CorrelationBuilder prefix(String prefix) {\n+      delegate.prefix(prefix);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      delegate.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(delegate);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+  }\n+\n+  final String prefix;\n+  final String name;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    prefix = builder.prefix;\n+    name = builder.name;\n+    redacted = builder.redacted;\n+  }\n+\n+  /** Extracts the value for this field in the context or null if unavailable. */\n+  @Nullable public String getValue(TraceContext context) {\n+    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /** Sets the value of the this field, or drops if not configured. */", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MjU4OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399842589", "bodyText": "here ignores is being used, wording is more clear to me", "author": "jorgheymans", "createdAt": "2020-03-29T19:34:21Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured\n+   * field.\n+   *\n+   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void setValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) setValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    String prefix;\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+    }\n+\n+    /**\n+     * @see #prefix()\n+     * @since 5.11\n+     */\n+    public Builder prefix(String prefix) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      this.prefix = prefix;\n+      return this;\n+    }\n+\n+    /**\n+     * @see #redacted()\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder {\n+    final Builder delegate;\n+\n+    CorrelationBuilder(Builder delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    /** @see Builder#prefix(String) */\n+    public CorrelationBuilder prefix(String prefix) {\n+      delegate.prefix(prefix);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      delegate.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(delegate);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+  }\n+\n+  final String prefix;\n+  final String name;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    prefix = builder.prefix;\n+    name = builder.name;\n+    redacted = builder.redacted;\n+  }\n+\n+  /** Extracts the value for this field in the context or null if unavailable. */\n+  @Nullable public String getValue(TraceContext context) {\n+    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /** Sets the value of the this field, or drops if not configured. */\n+  public void setValue(TraceContext context, String value) {\n+    PropagationFields.put(context, name, value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of this field in the implicit trace context or null if not available.\n+   *\n+   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n+   */\n+  @Nullable public String getValue() {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context) : null;\n+  }\n+\n+  /**\n+   * Sets the value of this field in the implicit trace context or ignores when not available.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb169a201cfab20323b5b8b44db51ce00007e323", "url": "https://github.com/openzipkin/brave/commit/bb169a201cfab20323b5b8b44db51ce00007e323", "message": "Exposes CorrelationField and ExtraField Apis\n\nThis completes the most common requests around correlation fields by\ngeneralizing code in support for correlation fields, both synchronizing\nto logging context and also propagation (extra fields).\n\nNotably, this allows you to not only define constants for the fields you\nwant, but also decide if they are permissible for correlation.\n\nEx.\n\n```java\n // configure the field, permitting it to be used in correlation contexts\n static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n\n // Allow logging patterns like %X{traceId} %X{bp}\n loggingContext = new Log4J2Context();\n\n decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n                                           .addField(BUSINESS_PROCESS).build();\n\n tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n                                                        .addField(BUSINESS_PROCESS)\n                                                        .build())\n               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n                                                                  .addScopeDecorator(decorator)\n                                                                  .build())\n\n // Assume runtime code looks like this\n @SendTo(SourceChannels.OUTPUT)\n public void timerMessageSource() {\n   BUSINESS_PROCESS.setValue(\"accounting\");\n   // The logging expression %{bp} will show \"accounting\" in businessCode()\n   businessCode();\n }\n```", "committedDate": "2020-03-30T04:26:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNTExNg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399935116", "bodyText": "Makes sense", "author": "anuraaga", "createdAt": "2020-03-30T05:29:38Z", "path": "brave/src/main/java/brave/internal/CorrelationContext.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal;\n+\n+import brave.propagation.CorrelationFieldScopeDecorator;\n+\n+/**\n+ * Dispatches methods to synchronize fields with a context such as SLF4J MDC.\n+ *\n+ * <p><em>This is internal:</em> All subtypes of {@link CorrelationFieldScopeDecorator} are sealed\n+ * to this repository until we better understand implications of making this a public type.\n+ */\n+// NOTE: revert to abstract class with protected signatures if this is ever promoted to the\n+// brave.propagation package.\n+public interface CorrelationContext {\n+  /**\n+   * Returns the correlation property of the specified name iff it is a string, or null otherwise.\n+   */\n+  @Nullable String get(String name);\n+\n+  /** Replaces the correlation property of the specified name with a non-null value. */\n+  void put(String name, @Nullable String value);\n+\n+  /** Removes the correlation property of the specified name. */\n+  void remove(String name);\n+\n+  // The below will be sorted into RATIONALE.md once stable\n+  //\n+  // NOTES: This design is based on cherry-picking methods available in underlying log contexts, but\n+  // avoiding operations that accept Map as this implies overhead to construct and iterate over.\n+  //\n+  // Here is an example source from Log4J 2:\n+  //\n+  // public interface ThreadContextMap2 extends ThreadContextMap {\n+  //   void putAll(Map<String, String> var1);\n+  //\n+  //   StringMap getReadOnlyContextData();\n+  // }\n+  //\n+  // public interface ThreadContextMap {\n+  //   void clear();\n+  //\n+  //   boolean containsKey(String var1);\n+  //\n+  //   String get(String var1);\n+  //\n+  //   Map<String, String> getCopy();\n+  //\n+  //   Map<String, String> getImmutableMapOrNull();\n+  //\n+  //   boolean isEmpty();\n+  //\n+  //   void put(String var1, String var2);\n+  //\n+  //   void remove(String var1);\n+  // }\n+  //\n+  // ## On guarding with previous value\n+  //\n+  // While the current design is optimized for log contexts (or those similar such as JFR), you can\n+  // reasonably think of this like generic contexts such as gRPC and Armeria\n+  // https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L88\n+  // https://github.com/grpc/grpc-java/blob/master/context/src/main/java/io/grpc/ThreadLocalContextStorage.java\n+  //\n+  // They have some design facets to help with overlapping scopes, notably comparing the current\n+  // value vs the one written prior to reverting a value. Since this feature was designed for\n+  // contexts which don't have these operators, achieving this would require reading back from the\n+  // logging context manually. This has two problems, one is performance impact and the other is\n+  // that the value may have been updated out-of-band. Unlike gRPC context, logging contexts are\n+  // plain string keys, and are easy to clobber by users or other code. It is therefore hard to tell\n+  // if inconsistency is due to things under your control or not (ex bad instrumentation vs 3rd\n+  // party code).", "originalCommit": "aaee287518c76adf4db49c8879695c1754441b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNTk1Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399935957", "bodyText": "Maybe could describe more what invalidation actually means - I guess it's losing any possible performance benefit.", "author": "anuraaga", "createdAt": "2020-03-30T05:32:55Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * A field which are applied in a correlation context such as MDC via {@link\n+ * CorrelationFieldScopeDecorator}.\n+ *\n+ * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n+ * decoration}. This means values set do not flush immediately to the underlying correlation context\n+ * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n+ * overhead. Use the type {@link Flushable} to allow immediate updates.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n+ * {@link #name()} comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /**\n+   * Returns the most recent value of the field named {@link #name()} in the context or null if\n+   * unavailable.\n+   */\n+  @Nullable String getValue(TraceContext context);\n+\n+  /**\n+   * Marks a field such that updates immediately flush to the correlation context, when configured\n+   * and their corresponding trace context is current. This has a significant performance impact as\n+   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.", "originalCommit": "aaee287518c76adf4db49c8879695c1754441b1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDE5NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400070194", "bodyText": "I rewrote as this:\n     * Call this to immediately flush a value update to the correlation context as opposed waiting\n     * for the next scope decoration. This has a significant performance impact as it requires even\n     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n\nmaybeScope returns no-op when applying the context results in the same data. maybeScope when not interfered with prevents another layer (ex several arrays). If we don't know if a field will be flushed or not, we need to allocate all of that even if no change ever takes place. This could happen thousands of times.", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNzUzNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399937535", "bodyText": "Maybe it's fun to put logger.info('Encoding the span, hope it works') // Log message will have ... in the context!", "author": "anuraaga", "createdAt": "2020-03-30T05:38:49Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.CorrelationContext;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging through decoration of a scope.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(cloudRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(decorator)\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!", "originalCommit": "aaee287518c76adf4db49c8879695c1754441b1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDM1NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400070354", "bodyText": "good idea", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNzUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzOTY5MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399939691", "bodyText": "Would it be more consistent for this to be update and others maybeUpdate?", "author": "anuraaga", "createdAt": "2020-03-30T05:46:28Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.CorrelationContext;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging through decoration of a scope.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(cloudRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(decorator)\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n+ *   return encoder.encode();\n+ * } catch (RuntimeException | Error e) {\n+ *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n+ *   throw e;\n+ * } finally {\n+ *   span.finish();\n+ * }\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationContext\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  // do not define newBuilder or create() here as it will mask subtypes\n+  public static abstract class Builder {\n+    final CorrelationContext context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,\n+      CorrelationFields.PARENT_ID,\n+      CorrelationFields.SPAN_ID,\n+      CorrelationFields.SAMPLED\n+    ));\n+\n+    /** Internal constructor used by subtypes. */\n+    protected Builder(CorrelationContext context) {\n+      if (context == null) throw new NullPointerException(\"context == null\");\n+      this.context = context;\n+    }\n+\n+    /**\n+     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n+     * ones you need}.\n+     *\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\n+     * performance, only include the fields you use in your correlation expressions (such as log\n+     * formats).\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearFields() {\n+      this.fields.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addField(CorrelationField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n+      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** @throws IllegalArgumentException if no correlation fields were added. */\n+    public final CorrelationFieldScopeDecorator build() {\n+      int fieldCount = fields.size();\n+      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n+      if (fieldCount == 1) {\n+        return new Single(context, fields.iterator().next());\n+      }\n+      return new Multiple(context, fields);\n+    }\n+  }\n+\n+  final CorrelationContext context;\n+\n+  CorrelationFieldScopeDecorator(CorrelationContext context) {\n+    this.context = context;\n+  }\n+\n+  // Users generally expect data to be \"cleaned up\" when a scope completes, even if it was written\n+  // mid-scope. Ex. https://github.com/spring-cloud/spring-cloud-sleuth/issues/1416\n+  //\n+  // This means we cannot return a no-op scope based on if we detect no change when comparing\n+  // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n+  // update changed the value mid-scope, it will reverted.\n+  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MTgzMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400071832", "bodyText": "already changed to update :)", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzOTY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0Mzg4NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399943884", "bodyText": "Probably over optimization, but what do you think about defaulting to only trace ID + span ID (think the javadoc on the fields indicate those are the two common ones), and having a Double for premature optimization of this use case? :)", "author": "anuraaga", "createdAt": "2020-03-30T06:00:41Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.CorrelationContext;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging through decoration of a scope.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(cloudRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(decorator)\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n+ *   return encoder.encode();\n+ * } catch (RuntimeException | Error e) {\n+ *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n+ *   throw e;\n+ * } finally {\n+ *   span.finish();\n+ * }\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationContext\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  // do not define newBuilder or create() here as it will mask subtypes\n+  public static abstract class Builder {\n+    final CorrelationContext context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MjQ0OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400072448", "bodyText": "I suppose we can for the builder variant. we still need all fields for the backported factory method. Sounds good!", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0Mzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NTk5MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399945990", "bodyText": "lcName? Otherwise, I think lcName.equals(o.name()) below doesn't work", "author": "anuraaga", "createdAt": "2020-03-30T06:07:37Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import java.util.Locale;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n+   *\n+   * @see TraceContext#spanIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.spanIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n+   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n+   * typically reported to Zipkin.\n+   *\n+   * @see TraceContext#sampled()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SAMPLED = new BaseCorrelationField(\"sampled\") {\n+    @Override public String getValue(TraceContext context) {\n+      Boolean sampled = context.sampled();\n+      return sampled != null ? sampled.toString() : null;\n+    }\n+  };\n+\n+  /**\n+   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n+   *\n+   * <p>Ex.\n+   * <pre>{@code\n+   * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+   * }</pre>\n+   *\n+   * @since 5.11\n+   */\n+  public static CorrelationField constant(String name, @Nullable String value) {\n+    return new ConstantCorrelationField(name, value);\n+  }\n+\n+  static final class ConstantCorrelationField extends BaseCorrelationField {\n+    final String value;\n+\n+    ConstantCorrelationField(String name, String value) {\n+      super(name);\n+      this.value = value;\n+    }\n+\n+    @Override public String getValue(TraceContext context) {\n+      return value;\n+    }\n+  }\n+\n+  static abstract class BaseCorrelationField implements CorrelationField {\n+    final String name, lcName;\n+\n+    BaseCorrelationField(String name) {\n+      this.name = validateName(name);\n+      this.lcName = name.toLowerCase(Locale.ROOT);\n+    }\n+\n+    @Override public String name() {\n+      return name;", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3NDMzMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400074332", "bodyText": "no this is case sensitive.. it is only the extra keys (not name) that are downcase.\nexisting correlation patterns use 'traceId' not 'traceid' for example.\nI put a TODO to seal this type.", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NjgyOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399946829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <p>For example, if you have a need to know a specific request's country code, you can\n          \n          \n            \n             * <p>For example, if you have a need to know a specific request's country code in a downstream service, you can", "author": "anuraaga", "createdAt": "2020-03-30T06:10:09Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzA2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399947062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n          \n          \n            \n             * // If configured and set, you can retrieve it later. All of the below result in the same tag in any service handling the trace:", "author": "anuraaga", "createdAt": "2020-03-30T06:10:51Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzM2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399947362", "bodyText": "For this example, could consider userinfo instead of baggage", "author": "anuraaga", "createdAt": "2020-03-30T06:11:45Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTI3Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399969273", "bodyText": "Realized that baggage + country code is fun too", "author": "anuraaga", "createdAt": "2020-03-30T07:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3ODc2Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400078766", "bodyText": "these are actual header names prefixes. ex sleuth adds the baggage- prefix. you'll find a lot where we intentionally use real examples so that things aren't so abstract. This isn't just test json in zipkin, rather all the projects.\nIs there a prefix you've mapped that would be better I tried to find a header prefixed userinfo and couldn't..", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0OTE1Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399949152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param name will be currently lower-cased for remote propagation\n          \n          \n            \n               * @param name will be lower-cased for remote propagation", "author": "anuraaga", "createdAt": "2020-03-30T06:16:59Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0OTIyMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399949222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param name will be currently lower-cased for remote propagation\n          \n          \n            \n               * @param name will be lower-cased for remote propagation", "author": "anuraaga", "createdAt": "2020-03-30T06:17:12Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDYyNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399950625", "bodyText": "Might be good to add a note that redacted fields will be correlated, so it's probably not desired to correlate a redacted field with a logging context.", "author": "anuraaga", "createdAt": "2020-03-30T06:21:08Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyOTM4MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400129380", "bodyText": "actually redacted was made exactly for logging context (exists now and is in use in sleuth)\nthe docs say \"Sets this field to be only visible in process, redacted from remote propagation.\"", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDgyOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399950829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * the correlation context as opposed waiting for the next scope decoration.\n          \n          \n            \n                 * the correlation context as opposed to waiting for the next scope decoration.", "author": "anuraaga", "createdAt": "2020-03-30T06:21:38Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTAwOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** @see Builder#redacted() */\n          \n          \n            \n                /** @see Builder#clearKeys() */", "author": "anuraaga", "createdAt": "2020-03-30T06:22:14Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     *\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     */\n+    public CorrelationBuilder flushOnUpdate() {\n+      this.flushOnUpdate = true;\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTA0NQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951045", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** @see Builder#redacted() */\n          \n          \n            \n                /** @see Builder#addKey() */", "author": "anuraaga", "createdAt": "2020-03-30T06:22:21Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     *\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     */\n+    public CorrelationBuilder flushOnUpdate() {\n+      this.flushOnUpdate = true;\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder clearKeys() {\n+      super.clearKeys();\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTgwMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951803", "bodyText": "Not sure what ignores if not configured. is referring to", "author": "anuraaga", "createdAt": "2020-03-30T06:24:41Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     *\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     */\n+    public CorrelationBuilder flushOnUpdate() {\n+      this.flushOnUpdate = true;\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder clearKeys() {\n+      super.clearKeys();\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder addKey(String key) {\n+      super.addKey(key);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      super.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(this);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public String name() {\n+      return name;\n+    }\n+\n+    @Override public CorrelationBuilder toBuilder() {\n+      return new Builder(this).withCorrelation();\n+    }\n+  }\n+\n+  final String name, lcName;\n+  final String[] keys; // for faster iteration\n+  final List<String> keysList;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    name = builder.name;\n+    lcName = name.toLowerCase(Locale.ROOT);\n+    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n+    keys = builder.keys.toArray(new String[0]);\n+    keysList = asList(keys);\n+    redacted = builder.redacted;\n+  }\n+\n+  /**\n+   * Returns the most recent value for this field in the context or null if unavailable.\n+   *\n+   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n+   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n+   */\n+  @Nullable public String getValue(TraceContext context) {\n+    return PropagationFields.get(context, this, ExtraFields.class);\n+  }\n+\n+  /** Updates the value of the this field, or ignores if not configured. */", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMDYxOA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400130618", "bodyText": "ExtraFieldPropagation is the component that configures extra fields and that's the first line of the type. comment later if you have another thing we have to do on this.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTE0Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399955147", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!remainingNames.remove(name)) builder.clearKeys();\n          \n          \n            \n                    // remainingNames contains the names that need be propagated as is, so only remove\n          \n          \n            \n                    // the default propagated keys if this name is not one of those.\n          \n          \n            \n                    if (!remainingNames.remove(name)) builder.clearKeys();\n          \n      \n    \n    \n  \n\nTried to see if a variable name change could clear that up but think this comment is better. It took me many rereads to finally understand it", "author": "anuraaga", "createdAt": "2020-03-30T06:34:00Z", "path": "brave/src/main/java/brave/propagation/ExtraFieldPropagation.java", "diffHunk": "@@ -15,246 +15,197 @@\n \n import brave.Tracing;\n import brave.internal.Nullable;\n-import brave.internal.PredefinedPropagationFields;\n-import brave.internal.PropagationFields;\n-import brave.internal.PropagationFieldsFactory;\n import brave.propagation.TraceContext.Extractor;\n import brave.propagation.TraceContext.Injector;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.BitSet;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n \n+import static brave.propagation.CorrelationFields.validateName;\n+\n /**\n- * Allows you to propagate predefined request-scoped fields, usually but not always HTTP headers.\n+ * This implements {@linkplain ExtraField extra field} in-process and remote propagation.\n  *\n- * <p>For example, if you are in a Cloud Foundry environment, you might want to pass the request\n- * ID:\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n  * <pre>{@code\n- * // when you initialize the builder, define the extra field you want to propagate\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-vcap-request-id\")\n- * );\n- *\n- * // later, you can tag that request ID or use it in log correlation\n- * requestId = ExtraFieldPropagation.get(\"x-vcap-request-id\");\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * ExtraFieldPropagation.get(\"x-country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n  *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * <h3>Passing through alternate trace contexts</h3>\n- * <p>You may also need to propagate an second trace context transparently. For example, when in\n- * an Amazon Web Services environment, but not reporting data to X-Ray. To ensure X-Ray can co-exist\n- * correctly, pass-through its tracing header like so.\n- *\n- * <pre>{@code\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-amzn-trace-id\")\n- * );\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * // Setup your tracing instance with allowed fields\n+ * // When you initialize the builder, add the extra field you want to propagate\n  * tracingBuilder.propagationFactory(\n  *   ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                        .addField(\"x-vcap-request-id\")\n- *                        .addPrefixedFields(\"baggage-\", Arrays.asList(\"country-code\", \"user-id\"))\n+ *                        .addField(countryCode)\n  *                        .build()\n  * );\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraFieldPropagation.set(\"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(\"country-code\");\n- *\n- * // Or, if you have a reference to a trace context, use it explicitly\n- * ExtraFieldPropagation.set(span.context(), \"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(span.context(), \"country-code\");\n- * }</pre>\n  */\n public class ExtraFieldPropagation<K> implements Propagation<K> {\n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, String... fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated public static Factory newFactory(Propagation.Factory delegate, String... names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    return newFactory(delegate, Arrays.asList(fieldNames));\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    return newFactory(delegate, Arrays.asList(names));\n   }\n \n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, Collection<String> fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated\n+  public static Factory newFactory(Propagation.Factory delegate, Collection<String> names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    String[] validated = ensureLowerCaseFieldNames(new LinkedHashSet<>(fieldNames));\n-    return new RealFactory(delegate, validated, validated, new BitSet());\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    if (names.isEmpty()) throw new IllegalArgumentException(\"no field names\");\n+    FactoryBuilder builder = new FactoryBuilder(delegate);\n+    for (String name : names) builder.addField(ExtraField.create(name));\n+    return builder.build();\n   }\n \n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n   public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n     return new FactoryBuilder(delegate);\n   }\n \n   public static final class FactoryBuilder {\n     final Propagation.Factory delegate;\n-    final Set<String> fieldNames = new LinkedHashSet<>();\n-    final Set<String> redactedFieldNames = new LinkedHashSet<>();\n-    final Map<String, String[]> prefixedNames = new LinkedHashMap<>();\n+    final Set<String> names = new LinkedHashSet<>();\n+    final Set<String> redactedNames = new LinkedHashSet<>();\n+    final Map<String, Set<String>> nameToPrefixes = new LinkedHashMap<>();\n+\n+    final Set<ExtraField> fields = new LinkedHashSet<>();\n \n     FactoryBuilder(Propagation.Factory delegate) {\n       if (delegate == null) throw new NullPointerException(\"delegate == null\");\n       this.delegate = delegate;\n     }\n \n-    /** Same as {@link #addField} except that this field is redacted from downstream propagation. */\n-    public FactoryBuilder addRedactedField(String fieldName) {\n-      fieldName = validateFieldName(fieldName);\n-      fieldNames.add(fieldName);\n-      redactedFieldNames.add(fieldName);\n-      return this;\n-    }\n-\n     /**\n-     * Adds a field that is referenced the same in-process as it is on the wire. For example, the\n-     * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+     * Adds an {@linkplain ExtraField extra field} for remote propagation.\n      *\n-     * <p>Note: {@code fieldName} will be implicitly lower-cased.\n+     * @since 5.11\n      */\n-    public FactoryBuilder addField(String fieldName) {\n-      fieldNames.add(validateFieldName(fieldName));\n+    public FactoryBuilder addField(ExtraField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      fields.add(field);\n       return this;\n     }\n \n-    /**\n-     * Adds a prefix when fields are extracted or injected from headers. For example, if the prefix\n-     * is \"baggage-\", the field \"country-code\" would end up as \"baggage-country-code\" on the wire.\n-     *\n-     * <p>Note: any {@code fieldNames} will be implicitly lower-cased.\n-     */\n-    public FactoryBuilder addPrefixedFields(String prefix, Collection<String> fieldNames) {\n-      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n-      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n-      if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-      prefixedNames.put(prefix, ensureLowerCaseFieldNames(new LinkedHashSet<>(fieldNames)));\n+    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n+    public FactoryBuilder addRedactedField(String name) {\n+      name = validateName(name).toLowerCase(Locale.ROOT);\n+      names.add(name);\n+      redactedNames.add(name);\n       return this;\n     }\n \n-    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n-    public Factory build() {\n-      BitSet redacted = new BitSet();\n-      List<String> fields = new ArrayList<>(), keys = new ArrayList<>();\n-      List<Integer> keyToFieldList = new ArrayList<>();\n+    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n+    public FactoryBuilder addField(String name) {\n+      names.add(validateName(name).toLowerCase(Locale.ROOT));\n+      return this;\n+    }\n \n-      // First pass: add any field names that are used as propagation keys directly\n-      int i = 0;\n-      for (String fieldName : fieldNames) {\n-        if (redactedFieldNames.contains(fieldName)) redacted.set(i); // flag to redact on inject\n-        fields.add(fieldName);\n-        keys.add(fieldName);\n-        keyToFieldList.add(i++);\n+    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n+    public FactoryBuilder addPrefixedFields(String prefix, Collection<String> names) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      if (names == null) throw new NullPointerException(\"names == null\");\n+      for (String name : names) {\n+        name = validateName(name).toLowerCase(Locale.ROOT);\n+        Set<String> prefixes = nameToPrefixes.get(name);\n+        if (prefixes == null) nameToPrefixes.put(name, prefixes = new LinkedHashSet<>());\n+        prefixes.add(prefix);\n       }\n+      return this;\n+    }\n \n-      // Second pass: add prefixed fields, noting a prefixed field could be a dupe of a non-prefixed\n-      for (Map.Entry<String, String[]> entry : prefixedNames.entrySet()) {\n-        String nextPrefix = entry.getKey();\n-        String[] nextFieldNames = entry.getValue();\n-        for (i = 0; i < nextFieldNames.length; i++) {\n-          String nextFieldName = nextFieldNames[i];\n-          int index = fields.indexOf(nextFieldName);\n-          if (index == -1) {\n-            index = fields.size();\n-            fields.add(nextFieldName);\n-          }\n-          keys.add(nextPrefix + nextFieldName);\n-          keyToFieldList.add(index);\n+    Set<ExtraField> convertDeprecated() {\n+      Set<String> remainingNames = new LinkedHashSet<>(names);\n+      Set<ExtraField> result = new LinkedHashSet<>();\n+      for (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n+        String name = entry.getKey();\n+        ExtraField.Builder builder = ExtraField.newBuilder(name);\n+        if (redactedNames.contains(name)) builder.redacted();\n+        if (!remainingNames.remove(name)) builder.clearKeys();", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzM1MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399957351", "bodyText": "Alternatively, this pattern might be clearer\nMap<String, ExtraField.Builder> converted = new LinkedHashMap<>();\nfor (String name : names) {\n  ExtraField.Builder builder = ExtraField.newBuilder(name);\n  if (redactedNames.contains(name)) builder.redacted();\n  converted.add(builder);\n}\n\nfor (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n  ExtraField.Builder builder = conveted.get(entry.key());\n  if (builder == null) {\n    // Only propagated with prefixes, not original name.\n    builder = ExtraField.newBuilder(name).clearKeys();\n    converted.put(name, builder);\n  }\n  for (String prefix : entry.getValue()) {\n    builder.addKey(prefix + name);\n  }\n}\n\nSet<ExtraField> result = new LinkedHashSet<>();\nfor (ExtraField.Builder builder : converted.valueSet()) {\n  result.add(builder.build());\n}\nreturn result;", "author": "anuraaga", "createdAt": "2020-03-30T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMjI5Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400132292", "bodyText": "I'm overloaded so I'll get back to this..", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTUwNw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399955507", "bodyText": "Wonder tradeoff of propagatedName vs key in clarity / verbosity", "author": "anuraaga", "createdAt": "2020-03-30T06:34:59Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMjA2Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400132067", "bodyText": "key is already used in Propagation component, that's what these names are literally for. I added @see ExtraFieldPropagation#keys() to the thing.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzU2Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399957566", "bodyText": "This new API is so much nicer!", "author": "anuraaga", "createdAt": "2020-03-30T06:40:29Z", "path": "brave/src/main/java/brave/propagation/ExtraFieldPropagation.java", "diffHunk": "@@ -15,246 +15,197 @@\n \n import brave.Tracing;\n import brave.internal.Nullable;\n-import brave.internal.PredefinedPropagationFields;\n-import brave.internal.PropagationFields;\n-import brave.internal.PropagationFieldsFactory;\n import brave.propagation.TraceContext.Extractor;\n import brave.propagation.TraceContext.Injector;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.BitSet;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n \n+import static brave.propagation.CorrelationFields.validateName;\n+\n /**\n- * Allows you to propagate predefined request-scoped fields, usually but not always HTTP headers.\n+ * This implements {@linkplain ExtraField extra field} in-process and remote propagation.\n  *\n- * <p>For example, if you are in a Cloud Foundry environment, you might want to pass the request\n- * ID:\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n  * <pre>{@code\n- * // when you initialize the builder, define the extra field you want to propagate\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-vcap-request-id\")\n- * );\n- *\n- * // later, you can tag that request ID or use it in log correlation\n- * requestId = ExtraFieldPropagation.get(\"x-vcap-request-id\");\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * ExtraFieldPropagation.get(\"x-country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n  *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * <h3>Passing through alternate trace contexts</h3>\n- * <p>You may also need to propagate an second trace context transparently. For example, when in\n- * an Amazon Web Services environment, but not reporting data to X-Ray. To ensure X-Ray can co-exist\n- * correctly, pass-through its tracing header like so.\n- *\n- * <pre>{@code\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-amzn-trace-id\")\n- * );\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * // Setup your tracing instance with allowed fields\n+ * // When you initialize the builder, add the extra field you want to propagate\n  * tracingBuilder.propagationFactory(\n  *   ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                        .addField(\"x-vcap-request-id\")\n- *                        .addPrefixedFields(\"baggage-\", Arrays.asList(\"country-code\", \"user-id\"))\n+ *                        .addField(countryCode)\n  *                        .build()\n  * );\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraFieldPropagation.set(\"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(\"country-code\");\n- *\n- * // Or, if you have a reference to a trace context, use it explicitly\n- * ExtraFieldPropagation.set(span.context(), \"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(span.context(), \"country-code\");\n- * }</pre>\n  */\n public class ExtraFieldPropagation<K> implements Propagation<K> {\n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, String... fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated public static Factory newFactory(Propagation.Factory delegate, String... names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    return newFactory(delegate, Arrays.asList(fieldNames));\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    return newFactory(delegate, Arrays.asList(names));\n   }\n \n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, Collection<String> fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated\n+  public static Factory newFactory(Propagation.Factory delegate, Collection<String> names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    String[] validated = ensureLowerCaseFieldNames(new LinkedHashSet<>(fieldNames));\n-    return new RealFactory(delegate, validated, validated, new BitSet());\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    if (names.isEmpty()) throw new IllegalArgumentException(\"no field names\");\n+    FactoryBuilder builder = new FactoryBuilder(delegate);\n+    for (String name : names) builder.addField(ExtraField.create(name));\n+    return builder.build();\n   }\n \n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n   public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n     return new FactoryBuilder(delegate);\n   }\n \n   public static final class FactoryBuilder {\n     final Propagation.Factory delegate;\n-    final Set<String> fieldNames = new LinkedHashSet<>();\n-    final Set<String> redactedFieldNames = new LinkedHashSet<>();\n-    final Map<String, String[]> prefixedNames = new LinkedHashMap<>();\n+    final Set<String> names = new LinkedHashSet<>();\n+    final Set<String> redactedNames = new LinkedHashSet<>();\n+    final Map<String, Set<String>> nameToPrefixes = new LinkedHashMap<>();\n+\n+    final Set<ExtraField> fields = new LinkedHashSet<>();\n \n     FactoryBuilder(Propagation.Factory delegate) {\n       if (delegate == null) throw new NullPointerException(\"delegate == null\");\n       this.delegate = delegate;\n     }\n \n-    /** Same as {@link #addField} except that this field is redacted from downstream propagation. */\n-    public FactoryBuilder addRedactedField(String fieldName) {\n-      fieldName = validateFieldName(fieldName);\n-      fieldNames.add(fieldName);\n-      redactedFieldNames.add(fieldName);\n-      return this;\n-    }\n-\n     /**\n-     * Adds a field that is referenced the same in-process as it is on the wire. For example, the\n-     * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+     * Adds an {@linkplain ExtraField extra field} for remote propagation.\n      *\n-     * <p>Note: {@code fieldName} will be implicitly lower-cased.\n+     * @since 5.11\n      */\n-    public FactoryBuilder addField(String fieldName) {\n-      fieldNames.add(validateFieldName(fieldName));\n+    public FactoryBuilder addField(ExtraField field) {", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzEwMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399963101", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                MapFieldConsumer result = new MapFieldConsumer();\n          \n          \n            \n                forEach(result);\n          \n          \n            \n                return result;\n          \n          \n            \n                LinkedHashMap<String, String> result = new LinkedHashMap<>();\n          \n          \n            \n                for (int i = 0, length = elements.length; i < length; i++) {\n          \n          \n            \n                  result.put(fields[i].name, elements[i]);\n          \n          \n            \n                }\n          \n          \n            \n                return Collections.unmodifiableMap(result);\n          \n      \n    \n    \n  \n\nLooks like same amount of code as the mapfield consumer, but avoids introducing a custom type into user stacktraces. unmodifiableMap is optional but I guess it's good for both return branches to return immutable instead of just one.", "author": "anuraaga", "createdAt": "2020-03-30T06:54:38Z", "path": "brave/src/main/java/brave/propagation/ExtraFields.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.PropagationFields;\n+import brave.internal.PropagationFieldsFactory;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Copy-on-write keeps propagation changes in a child context from affecting its parent */\n+final class ExtraFields extends PropagationFields<ExtraField, String> {\n+  static final class Factory extends PropagationFieldsFactory<ExtraField, String, ExtraFields> {\n+    final ExtraField[] fields;\n+\n+    Factory(ExtraField... fields) {\n+      this.fields = fields;\n+    }\n+\n+    @Override public Class<ExtraFields> type() {\n+      return ExtraFields.class;\n+    }\n+\n+    @Override public ExtraFields create() {\n+      return new ExtraFields(fields);\n+    }\n+\n+    @Override public ExtraFields create(ExtraFields parent) {\n+      return new ExtraFields(parent, fields);\n+    }\n+\n+    @Override protected TraceContext contextWithExtra(TraceContext context, List<Object> extra) {\n+      return context.withExtra(extra); // more efficient\n+    }\n+  }\n+\n+  final ExtraField[] fields;\n+  volatile String[] values; // guarded by this, copy on write\n+\n+  ExtraFields(ExtraField... fields) {\n+    this.fields = fields;\n+  }\n+\n+  ExtraFields(ExtraFields parent, ExtraField... fields) {\n+    this(fields);\n+    checkSameFields(parent);\n+    this.values = parent.values;\n+  }\n+\n+  @Override protected String get(ExtraField field) {\n+    int index = indexOf(field);\n+    return index != -1 ? get(index) : null;\n+  }\n+\n+  String get(int index) {\n+    if (index >= fields.length) return null;\n+\n+    String[] elements = values;\n+    return elements != null ? elements[index] : null;\n+  }\n+\n+  @Override protected void forEach(FieldConsumer<ExtraField, String> fieldConsumer) {\n+    String[] elements = values;\n+    if (elements == null) return;\n+\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      String value = elements[i];\n+      if (value == null) continue;\n+      fieldConsumer.accept(fields[i], value);\n+    }\n+  }\n+\n+  @Override protected final void put(ExtraField field, String value) {\n+    int index = indexOf(field);\n+    if (index == -1) return;\n+    put(index, value);\n+  }\n+\n+  @Override protected boolean isEmpty() {\n+    String[] elements = values;\n+    if (elements == null) return true;\n+    for (String value : elements) {\n+      if (value != null) return false;\n+    }\n+    return true;\n+  }\n+\n+  protected final void put(int index, String value) {\n+    if (index >= fields.length) return;\n+\n+    synchronized (this) {\n+      doPut(index, value);\n+    }\n+  }\n+\n+  void doPut(int index, String value) {\n+    String[] elements = values;\n+    if (elements == null) {\n+      elements = new String[fields.length];\n+      elements[index] = value;\n+    } else if (value.equals(elements[index])) {\n+      return;\n+    } else { // this is the copy-on-write part\n+      elements = Arrays.copyOf(elements, elements.length);\n+      elements[index] = value;\n+    }\n+    values = elements;\n+  }\n+\n+  @Override protected final void putAllIfAbsent(PropagationFields parent) {\n+    if (!(parent instanceof ExtraFields)) return;\n+    ExtraFields predefinedParent = (ExtraFields) parent;\n+    checkSameFields(predefinedParent);\n+    String[] parentValues = predefinedParent.values;\n+    if (parentValues == null) return;\n+    for (int i = 0; i < parentValues.length; i++) {\n+      if (parentValues[i] != null && get(i) == null) { // extracted wins vs parent\n+        doPut(i, parentValues[i]);\n+      }\n+    }\n+  }\n+\n+  void checkSameFields(ExtraFields predefinedParent) {\n+    if (!Arrays.equals(fields, predefinedParent.fields)) {\n+      throw new IllegalStateException(\n+        String.format(\"Mixed name configuration unsupported: found %s, expected %s\",\n+          Arrays.toString(fields), Arrays.toString(predefinedParent.fields))\n+      );\n+    }\n+  }\n+\n+  @Override public final Map<String, String> toMap() {\n+    String[] elements = values;\n+    if (elements == null) return Collections.emptyMap();\n+\n+    MapFieldConsumer result = new MapFieldConsumer();\n+    forEach(result);\n+    return result;", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMjYxMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400132612", "bodyText": "saved also for tomorrow.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjA2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399966062", "bodyText": "Even only for unit tests, probably good to compare fields too or if a newly added test doesn't work because of that in the future it will be quite mysterious", "author": "anuraaga", "createdAt": "2020-03-30T07:01:31Z", "path": "brave/src/main/java/brave/propagation/ExtraFields.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.PropagationFields;\n+import brave.internal.PropagationFieldsFactory;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Copy-on-write keeps propagation changes in a child context from affecting its parent */\n+final class ExtraFields extends PropagationFields<ExtraField, String> {\n+  static final class Factory extends PropagationFieldsFactory<ExtraField, String, ExtraFields> {\n+    final ExtraField[] fields;\n+\n+    Factory(ExtraField... fields) {\n+      this.fields = fields;\n+    }\n+\n+    @Override public Class<ExtraFields> type() {\n+      return ExtraFields.class;\n+    }\n+\n+    @Override public ExtraFields create() {\n+      return new ExtraFields(fields);\n+    }\n+\n+    @Override public ExtraFields create(ExtraFields parent) {\n+      return new ExtraFields(parent, fields);\n+    }\n+\n+    @Override protected TraceContext contextWithExtra(TraceContext context, List<Object> extra) {\n+      return context.withExtra(extra); // more efficient\n+    }\n+  }\n+\n+  final ExtraField[] fields;\n+  volatile String[] values; // guarded by this, copy on write\n+\n+  ExtraFields(ExtraField... fields) {\n+    this.fields = fields;\n+  }\n+\n+  ExtraFields(ExtraFields parent, ExtraField... fields) {\n+    this(fields);\n+    checkSameFields(parent);\n+    this.values = parent.values;\n+  }\n+\n+  @Override protected String get(ExtraField field) {\n+    int index = indexOf(field);\n+    return index != -1 ? get(index) : null;\n+  }\n+\n+  String get(int index) {\n+    if (index >= fields.length) return null;\n+\n+    String[] elements = values;\n+    return elements != null ? elements[index] : null;\n+  }\n+\n+  @Override protected void forEach(FieldConsumer<ExtraField, String> fieldConsumer) {\n+    String[] elements = values;\n+    if (elements == null) return;\n+\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      String value = elements[i];\n+      if (value == null) continue;\n+      fieldConsumer.accept(fields[i], value);\n+    }\n+  }\n+\n+  @Override protected final void put(ExtraField field, String value) {\n+    int index = indexOf(field);\n+    if (index == -1) return;\n+    put(index, value);\n+  }\n+\n+  @Override protected boolean isEmpty() {\n+    String[] elements = values;\n+    if (elements == null) return true;\n+    for (String value : elements) {\n+      if (value != null) return false;\n+    }\n+    return true;\n+  }\n+\n+  protected final void put(int index, String value) {\n+    if (index >= fields.length) return;\n+\n+    synchronized (this) {\n+      doPut(index, value);\n+    }\n+  }\n+\n+  void doPut(int index, String value) {\n+    String[] elements = values;\n+    if (elements == null) {\n+      elements = new String[fields.length];\n+      elements[index] = value;\n+    } else if (value.equals(elements[index])) {\n+      return;\n+    } else { // this is the copy-on-write part\n+      elements = Arrays.copyOf(elements, elements.length);\n+      elements[index] = value;\n+    }\n+    values = elements;\n+  }\n+\n+  @Override protected final void putAllIfAbsent(PropagationFields parent) {\n+    if (!(parent instanceof ExtraFields)) return;\n+    ExtraFields predefinedParent = (ExtraFields) parent;\n+    checkSameFields(predefinedParent);\n+    String[] parentValues = predefinedParent.values;\n+    if (parentValues == null) return;\n+    for (int i = 0; i < parentValues.length; i++) {\n+      if (parentValues[i] != null && get(i) == null) { // extracted wins vs parent\n+        doPut(i, parentValues[i]);\n+      }\n+    }\n+  }\n+\n+  void checkSameFields(ExtraFields predefinedParent) {\n+    if (!Arrays.equals(fields, predefinedParent.fields)) {\n+      throw new IllegalStateException(\n+        String.format(\"Mixed name configuration unsupported: found %s, expected %s\",\n+          Arrays.toString(fields), Arrays.toString(predefinedParent.fields))\n+      );\n+    }\n+  }\n+\n+  @Override public final Map<String, String> toMap() {\n+    String[] elements = values;\n+    if (elements == null) return Collections.emptyMap();\n+\n+    MapFieldConsumer result = new MapFieldConsumer();\n+    forEach(result);\n+    return result;\n+  }\n+\n+  static final class MapFieldConsumer extends LinkedHashMap<String, String>\n+    implements FieldConsumer<ExtraField, String> {\n+    @Override public void accept(ExtraField field, String value) {\n+      put(field.name, value);\n+    }\n+  }\n+\n+  int indexOf(ExtraField name) {\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      if (fields[i].equals(name)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  @Override public int hashCode() { // for unit tests", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEwOTE4Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400109186", "bodyText": "went offline for a while as I really don't want to do this.. I'm rejigging the tests instead.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzQzOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400117439", "bodyText": "glad I didn't want to change the hashCode/equals.. there's a bug in the impl :)", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjA2Mg=="}], "type": "inlineReview"}, {"oid": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "url": "https://github.com/openzipkin/brave/commit/1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "message": "First pass of lazy scope", "committedDate": "2020-03-30T08:44:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400732913", "bodyText": "I think this is missing else values.remove(key). But maybe simpler to just remove both != null checks", "author": "anuraaga", "createdAt": "2020-03-31T08:29:23Z", "path": "brave/src/main/java/brave/internal/MapPropagationFields.java", "diffHunk": "@@ -59,18 +59,18 @@ protected MapPropagationFields(MapPropagationFields<K, V> parent) {\n     }\n   }\n \n-  @Override public final void put(K key, V value) {\n+  @Override public final void put(K key, @Nullable V value) {\n     synchronized (this) {\n       Map<K, V> values = this.values;\n       if (values == null) {\n         values = new LinkedHashMap<>();\n-        values.put(key, value);\n-      } else if (value.equals(values.get(key))) {\n+        if (value != null) values.put(key, value);\n+      } else if (equal(value, values.get(key))) {\n         return;\n       } else {\n         // this is the copy-on-write part\n         values = new LinkedHashMap<>(values);\n-        values.put(key, value);\n+        if (value != null) values.put(key, value);", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2Nzk4MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400767981", "bodyText": "we just newed up values so we don't need an else right?", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MTgwMA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400771800", "bodyText": "We newed by copying values. If value is null, don't we need to remove it from the copy?", "author": "anuraaga", "createdAt": "2020-03-31T09:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5NjM4Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400796387", "bodyText": "you were right! we were missing a test", "author": "codefromthecrypt", "createdAt": "2020-03-31T10:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400744228", "bodyText": "For this new class is it possible to return Propagation.Factory and make the implementation package private?", "author": "anuraaga", "createdAt": "2020-03-31T08:48:02Z", "path": "brave/src/main/java/brave/propagation/BaggagePropagation.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This implements in-process and remote {@linkplain BaggageField baggage} propagation.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n+ * <pre>{@code\n+ * // Configure your baggage field\n+ * COUNTRY_CODE = BaggageField.create(\"country-code\");\n+ *\n+ * // When you initialize the builder, add the baggage you want to propagate\n+ * tracingBuilder.propagationFactory(\n+ *   BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                     .addField(COUNTRY_CODE)\n+ *                     .build()\n+ * );\n+ *\n+ * // later, you can tag that country code\n+ * COUNTRY_CODE.tag(span);\n+ * }</pre>\n+ *\n+ * @since 5.11\n+ */\n+public class BaggagePropagation<K> implements Propagation<K> {\n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n+  public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n+    return new FactoryBuilder(delegate);\n+  }\n+\n+  public static final class FactoryBuilder {\n+    final Propagation.Factory delegate;\n+    final Set<BaggageField> fields = new LinkedHashSet<>();\n+\n+    FactoryBuilder(Propagation.Factory delegate) {\n+      if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+      this.delegate = delegate;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain BaggageField baggage field} for remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public FactoryBuilder addField(BaggageField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n+    public Factory build() {", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2ODI0Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400768242", "bodyText": "we need to expose baggageKeys() for opentracing..", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MDk3Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400770976", "bodyText": "Ah got it", "author": "anuraaga", "createdAt": "2020-03-31T09:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3NTAxNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400775015", "bodyText": "wait maybe we don't anymore .. lemme check!", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3NTQ0Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400775442", "bodyText": "yeah we do.. I'll make a note", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3NjYxMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400776611", "bodyText": "actually I think we can maybe cheat. lemme try..", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5MjY0Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400792643", "bodyText": "wow that was nice! cheating works fine", "author": "codefromthecrypt", "createdAt": "2020-03-31T10:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0ODQzNA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400748434", "bodyText": "Since a local field never has keys (BaggateField.remoteNames = new String[0]) we could possibly reduce the checks in this class by not checking local.", "author": "anuraaga", "createdAt": "2020-03-31T08:54:41Z", "path": "brave/src/main/java/brave/propagation/BaggagePropagation.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This implements in-process and remote {@linkplain BaggageField baggage} propagation.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n+ * <pre>{@code\n+ * // Configure your baggage field\n+ * COUNTRY_CODE = BaggageField.create(\"country-code\");\n+ *\n+ * // When you initialize the builder, add the baggage you want to propagate\n+ * tracingBuilder.propagationFactory(\n+ *   BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                     .addField(COUNTRY_CODE)\n+ *                     .build()\n+ * );\n+ *\n+ * // later, you can tag that country code\n+ * COUNTRY_CODE.tag(span);\n+ * }</pre>\n+ *\n+ * @since 5.11\n+ */\n+public class BaggagePropagation<K> implements Propagation<K> {\n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n+  public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n+    return new FactoryBuilder(delegate);\n+  }\n+\n+  public static final class FactoryBuilder {\n+    final Propagation.Factory delegate;\n+    final Set<BaggageField> fields = new LinkedHashSet<>();\n+\n+    FactoryBuilder(Propagation.Factory delegate) {\n+      if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+      this.delegate = delegate;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain BaggageField baggage field} for remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public FactoryBuilder addField(BaggageField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n+    public Factory build() {\n+      if (fields.isEmpty()) return new Factory(delegate);\n+      return new RealFactory(delegate, fields.toArray(new BaggageField[0]));\n+    }\n+  }\n+\n+  public static class Factory extends Propagation.Factory {\n+    final Propagation.Factory delegate;\n+\n+    Factory(Propagation.Factory delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override public <K> BaggagePropagation<K> create(Propagation.KeyFactory<K> keyFactory) {\n+      return new BaggagePropagation<>(delegate, keyFactory);\n+    }\n+\n+    @Override public boolean supportsJoin() {\n+      return delegate.supportsJoin();\n+    }\n+\n+    @Override public boolean requires128BitTraceId() {\n+      return delegate.requires128BitTraceId();\n+    }\n+\n+    @Override public TraceContext decorate(TraceContext context) {\n+      return delegate.decorate(context);\n+    }\n+  }\n+\n+  static class BaggageFieldWithKeys<K> {\n+    final BaggageField field;\n+    /** Corresponds to {@link BaggageField#remoteNames()} */\n+    final K[] keys;\n+\n+    BaggageFieldWithKeys(BaggageField field, K[] keys) {\n+      this.field = field;\n+      this.keys = keys;\n+    }\n+  }\n+\n+  static final class RealFactory extends Factory {\n+    final PredefinedBaggageFields.Factory extraFactory;\n+\n+    RealFactory(Propagation.Factory delegate, BaggageField[] fields) {\n+      super(delegate);\n+      this.extraFactory = new PredefinedBaggageFields.Factory(fields);\n+    }\n+\n+    @Override\n+    public final <K> BaggagePropagation<K> create(Propagation.KeyFactory<K> keyFactory) {\n+      int i = 0;\n+      List<K> allKeys = new ArrayList<>();\n+      BaggageFieldWithKeys<K>[] fieldsWithKeys =\n+        new BaggageFieldWithKeys[extraFactory.fields.length];\n+      for (BaggageField field : extraFactory.fields) {\n+        K[] keysForField = (K[]) new Object[field.remoteNames.length];\n+        for (int j = 0, length = field.remoteNames.length; j < length; j++) {\n+          keysForField[j] = keyFactory.create(field.remoteNames[j]);\n+          allKeys.add(keysForField[j]);\n+        }\n+        fieldsWithKeys[i++] = new BaggageFieldWithKeys<>(field, keysForField);\n+      }\n+      return new RealBaggagePropagation<>(this, keyFactory, fieldsWithKeys, allKeys);\n+    }\n+\n+    @Override public TraceContext decorate(TraceContext context) {\n+      TraceContext result = delegate.decorate(context);\n+      return extraFactory.decorate(result);\n+    }\n+  }\n+\n+  final Propagation<K> delegate;\n+\n+  BaggagePropagation(Propagation.Factory factory, Propagation.KeyFactory<K> keyFactory) {\n+    this.delegate = factory.create(keyFactory);\n+  }\n+\n+  /**\n+   * Returns all propagation keys derived from {@linkplain BaggageField#remoteNames()}. This result\n+   * does not include any {@link #keys() trace context keys}.\n+   */\n+  // This is here to support extraction from carriers missing a get field by name function. The only\n+  // known example is OpenTracing TextMap https://github.com/opentracing/opentracing-java/issues/305\n+  public List<K> baggageKeys() {\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Only returns trace context keys. Baggage field names are not returned to ensure tools don't\n+   * delete them. This is to support users accessing baggage without Brave apis (ex via headers).\n+   */\n+  @Override public List<K> keys() {\n+    return delegate.keys();\n+  }\n+\n+  @Override public <C> Injector<C> injector(Setter<C, K> setter) {\n+    return delegate.injector(setter);\n+  }\n+\n+  @Override public <C> Extractor<C> extractor(Getter<C, K> getter) {\n+    return delegate.extractor(getter);\n+  }\n+\n+  static final class RealBaggagePropagation<K> extends BaggagePropagation<K> {\n+    final RealFactory factory;\n+    final BaggageFieldWithKeys<K>[] fieldsWithKeys;\n+    final List<K> allKeys;\n+\n+    RealBaggagePropagation(\n+      RealFactory factory, Propagation.KeyFactory<K> keyFactory,\n+      BaggageFieldWithKeys<K>[] fieldsWithKeys, List<K> allKeys) {\n+      super(factory.delegate, keyFactory);\n+      this.factory = factory;\n+      this.fieldsWithKeys = fieldsWithKeys;\n+      this.allKeys = Collections.unmodifiableList(allKeys);\n+    }\n+\n+    @Override public List<K> baggageKeys() {\n+      return allKeys;\n+    }\n+\n+    @Override public <C> Injector<C> injector(Setter<C, K> setter) {\n+      return new BaggageFieldInjector<>(this, setter);\n+    }\n+\n+    @Override public <C> Extractor<C> extractor(Getter<C, K> getter) {\n+      return new BaggageFieldExtractor<>(this, getter);\n+    }\n+  }\n+\n+  static final class BaggageFieldInjector<C, K> implements Injector<C> {\n+    final RealBaggagePropagation<K> propagation;\n+    final Injector<C> delegate;\n+    final Propagation.Setter<C, K> setter;\n+\n+    BaggageFieldInjector(RealBaggagePropagation<K> propagation, Setter<C, K> setter) {\n+      this.propagation = propagation;\n+      this.delegate = propagation.delegate.injector(setter);\n+      this.setter = setter;\n+    }\n+\n+    @Override public void inject(TraceContext traceContext, C carrier) {\n+      delegate.inject(traceContext, carrier);\n+      PredefinedBaggageFields extra = traceContext.findExtra(PredefinedBaggageFields.class);\n+      if (extra == null) return;\n+      inject(extra, carrier);\n+    }\n+\n+    void inject(PredefinedBaggageFields fields, C carrier) {\n+      for (BaggageFieldWithKeys<K> fieldWithKeys : propagation.fieldsWithKeys) {\n+        if (fieldWithKeys.field.local) continue; // don't propagate downstream", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2ODc2Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400768767", "bodyText": "yep good idea!", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0ODQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0OTM1Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400749356", "bodyText": "Any thoughts on removing local in favor of calling clearRemoteNames without addRemoteName and removing our validation on remote names length? If it quacks it's a duck.", "author": "anuraaga", "createdAt": "2020-03-31T08:56:06Z", "path": "brave/src/main/java/brave/propagation/BaggageField.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link BaggagePropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code in a downstream\n+ * service, you can propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your baggage field\n+ * COUNTRY_CODE = BaggageField.create(\"country-code\");\n+ * }</pre>\n+ *\n+ * <p>If you don't have a reference to a baggage field, you can use {@linkplain\n+ * #getByName(TraceContext, String)}.\n+ *\n+ * <h3>Local Usage</h3>\n+ * Baggage fields are also {@linkplain CorrelationField correlation fields}. As long as a field is\n+ * configured with {@link BaggagePropagation}, local reads and updates are possible in-process.\n+ *\n+ * <p>You can also integrate baggage with other correlated contexts such as logging:\n+ * <pre>{@code\n+ * AMZN_TRACE_ID = BaggageField.newBuilder(\"x-amzn-trace-id\").build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * decorator = MDCScopeDecorator.newBuilder()\n+ *                              .addField(AMZN_TRACE_ID).build();\n+ *\n+ * tracingBuilder.propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                     .addField(AMZN_TRACE_ID)\n+ *                                                     .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Local-only Baggage</h3>\n+ * You may have some fields that you would like to propagate in-process, but not downstream to other\n+ * hosts. Use {@link Builder#local()} to indicate a field should not be injected into headers.\n+ *\n+ * <h3>Different naming conventions</h3>\n+ * By default the name used for remote propagation (header) is the same as the lowercase variant of\n+ * the field name. You can override this using the builder.\n+ *\n+ * For example, the following will propagate the field \"x-vcap-request-id\" as-is, but send the\n+ * fields \"countryCode\" and \"userId\" on the wire as \"baggage-country-code\" and \"baggage-user-id\"\n+ * respectively.\n+ * <pre>{@code\n+ * REQUEST_ID = BaggageField.create(\"x-vcap-request-id\");\n+ * COUNTRY_CODE = BaggageField.newBuilder(\"countryCode\").clearKeys()\n+ *                            .addKey(\"baggage-country-code\").build();\n+ * USER_ID = BaggageField.newBuilder(\"userId\").clearKeys()\n+ *                       .addKey(\"baggage-user-id\").build();\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see BaggagePropagation\n+ * @see CorrelationScopeDecorator\n+ */\n+public final class BaggageField extends CorrelationField.Updatable {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static BaggageField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** Gets any fields in the in given trace context. */\n+  public static List<BaggageField> getAll(TraceContext context) {\n+    PredefinedBaggageFields fields = context.findExtra(PredefinedBaggageFields.class);\n+    if (fields == null) return Collections.emptyList();\n+    return Collections.unmodifiableList(asList(fields.fields));\n+  }\n+\n+  /**\n+   * Like {@link #getAll()} except against the current trace context.\n+   *\n+   * <p>Prefer {@link #getAll()} if you have a reference to the trace context.\n+   */\n+  @Nullable public static List<BaggageField> getAll() {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getAll(context) : Collections.emptyList();\n+  }\n+\n+  /** Looks up the field by {@linkplain #name()} when you do not have a reference to it. */\n+  @Nullable public static BaggageField getByName(TraceContext context, String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    PredefinedBaggageFields fields = context.findExtra(PredefinedBaggageFields.class);\n+    if (fields == null) return null;\n+    for (BaggageField field : fields.fields) {\n+      if (name.equals(field.name())) {\n+        return field;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Like {@link #getByName(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer {@link #getByName(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   */\n+  @Nullable public static BaggageField getByName(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getByName(context, name) : null;\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> remoteNames = new LinkedHashSet<>();\n+    boolean local = false, flushOnUpdate = false;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      remoteNames.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.remoteNames.addAll(builder.remoteNames);\n+      this.local = builder.local;\n+      this.flushOnUpdate = builder.flushOnUpdate;\n+    }\n+\n+    Builder(BaggageField baggageField) {\n+      this.name = baggageField.name;\n+      this.remoteNames.addAll(asList(baggageField.remoteNames));\n+      this.local = baggageField.local;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addRemoteName(String)}. <p>The default propagated name is the lowercase variant of\n+     * the field name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * USER_ID = BaggageField.newBuilder(\"userId\")\n+     *                       .clearRemoteNames()\n+     *                       .addRemoteName(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearRemoteNames() {\n+      remoteNames.clear();\n+      return this;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain #remoteNames() remote name} (header).\n+     *\n+     * <p>Note: remote names are implicitly lower-cased.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder addRemoteName(String remoteName) {\n+      remoteNames.add(validateName(remoteName).toLowerCase(Locale.ROOT));\n+      return this;\n+    }\n+\n+    /**\n+     * Restricts to local (in-process) propagation only. This is mostly useful when also configuring\n+     * {@link CorrelationScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder local() {", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2OTQyOA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400769428", "bodyText": "yep sounds good!", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0OTM1Ng=="}], "type": "inlineReview"}, {"oid": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "url": "https://github.com/openzipkin/brave/commit/261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "message": "Exposes CorrelationField and Baggage Apis", "committedDate": "2020-04-01T05:42:13Z", "type": "forcePushed"}, {"oid": "b70fe2ba9a617214b6431b49cc0d546c3fcf7a51", "url": "https://github.com/openzipkin/brave/commit/b70fe2ba9a617214b6431b49cc0d546c3fcf7a51", "message": "Exposes CorrelationField and Baggage Apis", "committedDate": "2020-04-01T05:45:04Z", "type": "forcePushed"}, {"oid": "f9410a443424c9a12db7b02196c2119ff6a05ee1", "url": "https://github.com/openzipkin/brave/commit/f9410a443424c9a12db7b02196c2119ff6a05ee1", "message": "addRemoteName", "committedDate": "2020-04-01T07:26:56Z", "type": "forcePushed"}, {"oid": "902eea9fe62f2a20be6a73ba005991ef400bf872", "url": "https://github.com/openzipkin/brave/commit/902eea9fe62f2a20be6a73ba005991ef400bf872", "message": "Exposes CorrelationField and Baggage Apis", "committedDate": "2020-04-02T02:56:25Z", "type": "commit"}, {"oid": "b36285a0a04b41e7876040e048a53c975a8f5a1d", "url": "https://github.com/openzipkin/brave/commit/b36285a0a04b41e7876040e048a53c975a8f5a1d", "message": "addRemoteName", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "50595d41ad5c5f2c458b179cac173a811a6e983c", "url": "https://github.com/openzipkin/brave/commit/50595d41ad5c5f2c458b179cac173a811a6e983c", "message": "fix spring tests", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "587b2a9179e0edb6c48d97c761ff2c288da0f4d0", "url": "https://github.com/openzipkin/brave/commit/587b2a9179e0edb6c48d97c761ff2c288da0f4d0", "message": "Don't yet support folding fields", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "4938e53719af19498e9e254d797f131c3db43a60", "url": "https://github.com/openzipkin/brave/commit/4938e53719af19498e9e254d797f131c3db43a60", "message": "organization", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "5191a21b466e9503b9f79b924fe2ecdbddeac918", "url": "https://github.com/openzipkin/brave/commit/5191a21b466e9503b9f79b924fe2ecdbddeac918", "message": "removes misalignment possibility", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "da9738c589d721b4d8d0f21c1e49e1f9476fae69", "url": "https://github.com/openzipkin/brave/commit/da9738c589d721b4d8d0f21c1e49e1f9476fae69", "message": "moves rationale", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "2079169132145921644ad7d5c7a95682c5d514a0", "url": "https://github.com/openzipkin/brave/commit/2079169132145921644ad7d5c7a95682c5d514a0", "message": "Collapsed to BaggageField", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "55dc29a3e85a3c9849341133dbf3026a8dab8aa3", "url": "https://github.com/openzipkin/brave/commit/55dc29a3e85a3c9849341133dbf3026a8dab8aa3", "message": "100% coverage on BaggageField", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "a042fe16ff30c94988396e85637471dfa9719845", "url": "https://github.com/openzipkin/brave/commit/a042fe16ff30c94988396e85637471dfa9719845", "message": "Moves to baggage package and refactors out read-only flag", "committedDate": "2020-04-02T02:56:56Z", "type": "forcePushed"}, {"oid": "a042fe16ff30c94988396e85637471dfa9719845", "url": "https://github.com/openzipkin/brave/commit/a042fe16ff30c94988396e85637471dfa9719845", "message": "Moves to baggage package and refactors out read-only flag", "committedDate": "2020-04-02T02:56:56Z", "type": "commit"}, {"oid": "016837e22164c69eb416b1c29fbd59e962634024", "url": "https://github.com/openzipkin/brave/commit/016837e22164c69eb416b1c29fbd59e962634024", "message": "Moves remote propagation concerns to BaggagePropagation", "committedDate": "2020-04-02T05:37:52Z", "type": "commit"}, {"oid": "59558faa081f4d5494509a814b81965444341825", "url": "https://github.com/openzipkin/brave/commit/59558faa081f4d5494509a814b81965444341825", "message": "drift", "committedDate": "2020-04-02T05:59:50Z", "type": "commit"}, {"oid": "bfc66a890876d4f4856e50d1e26482b50a3ee467", "url": "https://github.com/openzipkin/brave/commit/bfc66a890876d4f4856e50d1e26482b50a3ee467", "message": "opentracing and deprecated factory", "committedDate": "2020-04-02T06:37:20Z", "type": "commit"}, {"oid": "d077d1d08c2ca766bcc6252c208a329fabd94cb5", "url": "https://github.com/openzipkin/brave/commit/d077d1d08c2ca766bcc6252c208a329fabd94cb5", "message": "lenient on null tracecontext and backfill tests", "committedDate": "2020-04-02T08:38:35Z", "type": "commit"}, {"oid": "628f0a95015688e92b359773c7988b6ed6a615ba", "url": "https://github.com/openzipkin/brave/commit/628f0a95015688e92b359773c7988b6ed6a615ba", "message": "missing file", "committedDate": "2020-04-02T08:38:53Z", "type": "commit"}]}