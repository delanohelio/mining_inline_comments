{"pr_number": 1084, "pr_title": "Introduces HttpRequestParser and HttpResponseParser", "pr_createdAt": "2020-02-16T23:06:16Z", "pr_url": "https://github.com/openzipkin/brave/pull/1084", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzc0MQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379963741", "bodyText": "Returns the instrumentation-specific response object used to create this {@link Response}, or {@code this} otherwise.", "author": "anuraaga", "createdAt": "2020-02-17T02:33:25Z", "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * Returns the underlying response object or {@code this} if there is none. Here are some response", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzk4NQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379963985", "bodyText": "Is this better than null as a fallback? Since the return type of this unwrap is Object, which has no shared interface, I can't imagine the fallback to this actually being used other than as a comparison for checking whether it was unwrapped. On the flip side, I see our code checking null anyways for this method.", "author": "anuraaga", "createdAt": "2020-02-17T02:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQwMDU3Mg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380400572", "bodyText": "users are told to use instanceof, so we can switch this to null as instanceof will fail on null gracefully. I'll open a PR on the other side (Request) and update this.", "author": "codefromthecrypt", "createdAt": "2020-02-17T23:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NDc2NQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379964765", "bodyText": "Extra parenthesis around lambda", "author": "anuraaga", "createdAt": "2020-02-17T02:40:04Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -202,6 +202,39 @@ public void reportsServerAddress() throws Exception {\n   @Test public void supportsPortableCustomization() throws Exception {\n     String uri = \"/foo/bar?z=2&yAA=1\";\n \n+    close();\n+    httpTracing = httpTracing.toBuilder()\n+      .clientRequestParser((request, context, span) -> {\n+        span.name(request.method().toLowerCase() + \" \" + request.path());\n+        span.tag(\"http.url\", request.url()); // just the path is logged by default\n+        span.tag(\"request_customizer.is_span\", (span instanceof brave.Span) + \"\");\n+      })\n+      .clientResponseParser(((response, error, context, span) -> {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NDg0Mg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379964842", "bodyText": "Extra paren around lambda", "author": "anuraaga", "createdAt": "2020-02-17T02:40:37Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java", "diffHunk": "@@ -219,6 +220,31 @@ public void defaultSpanNameIsMethodNameOrRoute() throws Exception {\n \n   @Test\n   public void supportsPortableCustomization() throws Exception {\n+    httpTracing = httpTracing.toBuilder()\n+      .serverRequestParser((request, context, span) -> {\n+        span.name(request.method().toLowerCase() + \" \" + request.path());\n+        span.tag(\"http.url\", request.url()); // just the path is logged by default\n+        span.tag(\"request_customizer.is_span\", (span instanceof brave.Span) + \"\");\n+      })\n+      .serverResponseParser(((response, error, context, span) -> {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NTA5NA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379965094", "bodyText": "There are many classes, so not sure, but is this @Deprecated?", "author": "anuraaga", "createdAt": "2020-02-17T02:42:04Z", "path": "instrumentation/http/src/main/java/brave/http/HttpAdapter.java", "diffHunk": "@@ -13,113 +13,57 @@\n  */\n package brave.http;\n \n-import brave.Clock;\n-import brave.Span;\n import brave.internal.Nullable;\n-import brave.propagation.TraceContext;\n import java.net.URI;\n \n public abstract class HttpAdapter<Req, Resp> {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQzOTM1OA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382439358", "bodyText": "yep", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NTU1OQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379965559", "bodyText": "Keep this check?", "author": "anuraaga", "createdAt": "2020-02-17T02:44:49Z", "path": "instrumentation/http/src/main/java/brave/http/HttpClientHandler.java", "diffHunk": "@@ -196,22 +207,12 @@ public Span handleSend(HttpClientRequest request, Span span) {\n    * @since 4.3\n    */\n   public void handleReceive(@Nullable Resp response, @Nullable Throwable error, Span span) {\n-    if (response == null && error == null) {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNjY4MA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382426680", "bodyText": "moved to the parent class", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NTU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTI0OA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379971248", "bodyText": "Just wondering is there any ordering requirement between these two lines?", "author": "anuraaga", "createdAt": "2020-02-17T03:21:34Z", "path": "instrumentation/http/src/main/java/brave/http/HttpClientParserAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.propagation.CurrentTraceContext;\n+\n+/** Added to allow us to keep compatabilty with deprecated {@link HttpTracing#clientParser()} */\n+@Deprecated final class HttpClientParserAdapter extends HttpClientParser {\n+  final HttpRequestParser requestParser;\n+  final HttpResponseParser responseParser;\n+  final CurrentTraceContext currentTraceContext;\n+  final ErrorParser errorParser;\n+\n+  HttpClientParserAdapter(\n+    HttpRequestParser requestParser,\n+    HttpResponseParser responseParser,\n+    CurrentTraceContext currentTraceContext,\n+    ErrorParser errorParser\n+  ) {\n+    this.requestParser = requestParser;\n+    this.responseParser = responseParser;\n+    this.currentTraceContext = currentTraceContext;\n+    this.errorParser = errorParser;\n+  }\n+\n+  @Override protected ErrorParser errorParser() {\n+    return errorParser;\n+  }\n+\n+  @Override\n+  public <Req> void request(HttpAdapter<Req, ?> adapter, Req req, SpanCustomizer customizer) {\n+    HttpRequest request;\n+    if (req instanceof HttpClientRequest) {\n+      request = new HttpClientRequest.FromHttpAdapter((HttpClientAdapter) adapter, req);\n+    } else if (adapter instanceof HttpClientRequest.ToHttpAdapter) {\n+      request = ((HttpClientRequest.ToHttpAdapter) adapter).delegate;\n+    } else {\n+      throw new AssertionError(\"programming bug\");\n+    }\n+    requestParser.parse(request, currentTraceContext.get(), customizer);\n+  }\n+\n+  @Override public <Resp> void response(HttpAdapter<?, Resp> adapter, Resp res, Throwable error,\n+    SpanCustomizer customizer) {\n+    HttpResponse response;\n+    if (res instanceof HttpClientResponse) {\n+      response = new HttpClientResponse.FromHttpAdapter((HttpClientAdapter) adapter, res);\n+    } else if (adapter instanceof HttpClientResponse.ToHttpAdapter) {\n+      response = ((HttpClientResponse.ToHttpAdapter) adapter).delegate;\n+    } else {\n+      throw new AssertionError(\"programming bug\");\n+    }\n+    errorParser.error(error, customizer);", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyOTk0MQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382429941", "bodyText": "obviated now. thanks!", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTcxNw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379971717", "bodyText": "HttpRequest type", "author": "anuraaga", "createdAt": "2020-02-17T03:24:54Z", "path": "instrumentation/http/src/main/java/brave/http/HttpParserAdapter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.TraceContext;\n+\n+/** Adapts {@link HttpParser} to the new request and response objects. */\n+@Deprecated final class HttpParserAdapter implements HttpRequestParser, HttpResponseParser {\n+  final CurrentTraceContext currentTraceContext;\n+  final HttpParser parser;\n+\n+  HttpParserAdapter(CurrentTraceContext currentTraceContext, HttpParser parser) {\n+    this.currentTraceContext = currentTraceContext;\n+    this.parser = parser;\n+  }\n+\n+  @Override public void parse(HttpRequest request, TraceContext context, SpanCustomizer span) {\n+    HttpAdapter<Object, ?> adapter;\n+    Object req;\n+\n+    // The order matters here because the deprecated HttpClientHandler.create(httpTracing, adapter)\n+    // can be used even with the new HttpRequest type. This means we have to check the HttpResponse", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTg4OQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379971889", "bodyText": "Is it ok to have the else? (we don't have it above)", "author": "anuraaga", "createdAt": "2020-02-17T03:26:07Z", "path": "instrumentation/http/src/main/java/brave/http/HttpParserAdapter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.TraceContext;\n+\n+/** Adapts {@link HttpParser} to the new request and response objects. */\n+@Deprecated final class HttpParserAdapter implements HttpRequestParser, HttpResponseParser {\n+  final CurrentTraceContext currentTraceContext;\n+  final HttpParser parser;\n+\n+  HttpParserAdapter(CurrentTraceContext currentTraceContext, HttpParser parser) {\n+    this.currentTraceContext = currentTraceContext;\n+    this.parser = parser;\n+  }\n+\n+  @Override public void parse(HttpRequest request, TraceContext context, SpanCustomizer span) {\n+    HttpAdapter<Object, ?> adapter;\n+    Object req;\n+\n+    // The order matters here because the deprecated HttpClientHandler.create(httpTracing, adapter)\n+    // can be used even with the new HttpRequest type. This means we have to check the HttpResponse\n+    // type after checking to see if we are in an adapter scenario.\n+    if (request instanceof HttpClientRequest.FromHttpAdapter) {\n+      HttpClientRequest.FromHttpAdapter wrapped = (HttpClientRequest.FromHttpAdapter) request;\n+      adapter = wrapped.adapter;\n+      req = wrapped.request;\n+    } else if (request instanceof HttpServerRequest.FromHttpAdapter) {\n+      HttpServerRequest.FromHttpAdapter wrapped = (HttpServerRequest.FromHttpAdapter) request;\n+      adapter = wrapped.adapter;\n+      req = wrapped.request;\n+    }\n+    if (request instanceof HttpClientRequest) {\n+      req = request.unwrap();\n+      if (req == null) return; // unwrap() shouldn't return null, but we shouldn't crash either.\n+      adapter = new HttpClientRequest.ToHttpAdapter((HttpClientRequest) request);\n+    } else if (request instanceof HttpServerRequest) {\n+      req = request.unwrap();\n+      if (req == null) return; // unwrap() shouldn't return null, but we shouldn't crash either.\n+      adapter = new HttpServerRequest.ToHttpAdapter((HttpServerRequest) request);\n+    } else {\n+      throw new AssertionError(\"programming bug\");\n+    }\n+\n+    Scope ws = currentTraceContext.maybeScope(context);\n+    try {\n+      parser.request(adapter, req, span);\n+    } finally {\n+      ws.close();\n+    }\n+  }\n+\n+  @Override public void parse(@Nullable HttpResponse response, @Nullable Throwable error,\n+    TraceContext context, SpanCustomizer span) {\n+    HttpAdapter<?, Object> adapter;\n+    Object res;\n+\n+    // The order matters here because the deprecated HttpClientHandler.create(httpTracing, adapter)\n+    // can be used even with the new HttpResponse type. This means we have to check the HttpResponse\n+    // type after checking to see if we are in an adapter scenario.\n+    if (response instanceof HttpClientResponse.FromHttpAdapter) {\n+      HttpClientResponse.FromHttpAdapter wrapped = (HttpClientResponse.FromHttpAdapter) response;\n+      adapter = wrapped.adapter;\n+      res = wrapped.response;\n+    } else if (response instanceof HttpServerResponse.FromHttpAdapter) {\n+      HttpServerResponse.FromHttpAdapter wrapped = (HttpServerResponse.FromHttpAdapter) response;\n+      adapter = wrapped.adapter;\n+      res = wrapped.response;\n+    } else if (response instanceof HttpClientResponse) {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNzg3Mw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382427873", "bodyText": "because HttpClientAdapters.FromResponseAdapter is an instanceof HttpClientResponse I think we wouldn't intentionally break the if/else chain. as that would cause us to re-enter. I put stronger comments above this which can be improved if you feel need be.", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MjAyMg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379972022", "bodyText": "This class is mostly impossible to grok ;) But we can leave it at that since it's deprecated, I wonder if there isn't a small readability improvement possible though by splitting client and server.", "author": "anuraaga", "createdAt": "2020-02-17T03:27:04Z", "path": "instrumentation/http/src/main/java/brave/http/HttpParserAdapter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.TraceContext;\n+\n+/** Adapts {@link HttpParser} to the new request and response objects. */\n+@Deprecated final class HttpParserAdapter implements HttpRequestParser, HttpResponseParser {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQzMDEwNg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382430106", "bodyText": "agreed", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MjAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MzUwOQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379973509", "bodyText": "Seal to only allow subclasses in brave?", "author": "anuraaga", "createdAt": "2020-02-17T03:36:56Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponse.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Clock;\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of http clients and servers.\n+ *\n+ * @see HttpClientResponse\n+ * @see HttpServerResponse\n+ * @since 5.10\n+ */\n+public abstract class HttpResponse extends Response {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MzY5Mg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379973692", "bodyText": "I think it's good to add the method as a tag either way, but for this statement, can't we pass the request to the response parser?", "author": "anuraaga", "createdAt": "2020-02-17T03:38:11Z", "path": "instrumentation/http/src/main/java/brave/http/HttpRequestParser.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.SpanCustomizer;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the request data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that changes the span name and records the HTTP url instead of the path.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientRequestParser((request, context, span) -> {\n+ *     span.name(spanName(adapter, request)); // default span name\n+ *     span.tag(\"http.url\", request.url()); // the whole url, not just the path\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the request side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpRequest} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only request data, it is implementable as a lambda or method reference. This also passes\n+ * the trace context as a parameter, lowering parsing overhead vs relying on the current span.\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as {@link\n+ * ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed as you\n+ * cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpResponseParser\n+ */\n+public interface HttpRequestParser {\n+  HttpRequestParser DEFAULT = new HttpRequestParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http request are parsed into the span representing it.\n+   *\n+   * @see Default\n+   */\n+  void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP method and adds the \"http.method\" and\n+   * \"http.path\" tags.\n+   */\n+  // Eventhough the default span name is the method, we have no way of knowing that a user hasn't\n+  // overwritten the name to something else. If that occurs during response parsing, it is too late", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyODQ0Mw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382428443", "bodyText": "#1086", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3Mzc2NA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379973764", "bodyText": "Related to above comment, isn't it easier to reason about (and possibly more powerful) if we pass the request during response parsing instead of duplicating fields into the response?", "author": "anuraaga", "createdAt": "2020-02-17T03:38:39Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponse.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Clock;\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of http clients and servers.\n+ *\n+ * @see HttpClientResponse\n+ * @see HttpServerResponse\n+ * @since 5.10\n+ */\n+public abstract class HttpResponse extends Response {\n+  /**\n+   * Like {@link HttpRequest#method()} except used in response parsing.", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDIwNw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379974207", "bodyText": "To keep the javadoc of modern, non-deprecated types simpler for users, maybe this sort of reasoning should be in the javadoc of the deprecated type instead.", "author": "anuraaga", "createdAt": "2020-02-17T03:41:47Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponseParser.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the response data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that adds all HTTP status codes, not just the error ones.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientResponseParser((response, error, context, span) -> {\n+ *     HttpResponseParser.DEFAULT.parse(response, error, context, span);\n+ *     int statusCode = response != null ? response.statusCode() : 0;\n+ *     if (statusCode > 0) span.tag(\"http.status_code\", String.valueOf(statusCode));\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDYyOQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379974629", "bodyText": "It's probably too late now due to backwards compatibility, but I guess we didn't need to use @Nullable on attributes that are directly part of the HTTP spec. e.g., an HttpRequest without a method never exists and doesn't make sense. I find the business logic hard to follow because of the null checks that end up scattered around.", "author": "anuraaga", "createdAt": "2020-02-17T03:44:55Z", "path": "instrumentation/http/src/main/java/brave/http/HttpRequest.java", "diffHunk": "@@ -24,21 +26,63 @@\n  * @since 5.8\n  */\n public abstract class HttpRequest extends Request {\n-  /** @see HttpAdapter#startTimestamp(Object) */\n+  /**\n+   * The timestamp in epoch microseconds of the beginning of this request or zero to take this\n+   * implicitly from the current clock. Defaults to zero.\n+   *\n+   * <p>This is helpful in two scenarios: late parsing and avoiding redundant timestamp overhead.\n+   * If a server span, this helps reach the \"original\" beginning of the request, which is always\n+   * prior to parsing.\n+   *\n+   * <p>Note: Overriding has the same problems as using {@link brave.Span#start(long)}. For\n+   * example, it can result in negative duration if the clock used is allowed to correct backwards.\n+   * It can also result in misalignments in the trace, unless {@link brave.Tracing.Builder#clock(Clock)}\n+   * uses the same implementation.\n+   *\n+   * @see HttpResponse#finishTimestamp()\n+   * @see brave.Span#start(long)\n+   * @see brave.Tracing#clock(TraceContext)\n+   * @since 5.8\n+   */\n   public long startTimestamp() {\n     return 0L;\n   }\n \n-  /** @see HttpAdapter#method(Object) */\n+  /**\n+   * The HTTP method, or verb, such as \"GET\" or \"POST\" or null if unreadable.\n+   *\n+   * <p>Conventionally associated with the key \"http.method\"\n+   *\n+   * <h3>Note</h3>\n+   * <p>It is part of the <a href=\"https://tools.ietf.org/html/rfc7231#section-4.1\">HTTP RFC</a>\n+   * that an HTTP method is case-sensitive. Do not downcase results. If you do, not only will\n+   * integration tests fail, but you will surprise any consumers who expect compliant results.\n+   */\n   @Nullable public abstract String method();", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyNDE1OA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380524158", "bodyText": "agree on this.. throwing when method is null would be new, but we could remove the nullable", "author": "codefromthecrypt", "createdAt": "2020-02-18T08:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQzOTUzMA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382439530", "bodyText": "#1089", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDgxMA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379974810", "bodyText": "For example here, the fact that method is allowed to be null makes this single line of code a lot more complex (what are the implications of not setting name, for example)", "author": "anuraaga", "createdAt": "2020-02-17T03:46:03Z", "path": "instrumentation/http/src/main/java/brave/http/HttpRequestParser.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.SpanCustomizer;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the request data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that changes the span name and records the HTTP url instead of the path.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientRequestParser((request, context, span) -> {\n+ *     span.name(spanName(adapter, request)); // default span name\n+ *     span.tag(\"http.url\", request.url()); // the whole url, not just the path\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the request side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpRequest} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only request data, it is implementable as a lambda or method reference. This also passes\n+ * the trace context as a parameter, lowering parsing overhead vs relying on the current span.\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as {@link\n+ * ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed as you\n+ * cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpResponseParser\n+ */\n+public interface HttpRequestParser {\n+  HttpRequestParser DEFAULT = new HttpRequestParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http request are parsed into the span representing it.\n+   *\n+   * @see Default\n+   */\n+  void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP method and adds the \"http.method\" and\n+   * \"http.path\" tags.\n+   */\n+  // Eventhough the default span name is the method, we have no way of knowing that a user hasn't\n+  // overwritten the name to something else. If that occurs during response parsing, it is too late\n+  // to go back and get the http method. Adding http method by default ensures span naming doesn't\n+  // prevent basic HTTP info from being visible. A cost of this is another tag, but it is small with\n+  // very limited cardinality. Moreover, users who care strictly about size can override this.\n+  class Default implements HttpRequestParser {\n+    /**\n+     * This sets the span name to the HTTP method and adds the \"http.method\" and \"http.path\" tags.\n+     *\n+     * <p>If you only want to change the span name, subclass and override {@link\n+     * #spanName(HttpRequest, TraceContext)}.\n+     */\n+    @Override public void parse(HttpRequest req, TraceContext context, SpanCustomizer span) {\n+      String name = spanName(req, context);\n+      if (name != null) span.name(name);", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyNDk1OA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380524958", "bodyText": "spanName can be overridden, so it can return null anyway (because it allowed this in the past). For example, you can intentionally return null to only set the name at response time. Anyway, I get your point about method though.", "author": "codefromthecrypt", "createdAt": "2020-02-18T08:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyOTMwNw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382429307", "bodyText": "#1089", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTMwOA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379975308", "bodyText": "I guess most 3xx are redirects, but not 304 Not Modified.", "author": "anuraaga", "createdAt": "2020-02-17T03:49:38Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponseParser.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the response data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that adds all HTTP status codes, not just the error ones.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientResponseParser((response, error, context, span) -> {\n+ *     HttpResponseParser.DEFAULT.parse(response, error, context, span);\n+ *     int statusCode = response != null ? response.statusCode() : 0;\n+ *     if (statusCode > 0) span.tag(\"http.status_code\", String.valueOf(statusCode));\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the response side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpResponse} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only response data, it is implementable as a lambda or method reference.\n+ *\n+ * <p>This also fixes a few problems noticed in practice with {@link HttpParser}:\n+ * <ul>\n+ *   <li>Implementation complexity of {@link ErrorParser}: this is now handled outside</li>\n+ *   <li>Overhead of scoping the current span: {@link TraceContext} is now a parameter</li>\n+ *   <li>Boxing of the HTTP status code: the integer form is now used</li>\n+ * </ul>\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as\n+ * {@link ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed\n+ * as you cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpRequestParser\n+ */\n+public interface HttpResponseParser {\n+  HttpResponseParser DEFAULT = new HttpResponseParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http response are parsed into the span representing it.\n+   *\n+   * <p>Note: Either the response or error parameters may be null, but not both.\n+   *\n+   * @see Default\n+   */\n+  void parse(@Nullable HttpResponse response, @Nullable Throwable error, TraceContext context,\n+    SpanCustomizer customizer);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP route when available, and sets the and\n+   * adds the \"http.status_code\" and \"error\" tags.\n+   *\n+   * <p><h3>Route-based span name</h3>\n+   * If routing is supported, and a GET didn't match due to 404, the span name will be \"get\n+   * not_found\". If it didn't match due to redirect, the span name will be \"get redirected\". If\n+   * routing is not supported, the span name is left alone.\n+   */\n+  // This accepts response or exception because sometimes http 500 is an exception and sometimes not\n+  // If this were not an abstraction, we'd use separate hooks for response and error.\n+  class Default implements HttpResponseParser {\n+\n+    /**\n+     * This tags \"http.status_code\" when it is not 2xx. If the there is no exception and the status\n+     * code is neither 2xx nor 3xx, it tags \"error\". This also overrides the span name based on the\n+     * {@link HttpResponse#method()} and {@link HttpResponse#route()} where possible (ex \"get\n+     * /users/:userId\").\n+     *\n+     * <p>If you only want to change how exceptions are parsed, override {@link #error(int,\n+     * Throwable, TraceContext, SpanCustomizer)} instead.\n+     */\n+    @Override public void parse(@Nullable HttpResponse response, @Nullable Throwable error,\n+      TraceContext context, SpanCustomizer customizer) {\n+      int statusCode = 0;\n+      if (response != null) {\n+        statusCode = response.statusCode();\n+        String nameFromRoute = spanNameFromRoute(response, statusCode);\n+        if (nameFromRoute != null) customizer.name(nameFromRoute);\n+        String maybeStatus = maybeStatusAsString(statusCode, 299);\n+        if (maybeStatus != null) customizer.tag(\"http.status_code\", maybeStatus);\n+      }\n+      error(statusCode, error, context, customizer);\n+    }\n+\n+    /** The intent of this is to by default add \"http.status_code\", when not a success code */\n+    @Nullable String maybeStatusAsString(int statusCode, int upperRange) {\n+      if (statusCode != 0 && (statusCode < 200 || statusCode > upperRange)) {\n+        return String.valueOf(statusCode);\n+      }\n+      return null;\n+    }\n+\n+    static String spanNameFromRoute(HttpResponse response, int statusCode) {\n+      String method = response.method();\n+      if (method == null) return null; // don't undo a valid name elsewhere\n+      String route = response.route();\n+      if (route == null) return null; // don't undo a valid name elsewhere\n+      if (!\"\".equals(route)) return method + \" \" + route;\n+      if (statusCode / 100 == 3) return method + \" redirected\";", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQzMTg1MQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382431851", "bodyText": "agreed. fixed", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTY3OA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379975678", "bodyText": "It's not brave's job to validate HTTP, so this comment is a bit overkill", "author": "anuraaga", "createdAt": "2020-02-17T03:51:44Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponseParser.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the response data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that adds all HTTP status codes, not just the error ones.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientResponseParser((response, error, context, span) -> {\n+ *     HttpResponseParser.DEFAULT.parse(response, error, context, span);\n+ *     int statusCode = response != null ? response.statusCode() : 0;\n+ *     if (statusCode > 0) span.tag(\"http.status_code\", String.valueOf(statusCode));\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the response side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpResponse} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only response data, it is implementable as a lambda or method reference.\n+ *\n+ * <p>This also fixes a few problems noticed in practice with {@link HttpParser}:\n+ * <ul>\n+ *   <li>Implementation complexity of {@link ErrorParser}: this is now handled outside</li>\n+ *   <li>Overhead of scoping the current span: {@link TraceContext} is now a parameter</li>\n+ *   <li>Boxing of the HTTP status code: the integer form is now used</li>\n+ * </ul>\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as\n+ * {@link ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed\n+ * as you cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpRequestParser\n+ */\n+public interface HttpResponseParser {\n+  HttpResponseParser DEFAULT = new HttpResponseParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http response are parsed into the span representing it.\n+   *\n+   * <p>Note: Either the response or error parameters may be null, but not both.\n+   *\n+   * @see Default\n+   */\n+  void parse(@Nullable HttpResponse response, @Nullable Throwable error, TraceContext context,\n+    SpanCustomizer customizer);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP route when available, and sets the and\n+   * adds the \"http.status_code\" and \"error\" tags.\n+   *\n+   * <p><h3>Route-based span name</h3>\n+   * If routing is supported, and a GET didn't match due to 404, the span name will be \"get\n+   * not_found\". If it didn't match due to redirect, the span name will be \"get redirected\". If\n+   * routing is not supported, the span name is left alone.\n+   */\n+  // This accepts response or exception because sometimes http 500 is an exception and sometimes not\n+  // If this were not an abstraction, we'd use separate hooks for response and error.\n+  class Default implements HttpResponseParser {\n+\n+    /**\n+     * This tags \"http.status_code\" when it is not 2xx. If the there is no exception and the status\n+     * code is neither 2xx nor 3xx, it tags \"error\". This also overrides the span name based on the\n+     * {@link HttpResponse#method()} and {@link HttpResponse#route()} where possible (ex \"get\n+     * /users/:userId\").\n+     *\n+     * <p>If you only want to change how exceptions are parsed, override {@link #error(int,\n+     * Throwable, TraceContext, SpanCustomizer)} instead.\n+     */\n+    @Override public void parse(@Nullable HttpResponse response, @Nullable Throwable error,\n+      TraceContext context, SpanCustomizer customizer) {\n+      int statusCode = 0;\n+      if (response != null) {\n+        statusCode = response.statusCode();\n+        String nameFromRoute = spanNameFromRoute(response, statusCode);\n+        if (nameFromRoute != null) customizer.name(nameFromRoute);\n+        String maybeStatus = maybeStatusAsString(statusCode, 299);\n+        if (maybeStatus != null) customizer.tag(\"http.status_code\", maybeStatus);\n+      }\n+      error(statusCode, error, context, customizer);\n+    }\n+\n+    /** The intent of this is to by default add \"http.status_code\", when not a success code */\n+    @Nullable String maybeStatusAsString(int statusCode, int upperRange) {\n+      if (statusCode != 0 && (statusCode < 200 || statusCode > upperRange)) {\n+        return String.valueOf(statusCode);\n+      }\n+      return null;\n+    }\n+\n+    static String spanNameFromRoute(HttpResponse response, int statusCode) {\n+      String method = response.method();\n+      if (method == null) return null; // don't undo a valid name elsewhere\n+      String route = response.route();\n+      if (route == null) return null; // don't undo a valid name elsewhere\n+      if (!\"\".equals(route)) return method + \" \" + route;\n+      if (statusCode / 100 == 3) return method + \" redirected\";\n+      if (statusCode == 404) return method + \" not_found\";\n+      return null; // unexpected\n+    }\n+\n+    /**\n+     * Override to change what data from the HTTP error are parsed into the span modeling it. By\n+     * default, this tags \"error\" as the the status code, if the error parameter was null and the\n+     * HTTP status is below 1xx or above 3xx.\n+     *\n+     * <p>Note: Either the httpStatus can be zero or the error parameter null, but not both. This\n+     * does not parse the error, as it is assumed that the {@link ErrorParser has done so prior}.\n+     *\n+     * <p>Conventionally associated with the tag key \"error\"\n+     */\n+    protected void error(int httpStatus, @Nullable Throwable error, TraceContext context,\n+      SpanCustomizer customizer) {\n+      if (error != null) return; // the call site used the ErrorParser\n+\n+      // Instrumentation error should not make span errors. We don't know the difference between a\n+      // library being unable to get the http status and a bad status (0). We don't classify zero as\n+      // error in case instrumentation cannot read the status. This prevents tagging every response as\n+      // error.\n+      if (httpStatus == 0) return;\n+\n+      // Unlike success path tagging, we only want to indicate something as error if it is not in a\n+      // success range. 1xx-3xx are not errors. It is endpoint-specific if client codes like 404 are\n+      // in fact errors. That's why this is overridable.\n+\n+      // 1xx, 2xx, and 3xx codes are not all valid, but the math is good enough vs drift and opinion", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyNTM2Mw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380525363", "bodyText": "you are reviewing old code, so I guess it is a good thing to move things around occasionally :)", "author": "codefromthecrypt", "createdAt": "2020-02-18T08:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTcyMQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379975721", "bodyText": "Keep this check?", "author": "anuraaga", "createdAt": "2020-02-17T03:52:01Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerHandler.java", "diffHunk": "@@ -148,22 +151,12 @@ Span nextSpan(TraceContextOrSamplingFlags extracted, HttpServerRequest request)\n    * @since 4.3\n    */\n   public void handleSend(@Nullable Resp response, @Nullable Throwable error, Span span) {\n-    if (response == null && error == null) {", "originalCommit": "25ee51e62857c0f222944a33aec0347fb8fda5c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyODMwOQ==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382428309", "bodyText": "same answer as other copy/paste. we defer the check to the super", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDkzMw==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380390933", "bodyText": "nit: extra parenthesis in function", "author": "jeqo", "createdAt": "2020-02-17T22:55:21Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -155,9 +157,12 @@\n     String path = \"/foo\";\n \n     close();\n-    httpTracing = httpTracing.toBuilder().clientSampler(HttpRuleSampler.newBuilder()\n+\n+    SamplerFunction<HttpRequest> sampler = (HttpRuleSampler.newBuilder()", "originalCommit": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTIwMA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380391200", "bodyText": "nit: extra parenthesis around function", "author": "jeqo", "createdAt": "2020-02-17T22:56:39Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java", "diffHunk": "@@ -133,9 +137,11 @@ public void samplingDisabled() throws Exception {\n   @Test public void customSampler() throws Exception {\n     String path = \"/foo\";\n \n-    httpTracing = httpTracing.toBuilder().serverSampler(HttpRuleSampler.newBuilder()\n+    SamplerFunction<HttpRequest> sampler = (HttpRuleSampler.newBuilder()", "originalCommit": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjYyNg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380392626", "bodyText": "Should L35 be updates from:\n * @deprecated Since 5.8, use {@code RequestSampler<HttpRequest>}.\n\nto\n * @deprecated Since 5.8, use {@code SamplerFunction<HttpRequest>}.", "author": "jeqo", "createdAt": "2020-02-17T23:04:22Z", "path": "instrumentation/http/src/main/java/brave/http/HttpSampler.java", "diffHunk": "@@ -75,9 +75,9 @@\n     if (request == null) return null;\n     HttpAdapter<Object, Void> adapter;\n     if (request instanceof HttpClientRequest) {\n-      adapter = new HttpClientRequest.ToHttpAdapter((HttpClientRequest) request);\n+      adapter = new HttpClientAdapters.ToRequestAdapter((HttpClientRequest) request);", "originalCommit": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQzOTgxOA==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382439818", "bodyText": "yep!", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5Nzg0Mg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380397842", "bodyText": "@anuraaga this is the check that was moved from HttpClientHandler#handleReceive, but I'm also not sure if this check should be moved back to the beginning of handleReceive", "author": "jeqo", "createdAt": "2020-02-17T23:34:05Z", "path": "instrumentation/http/src/main/java/brave/http/HttpHandler.java", "diffHunk": "@@ -13,68 +13,66 @@\n  */\n package brave.http;\n \n+import brave.ErrorParser;\n import brave.Span;\n+import brave.SpanCustomizer;\n import brave.internal.Nullable;\n-import brave.propagation.CurrentTraceContext;\n-import brave.propagation.CurrentTraceContext.Scope;\n \n abstract class HttpHandler {\n-  final CurrentTraceContext currentTraceContext;\n-  final HttpParser parser;\n+  final HttpRequestParser requestParser;\n+  final HttpResponseParser responseParser;\n+  final ErrorParser errorParser;\n \n-  HttpHandler(CurrentTraceContext currentTraceContext, HttpParser parser) {\n-    this.currentTraceContext = currentTraceContext;\n-    this.parser = parser;\n+  HttpHandler(\n+    HttpRequestParser requestParser,\n+    HttpResponseParser responseParser,\n+    ErrorParser errorParser\n+  ) {\n+    this.requestParser = requestParser;\n+    this.responseParser = responseParser;\n+    this.errorParser = errorParser;\n   }\n \n-  <Req> Span handleStart(HttpAdapter<Req, ?> adapter, Req request, Span span) {\n+  Span handleStart(HttpRequest request, Span span) {\n     if (span.isNoop()) return span;\n-    Scope ws = currentTraceContext.maybeScope(span.context());\n+\n+    span.kind(request.spanKind());\n     try {\n-      parseRequest(adapter, request, span);\n+      parseRequest(request, span);\n     } finally {\n-      ws.close();\n-    }\n-\n-    // all of the above parsing happened before a timestamp on the span\n-    long timestamp = adapter.startTimestamp(request);\n-    if (timestamp == 0L) {\n-      span.start();\n-    } else {\n-      span.start(timestamp);\n+      // all of the above parsing happened before a timestamp on the span\n+      long timestamp = request.startTimestamp();\n+      if (timestamp == 0L) {\n+        span.start();\n+      } else {\n+        span.start(timestamp);\n+      }\n     }\n     return span;\n   }\n \n-  /** parses remote IP:port and tags while the span is in scope (for logging for example) */\n-  abstract <Req> void parseRequest(HttpAdapter<Req, ?> adapter, Req request, Span span);\n+  abstract void parseRequest(HttpRequest request, Span span);\n \n+  void handleFinish(@Nullable HttpResponse response, @Nullable Throwable error, Span span) {\n+    if (response == null && error == null) {", "originalCommit": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNzI1Mg==", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r382427252", "bodyText": "less work is happening in clientHandler.handleReceive, serverHandler.handleSend now... this allows us to avoid copy/paste", "author": "codefromthecrypt", "createdAt": "2020-02-21T07:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5Nzg0Mg=="}], "type": "inlineReview"}, {"oid": "5da79b48766f63f1a1d74deea30f5c040fa69b8a", "url": "https://github.com/openzipkin/brave/commit/5da79b48766f63f1a1d74deea30f5c040fa69b8a", "message": "Introduces HttpRequestParser and HttpResponseParser\n\nThis completes the transition of HTTP instrumentation to the new HttpRequest\nand HttpResponse types by implementing parsing. Notably, the new parsing\nfunctions can be implemented by lambdas and pass a TraceContext vs scoping.\n\nThe main change is implementing parsers more simply.\n\nEx before:\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientParser(new HttpClientParser() {\n      @Override\n      public <Req> void request(HttpAdapter<Req, ?> adapter, Req req, SpanCustomizer span) {\n        span.name(adapter.method(req)); // default span name\n        span.tag(\"http.url\", adapter.url(req)); // the whole url, not just the path\n      }\n    })\n    .build();\n```\n\nNow\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      span.name(req.method()); // default span name\n      span.tag(\"http.url\", req.url()); // the whole url, not just the path\n    })\n    .build();\n```\n\nThis increased performance and allows easier access to extra fields. For\nexample, a commonly request was to add extra fields as tags. This can now\nbe done in the parser instead of the FinishedSpanHandler, if desired.\n\nEx.\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      HttpClientRequestParser.DEFAULT.parse(req, context, span);\n      String userName = ExtraFieldPropagation.get(context, \"user-name\");\n      if (userName != null) span.tag(\"user-name\", userName);\n    })\n    .build();\n```\n\nIn order to not break api, all the other logic was kept in\n`HttpParserAdapter`, which we can't remove until the next release.", "committedDate": "2020-02-20T11:37:08Z", "type": "forcePushed"}, {"oid": "848562daa3d601c5124e4e0454bd081358b89a2c", "url": "https://github.com/openzipkin/brave/commit/848562daa3d601c5124e4e0454bd081358b89a2c", "message": "WIP: Introduces HttpRequestParser and HttpResponseParser", "committedDate": "2020-02-21T07:12:07Z", "type": "forcePushed"}, {"oid": "848562daa3d601c5124e4e0454bd081358b89a2c", "url": "https://github.com/openzipkin/brave/commit/848562daa3d601c5124e4e0454bd081358b89a2c", "message": "WIP: Introduces HttpRequestParser and HttpResponseParser", "committedDate": "2020-02-21T07:12:07Z", "type": "commit"}, {"oid": "02614ca813ba888d2ffb0ac0b23d1e7c43196888", "url": "https://github.com/openzipkin/brave/commit/02614ca813ba888d2ffb0ac0b23d1e7c43196888", "message": "feedback", "committedDate": "2020-02-21T07:37:48Z", "type": "commit"}, {"oid": "307f6f1e598fdb841286b5d751bfbefc4c964d49", "url": "https://github.com/openzipkin/brave/commit/307f6f1e598fdb841286b5d751bfbefc4c964d49", "message": "much nicer signature", "committedDate": "2020-02-21T07:57:31Z", "type": "commit"}, {"oid": "8d794293175675781d861b017d6bd703a4b4f822", "url": "https://github.com/openzipkin/brave/commit/8d794293175675781d861b017d6bd703a4b4f822", "message": "polish", "committedDate": "2020-02-21T08:24:33Z", "type": "commit"}, {"oid": "c00a8d761a6e3d72a7b99682eb9a43628d227450", "url": "https://github.com/openzipkin/brave/commit/c00a8d761a6e3d72a7b99682eb9a43628d227450", "message": "refactor and test backfill", "committedDate": "2020-02-22T09:35:30Z", "type": "commit"}, {"oid": "884c3d005fea2791351205bf0a4428d2bbe3a579", "url": "https://github.com/openzipkin/brave/commit/884c3d005fea2791351205bf0a4428d2bbe3a579", "message": "missing tests", "committedDate": "2020-02-22T11:47:19Z", "type": "commit"}]}