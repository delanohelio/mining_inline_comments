{"pr_number": 1085, "pr_title": "Introduces `Response.error()` and uses it in HTTP abstraction", "pr_createdAt": "2020-02-18T08:36:36Z", "pr_url": "https://github.com/openzipkin/brave/pull/1085", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380532639", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * The error raised during response processing or null if there was none.\n          \n          \n            \n               * The error raised during response processing or {@code null} if there was none.", "author": "anuraaga", "createdAt": "2020-02-18T08:56:26Z", "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * The error raised during response processing or null if there was none.", "originalCommit": "e58d0170be3eac056b5ab7b2c5910d983492d6a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjk4OQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380532989", "bodyText": "Maybe instead of Lack of throwable, {@code null}", "author": "anuraaga", "createdAt": "2020-02-18T08:57:02Z", "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * The error raised during response processing or null if there was none.\n+   *\n+   * <p>Lack of a throwable does not mean success. For example, in HTTP, there could be a 409", "originalCommit": "e58d0170be3eac056b5ab7b2c5910d983492d6a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNDAwNw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380534007", "bodyText": "Nice", "author": "anuraaga", "createdAt": "2020-02-18T08:58:55Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -298,6 +301,27 @@ public void reportsServerAddress() throws Exception {\n     checkReportsSpanOnTransportException();\n   }\n \n+  /**\n+   * This ensures custom finished span handlers can see the actual exception thrown, not just the\n+   * \"error\" tag value.\n+   */\n+  @Test public void finishedSpanHandlerSeesException() throws Exception {", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTE4Mw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380535183", "bodyText": "Just to confirm, we're adding this but may remove it later if we find it works well to pass the request into the response parser?", "author": "anuraaga", "createdAt": "2020-02-18T09:01:02Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponse.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Clock;\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of http clients and servers.\n+ *\n+ * @see HttpClientResponse\n+ * @see HttpServerResponse\n+ * @since 5.10\n+ */\n+public abstract class HttpResponse extends Response {\n+  /**\n+   * Like {@link HttpRequest#method()} except used in response parsing.\n+   *\n+   * <p>Notably, this is used to create a route-based span name.\n+   *\n+   * @since 5.10\n+   */\n+  @Nullable public String method() {", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwODg1Nw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380608857", "bodyText": "good point.. I'll put a TODO!", "author": "codefromthecrypt", "createdAt": "2020-02-18T11:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTk1OA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380535958", "bodyText": "linkplain when rendering a code link as a normal English word.", "author": "anuraaga", "createdAt": "2020-02-18T09:02:28Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerRequest.java", "diffHunk": "@@ -39,13 +39,34 @@\n   }\n \n   /**\n-   * Override and return true when it is possible to parse the {@link Span#remoteIpAndPort(String,\n-   * int) remote IP and port} from the {@link #unwrap() delegate}. Defaults to false.\n+   * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n+   * information about the client from the {@link #unwrap() delegate}.", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNjAxMA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380536010", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-02-18T09:02:34Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerRequest.java", "diffHunk": "@@ -39,13 +39,34 @@\n   }\n \n   /**\n-   * Override and return true when it is possible to parse the {@link Span#remoteIpAndPort(String,\n-   * int) remote IP and port} from the {@link #unwrap() delegate}. Defaults to false.\n+   * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n+   * information about the client from the {@link #unwrap() delegate}.\n    *\n-   * @see HttpServerAdapter#parseClientIpAndPort(Object, Span)\n+   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNjU1MQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380536551", "bodyText": "Not sure I parse this sentence well. Is it the same as It is more likely a server request object will be able to parse socket information as opposed to a client object.", "author": "anuraaga", "createdAt": "2020-02-18T09:03:35Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerRequest.java", "diffHunk": "@@ -39,13 +39,34 @@\n   }\n \n   /**\n-   * Override and return true when it is possible to parse the {@link Span#remoteIpAndPort(String,\n-   * int) remote IP and port} from the {@link #unwrap() delegate}. Defaults to false.\n+   * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n+   * information about the client from the {@link #unwrap() delegate}.\n    *\n-   * @see HttpServerAdapter#parseClientIpAndPort(Object, Span)\n+   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded\n+   * IP}. Override to add client socket information when forwarded info is not available.\n+   *\n+   * <p>Aside: the ability to parse socket information on server request objects is likely even if", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYxMDI2OA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380610268", "bodyText": "thanks for the help!", "author": "codefromthecrypt", "createdAt": "2020-02-18T11:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNjU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzODMxOQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380538319", "bodyText": "Almost commented this should be StringBuilder but realized it's not our API...", "author": "anuraaga", "createdAt": "2020-02-18T09:06:59Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/HttpServletRequestWrapper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.servlet;\n+\n+import brave.Span;\n+import brave.http.HttpServerRequest;\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * Besides delegating to {@link HttpServletRequest} methods, this also parses the remote IP of the\n+ * client.\n+ *\n+ * @since 5.10\n+ */\n+// Public for use in sparkjava or other frameworks that re-use servlet types\n+public final class HttpServletRequestWrapper extends HttpServerRequest {\n+  /** @since 5.10 */\n+  public static HttpServerRequest create(HttpServletRequest request) {\n+    return new HttpServletRequestWrapper(request);\n+  }\n+\n+  final HttpServletRequest delegate;\n+\n+  HttpServletRequestWrapper(HttpServletRequest delegate) {\n+    if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+    this.delegate = delegate;\n+  }\n+\n+  /**\n+   * This sets the client IP:port to the {@linkplain HttpServletRequest#getRemoteAddr() remote\n+   * address} if the {@link #parseClientIpAndPort default parsing} fails.\n+   */\n+  @Override public boolean parseClientIpAndPort(Span span) {\n+    if (parseClientIpFromXForwardedFor(span)) return true;\n+    return span.remoteIpAndPort(delegate.getRemoteAddr(), delegate.getRemotePort());\n+  }\n+\n+  @Override public final String method() {\n+    return delegate.getMethod();\n+  }\n+\n+  @Override public final String path() {\n+    return delegate.getRequestURI();\n+  }\n+\n+  // not final as some implementations may be able to do this more efficiently\n+  @Override public String url() {\n+    StringBuffer url = delegate.getRequestURL();", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3ODA0Nw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381278047", "bodyText": "TODO: make this test as hard as the server ones (eventhough it will hurt). Right now, this only looks for existance of the \"error\" tag, which in the case of server, hid bugs.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:07:48Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -310,10 +334,15 @@ protected Span checkReportsSpanOnTransportException() throws InterruptedExceptio\n     return takeSpan();\n   }\n \n-  @Test public void addsErrorTagOnTransportException() throws Exception {\n+  @Test public void errorTag_onTransportException() throws Exception {", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3ODcxMQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381278711", "bodyText": "when I made the assertion actually look at content, I found most of our code didn't return what we thought it would.. rather it just set the http status.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:09:11Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java", "diffHunk": "@@ -386,30 +390,82 @@ public void addsStatusCode_badRequest() throws Exception {\n       .containsEntry(\"error\", \"400\");\n   }\n \n+  /**\n+   * Some synchronous frameworks have limited means to adjust the HTTP status code upon raising an\n+   * exception. When this is the case, use the following built-in exception:\n+   *\n+   * <p><pre>{@code\n+   *   throw new UnavailableException(\"not ready\", 1); // implies 503\n+   * }</pre>\n+   */\n+  @Test\n+  public void httpStatusCodeTagMatchesResponse_onException() throws Exception {\n+    httpStatusCodeTagMatchesResponse_onException(\"/exception\");\n+  }\n+\n+  @Test\n+  public void httpStatusCodeTagMatchesResponse_onException_async() throws Exception {\n+    httpStatusCodeTagMatchesResponse_onException(\"/exceptionAsync\");\n+  }\n+\n+  Span httpStatusCodeTagMatchesResponse_onException(String path) throws Exception {\n+    Response response = get(path);\n+\n+    Span span = takeSpan();\n+    assertThat(span.tags())\n+      .containsEntry(\"http.status_code\", String.valueOf(response.code()));\n+\n+    return span;\n+  }\n+\n   @Test\n-  public void reportsSpanOnException() throws Exception {\n-    reportsSpanOnException(\"/exception\");\n+  public void errorTag_exceptionOverridesHttpStatus() throws Exception {\n+    errorTag_exceptionOverridesHttpStatus(\"/exception\");\n   }\n \n   @Test\n-  public void reportsSpanOnException_async() throws Exception {\n-    reportsSpanOnException(\"/exceptionAsync\");\n+  public void errorTag_exceptionOverridesHttpStatus_async() throws Exception {\n+    errorTag_exceptionOverridesHttpStatus(\"/exceptionAsync\");\n   }\n \n-  Span reportsSpanOnException(String path) throws Exception {\n+  void errorTag_exceptionOverridesHttpStatus(String path) throws Exception {\n     get(path);\n \n-    return takeSpan();\n+    Span span = takeSpan();\n+    assertThat(span.tags().get(\"error\"))\n+      .contains(\"not ready\"); // some controllers format the exception", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3OTM5NA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381279394", "bodyText": "this was a lot of time lost trying to figure out where it clobbers the code, only in sync errors, not async ones! :P", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:10:33Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITServlet25Container.java", "diffHunk": "@@ -71,9 +77,13 @@\n   }\n \n   static class ExceptionServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n-      throw new IOException(); // null exception message!\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+      throws UnavailableException {\n+      // Change the status from 500 to 503\n+      req.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, 503);\n+      // TODO: org.eclipse.jetty.server.HttpChannelState.onError() clobbers ^^ and hard-codes", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4MDIwOQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381280209", "bodyText": "I have seen some tests out there that say they are testing onError when they are really testing timeout. beware!\nbelow, I prove onError works by switching the http status", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:12:11Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITServlet3Container.java", "diffHunk": "@@ -30,59 +34,88 @@\n public abstract class ITServlet3Container extends ITServlet25Container {\n   static ExecutorService executor = Executors.newCachedThreadPool();\n \n-  @AfterClass\n-  public static void shutdownExecutor() {\n-    executor.shutdownNow();\n+  public ITServlet3Container() {\n+    super(new Jetty9ServerController());\n   }\n \n-  static class AsyncServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n-      if (Tracing.currentTracer().currentSpan() == null) {\n-        throw new IllegalStateException(\"couldn't read current span!\");\n-      }\n-      AsyncContext ctx = req.startAsync();\n-      ctx.start(ctx::complete);\n-    }\n+  @AfterClass public static void shutdownExecutor() {\n+    executor.shutdownNow();\n   }\n \n-  @Test\n-  public void forward() throws Exception {\n+  @Test public void forward() throws Exception {\n     get(\"/forward\");\n \n     takeSpan();\n   }\n \n-  @Test\n-  public void forwardAsync() throws Exception {\n+  @Test public void forwardAsync() throws Exception {\n     get(\"/forwardAsync\");\n \n     takeSpan();\n   }\n \n   static class ForwardServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n       throws ServletException, IOException {\n       req.getServletContext().getRequestDispatcher(\"/foo\").forward(req, resp);\n     }\n   }\n \n   static class AsyncForwardServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n       AsyncContext asyncContext = req.startAsync(req, resp);\n       executor.execute(() -> asyncContext.dispatch(\"/async\"));\n     }\n   }\n \n+  static class AsyncServlet extends HttpServlet {\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+      if (Tracing.currentTracer().currentSpan() == null) {\n+        throw new IllegalStateException(\"couldn't read current span!\");\n+      }\n+      AsyncContext ctx = req.startAsync();\n+      ctx.start(ctx::complete);\n+    }\n+  }\n+\n   static class ExceptionAsyncServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+      if (DispatcherType.ERROR.equals(req.getDispatcherType())) return; // don't loop\n+\n+      AsyncContext async = req.startAsync();\n+      // unless we add a listener, the onError hook will never occur", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4MDY1NA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381280654", "bodyText": "jetty 7 and 9 don't like eachother.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:13:05Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/Jetty9ServerController.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.test.http;\n+\n+import brave.test.http.ServletContainer.ServerController;\n+import org.eclipse.jetty.server.Connector;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+\n+public final class Jetty9ServerController implements ServerController {", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NDEyNw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381284127", "bodyText": "this magically became needed when I upgraded from jetty 8 to 9.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:20:05Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/HttpServletResponseWrapper.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.servlet;\n+\n+import brave.http.HttpServerResponse;\n+import brave.internal.Nullable;\n+import brave.servlet.internal.ServletRuntime;\n+import javax.servlet.UnavailableException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import static brave.servlet.internal.ServletRuntime.maybeError;\n+\n+/**\n+ * This delegates to {@link HttpServletResponse} methods, taking care to portably handle {@link\n+ * #statusCode()}.\n+ *\n+ * @since 5.10\n+ */\n+// Public for use in sparkjava or other frameworks that re-use servlet types\n+public class HttpServletResponseWrapper extends HttpServerResponse { // not final for inner subtype\n+  /**\n+   * Looks for the {@link HttpServletRequest#setAttribute(String, Object) request attributes}\n+   * \"http.route\" and \"error\" to customize the result.\n+   *\n+   * @param caught an exception caught serving the request.\n+   * @since 5.10\n+   */\n+  public static HttpServerResponse create(@Nullable HttpServletRequest req,\n+    HttpServletResponse res, @Nullable Throwable caught) {\n+    if (req == null) return new HttpServletResponseWrapper(res, caught);\n+    return new WithRequestProperties(req, res, caught);\n+  }\n+\n+  final HttpServletResponse delegate;\n+  @Nullable final Throwable caught;\n+\n+  HttpServletResponseWrapper(HttpServletResponse delegate, @Nullable Throwable caught) {\n+    if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+    this.delegate = delegate;\n+    this.caught = caught;\n+  }\n+\n+  @Override public int statusCode() {\n+    int result = ServletRuntime.get().status(delegate);\n+    if (caught != null && result == 200) { // We may have a potentially bad status due to defaults", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTI5Mw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381285293", "bodyText": "This stuff addresses #851 thanks @nicmunroe @felixbarny @eyalkoren", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:22:23Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java", "diffHunk": "@@ -91,43 +92,54 @@ private static ServletRuntime findServletRuntime() {\n     }\n \n     @Override public void handleAsync(\n-      HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n       HttpServletRequest request, HttpServletResponse response, Span span) {\n       if (span.isNoop()) return; // don't add overhead when we aren't httpTracing\n       TracingAsyncListener listener = new TracingAsyncListener(handler, span);\n       request.getAsyncContext().addListener(listener, request, response);\n     }\n \n     static final class TracingAsyncListener implements AsyncListener {\n-      final HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler;\n+      final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n-      volatile boolean complete; // multiple async events can occur, only complete once\n+      final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n+      final AtomicBoolean timeout = new AtomicBoolean(); // multiple timeout events can occur\n \n       TracingAsyncListener(\n-        HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+        HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n         this.span = span;\n       }\n \n       @Override public void onComplete(AsyncEvent e) {\n-        if (complete) return;\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!complete.compareAndSet(false, true)) return; // already completed\n+        HttpServletRequest req = (HttpServletRequest) e.getSuppliedRequest();\n+        HttpServletResponse res = (HttpServletResponse) e.getSuppliedResponse();\n+        HttpServerResponse response =\n+          brave.servlet.HttpServletResponseWrapper.create(req, res, e.getThrowable());\n+        handler.handleSend(response, response.error(), span);\n       }\n \n+      // Per Servlet 3 section 2.3.3.3, we can't see the final HTTP status, yet. defer to onComplete", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTczMg==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381285732", "bodyText": "I noticed timeout hitting many times in the same request, but I might double-check this before merge.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:23:14Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java", "diffHunk": "@@ -91,43 +92,54 @@ private static ServletRuntime findServletRuntime() {\n     }\n \n     @Override public void handleAsync(\n-      HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n       HttpServletRequest request, HttpServletResponse response, Span span) {\n       if (span.isNoop()) return; // don't add overhead when we aren't httpTracing\n       TracingAsyncListener listener = new TracingAsyncListener(handler, span);\n       request.getAsyncContext().addListener(listener, request, response);\n     }\n \n     static final class TracingAsyncListener implements AsyncListener {\n-      final HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler;\n+      final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n-      volatile boolean complete; // multiple async events can occur, only complete once\n+      final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n+      final AtomicBoolean timeout = new AtomicBoolean(); // multiple timeout events can occur\n \n       TracingAsyncListener(\n-        HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+        HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n         this.span = span;\n       }\n \n       @Override public void onComplete(AsyncEvent e) {\n-        if (complete) return;\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!complete.compareAndSet(false, true)) return; // already completed\n+        HttpServletRequest req = (HttpServletRequest) e.getSuppliedRequest();\n+        HttpServletResponse res = (HttpServletResponse) e.getSuppliedResponse();\n+        HttpServerResponse response =\n+          brave.servlet.HttpServletResponseWrapper.create(req, res, e.getThrowable());\n+        handler.handleSend(response, response.error(), span);\n       }\n \n+      // Per Servlet 3 section 2.3.3.3, we can't see the final HTTP status, yet. defer to onComplete\n+      // https://download.oracle.com/otndocs/jcp/servlet-3.0-mrel-eval-oth-JSpec/\n       @Override public void onTimeout(AsyncEvent e) {\n-        if (complete) return;\n-        span.tag(\"error\", String.format(\"Timed out after %sms\", e.getAsyncContext().getTimeout()));\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!timeout.compareAndSet(false, true)) return; // already timed out", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMDY1NA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381630654", "bodyText": "we weren't and what we are doing in this callback isn't worth guarding", "author": "codefromthecrypt", "createdAt": "2020-02-20T00:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTczMg=="}], "type": "inlineReview"}, {"oid": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "url": "https://github.com/openzipkin/brave/commit/5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "message": "polishing", "committedDate": "2020-02-20T00:26:55Z", "type": "forcePushed"}, {"oid": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "url": "https://github.com/openzipkin/brave/commit/9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "message": "Introduces `Response.error()` and uses it in HTTP abstraction\n\nThis introduces `Response.error()`, present when there was an exception\ninvoking a client request, or processing a server request. This also\nensures that `FinishedSpanHandler` can read it independently of the\n\"error\" tag.\n\nThis implied retro-fitting this in the HTTP abstraction and backfilling\ntests that tell the difference between HTTP status and a parsed\nexception. This identified a gap in Servlet libraries which formerly\nswallowed application level exceptions. To bridge that gap, we now\nlook at the request attribute \"error\" when ending a server span.", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "b29bae0fe830385230e1266a64c2bc95421492ef", "url": "https://github.com/openzipkin/brave/commit/b29bae0fe830385230e1266a64c2bc95421492ef", "message": "also async eats it", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "79cd5099f3030c1ca2a3e52074db59e76b540578", "url": "https://github.com/openzipkin/brave/commit/79cd5099f3030c1ca2a3e52074db59e76b540578", "message": "spark over servlet needs work", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "da68ac4e8171c496fdeac3be46f50ada43db4ebb", "url": "https://github.com/openzipkin/brave/commit/da68ac4e8171c496fdeac3be46f50ada43db4ebb", "message": "because we love dates", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "6c41602c8e9d096ceeb301a8493e0fdd2d417b1c", "url": "https://github.com/openzipkin/brave/commit/6c41602c8e9d096ceeb301a8493e0fdd2d417b1c", "message": "spark bug", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "ef72f0cf2e5a7a966d840978ba876ee1e8ce5769", "url": "https://github.com/openzipkin/brave/commit/ef72f0cf2e5a7a966d840978ba876ee1e8ce5769", "message": "Update brave/src/main/java/brave/Response.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "97417231534db67ce204cd7819029bbb1f9aee7e", "url": "https://github.com/openzipkin/brave/commit/97417231534db67ce204cd7819029bbb1f9aee7e", "message": "feedback", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "af16e223a4dbadd9ff5bf71c2ca50b9a63bb1fc2", "url": "https://github.com/openzipkin/brave/commit/af16e223a4dbadd9ff5bf71c2ca50b9a63bb1fc2", "message": "feedback", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"oid": "4fe976c36420845ed84791c140a3fa97d579cc29", "url": "https://github.com/openzipkin/brave/commit/4fe976c36420845ed84791c140a3fa97d579cc29", "message": "immense pain caused by asserting we don't return garbage", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"oid": "01f5285815f1c9685ec5fd8370b49f7753f1ac0c", "url": "https://github.com/openzipkin/brave/commit/01f5285815f1c9685ec5fd8370b49f7753f1ac0c", "message": "v is for vertx", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"oid": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "url": "https://github.com/openzipkin/brave/commit/5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "message": "polishing", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMTE1NQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381631155", "bodyText": "@nicmunroe @felixbarny PS I did something special to execute the entire suite and fail if this ever was the case.. it never was. Right now, I know I've been told this could be re-entrant, but I'd like to see what test we are missing. Or if any of you have a test that proves it is re-entrant?", "author": "codefromthecrypt", "createdAt": "2020-02-20T00:48:03Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java", "diffHunk": "@@ -91,43 +92,55 @@ private static ServletRuntime findServletRuntime() {\n     }\n \n     @Override public void handleAsync(\n-      HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n       HttpServletRequest request, HttpServletResponse response, Span span) {\n       if (span.isNoop()) return; // don't add overhead when we aren't httpTracing\n       TracingAsyncListener listener = new TracingAsyncListener(handler, span);\n       request.getAsyncContext().addListener(listener, request, response);\n     }\n \n     static final class TracingAsyncListener implements AsyncListener {\n-      final HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler;\n+      final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n-      volatile boolean complete; // multiple async events can occur, only complete once\n+      final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n \n-      TracingAsyncListener(\n-        HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      TracingAsyncListener(HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n         this.span = span;\n       }\n \n       @Override public void onComplete(AsyncEvent e) {\n-        if (complete) return;\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!complete.compareAndSet(false, true)) {\n+          // TODO: None of our tests reach this condition. Make a concrete case that re-enters the", "originalCommit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNzcwOA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r382707708", "bodyText": "@adriancole I can't remember if I've ever seen it be reentrant in practice. But it's servlet, so my cynical side says it's always possible. Even if you find something in the servlet spec that says impls shouldn't do it, I bet there's some framework that does either due to a bug or because they didn't realize they shouldn't or they feel like they have a use case that warrants it. That's all FUD - I don't have any concrete examples. But I wouldn't be surprised in the least. The question is whether it's worth the extra bulletproofing if we can't find a way to reproduce it. I don't have a good answer on that one.\nSo I don't really have any advice on this one, sorry. I think there are defensible arguments for going either way.", "author": "nicmunroe", "createdAt": "2020-02-21T17:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MjAwMA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r382862000", "bodyText": "Thanks for the feedback Nic! in our case, the only impact to doing this twice is overhead, because this is on the finish hook not the start hook (eg it won't leak a span). In this case, and as I can't reproduce it normally, I'm inclined to remove the bullet-proofing, maybe mentioning that there's no impact to calling twice (and a test to prove it)", "author": "codefromthecrypt", "createdAt": "2020-02-22T00:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMTE1NQ=="}], "type": "inlineReview"}, {"oid": "75369c851637b43c1ef5b3a7a3874469569c8869", "url": "https://github.com/openzipkin/brave/commit/75369c851637b43c1ef5b3a7a3874469569c8869", "message": "hardens http client tests", "committedDate": "2020-02-20T03:29:46Z", "type": "commit"}]}