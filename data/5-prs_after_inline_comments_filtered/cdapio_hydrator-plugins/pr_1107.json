{"pr_number": 1107, "pr_title": "CDAP-16895 use new aggregator api", "pr_createdAt": "2020-06-07T10:45:37Z", "pr_url": "https://github.com/cdapio/hydrator-plugins/pull/1107", "timeline": [{"oid": "59c990c12caa7cfa72a9b3e641b8d5a3ffafe239", "url": "https://github.com/cdapio/hydrator-plugins/commit/59c990c12caa7cfa72a9b3e641b8d5a3ffafe239", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-07T10:46:03Z", "type": "forcePushed"}, {"oid": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "url": "https://github.com/cdapio/hydrator-plugins/commit/f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-07T10:50:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNTA1OQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436905059", "bodyText": "if the input schema is null, moving this check down will cause the validation to be skipped.", "author": "albertshau", "createdAt": "2020-06-08T18:22:06Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/DedupAggregator.java", "diffHunk": "@@ -87,6 +84,13 @@ public void configurePipeline(PipelineConfigurer pipelineConfigurer) {\n     Schema outputSchema = getOutputSchema(inputSchema);\n     FailureCollector collector = stageConfigurer.getFailureCollector();\n     validateSchema(outputSchema, uniqueFields, functionInfo, collector);\n+\n+    if (functionInfo != null) {", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDYyMw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437080623", "bodyText": "If input schema is null, then this check cannot be performed, since the function will require a field schema to start with, passing a null to it just doesn't make sense.", "author": "yaojiefeng", "createdAt": "2020-06-09T01:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwODIyNQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436908225", "bodyText": "I'm confused about what is being put in this Table. Whatever object this is needs to be Serializable right? Does this work properly?", "author": "albertshau", "createdAt": "2020-06-08T18:27:52Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/GroupByAggregator.java", "diffHunk": "@@ -174,26 +179,50 @@ public void groupBy(StructuredRecord record, Emitter<StructuredRecord> emitter)\n   }\n \n   @Override\n-  public void aggregate(StructuredRecord groupKey, Iterator<StructuredRecord> iterator,\n-                        Emitter<StructuredRecord> emitter) throws Exception {\n-    if (!iterator.hasNext()) {\n-      return;\n+  public Table<String, String, Object> initializeAggregateValue(StructuredRecord record) {\n+    Table<String, String, Object> table = HashBasedTable.create();\n+    table.put(SCHEMA, \"\", record.getSchema());", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjk2Nw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436916967", "bodyText": "after reading some more, it seems like a proper object here would be better, would make it more clear what is happening instead of using special keys.", "author": "albertshau", "createdAt": "2020-06-08T18:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwODIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwOTI5OQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436909299", "bodyText": "I'm confused about what is in this Table.", "author": "albertshau", "createdAt": "2020-06-08T18:29:58Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/AggregateFunction.java", "diffHunk": "@@ -16,27 +16,46 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * Performs an aggregation. For each group that needs an aggregate to be calculated, the {@link #beginFunction()}\n- * method is called first. After that, one or more calls to {@link #operateOn(StructuredRecord)} are made, one call for\n- * each value in the group. Finally, {@link #getAggregate()} is called to retrieve the aggregate.\n- *\n- * todo: convert this to a plugin\n+ * Performs an aggregation.\n  *\n  * @param <T> type of aggregate value\n  */\n-public interface AggregateFunction<T> extends RecordFunctionLifecycle {\n+public interface AggregateFunction<T> {\n+\n+  /**\n+   * Merge the given record to the aggregated collection. This function is guaranteed to get called at least once\n+   * before {@link #mergeAggregates(Table, Table)} is called.\n+   *\n+   * @param agg the aggregated collection, the merged result should be added to it\n+   * @param record the record to merge\n+   */\n+  void mergeValue(Table<String, String, Object> agg, StructuredRecord record);", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNzM5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436927390", "bodyText": "After reading some more it seems like it's used to carry intermediate data? Using Table as the intermediate data makes things harder to understand and maintain because it's not clear what is in the Table.\nIt seems like it would be better for each individual function to be able to decide what reduced data it needs to keep track of, using an actual object instead of a Table or a Map with special keys.", "author": "albertshau", "createdAt": "2020-06-08T19:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwOTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNjMxMA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436926310", "bodyText": "ok so it looks like Table is used to prevent conflicts between fields in the group key and intermediate data?\nIt seems like it would be better to have a separate class that contains the group key as a field along with any additional fields that are required.", "author": "albertshau", "createdAt": "2020-06-08T19:00:48Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Avg.java", "diffHunk": "@@ -38,32 +43,45 @@ public Avg(String fieldName, Schema fieldSchema) {\n         \"Cannot compute avg on field %s because its type %s is not numeric\", fieldName, fieldType));\n     }\n \n+    // the avg is null only if the field value is always null\n     outputSchema = isNullable ? Schema.nullableOf(Schema.of(Schema.Type.DOUBLE)) : Schema.of(Schema.Type.DOUBLE);\n   }\n \n   @Override\n-  public void beginFunction() {\n-    avg = 0d;\n-    count = 0d;\n+  public void mergeValue(Table<String, String, Object> agg, StructuredRecord record) {\n+    Object val = record.get(fieldName);\n+    if (val == null) {\n+      return;\n+    }\n+    computeAvg(agg, 1L, (Number) val);\n   }\n \n   @Override\n-  public void operateOn(StructuredRecord record) {\n-    Object val = record.get(fieldName);\n+  public void mergeAggregates(Table<String, String, Object> agg1, Table<String, String, Object> agg2) {\n+    Object val = agg2.get(fieldName, AGG_KEY);\n     if (val == null) {\n       return;\n     }\n-    count++;\n-    avg = avg + (((Number) val).doubleValue() - avg) / count;\n+    Long agg2Count = (Long) agg2.get(fieldName, AGG_COUNT_KEY);\n+    computeAvg(agg1, agg2Count, (Number) val);\n   }\n \n-  @Override\n-  public Double getAggregate() {\n-    if (count == 0) {\n-      // only happens if the field value was always null\n-      return null;\n+  private void computeAvg(Table<String, String, Object> table, long deltaCount, Number oldAvg) {\n+    if (!table.contains(fieldName, AGG_KEY)) {", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNjg4NA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436936884", "bodyText": "typo", "author": "albertshau", "createdAt": "2020-06-08T19:11:51Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Stddev.java", "diffHunk": "@@ -16,51 +16,50 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n import io.cdap.plugin.batch.aggregator.AggregationUtils;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Calculates the Standard Deviation\n  */\n public class Stddev implements AggregateFunction<Double> {\n-  private final String fieldName;\n-  private final Schema outputSchema;\n-  private RunningStats stats;\n+  private final AggregateFunction<Double> variance;\n \n   public Stddev(String fieldName, Schema fieldSchema) {\n-    this.fieldName = fieldName;\n-    boolean isNullable = fieldSchema.isNullable();\n-    Schema.Type fieldType = isNullable ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n+    Schema.Type fieldType = fieldSchema.isNullable() ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n     if (!AggregationUtils.isNumericType(fieldType)) {\n       throw new IllegalArgumentException(String.format(\n-        \"Cannot compute standard deviation on field %s because its type %s is not numeric\", fieldName, fieldType));\n+        \"Cannot compute standard devisation on field %s because its type %s is not numeric\", fieldName, fieldType));", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436944226", "bodyText": "I thought the difference between population and sample variance is just the denominator, where one divides by n, and the other by n+1? If you're keeping track of the squared mean and count, it seems like it should be straightforward division?", "author": "albertshau", "createdAt": "2020-06-08T19:18:33Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Variance.java", "diffHunk": "@@ -16,17 +16,28 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n import io.cdap.plugin.batch.aggregator.AggregationUtils;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * Calculates Variance\n+ * Calculates Sample Variance\n+ * TODO: CDAP-16911 figure out a way to compute population variance", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk5MzkyMA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436993920", "bodyText": "Variance doesn't work in this way. The squared mean only makes sense for its own group since the mean and count are accumulated across the data.\nIf you consider following code:\n    count++;\n    double delta = value.doubleValue() - mean;\n    mean += delta / count;  // here the count only makes sense for individual group\n    double delta2 = value.doubleValue() - mean;\n    squareMean += delta * delta2;\n\nFor entire group, we cannot simply add up square mean as the new square mean because the actual square mean should be computed using the actual mean and count across the entire data.", "author": "yaojiefeng", "createdAt": "2020-06-08T20:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0NjMzMQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437046331", "bodyText": "Isn't the population variance just the sample variance * (N-1)/N, where N is the count?", "author": "albertshau", "createdAt": "2020-06-08T22:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1NTQ5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437055490", "bodyText": "Ah, you are right, I thought it is complicated than this, will fix.", "author": "yaojiefeng", "createdAt": "2020-06-08T23:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg=="}], "type": "inlineReview"}, {"oid": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "url": "https://github.com/cdapio/hydrator-plugins/commit/6e44efc1e5dd1615a0a78138c20a75dff840d542", "message": "get rid of table", "committedDate": "2020-06-09T17:28:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODI1Mw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437638253", "bodyText": "I think these were originally done so that we don't do an extra comparison on type for every record. I don't think it actually matters much from a performance perspective, don't imagine this was a bottleneck in any way. Are we just changing it for readability?", "author": "albertshau", "createdAt": "2020-06-09T18:35:55Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Min.java", "diffHunk": "@@ -16,80 +16,54 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n-import javax.annotation.Nullable;\n-\n /**\n  * Calculates minimum values of a field in a group.\n  */\n-public class Min extends NumberFunction {\n-  private Integer minInt;\n-  private Long minLong;\n-  private Float minFloat;\n-  private Double minDouble;\n+public class Min extends NumberFunction<Min> {\n \n-  public Min(String fieldName, @Nullable Schema fieldSchema) {\n+  public Min(String fieldName, Schema fieldSchema) {\n     super(fieldName, fieldSchema);\n   }\n \n   @Override\n-  protected void startInt() {\n-    minInt = null;\n-  }\n-\n-  @Override\n-  protected void startLong() {\n-    minLong = null;\n+  public void mergeValue(StructuredRecord record) {\n+    combine(record.get(fieldName));\n   }\n \n   @Override\n-  protected void startFloat() {\n-    minFloat = null;\n+  public void mergeAggregates(Min otherAgg) {\n+    combine(otherAgg.getAggregate());\n   }\n \n-  @Override\n-  protected void startDouble() {\n-    minDouble = null;\n-  }\n-\n-  @Override\n-  protected void updateInt(int val) {", "originalCommit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0MjQ3NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437642475", "bodyText": "Yes, the original class is really hard to understand and it creates delegates to make sure the correct function is called. Since this is just a simple comparison, I want to remove it for better readability.", "author": "yaojiefeng", "createdAt": "2020-06-09T18:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODg5NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437638895", "bodyText": "there used to be null handling before, how come it is being removed? Was that actually never supported?", "author": "albertshau", "createdAt": "2020-06-09T18:37:11Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java", "diffHunk": "@@ -19,172 +19,57 @@\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n /**\n  * Base class for number based selection functions.\n  * Allows subclasses to implement typed methods instead of implementing their own casting logic.\n  * Guarantees that only methods for one type will be called for each aggregate. For example,\n- * if {@link #operateOn(StructuredRecord)} is called, only {@link #operateOnInt(int, StructuredRecord)} will be called.\n+ * if {@link #select(StructuredRecord, StructuredRecord)} is called,\n+ * only {@link #combineInt(int, int)} will be called.\n  */\n public abstract class NumberSelection implements SelectionFunction {\n-  private final SelectionFunction delegate;\n   private final String fieldName;\n+  private final Schema.Type fieldType;\n \n-  public NumberSelection(final String fieldName, @Nullable Schema fieldSchema) {\n+  public NumberSelection(String fieldName, Schema fieldSchema) {\n     this.fieldName = fieldName;\n-    // if schema is not known before we start getting records, just use doubles.", "originalCommit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0Mzc2NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437643765", "bodyText": "By default it uses double to handle null, but a null schema scenario actually doesn't exist. If a field does not exist, the validation should fail. If a field does exist, then it has to have a field schema. Previously this was mainly used to validate and unit test that a null schema can fetch the result, so I removed this.", "author": "yaojiefeng", "createdAt": "2020-06-09T18:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzOTQ1MQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437639451", "bodyText": "these methods should be called 'compare' instead of 'combine', and they should all return an int.", "author": "albertshau", "createdAt": "2020-06-09T18:38:12Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java", "diffHunk": "@@ -19,172 +19,57 @@\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n /**\n  * Base class for number based selection functions.\n  * Allows subclasses to implement typed methods instead of implementing their own casting logic.\n  * Guarantees that only methods for one type will be called for each aggregate. For example,\n- * if {@link #operateOn(StructuredRecord)} is called, only {@link #operateOnInt(int, StructuredRecord)} will be called.\n+ * if {@link #select(StructuredRecord, StructuredRecord)} is called,\n+ * only {@link #combineInt(int, int)} will be called.\n  */\n public abstract class NumberSelection implements SelectionFunction {\n-  private final SelectionFunction delegate;\n   private final String fieldName;\n+  private final Schema.Type fieldType;\n \n-  public NumberSelection(final String fieldName, @Nullable Schema fieldSchema) {\n+  public NumberSelection(String fieldName, Schema fieldSchema) {\n     this.fieldName = fieldName;\n-    // if schema is not known before we start getting records, just use doubles.\n-    if (fieldSchema == null) {\n-      delegate = new SelectionFunction() {\n-        @Override\n-        public List<StructuredRecord> getSelectedRecords() {\n-          return getRecords();\n-        }\n+    this.fieldType = fieldSchema.isNullable() ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n+  }\n \n-        @Override\n-        public void beginFunction() {\n-          startDouble();\n-        }\n+  protected abstract int combineInt(int val1, int val2);\n \n-        @Override\n-        public void operateOn(StructuredRecord record) {\n-          Number number = record.get(fieldName);\n-          if (number != null) {\n-            operateOnDouble(number.doubleValue(), record);\n-          }\n-        }\n-      };\n-      return;\n-    }\n+  protected abstract long combineLong(long val1, long val2);\n \n-    final boolean isNullable = fieldSchema.isNullable();\n-    Schema.Type fieldType = isNullable ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n-    switch (fieldType) {\n-      case INT:\n-        delegate = new SelectionFunction() {\n-          @Override\n-          public List<StructuredRecord> getSelectedRecords() {\n-            return getRecords();\n-          }\n+  protected abstract float combineFloat(float val1, float val2);", "originalCommit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0NTg5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437645890", "bodyText": "good catch, the implementation is based on compare, I forgot to change this.", "author": "yaojiefeng", "createdAt": "2020-06-09T18:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzOTQ1MQ=="}], "type": "inlineReview"}, {"oid": "bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "url": "https://github.com/cdapio/hydrator-plugins/commit/bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-09T18:56:00Z", "type": "commit"}, {"oid": "bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "url": "https://github.com/cdapio/hydrator-plugins/commit/bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-09T18:56:00Z", "type": "forcePushed"}]}