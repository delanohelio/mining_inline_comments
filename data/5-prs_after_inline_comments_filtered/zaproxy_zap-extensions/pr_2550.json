{"pr_number": 2550, "pr_title": "GraphQL Add-On Updates", "pr_createdAt": "2020-09-23T19:43:32Z", "pr_url": "https://github.com/zaproxy/zap-extensions/pull/2550", "timeline": [{"oid": "d2a3b32395c4217a181cd7e69d46f84c34419af6", "url": "https://github.com/zaproxy/zap-extensions/commit/d2a3b32395c4217a181cd7e69d46f84c34419af6", "message": "Add Helper Class for Inline Arguments Injection\n\n- Add helper class InlineInjector for inline\narguments injection using script input vectors.\n- Add unit tests for this class.\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-23T19:54:21Z", "type": "forcePushed"}, {"oid": "53903b2cf0a1c3407760fa2d3eee787ae1fcefc7", "url": "https://github.com/zaproxy/zap-extensions/commit/53903b2cf0a1c3407760fa2d3eee787ae1fcefc7", "message": "Add Helper Class for Inline Arguments Injection\n\n- Add helper class InlineInjector for inline\narguments injection using script input vectors.\n- Add unit tests for this class.\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-24T05:06:17Z", "type": "forcePushed"}, {"oid": "c2944aa522b0d9e76e0a44ec06f5bc7079126d17", "url": "https://github.com/zaproxy/zap-extensions/commit/c2944aa522b0d9e76e0a44ec06f5bc7079126d17", "message": "Fix NPEs during Spidering\n\n- Add null check for the Content-Type Header\nin MessageValidator\n- Add a unit test for the null check\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-25T17:08:47Z", "type": "forcePushed"}, {"oid": "87467f87e57307caf169159a37f321ab0096cda3", "url": "https://github.com/zaproxy/zap-extensions/commit/87467f87e57307caf169159a37f321ab0096cda3", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-30T11:14:53Z", "type": "forcePushed"}, {"oid": "5b2c53efe260c96c24d06d58b9d5e9d202c5f93b", "url": "https://github.com/zaproxy/zap-extensions/commit/5b2c53efe260c96c24d06d58b9d5e9d202c5f93b", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-30T13:18:25Z", "type": "forcePushed"}, {"oid": "84e114191641dc4575d86429a161f44042400732", "url": "https://github.com/zaproxy/zap-extensions/commit/84e114191641dc4575d86429a161f44042400732", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-30T18:46:17Z", "type": "forcePushed"}, {"oid": "0ddf02e7314d4fcbd89171c9bfa6f5561eab3245", "url": "https://github.com/zaproxy/zap-extensions/commit/0ddf02e7314d4fcbd89171c9bfa6f5561eab3245", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-09-30T21:08:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTI5Ng==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r498421296", "bodyText": "@psiinon / @thc202 is there a core constant or something that would be handier for add-ons (vs. hard coding the path)?", "author": "kingthorin", "createdAt": "2020-10-01T17:56:24Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/ExtensionGraphQl.java", "diffHunk": "@@ -165,6 +181,33 @@ private void stopParserThreads() {\n         parserThreads.clear();\n     }\n \n+    private void addScript() throws IOException {\n+        ExtensionScript extScript =\n+                Control.getSingleton().getExtensionLoader().getExtension(ExtensionScript.class);\n+        if (extScript != null) {\n+            ScriptType variantType =\n+                    extScript.getScriptType(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+            ScriptEngineWrapper engine =\n+                    extScript.getEngineWrapper(\n+                            Constant.messages.getString(\"graphql.script.engine\"));\n+            if (variantType != null && engine != null) {\n+                String scriptName = Constant.messages.getString(\"graphql.script.name\");\n+                File scriptPath =\n+                        new File(Constant.getZapHome(), \"scripts/scripts/variant/\" + scriptName);", "originalCommit": "0ddf02e7314d4fcbd89171c9bfa6f5561eab3245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMyMDE1NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503320155", "bodyText": "Core provides several constants, e.g.:\nPaths.get(Constant.getZapHome(), ExtensionScript.SCRIPTS_DIR, ExtensionScript.SCRIPTS_DIR, ExtensionActiveScan.SCRIPT_TYPE_VARIANT, scriptName).toFile()", "author": "thc202", "createdAt": "2020-10-12T14:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTI5Ng=="}], "type": "inlineReview"}, {"oid": "6003f56910995270df0db064f423a2e006076a18", "url": "https://github.com/zaproxy/zap-extensions/commit/6003f56910995270df0db064f423a2e006076a18", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n- Add null check for import message in Introspection\n- Reduce Log Level for the Requestor\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-10-12T13:53:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMzE0OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503333148", "bodyText": "Does not seem to be used?", "author": "thc202", "createdAt": "2020-10-12T14:26:33Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/ExtensionGraphQl.java", "diffHunk": "@@ -60,6 +65,7 @@\n     private static final int ARG_IMPORT_FILE_IDX = 0;\n     private static final int ARG_IMPORT_URL_IDX = 1;\n     private static final int ARG_END_URL_IDX = 2;\n+    private static final String FIELD_ENGINE = \"scripts.dialog.script.label.engine\";", "originalCommit": "6003f56910995270df0db064f423a2e006076a18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMzQ5NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503333495", "bodyText": "&& extScript.getScript(scriptName) == null", "author": "thc202", "createdAt": "2020-10-12T14:27:02Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/ExtensionGraphQl.java", "diffHunk": "@@ -165,6 +181,33 @@ private void stopParserThreads() {\n         parserThreads.clear();\n     }\n \n+    private void addScript() throws IOException {\n+        ExtensionScript extScript =\n+                Control.getSingleton().getExtensionLoader().getExtension(ExtensionScript.class);\n+        if (extScript != null) {", "originalCommit": "6003f56910995270df0db064f423a2e006076a18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMzYzMw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503333633", "bodyText": "Might be better to hardcode, otherwise the user might end up with several scripts (e.g. when changing language).", "author": "thc202", "createdAt": "2020-10-12T14:27:11Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/ExtensionGraphQl.java", "diffHunk": "@@ -165,6 +181,33 @@ private void stopParserThreads() {\n         parserThreads.clear();\n     }\n \n+    private void addScript() throws IOException {\n+        ExtensionScript extScript =\n+                Control.getSingleton().getExtensionLoader().getExtension(ExtensionScript.class);\n+        if (extScript != null) {\n+            ScriptType variantType =\n+                    extScript.getScriptType(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+            ScriptEngineWrapper engine =\n+                    extScript.getEngineWrapper(\n+                            Constant.messages.getString(\"graphql.script.engine\"));\n+            if (variantType != null && engine != null) {\n+                String scriptName = Constant.messages.getString(\"graphql.script.name\");", "originalCommit": "6003f56910995270df0db064f423a2e006076a18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMzc5OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503333798", "bodyText": "The engine name can be hardcoded.", "author": "thc202", "createdAt": "2020-10-12T14:27:27Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/ExtensionGraphQl.java", "diffHunk": "@@ -165,6 +181,33 @@ private void stopParserThreads() {\n         parserThreads.clear();\n     }\n \n+    private void addScript() throws IOException {\n+        ExtensionScript extScript =\n+                Control.getSingleton().getExtensionLoader().getExtension(ExtensionScript.class);\n+        if (extScript != null) {\n+            ScriptType variantType =\n+                    extScript.getScriptType(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+            ScriptEngineWrapper engine =\n+                    extScript.getEngineWrapper(\n+                            Constant.messages.getString(\"graphql.script.engine\"));", "originalCommit": "6003f56910995270df0db064f423a2e006076a18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzNDA5MA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503334090", "bodyText": "Could check it's null and return to avoid nesting.", "author": "thc202", "createdAt": "2020-10-12T14:27:51Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/GraphQlParser.java", "diffHunk": "@@ -64,21 +64,22 @@ public void introspect() throws IOException {\n                 requestor.sendQuery(\n                         IntrospectionQuery.INTROSPECTION_QUERY,\n                         GraphQlParam.RequestMethodOption.POST_JSON);\n-\n-        try {\n-            Map<String, Object> result =\n-                    new Gson()\n-                            .fromJson(\n-                                    importMessage.getResponseBody().toString(),\n-                                    new TypeToken<Map<String, Object>>() {}.getType());\n-            @SuppressWarnings(\"unchecked\")\n-            Document schema =\n-                    new IntrospectionResultToSchema()\n-                            .createSchemaDefinition((Map<String, Object>) result.get(\"data\"));\n-            String schemaSdl = new SchemaPrinter().print(schema);\n-            parse(schemaSdl);\n-        } catch (JsonSyntaxException e) {\n-            throw new IOException(\"The response was not valid JSON.\");\n+        if (importMessage != null) {", "originalCommit": "6003f56910995270df0db064f423a2e006076a18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzNDc4OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2550#discussion_r503334788", "bodyText": "boolean", "author": "thc202", "createdAt": "2020-10-12T14:28:49Z", "path": "addOns/graphql/src/main/java/org/zaproxy/addon/graphql/InlineInjector.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.addon.graphql;\n+\n+import graphql.language.Argument;\n+import graphql.language.AstPrinter;\n+import graphql.language.Definition;\n+import graphql.language.Document;\n+import graphql.language.Field;\n+import graphql.language.FragmentDefinition;\n+import graphql.language.InlineFragment;\n+import graphql.language.OperationDefinition;\n+import graphql.language.Selection;\n+import graphql.language.Value;\n+import graphql.language.VariableDefinition;\n+import graphql.parser.Parser;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public final class InlineInjector {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public Map<String, String> extract(String query) {\n+        Document document = Parser.parse(query);\n+        HashMap<String, String> nameValueMap = new HashMap<>();\n+        List<Definition> definitions = document.getDefinitions();\n+        for (Definition definition : definitions) {\n+            // For queries, mutations and subscriptions.\n+            if (definition instanceof OperationDefinition) {\n+                OperationDefinition operation = (OperationDefinition) definition;\n+                StringBuilder variableName = new StringBuilder();\n+                if (operation.getName() != null && !operation.getName().isEmpty()) {\n+                    variableName.append(operation.getName()).append('.');\n+                }\n+                for (Selection<?> selection : operation.getSelectionSet().getSelections()) {\n+                    getArguments(selection, nameValueMap, variableName);\n+                }\n+            }\n+            // For fragment spreads.\n+            else if (definition instanceof FragmentDefinition) {\n+                FragmentDefinition fragment = (FragmentDefinition) definition;\n+                StringBuilder variableName = new StringBuilder(fragment.getName()).append('.');\n+                for (Selection<?> selection : fragment.getSelectionSet().getSelections()) {\n+                    getArguments(selection, nameValueMap, variableName);\n+                }\n+            }\n+        }\n+        return nameValueMap;\n+    }\n+\n+    private void getArguments(\n+            Selection<?> selection, Map<String, String> nameValueMap, StringBuilder variableName) {\n+        if (selection instanceof Field) {\n+            Field field = (Field) selection;\n+            variableName.append(field.getName()).append('.');\n+            List<Argument> args = field.getArguments();\n+            if (args != null && !args.isEmpty()) {\n+                for (Argument arg : args) {\n+                    String argName = variableName + arg.getName();\n+                    String argValue = AstPrinter.printAstCompact(arg.getValue());\n+                    nameValueMap.put(argName, argValue);\n+                }\n+            }\n+            if (field.getSelectionSet() != null) {\n+                for (Selection<?> subSelection : field.getSelectionSet().getSelections()) {\n+                    getArguments(subSelection, nameValueMap, variableName);\n+                }\n+            }\n+            variableName.setLength(variableName.length() - field.getName().length() - 1);\n+        } else if (selection instanceof InlineFragment) {\n+            InlineFragment inlineFragment = (InlineFragment) selection;\n+            variableName.append(inlineFragment.getTypeCondition().getName()).append('.');\n+            if (inlineFragment.getSelectionSet() != null) {\n+                for (Selection<?> subSelection : inlineFragment.getSelectionSet().getSelections()) {\n+                    getArguments(subSelection, nameValueMap, variableName);\n+                }\n+            }\n+            variableName.setLength(\n+                    variableName.length()\n+                            - inlineFragment.getTypeCondition().getName().length()\n+                            - 1);\n+        }\n+    }\n+\n+    public String inject(String query, String name, String value) {\n+        Document tempDocument = Parser.parse(query);\n+        // Reparse with AstPrinter.printAstCompact(...) to get the right source location later.\n+        Document document = Parser.parse(AstPrinter.printAstCompact(tempDocument));\n+        StringBuilder queryBuilder = new StringBuilder(AstPrinter.printAstCompact(document));\n+\n+        HashMap<String, String> nameValueMap = new HashMap<>();\n+        String definitionName = name.substring(0, name.indexOf('.'));\n+\n+        // First check fragment spreads.\n+        List<FragmentDefinition> fragments =\n+                document.getDefinitionsOfType(FragmentDefinition.class);\n+        for (FragmentDefinition fragment : fragments) {\n+            if (definitionName.equals(fragment.getName())) {\n+                for (Selection<?> selection : fragment.getSelectionSet().getSelections()) {\n+                    setPayload(\n+                            queryBuilder, selection, name.substring(name.indexOf('.') + 1), value);\n+                }\n+            }\n+        }\n+\n+        // Then check operations.\n+        // Checking operations later to avoid extra / unnecessary computations in some cases.\n+        List<OperationDefinition> operations =\n+                document.getDefinitionsOfType(OperationDefinition.class);\n+        for (OperationDefinition operation : operations) {\n+            if (operation.getName() != null && !operation.getName().isEmpty()) {\n+                if (definitionName.equals(operation.getName())) {\n+                    for (Selection<?> selection : operation.getSelectionSet().getSelections()) {\n+                        setPayload(\n+                                queryBuilder,\n+                                selection,\n+                                name.substring(name.indexOf('.') + 1),\n+                                value);\n+                    }\n+                }\n+            } else {\n+                for (Selection<?> selection : operation.getSelectionSet().getSelections()) {\n+                    setPayload(queryBuilder, selection, name, value);\n+                }\n+            }\n+\n+            // Remove variable definition of injected argument, if it exists.\n+            // This will only work if the query was generated by the add-on.\n+            List<VariableDefinition> vars = operation.getVariableDefinitions();\n+            if (vars != null && !vars.isEmpty()) {\n+                int startPos = vars.get(0).getSourceLocation().getColumn() - 1;\n+                VariableDefinition endVar = vars.get(vars.size() - 1);\n+                int endPos =\n+                        endVar.getSourceLocation().getColumn()\n+                                + AstPrinter.printAstCompact(endVar).length()\n+                                - 1;\n+\n+                String variableName = name.replace('.', '_');\n+                String csVars =\n+                        vars.stream()\n+                                .filter(var -> !variableName.equals(var.getName()))\n+                                .map(var -> AstPrinter.printAstCompact(var))\n+                                .collect(Collectors.joining(\", \"));\n+                if (csVars.isEmpty()) {\n+                    // Remove parantheses and extra whitespace.\n+                    startPos -= 2;\n+                    endPos++;\n+                }\n+                queryBuilder.replace(startPos, endPos, csVars);\n+            }\n+        }\n+\n+        return queryBuilder.toString();\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setPayload(\n+            StringBuilder queryBuilder, Selection<?> selection, String name, String value) {\n+        String selectionName = name.substring(0, name.indexOf('.'));\n+        if (selection instanceof Field) {\n+            Field field = (Field) selection;\n+            if (selectionName.equals(field.getName())) {\n+                List<Argument> args = field.getArguments();\n+                if (args != null && !args.isEmpty()) {\n+                    String argName = name.substring(name.indexOf('.') + 1);\n+                    for (Argument arg : args) {\n+                        if (argName.equals(arg.getName())) {\n+                            Value argValue = arg.getValue();\n+                            // Start Location of argument value.\n+                            int ivStartPos = argValue.getSourceLocation().getColumn() - 1;\n+                            // End Location of argument value.\n+                            int ivEndPos =\n+                                    ivStartPos + AstPrinter.printAstCompact(argValue).length();\n+                            queryBuilder.replace(ivStartPos, ivEndPos, value);\n+                            return;\n+                        }\n+                    }\n+                }\n+                if (field.getSelectionSet() != null) {\n+                    for (Selection<?> subSelection : field.getSelectionSet().getSelections()) {\n+                        setPayload(\n+                                queryBuilder,\n+                                subSelection,\n+                                name.substring(name.indexOf('.') + 1),\n+                                value);\n+                    }\n+                }\n+            }\n+        } else if (selection instanceof InlineFragment) {\n+            InlineFragment inlineFragment = (InlineFragment) selection;\n+            if (selectionName.equals(inlineFragment.getTypeCondition().getName())) {\n+                for (Selection<?> subSelection : inlineFragment.getSelectionSet().getSelections()) {\n+                    setPayload(\n+                            queryBuilder,\n+                            subSelection,\n+                            name.substring(name.indexOf('.') + 1),\n+                            value);\n+                }\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public String getNodeName(String query) {\n+        Document tempDocument = Parser.parse(query);\n+        // Reparse to get the right source location.\n+        Document document = Parser.parse(AstPrinter.printAstCompact(tempDocument));\n+        StringBuilder queryBuilder = new StringBuilder(AstPrinter.printAstCompact(document));\n+        StringBuilder queryPrefix = new StringBuilder();\n+\n+        List<Definition> definitions = document.getDefinitions();\n+        for (int i = definitions.size() - 1; i >= 0; i--) {\n+            Definition definition = definitions.get(i);\n+            if (definition instanceof OperationDefinition) {\n+                OperationDefinition operation = (OperationDefinition) definition;\n+                List<Selection> selections = operation.getSelectionSet().getSelections();\n+                for (int j = selections.size() - 1; j >= 0; j--) {\n+                    removeArgs(queryBuilder, selections.get(j));\n+                }\n+\n+                // Remove variable definitions.\n+                List<VariableDefinition> vars = operation.getVariableDefinitions();\n+                if (vars != null && !vars.isEmpty()) {\n+                    // Add '1' if it has variables.\n+                    queryPrefix.insert(0, 1);\n+\n+                    // -1 for offset, -1 for paranthesis, -1 for whitespace.\n+                    int startPos = vars.get(0).getSourceLocation().getColumn() - 3;\n+                    VariableDefinition endVar = vars.get(vars.size() - 1);\n+                    int endPos =\n+                            endVar.getSourceLocation().getColumn()\n+                                    + AstPrinter.printAstCompact(endVar).length();\n+                    queryBuilder.replace(startPos, endPos, \"\");\n+                } else {\n+                    // Add '0' if it does not have variables.\n+                    queryPrefix.insert(0, 0);\n+                }\n+            } else if (definition instanceof FragmentDefinition) {\n+                FragmentDefinition fragment = (FragmentDefinition) definition;\n+                List<Selection> selections = fragment.getSelectionSet().getSelections();\n+                for (int j = selections.size() - 1; j >= 0; j--) {\n+                    removeArgs(queryBuilder, selections.get(j));\n+                }\n+            }\n+        }\n+\n+        queryBuilder.insert(0, queryPrefix.insert(0, '(').append(\") \"));\n+        return queryBuilder.toString();\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private void removeArgs(StringBuilder queryBuilder, Selection<?> selection) {\n+        if (selection instanceof Field) {\n+            Field field = (Field) selection;\n+            if (field.getSelectionSet() != null) {\n+                List<Selection> subSelections = field.getSelectionSet().getSelections();\n+                for (int i = subSelections.size() - 1; i >= 0; i--) {\n+                    removeArgs(queryBuilder, subSelections.get(i));\n+                }\n+            }\n+            List<Argument> args = field.getArguments();\n+            if (args != null && !args.isEmpty()) {\n+                // -1 for offset, -1 for paranthesis.\n+                int startPos = args.get(0).getSourceLocation().getColumn() - 2;\n+                Argument endArg = args.get(args.size() - 1);\n+                int endPos =\n+                        endArg.getSourceLocation().getColumn()\n+                                + AstPrinter.printAstCompact(endArg).length();\n+                queryBuilder.replace(startPos, endPos, \"\");\n+            }\n+        } else if (selection instanceof InlineFragment) {\n+            InlineFragment inlineFragment = (InlineFragment) selection;\n+            List<Selection> subSelections = inlineFragment.getSelectionSet().getSelections();\n+            for (int i = subSelections.size() - 1; i >= 0; i--) {\n+                removeArgs(queryBuilder, subSelections.get(i));\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public String extractOperations(String query) {\n+        Document document = Parser.parse(query);\n+        List<Definition> definitions = document.getDefinitions();\n+        return definitions.stream()\n+                .filter(defn -> defn instanceof OperationDefinition)\n+                .map(defn -> (OperationDefinition) defn)\n+                .map(OperationDefinition::getOperation)\n+                .map(Object::toString)\n+                .map(s -> s.toLowerCase(Locale.ROOT))\n+                .distinct()\n+                .sorted()\n+                .collect(Collectors.joining(\", \"));\n+    }\n+\n+    public Boolean validateQuery(String query) {", "originalCommit": "6003f56910995270df0db064f423a2e006076a18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2abb9d14a469a8e805dfae06fb440bde1dfc066d", "url": "https://github.com/zaproxy/zap-extensions/commit/2abb9d14a469a8e805dfae06fb440bde1dfc066d", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n- Add null check for import message in Introspection\n- Reduce Log Level for the Requestor\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-10-12T14:38:24Z", "type": "forcePushed"}, {"oid": "a72075311351292c9026616eb6e5da1500859bce", "url": "https://github.com/zaproxy/zap-extensions/commit/a72075311351292c9026616eb6e5da1500859bce", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n- Add help page for the script\n- Add null check for import message in Introspection\n- Reduce Log Level for the Requestor\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-10-12T14:55:03Z", "type": "commit"}, {"oid": "a72075311351292c9026616eb6e5da1500859bce", "url": "https://github.com/zaproxy/zap-extensions/commit/a72075311351292c9026616eb6e5da1500859bce", "message": "GraphQL Add-on Updates\n\n- Fix variable names clash\n- Add Support for Inline Arguments Injection\n\t- Add helper class InlineInjector for inline\n\targuments injection using script input vectors.\n\t- Add unit tests for this class.\n- Fix NPEs during Spidering\n\t- Add null check for the Content-Type Header\n\tin MessageValidator\n\t- Add a unit test for the null check\n- Add Input Vectors Script\n\t- Bundle it with the add-on\n- Add help page for the script\n- Add null check for import message in Introspection\n- Reduce Log Level for the Requestor\n\nSigned-off-by: ricekot <ricekot@gmail.com>", "committedDate": "2020-10-12T14:55:03Z", "type": "forcePushed"}]}