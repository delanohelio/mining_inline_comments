{"pr_number": 2568, "pr_title": "6203: Remove status code check in XXE, extract Local File Reflection and Local File Inclusion", "pr_createdAt": "2020-10-11T13:44:44Z", "pr_url": "https://github.com/zaproxy/zap-extensions/pull/2568", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985622", "bodyText": "Remove, no longer necessary.", "author": "kingthorin", "createdAt": "2020-10-12T00:11:10Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDU0OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820548", "bodyText": "Updated.", "author": "ejayaraman", "createdAt": "2020-10-15T20:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985643", "bodyText": "Go for it \ud83d\ude00", "author": "kingthorin", "createdAt": "2020-10-12T00:11:26Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDczNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820734", "bodyText": "Doc comments included.", "author": "ejayaraman", "createdAt": "2020-10-15T20:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985735", "bodyText": "The blank and comment can be removed, it's in a separate method now, it obviously related to LFI.", "author": "kingthorin", "createdAt": "2020-10-12T00:12:09Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzI3Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505823272", "bodyText": "This has been updated.", "author": "ejayaraman", "createdAt": "2020-10-15T20:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgxNw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985817", "bodyText": "These blanks and comment are no longer necessary.", "author": "kingthorin", "createdAt": "2020-10-12T00:12:52Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985824", "bodyText": "Suggested change", "author": "kingthorin", "createdAt": "2020-10-12T00:12:59Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzc0OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505823748", "bodyText": "This is the one I forgot to remove. I can push another commit for this.", "author": "ejayaraman", "createdAt": "2020-10-15T20:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTg4Nw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit", "author": "kingthorin", "createdAt": "2020-10-12T00:13:33Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTkwNQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "author": "kingthorin", "createdAt": "2020-10-12T00:13:42Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985962", "bodyText": "Go for it.", "author": "kingthorin", "createdAt": "2020-10-12T00:14:00Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNDE1NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505824155", "bodyText": "Doc comments added.", "author": "ejayaraman", "createdAt": "2020-10-15T20:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986021", "bodyText": "Can be private. Will explain further while commenting on the other class.", "author": "kingthorin", "createdAt": "2020-10-12T00:14:37Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNDY1OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505824659", "bodyText": "This is private now, as the tests are using the scan() method.", "author": "ejayaraman", "createdAt": "2020-10-15T20:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE2Ng==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986166", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // msg = getNewMsg();", "author": "kingthorin", "createdAt": "2020-10-12T00:15:24Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE4Mw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986183", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Send message with local file inclusion", "author": "kingthorin", "createdAt": "2020-10-12T00:15:36Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIxNg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986216", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Parse the result", "author": "kingthorin", "createdAt": "2020-10-12T00:15:50Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986227", "bodyText": "Suggested change", "author": "kingthorin", "createdAt": "2020-10-12T00:15:57Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODgzMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505828831", "bodyText": "And another one to remove.", "author": "ejayaraman", "createdAt": "2020-10-15T20:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI3OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit\n          \n          \n            \n                            // Check if the scan has been stopped", "author": "kingthorin", "createdAt": "2020-10-12T00:16:17Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI4OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "author": "kingthorin", "createdAt": "2020-10-12T00:16:26Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjMyNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986324", "bodyText": "Suggested change", "author": "kingthorin", "createdAt": "2020-10-12T00:16:46Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n+            }\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986478", "bodyText": "This seems to be used over and over again, It may as well be extracted to a local method, such as createNanoHandler. Then just used as this.nano.addHandler(createHandler());", "author": "kingthorin", "createdAt": "2020-10-12T00:18:14Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxMzkyMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505813922", "bodyText": "A local method has been created: createNanoHandler", "author": "ejayaraman", "createdAt": "2020-10-15T20:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU0NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986545", "bodyText": "Suggested change", "author": "kingthorin", "createdAt": "2020-10-12T00:18:57Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU2Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986562", "bodyText": "Suggested change", "author": "kingthorin", "createdAt": "2020-10-12T00:19:06Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU4Ng==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986586", "bodyText": "Suggested change", "author": "kingthorin", "createdAt": "2020-10-12T00:19:19Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986700", "bodyText": "The blanks leading // When and // Then throughout can be removed, the comments already delineate things.", "author": "kingthorin", "createdAt": "2020-10-12T00:20:06Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDEwMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814101", "bodyText": "This has been removed now.", "author": "ejayaraman", "createdAt": "2020-10-15T20:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986845", "bodyText": "Is this an intentional mismatch?", "author": "kingthorin", "createdAt": "2020-10-12T00:21:25Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDM4OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814388", "bodyText": "yes, it is. I have added a comment in the test to explain this mismatch.", "author": "ejayaraman", "createdAt": "2020-10-15T20:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987235", "bodyText": "Throughout the new tests the scan method should be used. That ensures none of the payloads are misinterpreted.\nHowever, having the two test methods broken out in the scan rule allows for earlier troubleshooting and maintenance in the future so that was a worthy change (IMHO).", "author": "kingthorin", "createdAt": "2020-10-12T00:24:51Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDYyMw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814623", "bodyText": "Tests have been updated to use the scan method.", "author": "ejayaraman", "createdAt": "2020-10-15T20:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987351", "bodyText": "The number of messages sent should already be being tested as part of the generalized Strength tests.\nEdit: So I believe this one can be removed.", "author": "kingthorin", "createdAt": "2020-10-12T00:25:38Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDc5NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814795", "bodyText": "This has been removed.", "author": "ejayaraman", "createdAt": "2020-10-15T20:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987737", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alertsRaised.get(0).getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n          \n            \n                    Alert alert = alertsRaised.get(0);\n          \n          \n            \n                    assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alert.getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n      \n    \n    \n  \n\nThis likely applies elsewhere as well.", "author": "kingthorin", "createdAt": "2020-10-12T00:28:27Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDk4MQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814981", "bodyText": "This has been updated as well.", "author": "ejayaraman", "createdAt": "2020-10-15T20:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502988269", "bodyText": "This test is an interesting idea, however, I'm not sure it'll behave properly if When is rule.scan and parent.stop() was issued in Given.\n@thc202? @psiinon?", "author": "kingthorin", "createdAt": "2020-10-12T00:32:56Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDIxMA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820210", "bodyText": "This test did started failing after using rule.scan(), but not sure if it is for the same reason you had in mind. The reason it started failing for me was: since localFileInclusionAttack and localFileReflectionAttack has been moved to its own methods, return, when parent.stop() is true, exits only that method and not the scan itself. So I have added another check within the scan() method between attacks to stop scanning when parent.stop() is invoked. This fixed the test.", "author": "ejayaraman", "createdAt": "2020-10-15T20:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MDQzMw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510250433", "bodyText": "I'm not sure we should add it as is, if the scanner is already stopped the scan rule would not have been called (it could happen immediately after but it's less likely than when actually running), better to test that the stop is respected by stopping while running (i.e. in the several loops that it might have).", "author": "thc202", "createdAt": "2020-10-22T15:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MzAxOA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510253018", "bodyText": "This is probably something that can be added as part of the common tests.", "author": "thc202", "createdAt": "2020-10-22T15:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NTIwMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510255202", "bodyText": "For the time being lets just leave the stop testing out for now. It would be nice to get this done/in. Stop testing will require further unrelated changes.", "author": "kingthorin", "createdAt": "2020-10-22T15:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NDUwMA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510954500", "bodyText": "Sure. Will remove this test.", "author": "ejayaraman", "createdAt": "2020-10-23T15:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MDQ4MA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r513790480", "bodyText": "This test has been removed.", "author": "ejayaraman", "createdAt": "2020-10-28T22:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}], "type": "inlineReview"}, {"oid": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "url": "https://github.com/zaproxy/zap-extensions/commit/10de60d241a1143dc4c3717cb7a0e1bb870823be", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-15T20:04:24Z", "type": "forcePushed"}, {"oid": "5a73de1287b5c925621671e7553924fc32dd656a", "url": "https://github.com/zaproxy/zap-extensions/commit/5a73de1287b5c925621671e7553924fc32dd656a", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-15T20:12:07Z", "type": "forcePushed"}, {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "url": "https://github.com/zaproxy/zap-extensions/commit/29cf52d5bc300ca0f5729f0bb599771d725ed344", "message": "Removed blank lines.\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-17T13:55:08Z", "type": "forcePushed"}, {"oid": "9229f2da87b2eac652396f84f589a4df857495e7", "url": "https://github.com/zaproxy/zap-extensions/commit/9229f2da87b2eac652396f84f589a4df857495e7", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-28T21:16:25Z", "type": "forcePushed"}, {"oid": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "url": "https://github.com/zaproxy/zap-extensions/commit/6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "message": "XML External Entity Attack scan rule changed to skip only Remote File Inclusion Attack when Callback extension is not available\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:27:45Z", "type": "commit"}, {"oid": "380a0995ce8dd79e5596ae680e57849d85e5f447", "url": "https://github.com/zaproxy/zap-extensions/commit/380a0995ce8dd79e5596ae680e57849d85e5f447", "message": "XML External Entity Attack scan rule changed to parse response body irrespective of the HTTP response status code\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:28:10Z", "type": "commit"}, {"oid": "f06a9bb670792320ea21f2536832a87344616516", "url": "https://github.com/zaproxy/zap-extensions/commit/f06a9bb670792320ea21f2536832a87344616516", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:28:10Z", "type": "commit"}, {"oid": "f06a9bb670792320ea21f2536832a87344616516", "url": "https://github.com/zaproxy/zap-extensions/commit/f06a9bb670792320ea21f2536832a87344616516", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:28:10Z", "type": "forcePushed"}]}