{"pr_number": 2660, "pr_title": "Create ForbiddenBypassScanRule", "pr_createdAt": "2020-12-18T06:57:21Z", "pr_url": "https://github.com/zaproxy/zap-extensions/pull/2660", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547351953", "bodyText": "These should be removed.", "author": "thc202", "createdAt": "2020-12-22T15:47:02Z", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;", "originalCommit": "9afe57d880176b650fb08bcb8daa2867940f5e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg4MzcwNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547883704", "bodyText": "You mean parameters?", "author": "theamanrawat", "createdAt": "2020-12-23T10:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg4NDk2OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547884969", "bodyText": "The semicolons (this and the other after the following if), it's not necessary.", "author": "thc202", "createdAt": "2020-12-23T10:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzgwMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897801", "bodyText": "Done", "author": "theamanrawat", "createdAt": "2020-12-23T10:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjAwNg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547352006", "bodyText": "These cases should be covered by the tests too.", "author": "thc202", "createdAt": "2020-12-22T15:47:08Z", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/\";\n+            } else if (header.contains(\"Referer\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/anything\";\n+            } else {\n+                tmpUri = tmpUri + path;", "originalCommit": "9afe57d880176b650fb08bcb8daa2867940f5e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzczMw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897733", "bodyText": "Done", "author": "theamanrawat", "createdAt": "2020-12-23T10:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjA5MQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547352091", "bodyText": "The attack could be set to the payload sent.", "author": "thc202", "createdAt": "2020-12-22T15:47:19Z", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/\";\n+            } else if (header.contains(\"Referer\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/anything\";\n+            } else {\n+                tmpUri = tmpUri + path;\n+            }\n+\n+            HttpMessage reqWithPayload = new HttpMessage(new URI(tmpUri, true));\n+\n+            String[] headerPayload = header.split(\":\");\n+\n+            reqWithPayload.getRequestHeader().setHeader(headerPayload[0], headerPayload[1]);\n+            sendAndReceive(reqWithPayload);\n+\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private AlertBuilder createAlert(String uri, HttpMessage messgae) {\n+        return newAlert().setOtherInfo(uri).setMessage(messgae);", "originalCommit": "9afe57d880176b650fb08bcb8daa2867940f5e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzYyNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897624", "bodyText": "Done", "author": "theamanrawat", "createdAt": "2020-12-23T10:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjA5MQ=="}], "type": "inlineReview"}, {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93", "url": "https://github.com/zaproxy/zap-extensions/commit/0d792255c21cf6f5b8ce98b351df1b002c70ff93", "message": "Requested changes\n\nSigned-off-by: Aman Rawat <rawataman6525@gmail.com>", "committedDate": "2020-12-23T10:40:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODM4Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958382", "bodyText": "This is now the same case as the first if statement, better include this condition there.", "author": "thc202", "createdAt": "2020-12-23T13:28:00Z", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload, pathPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"/\";\n+            } else if (header.contains(\"Referer\")) {", "originalCommit": "0d792255c21cf6f5b8ce98b351df1b002c70ff93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODQ5OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958499", "bodyText": "Could you also assert the attack is not empty and for following tests that it's the expected one?", "author": "thc202", "createdAt": "2020-12-23T13:28:14Z", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {", "originalCommit": "0d792255c21cf6f5b8ce98b351df1b002c70ff93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODUyMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958522", "bodyText": "btw, given this is the same for all of them it could be extracted a method.", "author": "thc202", "createdAt": "2020-12-23T13:28:17Z", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());", "originalCommit": "0d792255c21cf6f5b8ce98b351df1b002c70ff93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODU3Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958572", "bodyText": "It's preferable to use specific names, e.g.shouldAlertIfOkWithRewriteUrlHeader.", "author": "thc202", "createdAt": "2020-12-23T13:28:24Z", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload1() throws Exception {", "originalCommit": "0d792255c21cf6f5b8ce98b351df1b002c70ff93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODg5MQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958891", "bodyText": "Same here regarding using specific names, although this should be changed to allow to pass the header being tested.", "author": "thc202", "createdAt": "2020-12-23T13:29:06Z", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload1() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload2() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload3() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload4() throws Exception {\n+        // Given\n+        nano.addHandler(new HeaderResponse2(PROTECTED_PATH));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    private static class OkResponse extends NanoServerHandler {\n+\n+        public OkResponse(String path) {\n+            super(path);\n+        }\n+\n+        @Override\n+        protected Response serve(IHTTPSession session) {\n+            return newFixedLengthResponse(Response.Status.OK, \"text/html\", GENERIC_RESPONSE);\n+        }\n+    }\n+\n+    private static class ForbiddenResponse extends NanoServerHandler {\n+\n+        public ForbiddenResponse(String path) {\n+            super(path);\n+        }\n+\n+        @Override\n+        protected Response serve(IHTTPSession session) {\n+            return newFixedLengthResponse(Response.Status.FORBIDDEN, \"text/html\", GENERIC_RESPONSE);\n+        }\n+    }\n+\n+    private static class HeaderResponse1 extends NanoServerHandler {", "originalCommit": "0d792255c21cf6f5b8ce98b351df1b002c70ff93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NjE5NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r548496195", "bodyText": "Note the last part, it should be changed to allow to pass the header (to avoid duplicating the same code for each header).", "author": "thc202", "createdAt": "2020-12-24T11:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODg5MQ=="}], "type": "inlineReview"}, {"oid": "637b0d484a3321fd68fae1fd0714da3a70548b47", "url": "https://github.com/zaproxy/zap-extensions/commit/637b0d484a3321fd68fae1fd0714da3a70548b47", "message": "Create ForbiddenBypassScanRule\n\n- Update Help.\n- Add CHANGELOG note.\n- Add UnitTests.\n\nSigned-off-by: theamanrawat <35992750+theamanrawat@users.noreply.github.com>", "committedDate": "2020-12-24T07:05:59Z", "type": "forcePushed"}, {"oid": "66adec8173e75097745688086e575fecd6ee2286", "url": "https://github.com/zaproxy/zap-extensions/commit/66adec8173e75097745688086e575fecd6ee2286", "message": "Create ForbiddenBypassScanRule\n\n- Update Help.\n- Add CHANGELOG note.\n- Add UnitTests.\n\nSigned-off-by: Aman Rawat <35992750+theamanrawat@users.noreply.github.com>", "committedDate": "2020-12-24T07:12:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NjA4Ng==", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r548496086", "bodyText": "private static\nassertAlert", "author": "thc202", "createdAt": "2020-12-24T11:10:18Z", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"/%2e\" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithRewriteUrlHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new RewriteUrlResponse(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"X-Rewrite-URL: \" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithRefererHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new RefererResponse(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Referer: \" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithOriginalUrlHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OriginalUrlResponse(\"/\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"X-Original-URL: \" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithCustomIpAuthorizationHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new CustomIpAuthorizationResponse(PROTECTED_PATH));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"X-Custom-IP-Authorization: 127.0.0.1\", alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    public void raiseAlert(Alert alert) {", "originalCommit": "66adec8173e75097745688086e575fecd6ee2286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "952198a0bf1817bad879e20f7e6a8a325cb6801f", "url": "https://github.com/zaproxy/zap-extensions/commit/952198a0bf1817bad879e20f7e6a8a325cb6801f", "message": "Create ForbiddenBypassScanRule\n\n- Update Help.\n- Add CHANGELOG note.\n- Add UnitTests.\n\nSigned-off-by: Aman Rawat <rawataman6525@gmail.com>", "committedDate": "2020-12-24T12:08:46Z", "type": "commit"}, {"oid": "952198a0bf1817bad879e20f7e6a8a325cb6801f", "url": "https://github.com/zaproxy/zap-extensions/commit/952198a0bf1817bad879e20f7e6a8a325cb6801f", "message": "Create ForbiddenBypassScanRule\n\n- Update Help.\n- Add CHANGELOG note.\n- Add UnitTests.\n\nSigned-off-by: Aman Rawat <rawataman6525@gmail.com>", "committedDate": "2020-12-24T12:08:46Z", "type": "forcePushed"}]}