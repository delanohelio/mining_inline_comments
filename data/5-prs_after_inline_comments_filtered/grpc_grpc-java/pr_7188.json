{"pr_number": 7188, "pr_title": "xds: implement CertificateProviderRegistry & CertificateProviderStore", "pr_createdAt": "2020-07-07T23:36:19Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7188", "timeline": [{"oid": "020ed1efa53d9ad959db3bfcfb1b4e2005d2bc56", "url": "https://github.com/grpc/grpc-java/commit/020ed1efa53d9ad959db3bfcfb1b4e2005d2bc56", "message": "xds: implement CertificateProviderRegistry & CertificateProviderStore", "committedDate": "2020-07-09T00:33:43Z", "type": "commit"}, {"oid": "592cc4bd8be87402a82f9d9e59b2d691508eb427", "url": "https://github.com/grpc/grpc-java/commit/592cc4bd8be87402a82f9d9e59b2d691508eb427", "message": "add tests for notifyError", "committedDate": "2020-07-09T00:33:50Z", "type": "commit"}, {"oid": "592cc4bd8be87402a82f9d9e59b2d691508eb427", "url": "https://github.com/grpc/grpc-java/commit/592cc4bd8be87402a82f9d9e59b2d691508eb427", "message": "add tests for notifyError", "committedDate": "2020-07-09T00:33:50Z", "type": "forcePushed"}, {"oid": "99125a567dc11a94d349ae614807ce14f6186b49", "url": "https://github.com/grpc/grpc-java/commit/99125a567dc11a94d349ae614807ce14f6186b49", "message": "fix lint for runtime exception", "committedDate": "2020-07-09T00:42:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjkwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452382901", "bodyText": "I think it's not necessary to introduce yet a new interface. Just make Handle a concrete class would be sufficient. Actually even the test is not taking advantage of interface.", "author": "dapengzhang0", "createdAt": "2020-07-09T17:37:54Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Status;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.Watcher;\n+import io.grpc.xds.internal.sds.ReferenceCountingMap;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Global map of all ref-counted {@link CertificateProvider}s that have been instantiated in\n+ * the application. Also  propagates updates received from a {@link CertificateProvider} to all\n+ * the {@link Watcher}s registered for that CertificateProvider. The Store is meant to be\n+ * used internally by gRPC and *not* a public API.\n+ */\n+@ThreadSafe\n+public final class CertificateProviderStore {\n+  private static final Logger logger = Logger.getLogger(CertificateProviderStore.class.getName());\n+\n+  private static CertificateProviderStore instance;\n+  private final CertificateProviderRegistry certificateProviderRegistry;\n+  private final ReferenceCountingMap<CertProviderKey, CertificateProvider> certProviderMap;\n+\n+  /** Opaque Handle returned by {@link #createOrGetProvider}. */\n+  interface Handle extends java.io.Closeable {", "originalCommit": "99125a567dc11a94d349ae614807ce14f6186b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NDYzOQ==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452954639", "bodyText": "Good point. Done.", "author": "sanjaypujare", "createdAt": "2020-07-10T16:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTMxOA==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452499318", "bodyText": "This casting is not obvious. What about defining CertificateProvider with a generic type for watcher:\npublic abstract class CertificateProvider<T extends Watcher> implements Closeable {\n  final T watcher;\n  public T getWatcher() {\n    return watcher;\n   }\n}", "author": "dapengzhang0", "createdAt": "2020-07-09T21:25:45Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Status;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.Watcher;\n+import io.grpc.xds.internal.sds.ReferenceCountingMap;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Global map of all ref-counted {@link CertificateProvider}s that have been instantiated in\n+ * the application. Also  propagates updates received from a {@link CertificateProvider} to all\n+ * the {@link Watcher}s registered for that CertificateProvider. The Store is meant to be\n+ * used internally by gRPC and *not* a public API.\n+ */\n+@ThreadSafe\n+public final class CertificateProviderStore {\n+  private static final Logger logger = Logger.getLogger(CertificateProviderStore.class.getName());\n+\n+  private static CertificateProviderStore instance;\n+  private final CertificateProviderRegistry certificateProviderRegistry;\n+  private final ReferenceCountingMap<CertProviderKey, CertificateProvider> certProviderMap;\n+\n+  /** Opaque Handle returned by {@link #createOrGetProvider}. */\n+  interface Handle extends java.io.Closeable {\n+\n+    /**\n+     * Removes the associated {@link Watcher} for the {@link CertificateProvider} and\n+     * decrements the ref-count. Releases the {@link CertificateProvider} if the ref-count\n+     * has reached 0.\n+     */\n+    @Override\n+    void close();\n+  }\n+\n+  private static final class CertProviderKey {\n+    private final String certName;\n+    private final String pluginName;\n+    private final boolean notifyCertUpdates;\n+    private final Object config;\n+\n+    private CertProviderKey(\n+        String certName, String pluginName, boolean notifyCertUpdates, Object config) {\n+      this.certName = certName;\n+      this.pluginName = pluginName;\n+      this.notifyCertUpdates = notifyCertUpdates;\n+      this.config = config;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (!(o instanceof CertProviderKey)) {\n+        return false;\n+      }\n+      CertProviderKey that = (CertProviderKey) o;\n+      return notifyCertUpdates == that.notifyCertUpdates\n+          && Objects.equals(certName, that.certName)\n+          && Objects.equals(pluginName, that.pluginName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(certName, pluginName, notifyCertUpdates, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CertProviderKey{\"\n+          + \"certName='\"\n+          + certName\n+          + '\\''\n+          + \", pluginName='\"\n+          + pluginName\n+          + '\\''\n+          + \", notifyCertUpdates=\"\n+          + notifyCertUpdates\n+          + \", config=\"\n+          + config\n+          + '}';\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static final class DistributorWatcher implements CertificateProvider.Watcher {\n+    @VisibleForTesting\n+    final ArrayList<Watcher> downsstreamWatchers = new ArrayList<>();\n+\n+    private synchronized void addWatcher(Watcher watcher) {\n+      downsstreamWatchers.add(watcher);\n+    }\n+\n+    private synchronized void removeWatcher(Watcher watcher) {\n+      downsstreamWatchers.remove(watcher);\n+    }\n+\n+    private DistributorWatcher() {\n+    }\n+\n+    @Override\n+    public void updateCertificate(PrivateKey key, List<X509Certificate> certChain) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.updateCertificate(key, certChain);\n+      }\n+    }\n+\n+    @Override\n+    public void updateTrustedRoots(List<X509Certificate> trustedRoots) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.updateTrustedRoots(trustedRoots);\n+      }\n+    }\n+\n+    @Override\n+    public void onError(Status errorStatus) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.onError(errorStatus);\n+      }\n+    }\n+  }\n+\n+  private final class CertProviderFactory\n+      implements ReferenceCountingMap.ValueFactory<CertProviderKey, CertificateProvider> {\n+\n+    private CertProviderFactory() {\n+    }\n+\n+    @Override\n+    public CertificateProvider create(CertProviderKey key) {\n+      CertificateProviderProvider certProviderProvider =\n+          certificateProviderRegistry.getProvider(key.pluginName);\n+      if (certProviderProvider == null) {\n+        throw new IllegalArgumentException(\"Provider not found.\");\n+      }\n+      return certProviderProvider.createCertificateProvider(\n+          key.config, new DistributorWatcher(), key.notifyCertUpdates);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  CertificateProviderStore(CertificateProviderRegistry certificateProviderRegistry) {\n+    this.certificateProviderRegistry = certificateProviderRegistry;\n+    certProviderMap = new ReferenceCountingMap<>(new CertProviderFactory());\n+  }\n+\n+  @VisibleForTesting\n+  final class HandleImpl implements Handle {\n+    private final CertProviderKey key;\n+    private final Watcher watcher;\n+    @VisibleForTesting\n+    final CertificateProvider certProvider;\n+\n+    private HandleImpl(CertProviderKey key, Watcher watcher, CertificateProvider certProvider) {\n+      this.key = key;\n+      this.watcher = watcher;\n+      this.certProvider = certProvider;\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+      DistributorWatcher distWatcher = (DistributorWatcher)certProvider.getWatcher();\n+      distWatcher.removeWatcher(watcher);\n+      certProviderMap.release(key, certProvider);\n+    }\n+  }\n+\n+  /**\n+   * Creates or retrieves a {@link CertificateProvider} instance, increments its ref-count and\n+   * registers the watcher passed. Returns a {@link Handle} that can be {@link Handle#close()}d when\n+   * the instance is no longer needed by the caller.\n+   *\n+   * @param notifyCertUpdates when true, the caller is interested in identity cert updates. When\n+   *     false, the caller cannot depend on receiving the {@link Watcher#updateCertificate}\n+   *     callbacks but may still receive these callbacks which should be ignored.\n+   * @throws IllegalArgumentException in case of errors in processing config or the plugin is\n+   *     incapable of sending cert updates when notifyCertUpdates is true.\n+   * @throws UnsupportedOperationException if the plugin is incapable of sending cert updates when\n+   *     notifyCertUpdates is true.\n+   */\n+  public synchronized Handle createOrGetProvider(\n+      String certName,\n+      String pluginName,\n+      Object config,\n+      Watcher watcher,\n+      boolean notifyCertUpdates) {\n+    if (!notifyCertUpdates) {\n+      // we try to get a provider first for notifyCertUpdates==true always\n+      try {\n+        return createProviderHelper(certName, pluginName, config, watcher, true);\n+      } catch (UnsupportedOperationException uoe) {\n+        // ignore & log exception and fall thru to create a provider with actual value\n+        logger.log(Level.FINE, \"Trying to get provider for notifyCertUpdates==true\", uoe);\n+      }\n+    }\n+    return createProviderHelper(certName, pluginName, config, watcher, notifyCertUpdates);\n+  }\n+\n+  private synchronized Handle createProviderHelper(\n+      String certName,\n+      String pluginName,\n+      Object config,\n+      Watcher watcher,\n+      boolean notifyCertUpdates) {\n+    CertProviderKey key = new CertProviderKey(certName, pluginName, notifyCertUpdates, config);\n+    CertificateProvider provider = certProviderMap.get(key);\n+    DistributorWatcher distWatcher = (DistributorWatcher) provider.getWatcher();", "originalCommit": "99125a567dc11a94d349ae614807ce14f6186b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NTMxMg==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452955312", "bodyText": "Good point about the casting. But I realized a generic is not needed. The CertificateProvider always takes a DistributorWatcher so I moved the inner class here and removed the casting in all those places.", "author": "sanjaypujare", "createdAt": "2020-07-10T16:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTc3NA==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452499774", "bodyText": "protected fields can be private as now you have public accessors.", "author": "dapengzhang0", "createdAt": "2020-07-09T21:26:41Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -62,4 +62,12 @@ protected CertificateProvider(Watcher watcher, boolean notifyCertUpdates) {\n \n   protected final Watcher watcher;\n   protected final boolean notifyCertUpdates;", "originalCommit": "99125a567dc11a94d349ae614807ce14f6186b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NTQ1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452955459", "bodyText": "Done", "author": "sanjaypujare", "createdAt": "2020-07-10T16:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTc3NA=="}], "type": "inlineReview"}, {"oid": "73120c0a16b8d1b7cc50ae8661261fe0f66be0b1", "url": "https://github.com/grpc/grpc-java/commit/73120c0a16b8d1b7cc50ae8661261fe0f66be0b1", "message": "address comments", "committedDate": "2020-07-10T16:40:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTIxNA==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r453075214", "bodyText": "What's the reason of using ArrayList rather than HashSet? Could there be duplicate entries in the collection? Do the order of the entries matter?", "author": "dapengzhang0", "createdAt": "2020-07-10T21:01:03Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -42,6 +44,41 @@\n     void onError(Status errorStatus);\n   }\n \n+  @VisibleForTesting\n+  static final class DistributorWatcher implements Watcher {\n+    @VisibleForTesting\n+    final ArrayList<Watcher> downsstreamWatchers = new ArrayList<>();", "originalCommit": "73120c0a16b8d1b7cc50ae8661261fe0f66be0b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5MzU2NA==", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r453093564", "bodyText": "Order definitely doesn't matter. And I cannot think of any straightforward example that requires duplicate entries support. For now I will change it to HashSet.", "author": "sanjaypujare", "createdAt": "2020-07-10T21:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTIxNA=="}], "type": "inlineReview"}, {"oid": "439e56363ae93d6229cc266772bfe442acc7add8", "url": "https://github.com/grpc/grpc-java/commit/439e56363ae93d6229cc266772bfe442acc7add8", "message": "use Set instead of List", "committedDate": "2020-07-10T21:56:21Z", "type": "commit"}]}