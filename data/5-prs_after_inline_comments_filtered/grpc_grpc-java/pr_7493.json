{"pr_number": 7493, "pr_title": "xds: implement ZatarCertificateProvider", "pr_createdAt": "2020-10-08T04:12:53Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7493", "timeline": [{"oid": "5da11ea88fc57b28ebc21c1134452aabd90b5887", "url": "https://github.com/grpc/grpc-java/commit/5da11ea88fc57b28ebc21c1134452aabd90b5887", "message": "xds: implement ZatarCertificateProvider", "committedDate": "2020-10-08T04:11:29Z", "type": "commit"}, {"oid": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "url": "https://github.com/grpc/grpc-java/commit/7b331522c7f1e6315e41b63e26f626c1ae1affdc", "message": "increase code coverage by deleting dead code and adding a test", "committedDate": "2020-10-08T16:30:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDEzMw==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505094133", "bodyText": "The comment is unclear whether it's for the line above or below. Maybe change back to the previous format.", "author": "dapengzhang0", "createdAt": "2020-10-15T00:22:35Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/trust/CertificateUtils.java", "diffHunk": "@@ -16,23 +16,46 @@\n \n package io.grpc.xds.internal.sds.trust;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.util.CharsetUtil;\n import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.KeyException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n import java.security.cert.Certificate;\n import java.security.cert.CertificateException;\n import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n+import java.security.spec.PKCS8EncodedKeySpec;\n import java.util.Collection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n /**\n  * Contains certificate utility method(s).\n  */\n public final class CertificateUtils {\n+  private static final Logger logger = Logger.getLogger(CertificateUtils.class.getName());\n \n   private static CertificateFactory factory;\n+  private static final Pattern KEY_PATTERN =\n+      Pattern.compile(\n+          \"-+BEGIN\\\\s+.*PRIVATE\\\\s+KEY[^-]*-+(?:\\\\s|\\\\r|\\\\n)+\"\n+              + // Header", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NjY4NA==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505096684", "bodyText": "Will this constructor be used not only for testing in future? If so no need to add @VisibleForTesting", "author": "dapengzhang0", "createdAt": "2020-10-15T00:31:59Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/ZatarCertificateProvider.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for Zatar cert provider. */\n+final class ZatarCertificateProvider extends CertificateProvider {\n+  private static final Logger logger = Logger.getLogger(ZatarCertificateProvider.class.getName());\n+\n+  /**\n+   * After the previous cert has expired, if we are unable to get new certificates we will report\n+   * errors. We will start doing this a few seconds before the previous cert expiry whose value is\n+   * given by this constant.\n+   */\n+  @VisibleForTesting static final long GRACE_INTERVAL_IN_SECONDS = 4L;\n+\n+  @VisibleForTesting", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2NTg4MQ==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505665881", "bodyText": "The constructor is package private only because of tests - otherwise it could have been made private. But it's not clear from the current PR so I will remove the annotation.", "author": "sanjaypujare", "createdAt": "2020-10-15T16:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEwMTQ2Mg==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505101462", "bodyText": "Clearly this won't happen because it is either the initial schedule or run by previous task, seems we don't need be too conservative checking the state.", "author": "dapengzhang0", "createdAt": "2020-10-15T00:49:50Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/ZatarCertificateProvider.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for Zatar cert provider. */\n+final class ZatarCertificateProvider extends CertificateProvider {\n+  private static final Logger logger = Logger.getLogger(ZatarCertificateProvider.class.getName());\n+\n+  /**\n+   * After the previous cert has expired, if we are unable to get new certificates we will report\n+   * errors. We will start doing this a few seconds before the previous cert expiry whose value is\n+   * given by this constant.\n+   */\n+  @VisibleForTesting static final long GRACE_INTERVAL_IN_SECONDS = 4L;\n+\n+  @VisibleForTesting\n+  ZatarCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String directory,\n+      String certFile,\n+      String privateKeyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.directory = Paths.get(checkNotNull(directory, \"diretory\"));\n+    this.certFile = checkNotNull(certFile, \"certFile\");\n+    this.privateKeyFile = checkNotNull(privateKeyFile, \"privateKeyFile\");\n+    this.trustFile = checkNotNull(trustFile, \"trustFile\");\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(directory);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"ZatarCertificateProvider\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public void start() {\n+    scheduleNextRefreshCertificate(/* delayInSeconds= */0);\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (scheduledHandle != null) {\n+      scheduledHandle.cancel();\n+      scheduledHandle = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledHandle != null && scheduledHandle.isPending()) {\n+      logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+      scheduledHandle.cancel();\n+    }", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505668521", "bodyText": "if checkAndReloadCertificates was called from somewhere else and not thru the scheduler then this could happen - but I agree this check is unnecessary if there is no coding bug. Removed", "author": "sanjaypujare", "createdAt": "2020-10-15T16:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEwMTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTIzNjA4MQ==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505236081", "bodyText": "I'd prefer to move the fields up to the topmost to be somewhat consistent in style.", "author": "dapengzhang0", "createdAt": "2020-10-15T07:03:19Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/ZatarCertificateProvider.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for Zatar cert provider. */\n+final class ZatarCertificateProvider extends CertificateProvider {\n+  private static final Logger logger = Logger.getLogger(ZatarCertificateProvider.class.getName());\n+\n+  /**\n+   * After the previous cert has expired, if we are unable to get new certificates we will report\n+   * errors. We will start doing this a few seconds before the previous cert expiry whose value is\n+   * given by this constant.\n+   */\n+  @VisibleForTesting static final long GRACE_INTERVAL_IN_SECONDS = 4L;\n+\n+  @VisibleForTesting\n+  ZatarCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String directory,\n+      String certFile,\n+      String privateKeyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.directory = Paths.get(checkNotNull(directory, \"diretory\"));\n+    this.certFile = checkNotNull(certFile, \"certFile\");\n+    this.privateKeyFile = checkNotNull(privateKeyFile, \"privateKeyFile\");\n+    this.trustFile = checkNotNull(trustFile, \"trustFile\");\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(directory);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"ZatarCertificateProvider\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public void start() {\n+    scheduleNextRefreshCertificate(/* delayInSeconds= */0);\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (scheduledHandle != null) {\n+      scheduledHandle.cancel();\n+      scheduledHandle = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledHandle != null && scheduledHandle.isPending()) {\n+      logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+      scheduledHandle.cancel();\n+    }\n+    RefreshCertificateTask runnable = new RefreshCertificateTask();\n+    scheduledHandle =\n+        syncContext.schedule(runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n+  }\n+\n+  @VisibleForTesting\n+  void checkAndReloadCertificates() {\n+    try {\n+      Path targetPath = Files.readSymbolicLink(directory);\n+      if (targetPath.equals(lastModifiedTarget)) {\n+        return;\n+      }\n+      PrivateKey privateKey =\n+          CertificateUtils.getPrivateKey(\n+              new FileInputStream(new File(targetPath.toFile(), privateKeyFile)));\n+      X509Certificate[] certs =\n+          CertificateUtils.toX509Certificates(\n+              new FileInputStream(new File(targetPath.toFile(), certFile)));\n+      X509Certificate[] caCerts =\n+          CertificateUtils.toX509Certificates(\n+              new FileInputStream(new File(targetPath.toFile(), trustFile)));\n+      getWatcher().updateCertificate(privateKey, Arrays.asList(certs));\n+      getWatcher().updateTrustedRoots(Arrays.asList(caCerts));\n+      lastModifiedTarget = targetPath;\n+    } catch (Throwable t) {\n+      generateErrorIfCurrentCertExpired(t);\n+    } finally {\n+      scheduleNextRefreshCertificate(refreshIntervalInSeconds);\n+    }\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > GRACE_INTERVAL_IN_SECONDS) {\n+        logger.log(Level.FINER, \"reload certificate error\", t);\n+        return;\n+      }\n+      getWatcher().clearValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  @SuppressWarnings(\"JdkObsolete\")\n+  private long computeDelaySecondsToCertExpiry(X509Certificate lastCert) {\n+    checkNotNull(lastCert, \"lastCert\");\n+    return TimeUnit.NANOSECONDS.toSeconds(\n+        TimeUnit.MILLISECONDS.toNanos(lastCert.getNotAfter().getTime())\n+            - timeProvider.currentTimeNanos());\n+  }\n+\n+  @VisibleForTesting\n+  class RefreshCertificateTask implements Runnable {\n+    @Override\n+    public void run() {\n+      checkAndReloadCertificates();\n+    }\n+  }\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path directory;\n+  private final String certFile;\n+  private final String privateKeyFile;\n+  private final String trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private Path lastModifiedTarget;", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI0Mzk0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505243941", "bodyText": "Try with resource, or let CertificateUtils close the stream (maybe introducing convenient method CertificateUtils.getPrivateKey(File file) that closes the input stream)?", "author": "dapengzhang0", "createdAt": "2020-10-15T07:10:47Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/ZatarCertificateProvider.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for Zatar cert provider. */\n+final class ZatarCertificateProvider extends CertificateProvider {\n+  private static final Logger logger = Logger.getLogger(ZatarCertificateProvider.class.getName());\n+\n+  /**\n+   * After the previous cert has expired, if we are unable to get new certificates we will report\n+   * errors. We will start doing this a few seconds before the previous cert expiry whose value is\n+   * given by this constant.\n+   */\n+  @VisibleForTesting static final long GRACE_INTERVAL_IN_SECONDS = 4L;\n+\n+  @VisibleForTesting\n+  ZatarCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String directory,\n+      String certFile,\n+      String privateKeyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.directory = Paths.get(checkNotNull(directory, \"diretory\"));\n+    this.certFile = checkNotNull(certFile, \"certFile\");\n+    this.privateKeyFile = checkNotNull(privateKeyFile, \"privateKeyFile\");\n+    this.trustFile = checkNotNull(trustFile, \"trustFile\");\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(directory);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"ZatarCertificateProvider\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public void start() {\n+    scheduleNextRefreshCertificate(/* delayInSeconds= */0);\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (scheduledHandle != null) {\n+      scheduledHandle.cancel();\n+      scheduledHandle = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledHandle != null && scheduledHandle.isPending()) {\n+      logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+      scheduledHandle.cancel();\n+    }\n+    RefreshCertificateTask runnable = new RefreshCertificateTask();\n+    scheduledHandle =\n+        syncContext.schedule(runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n+  }\n+\n+  @VisibleForTesting\n+  void checkAndReloadCertificates() {\n+    try {\n+      Path targetPath = Files.readSymbolicLink(directory);\n+      if (targetPath.equals(lastModifiedTarget)) {\n+        return;\n+      }\n+      PrivateKey privateKey =\n+          CertificateUtils.getPrivateKey(\n+              new FileInputStream(new File(targetPath.toFile(), privateKeyFile)));", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI1NTk2OQ==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505255969", "bodyText": "This seems generate error if current cert not expired. Maybe my understanding is wrong. Can you explain the logic here?", "author": "dapengzhang0", "createdAt": "2020-10-15T07:21:34Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/ZatarCertificateProvider.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for Zatar cert provider. */\n+final class ZatarCertificateProvider extends CertificateProvider {\n+  private static final Logger logger = Logger.getLogger(ZatarCertificateProvider.class.getName());\n+\n+  /**\n+   * After the previous cert has expired, if we are unable to get new certificates we will report\n+   * errors. We will start doing this a few seconds before the previous cert expiry whose value is\n+   * given by this constant.\n+   */\n+  @VisibleForTesting static final long GRACE_INTERVAL_IN_SECONDS = 4L;\n+\n+  @VisibleForTesting\n+  ZatarCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String directory,\n+      String certFile,\n+      String privateKeyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.directory = Paths.get(checkNotNull(directory, \"diretory\"));\n+    this.certFile = checkNotNull(certFile, \"certFile\");\n+    this.privateKeyFile = checkNotNull(privateKeyFile, \"privateKeyFile\");\n+    this.trustFile = checkNotNull(trustFile, \"trustFile\");\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(directory);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"ZatarCertificateProvider\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public void start() {\n+    scheduleNextRefreshCertificate(/* delayInSeconds= */0);\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (scheduledHandle != null) {\n+      scheduledHandle.cancel();\n+      scheduledHandle = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledHandle != null && scheduledHandle.isPending()) {\n+      logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+      scheduledHandle.cancel();\n+    }\n+    RefreshCertificateTask runnable = new RefreshCertificateTask();\n+    scheduledHandle =\n+        syncContext.schedule(runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n+  }\n+\n+  @VisibleForTesting\n+  void checkAndReloadCertificates() {\n+    try {\n+      Path targetPath = Files.readSymbolicLink(directory);\n+      if (targetPath.equals(lastModifiedTarget)) {\n+        return;\n+      }\n+      PrivateKey privateKey =\n+          CertificateUtils.getPrivateKey(\n+              new FileInputStream(new File(targetPath.toFile(), privateKeyFile)));\n+      X509Certificate[] certs =\n+          CertificateUtils.toX509Certificates(\n+              new FileInputStream(new File(targetPath.toFile(), certFile)));\n+      X509Certificate[] caCerts =\n+          CertificateUtils.toX509Certificates(\n+              new FileInputStream(new File(targetPath.toFile(), trustFile)));\n+      getWatcher().updateCertificate(privateKey, Arrays.asList(certs));\n+      getWatcher().updateTrustedRoots(Arrays.asList(caCerts));\n+      lastModifiedTarget = targetPath;\n+    } catch (Throwable t) {\n+      generateErrorIfCurrentCertExpired(t);\n+    } finally {\n+      scheduleNextRefreshCertificate(refreshIntervalInSeconds);\n+    }\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > GRACE_INTERVAL_IN_SECONDS) {\n+        logger.log(Level.FINER, \"reload certificate error\", t);\n+        return;", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MjQ4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505682482", "bodyText": "Sure. As we had specified in the design doc the CertificateProvider will generate error (i.e. notify thru watcher's onError) only if there is no current valid certificate or the last certificate had expired. Here I have provided for some grace period (4 seconds) so I generate the error if the certificate is about to expire in 4 seconds (instead of only after the cert has actually expired).\nBut I can see why there is confusion. I will remove GRACE_INTERVAL_IN_SECONDS and instead just use the refreshInterval as the grace period since it is an error-worthy event if the cert is about to expire in the next 10 minutes and my last cert refresh attempt failed.", "author": "sanjaypujare", "createdAt": "2020-10-15T16:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI1NTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI1ODY3OA==", "url": "https://github.com/grpc/grpc-java/pull/7493#discussion_r505258678", "bodyText": "Not used?", "author": "dapengzhang0", "createdAt": "2020-10-15T07:24:05Z", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/ZatarCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link ZatarCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class ZatarCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Rule\n+  public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();", "originalCommit": "7b331522c7f1e6315e41b63e26f626c1ae1affdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0a7f546a0ea8a4cf89b88bc1bcff46d4e0ee6834", "url": "https://github.com/grpc/grpc-java/commit/0a7f546a0ea8a4cf89b88bc1bcff46d4e0ee6834", "message": "address review comments", "committedDate": "2020-10-15T16:47:04Z", "type": "commit"}]}