{"pr_number": 7055, "pr_title": "xds: implement xds_routing policy config generation and parsing", "pr_createdAt": "2020-05-21T00:14:53Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7055", "timeline": [{"oid": "f238f2395203793e2610326dbc08e53e3338abd5", "url": "https://github.com/grpc/grpc-java/commit/f238f2395203793e2610326dbc08e53e3338abd5", "message": "Define route matcher types that can be shared by both xDS converted data and by gRPC Lb policies.", "committedDate": "2020-05-21T00:11:23Z", "type": "commit"}, {"oid": "f65468f9fde5025bfacdaafe401aac48c17dabfd", "url": "https://github.com/grpc/grpc-java/commit/f65468f9fde5025bfacdaafe401aac48c17dabfd", "message": "Used shared data types for matchers.", "committedDate": "2020-05-21T00:12:06Z", "type": "commit"}, {"oid": "468ecc24890e683660c3b29d179d134585249e59", "url": "https://github.com/grpc/grpc-java/commit/468ecc24890e683660c3b29d179d134585249e59", "message": "Temporarily delete implementation for xds_routing LB policy.", "committedDate": "2020-05-21T00:12:48Z", "type": "commit"}, {"oid": "63bfef189bea9dcb757c086fe295eb173c18a543", "url": "https://github.com/grpc/grpc-java/commit/63bfef189bea9dcb757c086fe295eb173c18a543", "message": "Define new format of xds_routing LB policy config, add in matchers and implement parsing logic.", "committedDate": "2020-05-21T01:02:27Z", "type": "forcePushed"}, {"oid": "7e85365ad5c149190ea9f6e3bde925e8271c9f5b", "url": "https://github.com/grpc/grpc-java/commit/7e85365ad5c149190ea9f6e3bde925e8271c9f5b", "message": "Define new format of xds_routing LB policy config, add in matchers and implement parsing logic.", "committedDate": "2020-05-21T01:10:51Z", "type": "commit"}, {"oid": "3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "url": "https://github.com/grpc/grpc-java/commit/3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "message": "Generate xds_routing config with all supported matchers in the xDS resolver.", "committedDate": "2020-05-22T01:36:13Z", "type": "commit"}, {"oid": "3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "url": "https://github.com/grpc/grpc-java/commit/3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "message": "Generate xds_routing config with all supported matchers in the xDS resolver.", "committedDate": "2020-05-22T01:36:13Z", "type": "forcePushed"}, {"oid": "3fd3ddccf2bbc577f24aed1d89c6abc50d1d54a0", "url": "https://github.com/grpc/grpc-java/commit/3fd3ddccf2bbc577f24aed1d89c6abc50d1d54a0", "message": "Refactor xds_routing config to the way that can be easily used by the xds_routing policy.", "committedDate": "2020-05-26T19:33:25Z", "type": "commit"}, {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "url": "https://github.com/grpc/grpc-java/commit/5b108802da64692ebe74bbae64a8e04c1cd5ef10", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/xds_routing_policy_config_generation_and_parsing", "committedDate": "2020-05-27T19:21:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU0NA==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432013544", "bodyText": "Add what getters in TODO?", "author": "dapengzhang0", "createdAt": "2020-05-28T17:45:09Z", "path": "xds/src/main/java/io/grpc/xds/RouteMatchers.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.MoreObjects.ToStringHelper;\n+import com.google.re2j.Pattern;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class RouteMatchers {\n+\n+  // Prevent instantiation\n+  private RouteMatchers() {\n+  }\n+\n+  static final class PathMatcher {\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String path;\n+    @Nullable\n+    private final String prefix;\n+    @Nullable\n+    private final Pattern regEx;\n+\n+    PathMatcher(@Nullable String path, @Nullable String prefix, @Nullable Pattern regEx) {\n+      this.path = path;\n+      this.prefix = prefix;\n+      this.regEx = regEx;\n+    }\n+\n+    @Nullable\n+    String getPath() {\n+      return path;\n+    }\n+\n+    @Nullable\n+    String getPrefix() {\n+      return prefix;\n+    }\n+\n+    @Nullable\n+    Pattern getRegEx() {\n+      return regEx;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      PathMatcher that = (PathMatcher) o;\n+      return Objects.equals(path, that.path)\n+          && Objects.equals(prefix, that.prefix)\n+          && Objects.equals(\n+              regEx == null ? null : regEx.pattern(),\n+              that.regEx == null ? null : that.regEx.pattern());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(path, prefix, regEx == null ? null : regEx.pattern());\n+    }\n+\n+    @Override\n+    public String toString() {\n+      ToStringHelper toStringHelper =\n+          MoreObjects.toStringHelper(this);\n+      if (path != null) {\n+        toStringHelper.add(\"path\", path);\n+      }\n+      if (prefix != null) {\n+        toStringHelper.add(\"prefix\", prefix);\n+      }\n+      if (regEx != null) {\n+        toStringHelper.add(\"regEx\", regEx.pattern());\n+      }\n+      return toStringHelper.toString();\n+    }\n+  }\n+\n+  /**\n+   * Matching rules for a specific HTTP/2 header.\n+   */\n+  static final class HeaderMatcher {\n+    private final String name;\n+\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String exactMatch;\n+    @Nullable\n+    private final Pattern safeRegExMatch;\n+    @Nullable\n+    private final Range rangeMatch;\n+    @Nullable\n+    private final Boolean presentMatch;\n+    @Nullable\n+    private final String prefixMatch;\n+    @Nullable\n+    private final String suffixMatch;\n+\n+    private final boolean isInvertedMatch;\n+\n+    // TODO(chengyuanzhang): use builder to enforce oneof semantics would be better.\n+    HeaderMatcher(\n+        String name,\n+        @Nullable String exactMatch, @Nullable Pattern safeRegExMatch, @Nullable Range rangeMatch,\n+        @Nullable Boolean presentMatch, @Nullable String prefixMatch, @Nullable String suffixMatch,\n+        boolean isInvertedMatch) {\n+      this.name = name;\n+      this.exactMatch = exactMatch;\n+      this.safeRegExMatch = safeRegExMatch;\n+      this.rangeMatch = rangeMatch;\n+      this.presentMatch = presentMatch;\n+      this.prefixMatch = prefixMatch;\n+      this.suffixMatch = suffixMatch;\n+      this.isInvertedMatch = isInvertedMatch;\n+    }\n+\n+    // TODO (chengyuanzhang): add getters when needed.", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzY0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432213649", "bodyText": "Should always have headers entry to be compatible with the proto format.", "author": "dapengzhang0", "createdAt": "2020-05-29T01:47:44Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -228,70 +230,126 @@ public void onError(Status error) {\n     }\n   }\n \n-  private static ImmutableMap<String, ?> generateXdsRoutingRawConfig(List<Route> routesUpdate) {\n-    List<Object> routes = new ArrayList<>(routesUpdate.size());\n-    Map<String, Object> actions = new LinkedHashMap<>();\n-    Map<RouteAction, String> exitingActions = new HashMap<>();\n-    for (Route route : routesUpdate) {\n-      String service = \"\";\n-      String method = \"\";\n-      if (!route.isDefaultRoute()) {\n-        String prefix = route.getRouteMatch().getPathPrefixMatch();\n-        String path = route.getRouteMatch().getPathExactMatch();\n-        if (prefix != null) {\n-          service = prefix.substring(1, prefix.length() - 1);\n-        } else if (path != null) {\n-          int splitIndex = path.lastIndexOf('/');\n-          service = path.substring(1, splitIndex);\n-          method = path.substring(splitIndex + 1);\n-        } else {\n-          // TODO (chengyuanzhang): match with regex.\n-          continue;\n-        }\n-      }\n-      Map<String, String> methodName = ImmutableMap.of(\"service\", service, \"method\", method);\n-      String actionName;\n+  @VisibleForTesting\n+  static ImmutableMap<String, ?> generateXdsRoutingRawConfig(List<Route> routes) {\n+    List<Object> rawRoutes = new ArrayList<>();\n+    Map<String, Object> rawActions = new LinkedHashMap<>();\n+    Map<RouteAction, String> existingActions = new HashMap<>();\n+    for (Route route : routes) {\n       RouteAction routeAction = route.getRouteAction();\n+      String actionName;\n       Map<String, ?> actionPolicy;\n-      if (exitingActions.containsKey(routeAction)) {\n-        actionName = exitingActions.get(routeAction);\n+      if (existingActions.containsKey(routeAction)) {\n+        actionName = existingActions.get(routeAction);\n       } else {\n         if (routeAction.getCluster() != null) {\n           actionName = \"cds:\" + routeAction.getCluster();\n           actionPolicy = generateCdsRawConfig(routeAction.getCluster());\n-        } else if (routeAction.getWeightedCluster() != null) {\n+        } else {\n           StringBuilder sb = new StringBuilder(\"weighted:\");\n           List<ClusterWeight> clusterWeights = routeAction.getWeightedCluster();\n           for (ClusterWeight clusterWeight : clusterWeights) {\n             sb.append(clusterWeight.getName()).append('_');\n           }\n           sb.append(routeAction.hashCode());\n           actionName = sb.toString();\n-          if (actions.containsKey(actionName)) {\n-            // Just in case of hash collision, append exitingActions.size() to make actionName\n+          if (rawActions.containsKey(actionName)) {\n+            // Just in case of hash collision, append existingActions.size() to make actionName\n             // unique. However, in case of collision, when new ConfigUpdate is received, actions\n             // and actionNames might be associated differently from the previous update, but it\n             // is just suboptimal and won't cause a problem.\n-            actionName = actionName + \"_\" + exitingActions.size();\n+            actionName = actionName + \"_\" + existingActions.size();\n           }\n           actionPolicy = generateWeightedTargetRawConfig(clusterWeights);\n-        } else {\n-          // TODO (chengyuanzhang): route with cluster_header.\n-          continue;\n         }\n-        exitingActions.put(routeAction, actionName);\n+        existingActions.put(routeAction, actionName);\n         List<?> childPolicies = ImmutableList.of(actionPolicy);\n-        actions.put(actionName, ImmutableMap.of(\"childPolicy\", childPolicies));\n+        rawActions.put(actionName, ImmutableMap.of(\"childPolicy\", childPolicies));\n       }\n-      routes.add(ImmutableMap.of(\"methodName\", methodName, \"action\", actionName));\n+      ImmutableMap<String, ?> configRoute = convertToRawRoute(route.getRouteMatch(), actionName);\n+      rawRoutes.add(configRoute);\n     }\n-\n     return ImmutableMap.of(\n         XdsLbPolicies.XDS_ROUTING_POLICY_NAME,\n-        ImmutableMap.of(\"route\", routes, \"action\", actions));\n+        ImmutableMap.of(\n+            \"route\", Collections.unmodifiableList(rawRoutes),\n+            \"action\", Collections.unmodifiableMap(rawActions)));\n+  }\n+\n+  @VisibleForTesting\n+  static ImmutableMap<String, ?> convertToRawRoute(RouteMatch routeMatch, String actionName) {\n+    ImmutableMap.Builder<String, Object> configRouteBuilder = new ImmutableMap.Builder<>();\n+\n+    PathMatcher pathMatcher = routeMatch.getPathMatch();\n+    String path = pathMatcher.getPath();\n+    String prefix = pathMatcher.getPrefix();\n+    Pattern regex = pathMatcher.getRegEx();\n+    if (path != null) {\n+      configRouteBuilder.put(\"path\", path);\n+    }\n+    if (prefix != null) {\n+      configRouteBuilder.put(\"prefix\", prefix);\n+    }\n+    if (regex != null) {\n+      configRouteBuilder.put(\"regex\", regex.pattern());\n+    }\n+\n+    ImmutableList.Builder<Object> rawHeaderMatcherListBuilder = new ImmutableList.Builder<>();\n+    List<HeaderMatcher> headerMatchers = routeMatch.getHeaderMatchers();\n+    for (HeaderMatcher headerMatcher : headerMatchers) {\n+      ImmutableMap.Builder<String, Object> rawHeaderMatcherBuilder = new ImmutableMap.Builder<>();\n+      rawHeaderMatcherBuilder.put(\"name\", headerMatcher.getName());\n+      String exactMatch = headerMatcher.getExactMatch();\n+      Pattern regexMatch = headerMatcher.getRegExMatch();\n+      HeaderMatcher.Range rangeMatch = headerMatcher.getRangeMatch();\n+      Boolean presentMatch = headerMatcher.getPresentMatch();\n+      String prefixMatch = headerMatcher.getPrefixMatch();\n+      String suffixMatch = headerMatcher.getSuffixMatch();\n+      if (exactMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"exactMatch\", exactMatch);\n+      }\n+      if (regexMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"regexMatch\", regexMatch.pattern());\n+      }\n+      if (rangeMatch != null) {\n+        rawHeaderMatcherBuilder\n+            .put(\n+                \"rangeMatch\",\n+                ImmutableMap.of(\"start\", rangeMatch.getStart(), \"end\", rangeMatch.getEnd()));\n+      }\n+      if (presentMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"presentMatch\", presentMatch);\n+      }\n+      if (prefixMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"prefixMatch\", prefixMatch);\n+      }\n+      if (suffixMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"suffixMatch\", suffixMatch);\n+      }\n+      rawHeaderMatcherBuilder.put(\"invertMatch\", headerMatcher.isInvertedMatch());\n+      rawHeaderMatcherListBuilder.add(rawHeaderMatcherBuilder.build());\n+    }\n+    ImmutableList<?> rawHeaderMatchers = rawHeaderMatcherListBuilder.build();\n+    if (!rawHeaderMatchers.isEmpty()) {\n+      configRouteBuilder.put(\"headers\", rawHeaderMatchers);", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMjY0NA==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r433122644", "bodyText": "The xds_routing config is not a mapping of the RouteMatch proto. It intends to be our own design, although the designer does just borrow the format and make them highly similar. In the design doc, the example xds_routing config does not include \"headers\" if not header matcher exists. So I followed that.\nAlso, the steps of converting what XdsClient receives to a raw xds_routing config and then converting it to a parsed xds_routing config is internal (and the designer says this double conversion is a temporary thing and will be eliminated in the short future), so as long as the config parser is able to parse the raw format correctly, whether it's an empty list or absence does not matter. (Btw, making the parser being able to parse absence seems to be more robust).", "author": "voidzcy", "createdAt": "2020-06-01T09:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTg5OQ==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432601899", "bodyText": "Revert the empty line change.", "author": "dapengzhang0", "createdAt": "2020-05-29T16:33:28Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancer.java", "diffHunk": "@@ -182,39 +181,18 @@ protected Helper delegate() {\n     }\n   }\n \n-  private static final class PathMatchingSubchannelPicker extends SubchannelPicker {\n+  private static final class RouteMatchingSubchannelPicker extends SubchannelPicker {\n \n-    final Map<MethodName, SubchannelPicker> routePickers;\n+    final Map<RouteMatch, SubchannelPicker> routePickers;\n \n-    /**\n-     * Constructs a picker that will match the path of PickSubchannelArgs with the given map.\n-     * The order of the map entries matters. First match will be picked even if second match is an\n-     * exact (service + method) path match.\n-     */\n-    PathMatchingSubchannelPicker(Map<MethodName, SubchannelPicker> routePickers) {\n+    RouteMatchingSubchannelPicker(Map<RouteMatch, SubchannelPicker> routePickers) {\n       this.routePickers = routePickers;\n     }\n \n     @Override\n     public PickResult pickSubchannel(PickSubchannelArgs args) {\n-      for (MethodName methodName : routePickers.keySet()) {\n-        if (match(args.getMethodDescriptor(), methodName)) {\n-          return routePickers.get(methodName).pickSubchannel(args);\n-        }\n-      }\n-      // At least the default route should match, otherwise there is a bug.\n-      throw new IllegalStateException(\"PathMatchingSubchannelPicker: error in matching path\");\n-    }\n-\n-    boolean match(MethodDescriptor<?, ?> methodDescriptor, MethodName methodName) {\n-      if (methodName.service.isEmpty() && methodName.method.isEmpty()) {\n-        return true;\n-      }\n-      if (methodName.method.isEmpty()) {\n-        return methodName.service.equals(methodDescriptor.getServiceName());\n-      }\n-      return (methodName.service + '/' + methodName.method)\n-          .equals(methodDescriptor.getFullMethodName());\n+      // TODO(chengyuanzhang): to be implemented.\n+      return PickResult.withError(Status.INTERNAL.withDescription(\"routing picker unimplemented\"));\n     }\n   }\n-}\n+}", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNjI5NQ==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432606295", "bodyText": "The error message does not indicate which child policy is not specified. However, it will be awkward to pass action name to this method. Seems there's no obvious better alternative.\nWhat about return StructOrErrorStatus<PolicySelection> and then augment the error message?", "author": "dapengzhang0", "createdAt": "2020-05-29T16:42:09Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -97,77 +101,167 @@ public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n-            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n-        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-\n-        LoadBalancerRegistry lbRegistry =\n-            this.lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry;\n-        ConfigOrError selectedConfigOrError =\n-            ServiceConfigUtil.selectLbPolicyFromList(childConfigCandidates, lbRegistry);\n-        if (selectedConfigOrError.getError() != null) {\n-          return selectedConfigOrError;\n-        }\n-\n-        parsedActions.put(name, (PolicySelection) selectedConfigOrError.getConfig());\n+        PolicySelection parsedAction =\n+            parseAction(\n+                rawAction,\n+                this.lbRegistry == null\n+                    ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry);\n+        parsedActions.put(name, parsedAction);\n       }\n \n-      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n-      if (routes == null || routes.isEmpty()) {\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      List<Map<String, ?>> rawRoutes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (rawRoutes == null || rawRoutes.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n             \"No routes provided for xds_routing LB policy: \" + rawConfig));\n       }\n-      List<Route> parsedRoutes = new ArrayList<>();\n-      Set<MethodName> methodNames = new HashSet<>();\n-      for (int i = 0; i < routes.size(); i++) {\n-        Map<String, ?> route = routes.get(i);\n-        String actionName = JsonUtil.getString(route, \"action\");\n-        if (actionName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No action name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        if (!parsedActions.containsKey(actionName)) {\n+      for (Map<String, ?> rawRoute: rawRoutes) {\n+        Route route = parseRoute(rawRoute);\n+        if (!parsedActions.containsKey(route.getActionName())) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No action defined for route \" + route + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n-        if (methodName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No method_name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        String service = JsonUtil.getString(methodName, \"service\");\n-        String method = JsonUtil.getString(methodName, \"method\");\n-        if (service == null || method == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No service or method provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n+        parsedRoutes.add(route);\n+      }\n+      return ConfigOrError.fromConfig(new XdsRoutingConfig(parsedRoutes, parsedActions));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse xds_routing LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  private static PolicySelection parseAction(\n+      Map<String, ?> rawAction, LoadBalancerRegistry registry) {\n+    List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+        JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+    if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+      throw new RuntimeException(\"childPolicy not specified\");", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDk3Ng==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432610976", "bodyText": "2020?", "author": "dapengzhang0", "createdAt": "2020-05-29T16:50:57Z", "path": "xds/src/test/java/io/grpc/xds/XdsNameResolverIntegrationTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Copyright 2019 The gRPC Authors", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDU2OA==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432620568", "bodyText": "This wrapping and unwrapping create unnecessary stacktrace of exception. Some other places like\n} catch (RuntimeException e) {\n  throw new RuntimeException(\"Failed to parse Route: \" + e);\n}\nhave the same problem\nI feel the trick returning StructOrErrorStatus<PolicySelection> might be better.", "author": "dapengzhang0", "createdAt": "2020-05-29T17:06:01Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -97,77 +101,167 @@ public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n-            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n-        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-\n-        LoadBalancerRegistry lbRegistry =\n-            this.lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry;\n-        ConfigOrError selectedConfigOrError =\n-            ServiceConfigUtil.selectLbPolicyFromList(childConfigCandidates, lbRegistry);\n-        if (selectedConfigOrError.getError() != null) {\n-          return selectedConfigOrError;\n-        }\n-\n-        parsedActions.put(name, (PolicySelection) selectedConfigOrError.getConfig());\n+        PolicySelection parsedAction =\n+            parseAction(\n+                rawAction,\n+                this.lbRegistry == null\n+                    ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry);\n+        parsedActions.put(name, parsedAction);\n       }\n \n-      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n-      if (routes == null || routes.isEmpty()) {\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      List<Map<String, ?>> rawRoutes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (rawRoutes == null || rawRoutes.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n             \"No routes provided for xds_routing LB policy: \" + rawConfig));\n       }\n-      List<Route> parsedRoutes = new ArrayList<>();\n-      Set<MethodName> methodNames = new HashSet<>();\n-      for (int i = 0; i < routes.size(); i++) {\n-        Map<String, ?> route = routes.get(i);\n-        String actionName = JsonUtil.getString(route, \"action\");\n-        if (actionName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No action name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        if (!parsedActions.containsKey(actionName)) {\n+      for (Map<String, ?> rawRoute: rawRoutes) {\n+        Route route = parseRoute(rawRoute);\n+        if (!parsedActions.containsKey(route.getActionName())) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No action defined for route \" + route + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n-        if (methodName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No method_name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        String service = JsonUtil.getString(methodName, \"service\");\n-        String method = JsonUtil.getString(methodName, \"method\");\n-        if (service == null || method == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No service or method provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n+        parsedRoutes.add(route);\n+      }\n+      return ConfigOrError.fromConfig(new XdsRoutingConfig(parsedRoutes, parsedActions));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse xds_routing LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  private static PolicySelection parseAction(\n+      Map<String, ?> rawAction, LoadBalancerRegistry registry) {\n+    List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+        JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+    if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+      throw new RuntimeException(\"childPolicy not specified\");\n+    }\n+    ConfigOrError selectedConfigOrError =\n+        ServiceConfigUtil.selectLbPolicyFromList(childConfigCandidates, registry);\n+    if (selectedConfigOrError.getError() != null) {\n+      throw selectedConfigOrError.getError().asRuntimeException();", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0ODA2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r433548067", "bodyText": "Slightly enhanced error propagation, threw away some stacktrace. Btw, the exception cases should ideally never happen. If it happens, the exception should have been surfaced to the Channel.\nThere is no perfect way to provide information about the error precisely, given that the JSON config is deeply nested and objects do not have keys that we can reference to. Unless we print out a tremendously long error message that locates the error level by level down, we are not able to point to the exact line of error in the JSON config. With that way, the error message would be something like:\nFailed to parse xds_routing LB config: [a giant config JSON string for the whole config]\n.....\nFailed to parse HeaderMatcher: [a smaller but still big JSON object for the header matcher]\n.....\nFailed to parse Range: [a JSON object represents a Range]\n....\n\nThis is hard to read and the effort it takes to find the malformed data is equal to proofread the whole JSON config.\nThe StructOrErrorStatus approach doesn't give better handling, it gives similar result but with verbose handling logic (at each step, always need to check if the enclosed is a struct or an error). Currently, we use a concise the error message that gives pretty much valuable hint for users to find the issue of the config.", "author": "voidzcy", "createdAt": "2020-06-01T23:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1NTA4MA==", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432655080", "bodyText": "This is wrong. It should be import com.google.re2j.PatternSyntaxException;", "author": "voidzcy", "createdAt": "2020-05-29T18:12:26Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -31,13 +33,15 @@\n import io.grpc.internal.ServiceConfigUtil;\n import io.grpc.internal.ServiceConfigUtil.LbConfig;\n import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.RouteMatchers.FractionMatcher;\n+import io.grpc.xds.RouteMatchers.HeaderMatcher;\n+import io.grpc.xds.RouteMatchers.PathMatcher;\n import java.util.ArrayList;\n-import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n+import java.util.regex.PatternSyntaxException;", "originalCommit": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "df9957368b2ac46e957a825f008e2c7046ea8d53", "url": "https://github.com/grpc/grpc-java/commit/df9957368b2ac46e957a825f008e2c7046ea8d53", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/xds_routing_policy_config_generation_and_parsing", "committedDate": "2020-06-01T21:31:44Z", "type": "commit"}, {"oid": "665bb77900c96bcd6cd0cc015bdbb8d4a9e44880", "url": "https://github.com/grpc/grpc-java/commit/665bb77900c96bcd6cd0cc015bdbb8d4a9e44880", "message": "Fix using the wrong regex exception type.", "committedDate": "2020-06-01T21:34:15Z", "type": "commit"}, {"oid": "86a66e14756ed22167b052b24d428288070553cb", "url": "https://github.com/grpc/grpc-java/commit/86a66e14756ed22167b052b24d428288070553cb", "message": "Empty line at the end of file.", "committedDate": "2020-06-01T21:34:49Z", "type": "commit"}, {"oid": "c820a6b8e8dbb56ec846b1cbef97d1759fceb0d5", "url": "https://github.com/grpc/grpc-java/commit/c820a6b8e8dbb56ec846b1cbef97d1759fceb0d5", "message": "Remove implemented TODO", "committedDate": "2020-06-01T21:35:54Z", "type": "commit"}, {"oid": "4c5425460163e513ee2a9df53e466961df0f30b7", "url": "https://github.com/grpc/grpc-java/commit/4c5425460163e513ee2a9df53e466961df0f30b7", "message": "Fix year in preface.", "committedDate": "2020-06-01T21:36:35Z", "type": "commit"}, {"oid": "9ec36cfd87400c46933df39bedc49f4ee6a30496", "url": "https://github.com/grpc/grpc-java/commit/9ec36cfd87400c46933df39bedc49f4ee6a30496", "message": "Suppress unchecked warning.", "committedDate": "2020-06-01T22:52:30Z", "type": "commit"}, {"oid": "fff55261c72e276015da17cfb070ad5638c64f43", "url": "https://github.com/grpc/grpc-java/commit/fff55261c72e276015da17cfb070ad5638c64f43", "message": "Use an unified definition of RouteMatch for both parsed Envoy proto and in xds_routing LB config.", "committedDate": "2020-06-01T23:03:48Z", "type": "commit"}, {"oid": "1c2028fa420008e9fd7a71275225bed28b155200", "url": "https://github.com/grpc/grpc-java/commit/1c2028fa420008e9fd7a71275225bed28b155200", "message": "Add head comment for RouteMatch.", "committedDate": "2020-06-01T23:11:04Z", "type": "commit"}, {"oid": "8348b5b1b1ccb0b3267f4a79129378b4694aef40", "url": "https://github.com/grpc/grpc-java/commit/8348b5b1b1ccb0b3267f4a79129378b4694aef40", "message": "Improve error message propagation.", "committedDate": "2020-06-01T23:37:23Z", "type": "commit"}]}