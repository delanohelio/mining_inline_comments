{"pr_number": 7039, "pr_title": "xds: implement priority lb", "pr_createdAt": "2020-05-13T18:32:52Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7039", "timeline": [{"oid": "d9394bbde09f9b753e76e656700ef8ba4c72a48d", "url": "https://github.com/grpc/grpc-java/commit/d9394bbde09f9b753e76e656700ef8ba4c72a48d", "message": "add tests", "committedDate": "2020-05-18T22:25:51Z", "type": "forcePushed"}, {"oid": "2a9a6141e5d40b210acd404c697188aea578ca21", "url": "https://github.com/grpc/grpc-java/commit/2a9a6141e5d40b210acd404c697188aea578ca21", "message": "xds: implement priority lb", "committedDate": "2020-05-19T00:03:58Z", "type": "commit"}, {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "url": "https://github.com/grpc/grpc-java/commit/ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "message": "add tests", "committedDate": "2020-05-19T00:04:06Z", "type": "commit"}, {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "url": "https://github.com/grpc/grpc-java/commit/ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "message": "add tests", "committedDate": "2020-05-19T00:04:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NzQ1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427477456", "bodyText": "Should this be put in XdsLbPolicies?", "author": "voidzcy", "createdAt": "2020-05-19T17:32:18Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Provider for priority load balancing policy. */\n+final class PriorityLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return \"priority_experimental\";", "originalCommit": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwODEwMA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427608100", "bodyText": "Unlike policies in XdsLbPolicies, this string is not used anywhere, like used by XdsNameResolver. When we do have usage of it, we can move it there.", "author": "dapengzhang0", "createdAt": "2020-05-19T21:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NzQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NTQ2NA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427495464", "bodyText": "Maybe also check the other direction to ensure exact 1:1 mapping?", "author": "voidzcy", "createdAt": "2020-05-19T18:00:06Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Provider for priority load balancing policy. */\n+final class PriorityLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return \"priority_experimental\";\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new PriorityLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  static final class PriorityLbConfig {\n+    final Map<String, PolicySelection> childConfigs;\n+    final List<String> priorities;\n+\n+    PriorityLbConfig(Map<String, PolicySelection> childConfigs, List<String> priorities) {\n+      this.childConfigs = Collections.unmodifiableMap(checkNotNull(childConfigs, \"childConfigs\"));\n+      this.priorities = Collections.unmodifiableList(checkNotNull(priorities, \"priorities\"));\n+      checkArgument(!priorities.isEmpty(), \"priority list is empty\");\n+      checkArgument(\n+          childConfigs.keySet().containsAll(priorities),", "originalCommit": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMjIwMg==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427622202", "bodyText": "Yes, but sometime it's easy to miss some non-essential checks. Another check is that the list should not have duplicate names.", "author": "dapengzhang0", "createdAt": "2020-05-19T21:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NTQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MzczMg==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r430773732", "bodyText": "An implementation can do anything (even halt the program) if the input does not meet the precondition. Checks are just performing quick screenings to the input and fail uniformly if precondition is not met. If checks are expensive (e.g., no duplicates), we should not do it. It's caller's responsibility to ensure the precondition of the callee method is met.\nI would not be too picky for this.", "author": "voidzcy", "createdAt": "2020-05-27T00:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxODk0NA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427518944", "bodyText": "It's better to cache addresses and mappings in a way that is easy for this class to use and represents this class's internal state, instead of dumping ResolvedAddresses here.", "author": "voidzcy", "createdAt": "2020-05-19T18:39:16Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;", "originalCommit": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNzk3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427627979", "bodyText": "We still need resolvedAddresses.toBuilder() for ChildLbState.updateResolvedAddresses(). Otherwise we need cache all fields, such as attributes,  of resolvedAddresses that are unchanged and passing downstream. If ResolvedAddresses have more fields in the future, it's tedious to cache them and easy forgotten.", "author": "dapengzhang0", "createdAt": "2020-05-19T22:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxODk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0NzQ0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427647447", "bodyText": "Personally, I am not wild of doing resolvedAddresses.toBuilder() for passing addresses to downstream policies. I would just create a new ResolvedAddresses and only put in things needed.\nEach policy should keep only information it and its downstream policies need from ResolvedAddresses and throw away anything else. It should only pass down information needed by its downstream policies, nothing more. We are doing address filtering to give each downstream policy only addresses they need, same idea should apply for all information they would receive. This is how layering works.\nBut anyway, we already have a lot of this kind of \"lazy ideas\" involved in the design, I am fine with what it is now.", "author": "voidzcy", "createdAt": "2020-05-19T23:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxODk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0OTgzOA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427649838", "bodyText": "Each policy does not know in general what information are not needed by its downstream. Each policy can only process the information it knows (address filtering, and extract child policy from PolicySelection), all other unrecognized attributes need be passed downstream.", "author": "dapengzhang0", "createdAt": "2020-05-19T23:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxODk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzA4Nw==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427523087", "bodyText": "\"Resources\" might be ambiguous. Maybe: \"Unable to connect to endpoints with priority ...\". Also, the variable priority (and keys of priorityToIndex) is just a canonical string used to refer to each child policy, it does not reveal any priority information. I believe those names are internal implementation details and have no real meanings (they are created only for easiness of updating existing child policies). So you may want to change misleading usages in this class such as error messages, variable naming, etc.", "author": "voidzcy", "createdAt": "2020-05-19T18:46:07Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(\n+              TRANSIENT_FAILURE,\n+              new ErrorPicker(\n+                  Status.UNAVAILABLE.withDescription(\n+                      \"Resources for priority \" + priority + \" not reachable in 10 seconds\")));", "originalCommit": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MDMwNA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427640304", "bodyText": "\"endpoints\" might be too specific, given that priority_lb is not xds-specific.\nAs for the variable priority, do you think the priority index would be better?", "author": "dapengzhang0", "createdAt": "2020-05-19T22:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427530224", "bodyText": "Isn't this wrong? Failing over from one priority to another causes a TRANSIENT_FAILURE picker to the upstream policy (and maybe Channel)?", "author": "voidzcy", "createdAt": "2020-05-19T18:58:01Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(", "originalCommit": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjE1MQ==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427642151", "bodyText": "I think when current priority fails explicitly, we should go to TRANSIENT_FAILURE to let the end user know something is already broken, before failing over to the next priority (which takes time to connect). I remember we had a discussion with @ejona86  before. An exceptional case might be that the next priority is already READY but was in a previously de-activated state, in this case we can immediately re-activate the next priority and use its picker without disruption.", "author": "dapengzhang0", "createdAt": "2020-05-19T22:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MjUyMA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427672520", "bodyText": "I think @markdroth had said the behavior should be to wait for the new priority to come online, like we do in startup. I can see it both ways, but delaying seems fair; that would be similar to our pick_first behavior. It is clear we would want this behavior to be the same cross-language.", "author": "ejona86", "createdAt": "2020-05-20T00:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MzM5NA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428183394", "bodyText": "If the current priority fails and there is another priority to try, we should report CONNECTING.  I think we should report failure only if all priorities have failed.\nIn C-core, TryNextPriority() takes a boolean parameter called report_connecting that tells it whether to put the channel in CONNECTING when it finds a priority that needs time to connect:\nhttps://github.com/grpc/grpc/blob/7f20bccd4ddeceaad0a8ad9532e68a0f9e10b359/src/core/ext/filters/client_channel/lb_policy/priority/priority.cc#L399\nWe call TryNextPriority() with report_connecting=true when the current priority fails and when we get our very first update after we are created.  Otherwise, we call it with report_connecting=false.\nI've updated the psuedo-code in the design doc to clarify this.", "author": "markdroth", "createdAt": "2020-05-20T17:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MTI5MA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428981290", "bodyText": "Changed. Thanks for the pseudo-code update.", "author": "dapengzhang0", "createdAt": "2020-05-22T00:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA=="}], "type": "inlineReview"}, {"oid": "4a0e10eb861b01eb71b69915b55139c047c8dd7e", "url": "https://github.com/grpc/grpc-java/commit/4a0e10eb861b01eb71b69915b55139c047c8dd7e", "message": "add more checks for PriorityLbConfig", "committedDate": "2020-05-19T22:01:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4NDkzNQ==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428184935", "bodyText": "I haven't reviewed all of this code, but I happened to notice this while replying to the comment above, and I thought I should mention that this looks wrong.\nWhen a given child goes into TRANSIENT_FAILURE, we don't necessarily know that we should go to the priority after the current one.  For example, consider the following case:\n\nPriority list is [A, B, C], and we are currently using A.\nWe get an update that changes the priority list to [B, A, C].  We keep the current priority set to A, but we immediately start trying to connect to B, since it is now a higher priority.\nWhile B is still trying to connect, A fails.\n\nIn this case, there is no need to start trying C, because we are already trying B.  We should not try C unless B winds up failing.\nTo address this, I think that TryNextPriority() should always start from the highest priority and work its way down the list, even if it's called because a priority halfway down the list failed.  At worst, this will cause it to iterate over some priorities that are already known to be bad, but the current state of those priorities should be cached, so that shouldn't cause much overhead.", "author": "markdroth", "createdAt": "2020-05-20T17:27:44Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(\n+              TRANSIENT_FAILURE,\n+              new ErrorPicker(\n+                  Status.UNAVAILABLE.withDescription(\n+                      \"Resources for priority \" + priority + \" not reachable in 10 seconds\")));\n+          logger.log(XdsLogLevel.DEBUG, \"Priority {0} failed over to next\", priority);\n+          tryNextPriority(idx + 1);", "originalCommit": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNzI4NA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428317284", "bodyText": "1 Priority list is [A, B, C], and we are currently using A.\n\nIf A is READY, then this timer is cancelled.\n\n\nWe get an update that changes the priority list to [B, A, C]. We keep the current priority set to A, but we immediately start trying to connect to B, since it is now a higher priority.\n\n\nIf A was not ready yet, A is deactivated because B bumps up, so when the timer expires, it does nothing https://github.com/grpc/grpc-java/pull/7039/files/ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03#diff-73965829139c9a616f79961469364652R183-R184\nSo in either case, when B bumps up and A fails while B is still trying to connect, A won't fail over to C.", "author": "dapengzhang0", "createdAt": "2020-05-20T21:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyNzQ3NQ==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428327475", "bodyText": "But I agree that let TryNextPriority() always start from the highest priority will make the code much more easier to read with less concern. It does not cause overhead, only when debugging it might take more iterations to track the code.", "author": "dapengzhang0", "createdAt": "2020-05-20T21:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzODU2MA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428338560", "bodyText": "If A was not ready yet, A is deactivated because B bumps up\n\nI don't think A should be deactivated in that case, becuse it is still present in the config, and it is the currently the highest-priority child that is READY.  It should only get deactivated once B becomes READY, at which point we should use the same code-path as if the config had never changed but B had previously been in TRANSIENT_FAILURE (i.e., as if we are moving back to a higher-priority child that has just recovered from a failure).", "author": "markdroth", "createdAt": "2020-05-20T22:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM0MzkyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428343929", "bodyText": "If A was not ready yet, A is deactivated because B bumps up\n\n\n\nI don't think A should be deactivated in that case, becuse it is still present in the config, and it is the currently the highest-priority child that is READY.\n\nThe assumption in that case A is not READY. If A had been READY the timer itself would be cancelled. I think that \"A should only get deactivated once B becomes READY\" is right. Anyway, I will let TryNextPriority() always start from p0. Otherwise there are so many edge cases and subtleties to worry about.", "author": "dapengzhang0", "createdAt": "2020-05-20T22:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4NDkzNQ=="}], "type": "inlineReview"}, {"oid": "676ef03c9a29c2a3fc6e8c23f0f6a2363ea9ded5", "url": "https://github.com/grpc/grpc-java/commit/676ef03c9a29c2a3fc6e8c23f0f6a2363ea9ded5", "message": "tryNextPriority() always starts from P0", "committedDate": "2020-05-21T23:09:49Z", "type": "commit"}, {"oid": "1f8058e4b8e50bae47288ecf993616ca60e44454", "url": "https://github.com/grpc/grpc-java/commit/1f8058e4b8e50bae47288ecf993616ca60e44454", "message": "comply with the latest tryNextPriority()", "committedDate": "2020-05-22T00:18:18Z", "type": "commit"}, {"oid": "a3fbd774f7ae3aeb5d41a395b469af6258eb7a08", "url": "https://github.com/grpc/grpc-java/commit/a3fbd774f7ae3aeb5d41a395b469af6258eb7a08", "message": "fix a typo", "committedDate": "2020-05-22T00:23:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MDExNA==", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r430780114", "bodyText": "nit: Can you update the naming? Things like List<String> priorities or String priority are hard to follow (I would expect a number when seeing something named priority). Something like priorityName would be much better.", "author": "voidzcy", "createdAt": "2020-05-27T00:31:42Z", "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;", "originalCommit": "a3fbd774f7ae3aeb5d41a395b469af6258eb7a08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f38f13c9929766557bb0c676e944074f5ea01258", "url": "https://github.com/grpc/grpc-java/commit/f38f13c9929766557bb0c676e944074f5ea01258", "message": "make comment more precise", "committedDate": "2020-05-28T17:22:50Z", "type": "commit"}, {"oid": "b7cc4f0638f7bd89e544a1fcd5e657bec20b7239", "url": "https://github.com/grpc/grpc-java/commit/b7cc4f0638f7bd89e544a1fcd5e657bec20b7239", "message": "rename priorities to priorityNames", "committedDate": "2020-05-28T17:31:21Z", "type": "commit"}]}