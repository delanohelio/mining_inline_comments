{"pr_number": 6585, "pr_title": "interop-testing: Add XdsTestClient and XdsTestServer", "pr_createdAt": "2020-01-06T18:38:03Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6585", "timeline": [{"oid": "da2b433b200104b83e6914d2f67234452be989c1", "url": "https://github.com/grpc/grpc-java/commit/da2b433b200104b83e6914d2f67234452be989c1", "message": "interop-testing: Add XdsTestClient and XdsTestServer", "committedDate": "2020-01-06T22:08:57Z", "type": "commit"}, {"oid": "da2b433b200104b83e6914d2f67234452be989c1", "url": "https://github.com/grpc/grpc-java/commit/da2b433b200104b83e6914d2f67234452be989c1", "message": "interop-testing: Add XdsTestClient and XdsTestServer", "committedDate": "2020-01-06T22:08:57Z", "type": "forcePushed"}, {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3", "url": "https://github.com/grpc/grpc-java/commit/ca483af07cf554fc5fd4ccbfa2659640b2419dc3", "message": "fix android-interop-testing build", "committedDate": "2020-01-06T23:10:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5Mjk1MQ==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364492951", "bodyText": "Why not fail the entire test immediately? Or just log the error and let host name be empty.", "author": "dapengzhang0", "createdAt": "2020-01-08T23:22:24Z", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+\n+/** Interop test server that implements the xDS testing service. */\n+public final class XdsTestServer {\n+  private int port = 8080;\n+  private String serverId = \"java_server\";\n+  private Server server;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) throws Exception {\n+    final XdsTestServer server = new XdsTestServer();\n+    server.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  System.out.println(\"Shutting down\");\n+                  server.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    server.start();\n+    System.out.println(\"Server started on port \" + server.port);\n+    server.blockUntilShutdown();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"port\".equals(key)) {\n+        port = Integer.valueOf(value);\n+      } else if (\"server_id\".equals(key)) {\n+        serverId = value;\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestServer s = new XdsTestServer();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --port=INT          listening port for server.\"\n+              + \"\\n                      Default: \"\n+              + s.port\n+              + \"\\n  --server_id=STRING  server ID for response.\"\n+              + \"\\n                      Default: \"\n+              + s.serverId);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void start() throws Exception {\n+    server = NettyServerBuilder.forPort(port).addService(new TestServiceImpl()).build().start();\n+  }\n+\n+  private void stop() throws Exception {\n+    server.shutdownNow();\n+    if (!server.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private void blockUntilShutdown() throws InterruptedException {\n+    if (server != null) {\n+      server.awaitTermination();\n+    }\n+  }\n+\n+  private class TestServiceImpl extends TestServiceGrpc.TestServiceImplBase {\n+    private final String host;\n+\n+    private TestServiceImpl() {\n+      String tmpHost;\n+      try {\n+        tmpHost = InetAddress.getLocalHost().getHostName();\n+      } catch (UnknownHostException e) {\n+        tmpHost = \"failed to get host \" + e;", "originalCommit": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzY4MQ==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364897681", "bodyText": "Done", "author": "ericgribkoff", "createdAt": "2020-01-09T18:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5Mjk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364497171", "bodyText": "Why not just call the rpc method with stub?", "author": "dapengzhang0", "createdAt": "2020-01-08T23:37:21Z", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      ListeningScheduledExecutorService exec =\n+          MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        exec.shutdownNow();\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();\n+        }\n+      }\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+\n+    statsServer.shutdownNow();\n+    System.exit(success ? 0 : 1);\n+  }\n+\n+  private void stop() throws Exception {\n+    statsServer.shutdownNow();\n+    if (!statsServer.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private long currentRequestId;\n+\n+  private void runQps(final List<ManagedChannel> chans, ListeningScheduledExecutorService exec)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    final SettableFuture<Void> failure = SettableFuture.create();\n+    final class PeriodicRpc implements Runnable {\n+      final AtomicLong messageIds = new AtomicLong();\n+\n+      @Override\n+      public void run() {\n+        final long requestId;\n+        final Set<XdsStatsWatcher> savedWatchers = new HashSet<>();\n+        synchronized (lock) {\n+          currentRequestId += 1;\n+          requestId = currentRequestId;\n+          savedWatchers.addAll(watchers);\n+        }\n+\n+        SimpleRequest request = SimpleRequest.newBuilder().setFillServerId(true).build();\n+        ManagedChannel channel = chans.get((int) (requestId % chans.size()));\n+        final ClientCall<SimpleRequest, SimpleResponse> call =\n+            channel.newCall(", "originalCommit": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUwMDczOQ==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364500739", "bodyText": "To be able to invoke call.getAttributes().get(Grpc.TRANSPORT_ATTR_REMOTE_ADDR). If there's a simpler way to get access to the call attributes I'd be happy to change this.", "author": "ericgribkoff", "createdAt": "2020-01-08T23:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMDA2Ng==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364510066", "bodyText": "An alternative is using interceptor, it may not be much simpler though.\nAtomicReference<ClientCall> clientCallRef = new AtomicReference<>();\nstub = stub.withDeadlineAfter().withInterceptors(\n  new ClientInterceptor() {\n      @Override\n      public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n          MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n        ClientCall<ReqT, RespT> call = next.newCall(method,callOptions);\n        clientCallRef.set(call);\n        return call;\n  });\n\ntry {\n  SimpleResponse response = stub.unaryCall(request);\n  serverId = response.getServerId();\n  if (printResponse) {\n    System.out.println(\n       \"Greeting: Hello world, this is \"\n          + response.getHostname()\n          + \", from \"\n          + clientCallRef.get().getAttributes().get(Grpc.TRANSPORT_ATTR_REMOTE_ADDR));\n  }\n} catch(RuntimeException e) {\n} finally {\n  for (XdsStatsWatcher watcher : savedWatchers) {\n    watcher.rpcCompleted(requestId, serverId);\n  }\n}", "author": "dapengzhang0", "createdAt": "2020-01-09T00:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMjI3Ng==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364512276", "bodyText": "Yeah I'm not sure that's simpler either :) I think it's \"equally\" valid to directly interact with the ClientCall API as opposed to using an interceptor (there are at least examples of how do so in the ClientCall javadoc)?", "author": "ericgribkoff", "createdAt": "2020-01-09T00:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ=="}], "type": "inlineReview"}, {"oid": "2978f26386fda3aaacb63372eb5dbb1bc8d3080b", "url": "https://github.com/grpc/grpc-java/commit/2978f26386fda3aaacb63372eb5dbb1bc8d3080b", "message": "fixup", "committedDate": "2020-01-09T18:48:46Z", "type": "commit"}, {"oid": "2142548af7e7da5fbbd9566186dcad4be1e8a1e7", "url": "https://github.com/grpc/grpc-java/commit/2142548af7e7da5fbbd9566186dcad4be1e8a1e7", "message": "comment", "committedDate": "2020-01-10T19:06:46Z", "type": "commit"}, {"oid": "1db6bce61f5b9342f2225278a5dede6245b9a8c8", "url": "https://github.com/grpc/grpc-java/commit/1db6bce61f5b9342f2225278a5dede6245b9a8c8", "message": "shutdown exec\n\ncla bump?", "committedDate": "2020-01-11T00:12:49Z", "type": "commit"}, {"oid": "1db6bce61f5b9342f2225278a5dede6245b9a8c8", "url": "https://github.com/grpc/grpc-java/commit/1db6bce61f5b9342f2225278a5dede6245b9a8c8", "message": "shutdown exec\n\ncla bump?", "committedDate": "2020-01-11T00:12:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4Mjg1NQ==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r365482855", "bodyText": "nit: This should also be done in ShutdownHook, otherwise it may not be triggered if you press Ctrl-C.", "author": "dapengzhang0", "createdAt": "2020-01-11T00:44:56Z", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+  private long currentRequestId;\n+  private ListeningScheduledExecutorService exec;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      exec = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();", "originalCommit": "1db6bce61f5b9342f2225278a5dede6245b9a8c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk5OTc1MQ==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r365999751", "bodyText": "done", "author": "ericgribkoff", "createdAt": "2020-01-13T19:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4Mjg1NQ=="}], "type": "inlineReview"}, {"oid": "897a0dd24f4f1773745463a2a65497682e92dc3f", "url": "https://github.com/grpc/grpc-java/commit/897a0dd24f4f1773745463a2a65497682e92dc3f", "message": "fixup: move channel shutdown", "committedDate": "2020-01-13T19:58:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyMjEwNw==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r366022107", "bodyText": "Should we always System.exit(1)?", "author": "dapengzhang0", "createdAt": "2020-01-13T20:53:04Z", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private final List<ManagedChannel> channels = new ArrayList<>();\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+  private long currentRequestId;\n+  private ListeningScheduledExecutorService exec;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      for (int i = 0; i < numChannels; i++) {\n+        channels.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      exec = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      runQps();\n+      success = true;\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+    System.exit(success ? 0 : 1);", "originalCommit": "897a0dd24f4f1773745463a2a65497682e92dc3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA1MjA5MA==", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r366052090", "bodyText": "yep, done", "author": "ericgribkoff", "createdAt": "2020-01-13T22:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyMjEwNw=="}], "type": "inlineReview"}, {"oid": "791ee152eec2e25ad8530a70cba52227fd9f61e6", "url": "https://github.com/grpc/grpc-java/commit/791ee152eec2e25ad8530a70cba52227fd9f61e6", "message": "more", "committedDate": "2020-01-13T22:00:56Z", "type": "commit"}]}