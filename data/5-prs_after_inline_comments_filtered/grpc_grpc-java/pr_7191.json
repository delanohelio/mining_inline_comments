{"pr_number": 7191, "pr_title": "xds: Added a CEL-based Authorization Engine", "pr_createdAt": "2020-07-08T23:18:52Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7191", "timeline": [{"oid": "78118e910777a900cf86a9601196c43dc8418664", "url": "https://github.com/grpc/grpc-java/commit/78118e910777a900cf86a9601196c43dc8418664", "message": "Resolved Sanjay's review comments", "committedDate": "2020-08-13T19:04:07Z", "type": "forcePushed"}, {"oid": "246c04477f3c8fcddfb17f326de8bd4edd5cc294", "url": "https://github.com/grpc/grpc-java/commit/246c04477f3c8fcddfb17f326de8bd4edd5cc294", "message": "Resolved Sanjay's review comments", "committedDate": "2020-08-13T19:23:06Z", "type": "commit"}, {"oid": "246c04477f3c8fcddfb17f326de8bd4edd5cc294", "url": "https://github.com/grpc/grpc-java/commit/246c04477f3c8fcddfb17f326de8bd4edd5cc294", "message": "Resolved Sanjay's review comments", "committedDate": "2020-08-13T19:23:06Z", "type": "forcePushed"}, {"oid": "11bca0f1985bb1062a785b145a53c21ff4ddd62f", "url": "https://github.com/grpc/grpc-java/commit/11bca0f1985bb1062a785b145a53c21ff4ddd62f", "message": "Added cel evaluation engine implementation", "committedDate": "2020-07-09T21:31:22Z", "type": "forcePushed"}, {"oid": "d2b82cfaad4bfa29164ef17812ae649d7ca55af3", "url": "https://github.com/grpc/grpc-java/commit/d2b82cfaad4bfa29164ef17812ae649d7ca55af3", "message": "Updated Cel Engine's evaluate function", "committedDate": "2020-07-13T19:13:07Z", "type": "forcePushed"}, {"oid": "8d13480ec2556ea110b4ed873322c7df50af1726", "url": "https://github.com/grpc/grpc-java/commit/8d13480ec2556ea110b4ed873322c7df50af1726", "message": "Updated Cel Engine's evaluate function", "committedDate": "2020-07-13T20:08:39Z", "type": "forcePushed"}, {"oid": "99583cc57f1fd0c0aad3eb1d4497a48f88826085", "url": "https://github.com/grpc/grpc-java/commit/99583cc57f1fd0c0aad3eb1d4497a48f88826085", "message": "Updated Cel Engine's evaluate function", "committedDate": "2020-07-13T20:35:54Z", "type": "forcePushed"}, {"oid": "02d77d939e57383eb235d61362d26bf09b71b905", "url": "https://github.com/grpc/grpc-java/commit/02d77d939e57383eb235d61362d26bf09b71b905", "message": "Add unit test for evaluate function and EvaluateArgs\n\nCindy/cel engine mock", "committedDate": "2020-07-14T20:49:14Z", "type": "forcePushed"}, {"oid": "a72fb92b39e2ce74fc8d683694f8e67a8c403608", "url": "https://github.com/grpc/grpc-java/commit/a72fb92b39e2ce74fc8d683694f8e67a8c403608", "message": "Merged master into current branch", "committedDate": "2020-07-14T23:14:51Z", "type": "forcePushed"}, {"oid": "2cc3916fb49fcbc735b32270ffede164c2344bea", "url": "https://github.com/grpc/grpc-java/commit/2cc3916fb49fcbc735b32270ffede164c2344bea", "message": "Rebased with master branch", "committedDate": "2020-07-14T23:27:06Z", "type": "forcePushed"}, {"oid": "c7aeba38e5640dc480d09b917425c7f5e9742884", "url": "https://github.com/grpc/grpc-java/commit/c7aeba38e5640dc480d09b917425c7f5e9742884", "message": "Rebased with master branch", "committedDate": "2020-07-14T23:52:21Z", "type": "forcePushed"}, {"oid": "82a2cef263847100a1588d48bb1b3422ac4cdd0b", "url": "https://github.com/grpc/grpc-java/commit/82a2cef263847100a1588d48bb1b3422ac4cdd0b", "message": "Rebased with master branch", "committedDate": "2020-07-15T00:27:15Z", "type": "forcePushed"}, {"oid": "f41404a5b7f10e52252156606dddad3822bb5e8e", "url": "https://github.com/grpc/grpc-java/commit/f41404a5b7f10e52252156606dddad3822bb5e8e", "message": "Rebased with master branch", "committedDate": "2020-07-15T00:46:07Z", "type": "forcePushed"}, {"oid": "4f91b1510db52065bf4603b41856a249b75474e2", "url": "https://github.com/grpc/grpc-java/commit/4f91b1510db52065bf4603b41856a249b75474e2", "message": "Rebased with master branch", "committedDate": "2020-07-15T01:36:12Z", "type": "forcePushed"}, {"oid": "460cfaf10608f1e7fbbda9dc8a2d127cf332da64", "url": "https://github.com/grpc/grpc-java/commit/460cfaf10608f1e7fbbda9dc8a2d127cf332da64", "message": "Rebased with master branch", "committedDate": "2020-07-15T02:02:55Z", "type": "forcePushed"}, {"oid": "e0d29d23dd88e025cce194232507c888fc6fa902", "url": "https://github.com/grpc/grpc-java/commit/e0d29d23dd88e025cce194232507c888fc6fa902", "message": "Rebased with master branch", "committedDate": "2020-07-15T02:21:42Z", "type": "forcePushed"}, {"oid": "507ef4a7983d4bb6e980874c56694984c87b0df2", "url": "https://github.com/grpc/grpc-java/commit/507ef4a7983d4bb6e980874c56694984c87b0df2", "message": "Rebased with master branch", "committedDate": "2020-07-15T02:34:25Z", "type": "commit"}, {"oid": "507ef4a7983d4bb6e980874c56694984c87b0df2", "url": "https://github.com/grpc/grpc-java/commit/507ef4a7983d4bb6e980874c56694984c87b0df2", "message": "Rebased with master branch", "committedDate": "2020-07-15T02:34:25Z", "type": "forcePushed"}, {"oid": "2c4199484718789ea60c5dcec2341d96aa58c457", "url": "https://github.com/grpc/grpc-java/commit/2c4199484718789ea60c5dcec2341d96aa58c457", "message": "Addressed updates on Cel engine", "committedDate": "2020-07-15T19:19:52Z", "type": "commit"}, {"oid": "c9b370d3d36f58a928993b27a1e6403d32084073", "url": "https://github.com/grpc/grpc-java/commit/c9b370d3d36f58a928993b27a1e6403d32084073", "message": "Changed evaluate's arguments from taking args to activation", "committedDate": "2020-07-15T20:36:19Z", "type": "commit"}, {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "url": "https://github.com/grpc/grpc-java/commit/17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "message": "Enabled cel engine to return a list of matching policies when there is a match", "committedDate": "2020-07-15T22:48:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMjIxNw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455432217", "bodyText": "nit: s/Cel/CEL/g.", "author": "ZhenLian", "createdAt": "2020-07-16T00:00:17Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by Cel Evaluation Engine. ", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzNjAyNA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455436024", "bodyText": "Should the length of action and conditions always be the same? If so, I think we can have one List here where RBACEngine is an inner class that contains RBAC.Action and ImmutableMap<String, Expr>. That might make the structure clearer.", "author": "ZhenLian", "createdAt": "2020-07-16T00:12:41Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MzM5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455483396", "bodyText": "Good point! Thanks for the advice :)", "author": "cindyxue", "createdAt": "2020-07-16T03:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzNjAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzODMyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455438329", "bodyText": "You can just use variable name rbac here otherwise rbacPolicy.getPolicies() looks a bit weird to me.\nAlso can we use range-based for loop hereI as well(like you did for the map)?", "author": "ZhenLian", "createdAt": "2020-07-16T00:20:43Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MDIyOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455480228", "bodyText": "Yes!", "author": "cindyxue", "createdAt": "2020-07-16T02:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzODMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0Mzk0MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455443940", "bodyText": "You can directly generate an ImmutableMap using ImmutableMap.Builder. No need to create one from Map.", "author": "ZhenLian", "createdAt": "2020-07-16T00:41:29Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {\n+        try {\n+          if (matches(entry.getValue(), activation)) {\n+            if (this.action.get(i) == RBAC.Action.ALLOW) {\n+              authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+            } else {\n+              authorizationDecision = AuthorizationDecision.Decision.DENY;\n+            }\n+            matchingPolicyNames.add(entry.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(entry.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and found unknown conditions. \n+    if (unknownPolicyNames.size() > 0) {\n+      authorizationDecision = AuthorizationDecision.Decision.UNKNOWN;\n+      return new AuthorizationDecision(authorizationDecision, unknownPolicyNames);\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.action.size() == 1 && this.action.get(0) == RBAC.Action.DENY) {\n+      authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+    } else {\n+      authorizationDecision = AuthorizationDecision.Decision.DENY;\n+    }\n+    return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using Cel library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in Cel library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    Object result = interpreter.createInterpretable(condition).eval(activation);\n+    if (result instanceof Boolean) {\n+      return Boolean.parseBoolean(result.toString());\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs<ReqT, RespT> args) {\n+    Map<String, Object> attributes = new HashMap<>();", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MDQwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455490401", "bodyText": "Sounds good!", "author": "cindyxue", "createdAt": "2020-07-16T03:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0Mzk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NDU3Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455444572", "bodyText": "nit: range-based loop.", "author": "ZhenLian", "createdAt": "2020-07-16T00:43:52Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4ODUyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455488529", "bodyText": "Ok, will fix!", "author": "cindyxue", "createdAt": "2020-07-16T03:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NDU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NDcxNQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455444715", "bodyText": "nit: avoid using vague names like \"entry\", etc.", "author": "ZhenLian", "createdAt": "2020-07-16T00:44:21Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTIyOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455445228", "bodyText": "nit:\nauthorizationDecision = this.action.get(i) == RBAC.Action.ALLOW ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY", "author": "ZhenLian", "createdAt": "2020-07-16T00:46:08Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {\n+        try {\n+          if (matches(entry.getValue(), activation)) {\n+            if (this.action.get(i) == RBAC.Action.ALLOW) {\n+              authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+            } else {\n+              authorizationDecision = AuthorizationDecision.Decision.DENY;\n+            }", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTU3NQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455445575", "bodyText": "when action is unknown, we will need to return a unknownPolicyNames; when action is allow/deny, we will need matchingPolicyNames. So actually we just need one list here.", "author": "ZhenLian", "createdAt": "2020-07-16T00:47:31Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4NzY4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455487682", "bodyText": "The reason I separate these two lists here is for a particular case when some conditions are matched and some conditions are unknown. If so, we would want to store matchedPolicy and unknownPolicy separately and always check if matchedPolicy is empty first. If matchedPolicy isn't empty, it means that there is at least a match, so we would return matchedPolicy and ignore unknownPolicy no matter if there are unknown conditions or not.", "author": "cindyxue", "createdAt": "2020-07-16T03:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUwNjkxNA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455506914", "bodyText": "OK. This sounds good. Thanks for the clarification!", "author": "ZhenLian", "createdAt": "2020-07-16T04:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODgxNw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455448817", "bodyText": "Let's change this to\nif (this.action.size() == 1 && this.action.get(0) == RBAC.Action.DENY) {\n      return new AuthorizationDecision(AuthorizationDecision.Decision.ALLOW, matchingPolicyNames);\n} \nreturn new AuthorizationDecision(AuthorizationDecision.Decision.DENY, matchingPolicyNames);\n\nSo basically we want to first pick out the special case, and do whatever we want for the rest, to avoid embedded if-else statements.\nAlso if matchingPolicyNames should always be empty in this case, consider adding a check before the if statement, or explicitly return an empty list.", "author": "ZhenLian", "createdAt": "2020-07-16T00:59:59Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {\n+        try {\n+          if (matches(entry.getValue(), activation)) {\n+            if (this.action.get(i) == RBAC.Action.ALLOW) {\n+              authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+            } else {\n+              authorizationDecision = AuthorizationDecision.Decision.DENY;\n+            }\n+            matchingPolicyNames.add(entry.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(entry.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and found unknown conditions. \n+    if (unknownPolicyNames.size() > 0) {\n+      authorizationDecision = AuthorizationDecision.Decision.UNKNOWN;\n+      return new AuthorizationDecision(authorizationDecision, unknownPolicyNames);\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.action.size() == 1 && this.action.get(0) == RBAC.Action.DENY) {\n+      authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+    } else {\n+      authorizationDecision = AuthorizationDecision.Decision.DENY;\n+    }\n+    return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);", "originalCommit": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MjUyNw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455482527", "bodyText": "I would prefer return an empty list in order to address that there is no matching policy in this case.", "author": "cindyxue", "createdAt": "2020-07-16T03:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUwNzY1MQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455507651", "bodyText": "OK. SG!", "author": "ZhenLian", "createdAt": "2020-07-16T04:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODgxNw=="}], "type": "inlineReview"}, {"oid": "d66f0250a2ba43524f7334f13fe6b262d8ac32cb", "url": "https://github.com/grpc/grpc-java/commit/d66f0250a2ba43524f7334f13fe6b262d8ac32cb", "message": "Review comments #1 - resolved nit issues", "committedDate": "2020-07-16T03:26:19Z", "type": "commit"}, {"oid": "a03e0ca5be8c3042a697b777c97ce2313735e09f", "url": "https://github.com/grpc/grpc-java/commit/a03e0ca5be8c3042a697b777c97ce2313735e09f", "message": "Used ImmutableMap builder to build ImmutableMap", "committedDate": "2020-07-16T03:54:10Z", "type": "commit"}, {"oid": "a03e0ca5be8c3042a697b777c97ce2313735e09f", "url": "https://github.com/grpc/grpc-java/commit/a03e0ca5be8c3042a697b777c97ce2313735e09f", "message": "Used ImmutableMap builder to build ImmutableMap", "committedDate": "2020-07-16T03:54:10Z", "type": "forcePushed"}, {"oid": "c4f3542dd3d19ec73837334fac6e22db9280d4c9", "url": "https://github.com/grpc/grpc-java/commit/c4f3542dd3d19ec73837334fac6e22db9280d4c9", "message": "Added an inner class RbacEngine to wrap action and condition fields", "committedDate": "2020-07-16T19:18:01Z", "type": "forcePushed"}, {"oid": "75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "url": "https://github.com/grpc/grpc-java/commit/75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "message": "Added an inner class RbacEngine to wrap action and condition fields", "committedDate": "2020-07-16T19:23:15Z", "type": "commit"}, {"oid": "75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "url": "https://github.com/grpc/grpc-java/commit/75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "message": "Added an inner class RbacEngine to wrap action and condition fields", "committedDate": "2020-07-16T19:23:15Z", "type": "forcePushed"}, {"oid": "bb21aeceb15469296e891a326c3a90bbd8bb5345", "url": "https://github.com/grpc/grpc-java/commit/bb21aeceb15469296e891a326c3a90bbd8bb5345", "message": "Merged master branch\n\nMerge with master branch", "committedDate": "2020-07-18T03:57:50Z", "type": "commit"}, {"oid": "4bf2da7a3f93da20e5c5c46d647b55ed4168064a", "url": "https://github.com/grpc/grpc-java/commit/4bf2da7a3f93da20e5c5c46d647b55ed4168064a", "message": "Changed package name for Cel Engine", "committedDate": "2020-07-18T04:19:03Z", "type": "commit"}, {"oid": "310e725be68be08f931a84befbf173ab44822ced", "url": "https://github.com/grpc/grpc-java/commit/310e725be68be08f931a84befbf173ab44822ced", "message": "Restructured unit test for cel evaluation which is able to take rbac with multiple policies now", "committedDate": "2020-07-19T23:35:15Z", "type": "commit"}, {"oid": "6c71c92b271c81d5f70408df52f327d07faff499", "url": "https://github.com/grpc/grpc-java/commit/6c71c92b271c81d5f70408df52f327d07faff499", "message": "Updated cel engine and unit tests based on new decision logic", "committedDate": "2020-07-20T20:30:33Z", "type": "commit"}, {"oid": "6c71c92b271c81d5f70408df52f327d07faff499", "url": "https://github.com/grpc/grpc-java/commit/6c71c92b271c81d5f70408df52f327d07faff499", "message": "Updated cel engine and unit tests based on new decision logic", "committedDate": "2020-07-20T20:30:33Z", "type": "forcePushed"}, {"oid": "9a0d1caaf088834027d3c4844f0c0d325453f63f", "url": "https://github.com/grpc/grpc-java/commit/9a0d1caaf088834027d3c4844f0c0d325453f63f", "message": "Renamed CelEngine to AuthorizationEngine", "committedDate": "2020-07-22T18:48:14Z", "type": "commit"}, {"oid": "c7a5a7a73b94eaad9b9d428e74a905d0c3337bc5", "url": "https://github.com/grpc/grpc-java/commit/c7a5a7a73b94eaad9b9d428e74a905d0c3337bc5", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes", "committedDate": "2020-07-23T19:59:12Z", "type": "forcePushed"}, {"oid": "9a20315153097991e4de88a3f704b2af1f376e82", "url": "https://github.com/grpc/grpc-java/commit/9a20315153097991e4de88a3f704b2af1f376e82", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes", "committedDate": "2020-07-23T20:13:32Z", "type": "forcePushed"}, {"oid": "f867d922aee9110ab0f89fe8b3ba5648348086b2", "url": "https://github.com/grpc/grpc-java/commit/f867d922aee9110ab0f89fe8b3ba5648348086b2", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes", "committedDate": "2020-07-24T01:41:11Z", "type": "forcePushed"}, {"oid": "9a0d1caaf088834027d3c4844f0c0d325453f63f", "url": "https://github.com/grpc/grpc-java/commit/9a0d1caaf088834027d3c4844f0c0d325453f63f", "message": "Renamed CelEngine to AuthorizationEngine", "committedDate": "2020-07-22T18:48:14Z", "type": "forcePushed"}, {"oid": "9a0d1caaf088834027d3c4844f0c0d325453f63f", "url": "https://github.com/grpc/grpc-java/commit/9a0d1caaf088834027d3c4844f0c0d325453f63f", "message": "Renamed CelEngine to AuthorizationEngine", "committedDate": "2020-07-22T18:48:14Z", "type": "forcePushed"}, {"oid": "a4c3ec8c2deee07c161ef87072a145632c287fba", "url": "https://github.com/grpc/grpc-java/commit/a4c3ec8c2deee07c161ef87072a145632c287fba", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes", "committedDate": "2020-07-31T22:30:12Z", "type": "commit"}, {"oid": "a4c3ec8c2deee07c161ef87072a145632c287fba", "url": "https://github.com/grpc/grpc-java/commit/a4c3ec8c2deee07c161ef87072a145632c287fba", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes", "committedDate": "2020-07-31T22:30:12Z", "type": "forcePushed"}, {"oid": "0d38b1f494d4a719dd54a45ff11f4ee076adbdc2", "url": "https://github.com/grpc/grpc-java/commit/0d38b1f494d4a719dd54a45ff11f4ee076adbdc2", "message": "Merge branch 'master' into Cindy/CelEvaluationEngine", "committedDate": "2020-07-31T22:42:22Z", "type": "commit"}, {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef", "url": "https://github.com/grpc/grpc-java/commit/65c31bda15da82ddf56726044a8adc80df9455ef", "message": "Merge branch 'master' into Cindy/CelEvaluationEngine", "committedDate": "2020-08-01T03:06:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzODA2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464138065", "bodyText": "nit: shall we change this variable name to policyNames? CEL expression is used to check if matches. At the level of authorization engine, we might not need to use the term matching, to avoid confusion.", "author": "ZhenLian", "createdAt": "2020-08-02T23:44:41Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {\n+    /** \n+     * The Decision ALLOW indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and allowed the gRPC call to go through.\n+     */\n+    ALLOW,\n+    /** \n+     * The Decision DENY indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and denied the gRPC call from going through.\n+     */\n+    DENY,\n+    /** \n+     * The Decision UNKNOWN indicates that CEL Evaluate Engine \n+     * did not have enough information to authorize the gRPC call. \n+     * */\n+    UNKNOWN,\n+  }\n+\n+  private final Decision decision;\n+  private final List<String> matchingPolicyNames;\n+\n+  /**\n+   * Creates a new authorization decision using the input {@code decision} \n+   * for resolving authorization decision\n+   * and {@code matchingPolicyNames} for resolving authorization context.\n+   */\n+  public AuthorizationDecision(Decision decision, List<String> matchingPolicyNames) {\n+    this.decision = decision;\n+    this.matchingPolicyNames = matchingPolicyNames;", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3Njg4NQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464176885", "bodyText": "Sure, that makes sense!", "author": "cindyxue", "createdAt": "2020-08-03T03:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzODA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzODI1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464138256", "bodyText": "Can we use some other names for authContext? such as authzStr, or decisionStr, etc.", "author": "ZhenLian", "createdAt": "2020-08-02T23:46:00Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {\n+    /** \n+     * The Decision ALLOW indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and allowed the gRPC call to go through.\n+     */\n+    ALLOW,\n+    /** \n+     * The Decision DENY indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and denied the gRPC call from going through.\n+     */\n+    DENY,\n+    /** \n+     * The Decision UNKNOWN indicates that CEL Evaluate Engine \n+     * did not have enough information to authorize the gRPC call. \n+     * */\n+    UNKNOWN,\n+  }\n+\n+  private final Decision decision;\n+  private final List<String> matchingPolicyNames;\n+\n+  /**\n+   * Creates a new authorization decision using the input {@code decision} \n+   * for resolving authorization decision\n+   * and {@code matchingPolicyNames} for resolving authorization context.\n+   */\n+  public AuthorizationDecision(Decision decision, List<String> matchingPolicyNames) {\n+    this.decision = decision;\n+    this.matchingPolicyNames = matchingPolicyNames;\n+  }\n+\n+  /** Returns the authorization decision. */\n+  public Decision getDecision() {\n+    return this.decision;\n+  }\n+\n+  /** Returns the matching policy list. */\n+  public List<String> getMatchingPolicyNames() {\n+    return this.matchingPolicyNames;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder authContext = new StringBuilder();", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3NzE2Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464177162", "bodyText": "Yes, I will change it to authzStr.", "author": "cindyxue", "createdAt": "2020-08-03T03:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzODI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzOTk3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464139979", "bodyText": "Can we directly use RBAC.Conditions here? If so, we probably can avoid creating our own map and can just use whatever provided by RBAC.", "author": "ZhenLian", "createdAt": "2020-08-03T00:01:28Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3ODgwMg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464178802", "bodyText": "RBAC only offers a policy map (reference). However, we only need policy's condition field, so I'm assuming we have to create our own condition map here?", "author": "cindyxue", "createdAt": "2020-08-03T03:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzOTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwMjYxMg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464502612", "bodyText": "Eventually we don't need RbacEngine.\nAuthorizationEngine just need to keep two InternalAuthorzationPolicy proto (allowPolicy and denyPolicy).\nDuring constructor of AuthorizationEngine:\n\nif input is Envoy RBAC, we just convert to InternalAuthorzationPolicy\nif input is InternalAuthorzationPolicy, we just store input internally.\n\nIn Evaluate(), we just first iterate denyPolicy then allowPolicy.\nFor now, let's keep as it is.\nOnce my design is signed off, I will make a PR for the AuthorizatioPolicy proto.", "author": "jiangtaoli2016", "createdAt": "2020-08-03T15:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzOTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDUwOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464140508", "bodyText": "Interpreter will be created for every CEL evaluation checking. Let's move it outside of the loop.", "author": "ZhenLian", "createdAt": "2020-08-03T00:06:42Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpreter.createInterpretable(condition).eval(activation);", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3OTE3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464179177", "bodyText": "Sounds good!", "author": "cindyxue", "createdAt": "2020-08-03T03:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464141102", "bodyText": "As far as I understand, the design of part is still ongoing yet. In this PR, we can assume evaluate function takes the activation and gRPC stack will set it directly(so in this PR we don't have to deal with that EvaluateArgs<ReqT, RespT> args anymore).\n@jiangtaoli2016 Feel free to correct me if this is not our current plan. Thanks!", "author": "ZhenLian", "createdAt": "2020-08-03T00:11:44Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpreter.createInterpretable(condition).eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs<ReqT, RespT> args) {", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3OTk1Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464179952", "bodyText": "Does it mean we can change the function signature to public AuthorizationDecision evaluate(Activation activation) for now?", "author": "cindyxue", "createdAt": "2020-08-03T03:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5NjY2MQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464496661", "bodyText": "I would keep the current API, i.e.,\nAuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args)\nAlso keep the extractFields -- so that we can test it.", "author": "jiangtaoli2016", "createdAt": "2020-08-03T15:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxODAwMg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464618002", "bodyText": "Sounds good!", "author": "cindyxue", "createdAt": "2020-08-03T19:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNDA1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468214057", "bodyText": "why protected ? Also related to whether AuthorizationEngine can be final or needs to be extended. If final this method can be final or private", "author": "sanjaypujare", "createdAt": "2020-08-10T22:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzQ1MQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468227451", "bodyText": "Currently there is no open-sourced CEL library in Java, so all the APIs used in Authorization Engine is from a mock Cel Library interface that only holds the function signature. Therefore, I had to use Mockito to mock the behavior of helper functions in order to test the logic of evaluate function on top of that. With that being said, all the helper functions are set to protected for now, so that they can be exposed for testing, but we will change it once CEL library is open sourced in the future.", "author": "cindyxue", "createdAt": "2020-08-10T22:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464142168", "bodyText": "if matches is only used once, can we move it to the evaluate logic? It might simplify the logic to handle IncompleteData.", "author": "ZhenLian", "createdAt": "2020-08-03T00:21:04Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MTQ4NA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464181484", "bodyText": "The evaluate function is more like evaluating the RBAC condition list input by the user and outputting the authorization decision, whereas the matches function handles evaluation of CEL expression and returns the eval result generated by CEL library. Thus, I think it would be more clear and readable to separate these two functions because they have different purposes. What do you think?\nMaybe we could rename matches if it's confusing?", "author": "cindyxue", "createdAt": "2020-08-03T03:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NTEwOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464575108", "bodyText": "I separated this matches function also because in the unit test, I have to mock the behavior of matches in order to test the behavior of evaluate function.", "author": "cindyxue", "createdAt": "2020-08-03T18:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3NzE4NQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465877185", "bodyText": "I guess you can also mock interpretable.eval(...) to achieve similar purposes, right?\nIMO, generally it is probably not a good idea to change the code structures to make the testing easier, unless you really have to. Also making this function protected also raised a bit of my concern(I guess you make it for testing purposes as well).\nBut honestly I am not sure about this as well. We can keep it as what it is right now, and see if other reviewers have any suggestions on that.", "author": "ZhenLian", "createdAt": "2020-08-05T17:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyNTg2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465925867", "bodyText": "Sure, thanks for pointing it out tho!", "author": "cindyxue", "createdAt": "2020-08-05T18:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMTUwMA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468231500", "bodyText": "protected is for subclasses and AFAICS there aren't any. May be package-private vs private is the issue? Also my personal preference is to split code into multiple functions for modularity/testability.", "author": "sanjaypujare", "createdAt": "2020-08-10T22:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMTY5Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468231692", "bodyText": "matches can be static since it doesn't use any instance vars of AuthorizationEngine?", "author": "sanjaypujare", "createdAt": "2020-08-10T23:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzODY4Mw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468938683", "bodyText": "The function matches will be changed to a private function in the future.", "author": "cindyxue", "createdAt": "2020-08-12T00:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0Mjg0OA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464142848", "bodyText": "Now when there is a match, we will only return the policy that first matches and return it in a list. So if there is a match, we will do an early stop and return a list containing only 1 item. We might also want to slightly change the logic we check the RBACs(So we will first check the first RABC, if it's undecided, then the result would be the decision of second RBAC). You can checkout the latest design details in @jiangtaoli2016 's doc, or check with Elizabeth. Please LMK if you have any questions. Thanks!", "author": "ZhenLian", "createdAt": "2020-08-03T00:26:17Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();", "originalCommit": "65c31bda15da82ddf56726044a8adc80df9455ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxMDA2Mw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464510063", "bodyText": "Once you have allowEngine and denyEngine. See discussion above. The evaluation logic is as follows:\nFirst iterate denyEngine's map (could be empty map). If there is match, immediately return deny. If there are unknown results, return undecided. If all non-match, we iterate allowEngine.\nOnce we enter allowEngine, if there is a match, immediately return allow. In the end of iteration, if there are unknown rules, return undecided. If all non-match, return deny.\nThe above logic is the same regardless if the constructor takes 1 or 2 RBAC rules.", "author": "jiangtaoli2016", "createdAt": "2020-08-03T16:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0Mjg0OA=="}], "type": "inlineReview"}, {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "url": "https://github.com/grpc/grpc-java/commit/e4def2622ab97ef95d96a39a5c0e02077eafa51e", "message": "Resolved Zhen's comments pt.2", "committedDate": "2020-08-03T04:10:30Z", "type": "commit"}, {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "url": "https://github.com/grpc/grpc-java/commit/e4def2622ab97ef95d96a39a5c0e02077eafa51e", "message": "Resolved Zhen's comments pt.2", "committedDate": "2020-08-03T04:10:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4ODgyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464488829", "bodyText": "Since we don't allow changing the policyNames, use ImmutableList", "author": "jiangtaoli2016", "createdAt": "2020-08-03T15:29:19Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {\n+    /** \n+     * The Decision ALLOW indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and allowed the gRPC call to go through.\n+     */\n+    ALLOW,\n+    /** \n+     * The Decision DENY indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and denied the gRPC call from going through.\n+     */\n+    DENY,\n+    /** \n+     * The Decision UNKNOWN indicates that CEL Evaluate Engine \n+     * did not have enough information to authorize the gRPC call. \n+     * */\n+    UNKNOWN,\n+  }\n+\n+  private final Decision decision;\n+  private final List<String> policyNames;", "originalCommit": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNTIyNw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464525227", "bodyText": "Sure!", "author": "cindyxue", "createdAt": "2020-08-03T16:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4ODgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwNTE5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464505193", "bodyText": "nit: make it static\nstatic private class RbacEngine", "author": "jiangtaoli2016", "createdAt": "2020-08-03T15:56:09Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {", "originalCommit": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNjQxNQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464526415", "bodyText": "Ok, will change!", "author": "cindyxue", "createdAt": "2020-08-03T16:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwNTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwNjg1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464506856", "bodyText": "I would explicitly have two engines: allowEngine and denyEngine, built from constructor.\nIf there is only one RBAC policy as input, we still have two engines, one of the engine has empty map though.", "author": "jiangtaoli2016", "createdAt": "2020-08-03T15:58:52Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;", "originalCommit": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzg5NA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464613894", "bodyText": "Ah I see, thanks for the advice :)", "author": "cindyxue", "createdAt": "2020-08-03T19:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwNjg1Ng=="}], "type": "inlineReview"}, {"oid": "d590b35322ad35a13d815fd3337615863f4a86a4", "url": "https://github.com/grpc/grpc-java/commit/d590b35322ad35a13d815fd3337615863f4a86a4", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T19:05:21Z", "type": "forcePushed"}, {"oid": "00d018a8ca8afb535fc9f8bf4c4b59830fdb9262", "url": "https://github.com/grpc/grpc-java/commit/00d018a8ca8afb535fc9f8bf4c4b59830fdb9262", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T19:16:40Z", "type": "forcePushed"}, {"oid": "bcc7f0f9d7ba3c2d4c50de01105c5d1915445cac", "url": "https://github.com/grpc/grpc-java/commit/bcc7f0f9d7ba3c2d4c50de01105c5d1915445cac", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T19:19:54Z", "type": "forcePushed"}, {"oid": "91b3835e2eb7de0c8dc75796590bd656248ab684", "url": "https://github.com/grpc/grpc-java/commit/91b3835e2eb7de0c8dc75796590bd656248ab684", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T19:26:10Z", "type": "forcePushed"}, {"oid": "3ef75f16f9a1687f284fa2947b82b9536ad7f1c5", "url": "https://github.com/grpc/grpc-java/commit/3ef75f16f9a1687f284fa2947b82b9536ad7f1c5", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T19:26:42Z", "type": "forcePushed"}, {"oid": "ee29c98b1f332595f223e3c46f7e7802800d83b1", "url": "https://github.com/grpc/grpc-java/commit/ee29c98b1f332595f223e3c46f7e7802800d83b1", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T20:22:22Z", "type": "forcePushed"}, {"oid": "63e65e98269bf63e8a61f7bd145dddb0fb7fe048", "url": "https://github.com/grpc/grpc-java/commit/63e65e98269bf63e8a61f7bd145dddb0fb7fe048", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T20:51:52Z", "type": "forcePushed"}, {"oid": "2fa798fa85c5d4b4066649f590f277d3608b45b2", "url": "https://github.com/grpc/grpc-java/commit/2fa798fa85c5d4b4066649f590f277d3608b45b2", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T21:36:33Z", "type": "forcePushed"}, {"oid": "bf3556e792c1bf024043ee1c7cd1782d0cace08d", "url": "https://github.com/grpc/grpc-java/commit/bf3556e792c1bf024043ee1c7cd1782d0cace08d", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T21:44:09Z", "type": "forcePushed"}, {"oid": "bb9d66ae38890ccbb5fede9bb0767f6715519334", "url": "https://github.com/grpc/grpc-java/commit/bb9d66ae38890ccbb5fede9bb0767f6715519334", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T22:03:24Z", "type": "commit"}, {"oid": "bb9d66ae38890ccbb5fede9bb0767f6715519334", "url": "https://github.com/grpc/grpc-java/commit/bb9d66ae38890ccbb5fede9bb0767f6715519334", "message": "Resolved Jiangtao's comments", "committedDate": "2020-08-03T22:03:24Z", "type": "forcePushed"}, {"oid": "baf4e4361699877f27439910b855e52222c3a0d5", "url": "https://github.com/grpc/grpc-java/commit/baf4e4361699877f27439910b855e52222c3a0d5", "message": "Added source.principal field", "committedDate": "2020-08-05T16:47:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465864958", "bodyText": "nit: you can directly setting this.allowEngine, without these local variables.", "author": "ZhenLian", "createdAt": "2020-08-05T16:49:02Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;", "originalCommit": "bb9d66ae38890ccbb5fede9bb0767f6715519334", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTMzMA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465921330", "bodyText": "Since this.allowEngine is a final variable, am I still able to change the value later if I initialized it to null?", "author": "cindyxue", "createdAt": "2020-08-05T18:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3MDU3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r466070577", "bodyText": "Java doesn't allow us to assign final variables in a loop, so I guess we still have to do it the old way :(", "author": "cindyxue", "createdAt": "2020-08-06T00:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMjUyNg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468212526", "bodyText": "Instead of the list (and the corresponding loop) if you accept 2 params in the constructor you'll be able to do without the local vars and the loop. Of course this is not a serious issue but might point towards the simpler way of having 2 params", "author": "sanjaypujare", "createdAt": "2020-08-10T22:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNDU4MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468214580", "bodyText": "Yes, that's a good point! Just want to double check with my host to see if we need to stay consistent with the design doc since it uses a list there :)", "author": "cindyxue", "createdAt": "2020-08-10T22:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NTY1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468295656", "bodyText": "Does the design doc mention why a list is used?", "author": "sanjaypujare", "createdAt": "2020-08-11T02:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNTk5Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465905992", "bodyText": "Some general thoughts on this: try not to use policy_1, policy_2, ...  for variables that could exist across functions. That would make the purposes of each variables very difficult to understand.", "author": "ZhenLian", "createdAt": "2020-08-05T17:59:46Z", "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/CelEvaluationTest.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.api.expr.v1alpha1.Expr.Ident;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import java.lang.StringBuilder;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate function of CEL Evaluation Engine. */\n+@RunWith(JUnit4.class)\n+public class CelEvaluationTest<ReqT, RespT> {\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+  \n+  @Mock\n+  private EvaluateArgs<ReqT,RespT> args;\n+\n+  @Mock\n+  private Activation activation;\n+\n+  @Mock\n+  private Map<String, Object> attributes;\n+\n+  private AuthorizationEngine<ReqT,RespT> engine;\n+  private AuthorizationEngine<ReqT,RespT> spyEngine;\n+  private AuthorizationDecision evaluateResult;\n+  private RBAC rbacAllow;\n+  private RBAC rbacDeny;\n+  private Policy policy1;\n+  private Policy policy2;\n+  private Policy policy3;\n+  private Policy policy4;\n+  private Policy policy5;\n+  private Policy policy6;\n+  private Expr condition1;\n+  private Expr condition2;\n+  private Expr condition3;\n+  private Expr condition4;\n+  private Expr condition5;\n+  private Expr condition6;\n+  \n+  @Before\n+  public void buildRbac() {\n+    // Set up RBAC condition.\n+    condition1 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 1\").build())\n+        .build();\n+    condition2 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 2\").build())\n+        .build();\n+    condition3 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 3\").build())\n+        .build();\n+    condition4 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 4\").build())\n+        .build();\n+    condition5 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 5\").build())\n+        .build();\n+    condition6 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 6\").build())\n+        .build();\n+    // Set up RBAC policy.\n+    policy1 = Policy.newBuilder().setCondition(condition1).build();", "originalCommit": "baf4e4361699877f27439910b855e52222c3a0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyNzM1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465927359", "bodyText": "Sure, I can rename it. Is mockPolicy1/2/3 a proper name? Or shall I use policyA/B/C if that sounds better lol?", "author": "cindyxue", "createdAt": "2020-08-05T18:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzEwOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465907108", "bodyText": "For a test this long, you can add some comments on the purposes of each policy, or try to break them down into small pieces. Otherwise it's a bit hard to keep track of what's tested in each small section.", "author": "ZhenLian", "createdAt": "2020-08-05T18:01:47Z", "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/CelEvaluationTest.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.api.expr.v1alpha1.Expr.Ident;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import java.lang.StringBuilder;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate function of CEL Evaluation Engine. */\n+@RunWith(JUnit4.class)\n+public class CelEvaluationTest<ReqT, RespT> {\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+  \n+  @Mock\n+  private EvaluateArgs<ReqT,RespT> args;\n+\n+  @Mock\n+  private Activation activation;\n+\n+  @Mock\n+  private Map<String, Object> attributes;\n+\n+  private AuthorizationEngine<ReqT,RespT> engine;\n+  private AuthorizationEngine<ReqT,RespT> spyEngine;\n+  private AuthorizationDecision evaluateResult;\n+  private RBAC rbacAllow;\n+  private RBAC rbacDeny;\n+  private Policy policy1;\n+  private Policy policy2;\n+  private Policy policy3;\n+  private Policy policy4;\n+  private Policy policy5;\n+  private Policy policy6;\n+  private Expr condition1;\n+  private Expr condition2;\n+  private Expr condition3;\n+  private Expr condition4;\n+  private Expr condition5;\n+  private Expr condition6;\n+  \n+  @Before\n+  public void buildRbac() {\n+    // Set up RBAC condition.\n+    condition1 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 1\").build())\n+        .build();\n+    condition2 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 2\").build())\n+        .build();\n+    condition3 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 3\").build())\n+        .build();\n+    condition4 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 4\").build())\n+        .build();\n+    condition5 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 5\").build())\n+        .build();\n+    condition6 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 6\").build())\n+        .build();\n+    // Set up RBAC policy.\n+    policy1 = Policy.newBuilder().setCondition(condition1).build();\n+    policy2 = Policy.newBuilder().setCondition(condition2).build();\n+    policy3 = Policy.newBuilder().setCondition(condition3).build();\n+    policy4 = Policy.newBuilder().setCondition(condition4).build();\n+    policy5 = Policy.newBuilder().setCondition(condition5).build();\n+    policy6 = Policy.newBuilder().setCondition(condition6).build();\n+    // Set up RBAC.\n+    rbacAllow = RBAC.newBuilder()\n+        .setAction(Action.ALLOW)\n+        .putPolicies(\"Policy 1\", policy1)\n+        .putPolicies(\"Policy 2\", policy2)\n+        .putPolicies(\"Policy 3\", policy3)\n+        .build();\n+    rbacDeny = RBAC.newBuilder()\n+        .setAction(Action.DENY)\n+        .putPolicies(\"Policy 4\", policy4)\n+        .putPolicies(\"Policy 5\", policy5)\n+        .putPolicies(\"Policy 6\", policy6)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setupEngineSingleRbacAllow() {\n+    buildRbac();\n+    List<RBAC> rbacList = new ArrayList<>(Arrays.asList(new RBAC[] {rbacAllow}));\n+    engine = new AuthorizationEngine<>(ImmutableList.copyOf(rbacList));\n+    spyEngine = Mockito.spy(engine);\n+    doReturn(ImmutableMap.copyOf(attributes)).when(spyEngine).extractFields(\n+        ArgumentMatchers.<EvaluateArgs<ReqT,RespT>>any());\n+  }\n+\n+  @Before\n+  public void setupEngineSingleRbacDeny() {\n+    buildRbac();\n+    List<RBAC> rbacList = new ArrayList<>(Arrays.asList(new RBAC[] {rbacDeny}));\n+    engine = new AuthorizationEngine<>(ImmutableList.copyOf(rbacList));\n+    spyEngine = Mockito.spy(engine);\n+    doReturn(ImmutableMap.copyOf(attributes)).when(spyEngine).extractFields(\n+        ArgumentMatchers.<EvaluateArgs<ReqT,RespT>>any());\n+  }\n+\n+  @Before\n+  public void setupEngineRbacPair() {\n+    buildRbac();\n+    List<RBAC> rbacList = new ArrayList<>(Arrays.asList(new RBAC[] {rbacDeny, rbacAllow}));\n+    engine = new AuthorizationEngine<>(ImmutableList.copyOf(rbacList));\n+    spyEngine = Mockito.spy(engine);\n+    doReturn(ImmutableMap.copyOf(attributes)).when(spyEngine).extractFields(\n+        ArgumentMatchers.<EvaluateArgs<ReqT,RespT>>any());\n+  }\n+\n+  @Test\n+  public void testEvaluateEngineRbacAllow() throws InterpreterException {", "originalCommit": "baf4e4361699877f27439910b855e52222c3a0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyNjM3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465926377", "bodyText": "I see. I will split it up to smaller tests then.", "author": "cindyxue", "createdAt": "2020-08-05T18:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzEwOA=="}], "type": "inlineReview"}, {"oid": "bd238afaf54349ef56683d60c6e34e19c12e2358", "url": "https://github.com/grpc/grpc-java/commit/bd238afaf54349ef56683d60c6e34e19c12e2358", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-05T20:57:17Z", "type": "forcePushed"}, {"oid": "b46ae5ded873b466cd8d7cffa28a6c5bbf0ef005", "url": "https://github.com/grpc/grpc-java/commit/b46ae5ded873b466cd8d7cffa28a6c5bbf0ef005", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-05T21:28:15Z", "type": "forcePushed"}, {"oid": "f6ba1e5b4bfd53fc25b7e59d4755f7414d0b4a20", "url": "https://github.com/grpc/grpc-java/commit/f6ba1e5b4bfd53fc25b7e59d4755f7414d0b4a20", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-05T23:35:23Z", "type": "forcePushed"}, {"oid": "39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "url": "https://github.com/grpc/grpc-java/commit/39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-05T23:49:48Z", "type": "forcePushed"}, {"oid": "7e68169c1a05692410a60bed43f952412705dafd", "url": "https://github.com/grpc/grpc-java/commit/7e68169c1a05692410a60bed43f952412705dafd", "message": "Fixed constructor of CEL engine", "committedDate": "2020-08-05T23:58:55Z", "type": "forcePushed"}, {"oid": "39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "url": "https://github.com/grpc/grpc-java/commit/39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-05T23:49:48Z", "type": "forcePushed"}, {"oid": "661ac0f8b66abc23ce554f87ff1077c41608fbed", "url": "https://github.com/grpc/grpc-java/commit/661ac0f8b66abc23ce554f87ff1077c41608fbed", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-06T00:08:16Z", "type": "commit"}, {"oid": "661ac0f8b66abc23ce554f87ff1077c41608fbed", "url": "https://github.com/grpc/grpc-java/commit/661ac0f8b66abc23ce554f87ff1077c41608fbed", "message": "Split up unit test into smaller pieces", "committedDate": "2020-08-06T00:08:16Z", "type": "forcePushed"}, {"oid": "9c28a4f4db1c400859436a8c444fc94117bc668b", "url": "https://github.com/grpc/grpc-java/commit/9c28a4f4db1c400859436a8c444fc94117bc668b", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T17:54:22Z", "type": "forcePushed"}, {"oid": "1802a522c03b59ad78b9234cf2e4253b4d5b85a8", "url": "https://github.com/grpc/grpc-java/commit/1802a522c03b59ad78b9234cf2e4253b4d5b85a8", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T18:13:58Z", "type": "forcePushed"}, {"oid": "cc7cc45ec764f5049b3af057ee4202bc7c2207e6", "url": "https://github.com/grpc/grpc-java/commit/cc7cc45ec764f5049b3af057ee4202bc7c2207e6", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T18:42:08Z", "type": "forcePushed"}, {"oid": "d7511aea2c354fcc89c127d557dbb93ff3c0df26", "url": "https://github.com/grpc/grpc-java/commit/d7511aea2c354fcc89c127d557dbb93ff3c0df26", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T19:24:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4OTk3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r466689977", "bodyText": "Just curious - why do we give up on throwing an exception here?", "author": "ZhenLian", "createdAt": "2020-08-06T21:14:21Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -119,10 +119,8 @@ public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgum\n    * Determines whether a gRPC call is allowed, denied, or unable to decide.\n    * @param args evaluate argument that is used to evaluate the RBAC conditions.\n    * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n-   * @throws InterpreterException if something goes wrong in CEL library.\n    */\n-  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n-      throws IllegalArgumentException {\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) {", "originalCommit": "d7511aea2c354fcc89c127d557dbb93ff3c0df26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTA2Mw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r466691063", "bodyText": "IllegalArgumentException is a RuntimeException do adding that to the throws clause doesn't achieve anything?", "author": "sanjaypujare", "createdAt": "2020-08-06T21:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4OTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTEyNw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r466691127", "bodyText": "Because we changed the member variables from List<RbacEngine> to RbacEngine denyEngine and RbacEngine allowEngine, which is always a valid argument. Therefore, this function no longer throws IllegalArgumentException.", "author": "cindyxue", "createdAt": "2020-08-06T21:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4OTk3Nw=="}], "type": "inlineReview"}, {"oid": "d50ae19fe52afe9161b30984af7ebd24aab34b50", "url": "https://github.com/grpc/grpc-java/commit/d50ae19fe52afe9161b30984af7ebd24aab34b50", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T21:50:41Z", "type": "forcePushed"}, {"oid": "337dba23ce34189be2aa35880dcd162b7fec9d7a", "url": "https://github.com/grpc/grpc-java/commit/337dba23ce34189be2aa35880dcd162b7fec9d7a", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T22:28:27Z", "type": "forcePushed"}, {"oid": "978d5bdca250141d50eb4975b09822dca6f842c3", "url": "https://github.com/grpc/grpc-java/commit/978d5bdca250141d50eb4975b09822dca6f842c3", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T23:03:28Z", "type": "commit"}, {"oid": "978d5bdca250141d50eb4975b09822dca6f842c3", "url": "https://github.com/grpc/grpc-java/commit/978d5bdca250141d50eb4975b09822dca6f842c3", "message": "Added fake tests for attributes extraction", "committedDate": "2020-08-06T23:03:28Z", "type": "forcePushed"}, {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "url": "https://github.com/grpc/grpc-java/commit/e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "message": "Added test for matches function", "committedDate": "2020-08-06T23:53:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjMwOQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468206309", "bodyText": "Instead of accepting a list of size 1 or 2 why not accept 2 params: if both params present then 1st param is DENY RBAC and 2nd param ALLOW RBAC\nIs there a reason for a list (such as future enhancements) which is not documented here?", "author": "sanjaypujare", "createdAt": "2020-08-10T21:51:21Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {", "originalCommit": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMTc0MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468211740", "bodyText": "@ZhenLian Could you please take a look at this? Is it okay to change the list to two RBAC parameters?", "author": "cindyxue", "createdAt": "2020-08-10T22:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMzMzQ0OA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468333448", "bodyText": "Yeah, that looks better. Actually, can I further suggest we have two construction functions? One only takes one RBAC, and it could be either DENY or ALLOW. the other takes two RBACs, and we will verify if the 1st param is DENY RBAC and 2nd param ALLOW RBAC.", "author": "ZhenLian", "createdAt": "2020-08-11T05:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM0NzQ2NA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468347464", "bodyText": "That's even better. In any case I don't see any need for a constructor that takes a list of policies.", "author": "sanjaypujare", "createdAt": "2020-08-11T06:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxOTc5Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468719792", "bodyText": "Fixed!", "author": "cindyxue", "createdAt": "2020-08-11T16:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNzIzOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468207238", "bodyText": "Why not final ?", "author": "sanjaypujare", "createdAt": "2020-08-10T21:53:26Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {", "originalCommit": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjMwNQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468232305", "bodyText": "Similarly as above, using Mockito for unit testing has a lot of limitations including not able to mock a final class. However, this is definitely something that can be changed in the future :)", "author": "cindyxue", "createdAt": "2020-08-10T23:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNzIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNTc1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468215756", "bodyText": "Not in this PR but from might be a better name than copyOf since the method creates an Activation from a Map?", "author": "sanjaypujare", "createdAt": "2020-08-10T22:14:34Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));", "originalCommit": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyOTg1MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468229850", "bodyText": "Yes, I agree it makes more sense to call it from rather than copyOf. However, this function is originally from the CEL library, so I'm not able to change it unfortunately :(", "author": "cindyxue", "createdAt": "2020-08-10T22:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNTc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNzk2OA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468217968", "bodyText": "Will be good avoid repetition of Decision in AuthorizationDecision.Decision ? Just a suggestion.", "author": "sanjaypujare", "createdAt": "2020-08-10T22:20:26Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {", "originalCommit": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNTgwMA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468235800", "bodyText": "The enum Decision is only declared in class AuthorizationDecision, but it's used in AuthorizationEngine when generating an AuthorizationDecision object.\nWhich repetition did you mean exactly?", "author": "cindyxue", "createdAt": "2020-08-10T23:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NTQxMg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468295412", "bodyText": "I mean the word Decision is repeated in fully qualified AuthorizationDecision.Decision . It is not a big deal but it will be nice to avoid such things for better readability and intuitiveness. So the Decision enum can be called Outcome or Output or just Value?", "author": "sanjaypujare", "createdAt": "2020-08-11T02:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMzNDM5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468334393", "bodyText": "Yeah that's actually a good point. I think maybe we can call it Output?", "author": "ZhenLian", "createdAt": "2020-08-11T05:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM0NzM3NQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468347375", "bodyText": "Done :)", "author": "cindyxue", "createdAt": "2020-08-11T06:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNzk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTE3MQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468221171", "bodyText": "So the above 2 if clauses can be refactored to avoid repetition, right? The method takes an entrySet and AuthorizationDecision.Decision as params and you call it twice with (allowEngine.conditions.entrySet(), AuthorizationDecision.Decision.ALLOW) and (denyEngine.conditions.entrySet(), AuthorizationDecision.Decision.DENY).", "author": "sanjaypujare", "createdAt": "2020-08-10T22:29:23Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Iterate through denyEngine's map.\n+    // If there is match, immediately return deny. \n+    // If there are unknown results, return undecided. \n+    // If all non-match, then iterate through allowEngine.\n+    if (denyEngine != null) {\n+      for (Map.Entry<String, Expr> condition : denyEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, \n+                new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // Once we enter allowEngine, if there is a match, immediately return allow. \n+    // In the end of iteration, if there are unknown rules, return undecided.\n+    // If all non-match, return deny.\n+    if (allowEngine != null) {\n+      for (Map.Entry<String, Expr> condition : allowEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            return new AuthorizationDecision(AuthorizationDecision.Decision.ALLOW, \n+                new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }", "originalCommit": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNjc0MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468236740", "bodyText": "Yes! I'll change it to avoid duplicate code :)", "author": "cindyxue", "createdAt": "2020-08-10T23:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzk4Mw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468237983", "bodyText": "This is a general comment/question that applies to multiple classes in this PR and not just this class. I noticed the use of ReqT, RespT as type params which causes all of these classes (EvaluateArgs in this example) to be generic types. However these type params always (unless I miss somewhere) are ultimately plumbed down to a ServerCall<ReqT, RespT> and serve no other purpose. So in your code itself you never use ReqT, RespT to define/reference any generic types. In that case if you just use ServerCall<?, ?> do you lose any functionality or even type checks offered by the Java compiler? I suspect the answer is no .", "author": "sanjaypujare", "createdAt": "2020-08-10T23:20:48Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/EvaluateArgs.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import io.grpc.Grpc;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+\n+/** The EvaluateArgs class holds evaluate arguments used in CEL Evaluation Engine. */\n+public class EvaluateArgs<ReqT, RespT> {\n+  private Metadata headers;\n+  private ServerCall<ReqT, RespT> call;", "originalCommit": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0NjI1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468246257", "bodyText": "That makes sense. I removed those pointless <ReqT, RespT>. Thanks for pointing it out!", "author": "cindyxue", "createdAt": "2020-08-10T23:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzk4Mw=="}], "type": "inlineReview"}, {"oid": "218211826f95c3807e492d5fc6a2851e54b036c2", "url": "https://github.com/grpc/grpc-java/commit/218211826f95c3807e492d5fc6a2851e54b036c2", "message": "Removed useless <ReqT, RespT>", "committedDate": "2020-08-10T23:45:43Z", "type": "commit"}, {"oid": "4d989faef9e560286834ddbe23a01380ab902aba", "url": "https://github.com/grpc/grpc-java/commit/4d989faef9e560286834ddbe23a01380ab902aba", "message": "Refactor code for evaluating a single engine", "committedDate": "2020-08-11T00:25:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzI3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468297277", "bodyText": "Shouldn't this belong to EvaluateArgs? It should know how to generate a Map out of its field values. Otherwise you are exposing fields like request.method here. You can call the method (there) generateEnvoyAttributes (based on the comment here)", "author": "sanjaypujare", "createdAt": "2020-08-11T02:55:05Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Iterate through denyEngine's map.\n+    // If there is match, immediately return deny. \n+    // If there are unknown results, return undecided. \n+    // If all non-match, then iterate through allowEngine.\n+    if (denyEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(denyEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.DENY, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Once we enter allowEngine, if there is a match, immediately return allow. \n+    // In the end of iteration, if there are unknown rules, return undecided.\n+    // If all non-match, return deny.\n+    if (allowEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(allowEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.ALLOW, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Only has a denyEngine and it\u2019s unmatched.\n+    if (this.allowEngine == null && this.denyEngine != null) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    // None of denyEngine and allowEngine matched, or the single Allow Engine is unmatched.\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate a single RbacEngine. */\n+  protected AuthorizationDecision evaluateEngine(Set<Map.Entry<String, Expr>> entrySet, \n+      AuthorizationDecision.Decision decision, List<String> unknownPolicyNames, \n+      Activation activation) {\n+    for (Map.Entry<String, Expr> condition : entrySet) {\n+      try {\n+        if (matches(condition.getValue(), activation)) {\n+          return new AuthorizationDecision(decision, \n+              new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+        }\n+      } catch (InterpreterException e) {\n+        unknownPolicyNames.add(condition.getKey());\n+      }\n+    }\n+    if (unknownPolicyNames.size() > 0) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+    }\n+    return null;\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpretable used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    Interpretable interpretable = interpreter.createInterpretable(condition);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpretable.eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs args) {", "originalCommit": "4d989faef9e560286834ddbe23a01380ab902aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMjI5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468302297", "bodyText": "You are correct. It makes more sense to move this inside EvaluateArgs. Will fix!", "author": "cindyxue", "createdAt": "2020-08-11T03:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5ODkwOA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468298908", "bodyText": "Any reason for using getCall instead of directly using this.call? Mocking getCall could be the only reason but why would you mock a simple getter?", "author": "sanjaypujare", "createdAt": "2020-08-11T03:01:24Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/EvaluateArgs.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import io.grpc.Grpc;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+\n+/** The EvaluateArgs class holds evaluate arguments used in CEL Evaluation Engine. */\n+public class EvaluateArgs {\n+  private Metadata headers;\n+  private ServerCall<?, ?> call;\n+\n+  /**\n+   * Creates a new evaluate argument using the input {@code headers} for resolving headers\n+   * and {@code call} for resolving gRPC call.\n+   */\n+  public EvaluateArgs(Metadata headers, ServerCall<?, ?> call) {\n+    this.headers = headers;\n+    this.call = call;\n+  }\n+\n+  /** Return the headers. */\n+  public Metadata getHeaders() {\n+    return headers;\n+  }\n+\n+  /** Return the gRPC call. */\n+  public ServerCall<?, ?> getCall() {\n+    return call;\n+  }\n+\n+  /** Extract the request.url_path field. */\n+  public String getRequestUrlPath() {\n+    String requestUrlPath = this.getCall().getMethodDescriptor().getFullMethodName();", "originalCommit": "4d989faef9e560286834ddbe23a01380ab902aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTU4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468301582", "bodyText": "Fixed!", "author": "cindyxue", "createdAt": "2020-08-11T03:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5ODkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMDA1NQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468300055", "bodyText": "Couple of things about this test:\n\n\nwhich class are you testing? EvaluateArgs or AuthorizationEngine ? Ideally only one class. And like I said elsewhere if you had moved extractFields to EvaluateArgs there would be only one class to test\n\n\nmocking EvaluateArgs's getter methods is not very useful or trivial. Better would be to mock/spy ServerCall<?,?> call member inside EvaluateArgs which is more work but is a better test", "author": "sanjaypujare", "createdAt": "2020-08-11T03:06:19Z", "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/AttributesExtractionTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.Metadata;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate argument. */\n+@RunWith(JUnit4.class)\n+public class AttributesExtractionTest {", "originalCommit": "4d989faef9e560286834ddbe23a01380ab902aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMjY0MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468322640", "bodyText": "I deleted this test and moved tests for generateEnvoyAttributes inside EvaluateArgsTest now. Getter methods for EvaluateArgs haven't been finalized yet, so  the testing will be changed later.", "author": "cindyxue", "createdAt": "2020-08-11T04:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTIxNA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468301214", "bodyText": "This can be static since it doesn't use any member vars? But this function really belongs to EvaluateArgs", "author": "sanjaypujare", "createdAt": "2020-08-11T03:10:56Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Iterate through denyEngine's map.\n+    // If there is match, immediately return deny. \n+    // If there are unknown results, return undecided. \n+    // If all non-match, then iterate through allowEngine.\n+    if (denyEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(denyEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.DENY, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Once we enter allowEngine, if there is a match, immediately return allow. \n+    // In the end of iteration, if there are unknown rules, return undecided.\n+    // If all non-match, return deny.\n+    if (allowEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(allowEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.ALLOW, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Only has a denyEngine and it\u2019s unmatched.\n+    if (this.allowEngine == null && this.denyEngine != null) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    // None of denyEngine and allowEngine matched, or the single Allow Engine is unmatched.\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate a single RbacEngine. */\n+  protected AuthorizationDecision evaluateEngine(Set<Map.Entry<String, Expr>> entrySet, \n+      AuthorizationDecision.Decision decision, List<String> unknownPolicyNames, \n+      Activation activation) {\n+    for (Map.Entry<String, Expr> condition : entrySet) {\n+      try {\n+        if (matches(condition.getValue(), activation)) {\n+          return new AuthorizationDecision(decision, \n+              new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+        }\n+      } catch (InterpreterException e) {\n+        unknownPolicyNames.add(condition.getKey());\n+      }\n+    }\n+    if (unknownPolicyNames.size() > 0) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+    }\n+    return null;\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpretable used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    Interpretable interpretable = interpreter.createInterpretable(condition);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpretable.eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs args) {", "originalCommit": "4d989faef9e560286834ddbe23a01380ab902aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNDc4OA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468304788", "bodyText": "Yeah I agree. Will move it into EvaluateArgs. Thanks for bringing it up :)", "author": "cindyxue", "createdAt": "2020-08-11T03:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTg5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468301897", "bodyText": "Can you mock the other properties of call to be able to better test your EvalutateArgs getters?", "author": "sanjaypujare", "createdAt": "2020-08-11T03:13:59Z", "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/EvaluateArgsTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate argument. */\n+@RunWith(JUnit4.class)\n+public class EvaluateArgsTest<ReqT,RespT> {\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+\n+  @Mock\n+  private ServerCall<ReqT,RespT> call;\n+\n+  private EvaluateArgs args;\n+  \n+  @Test\n+  public void testEvaluateArgsAccessorFunctions() {\n+    args = new EvaluateArgs(new Metadata(), call);\n+    when(call.getAuthority()).thenReturn(\"fooapi.googleapis.com\");", "originalCommit": "4d989faef9e560286834ddbe23a01380ab902aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM1NDgxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468354819", "bodyText": "Yes, I believe it's good to include those.", "author": "cindyxue", "createdAt": "2020-08-11T06:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0Mjk0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468742947", "bodyText": "I add more testing on call, but implementation of some of the methods are still under discussion and those will be added later :)", "author": "cindyxue", "createdAt": "2020-08-11T17:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTg5Nw=="}], "type": "inlineReview"}, {"oid": "106bc62b99dd21aa4950203fe923ea87c0e04941", "url": "https://github.com/grpc/grpc-java/commit/106bc62b99dd21aa4950203fe923ea87c0e04941", "message": "Moved extractFields from AuthzEngine to EvaluateArgs and renamed to generateEnvoyAttributes", "committedDate": "2020-08-11T04:40:29Z", "type": "commit"}, {"oid": "f8300230ca1441f360423c64789a6c6a9758f6b4", "url": "https://github.com/grpc/grpc-java/commit/f8300230ca1441f360423c64789a6c6a9758f6b4", "message": "Added tests for getSourceAddress and getDestinationAddress", "committedDate": "2020-08-11T05:40:59Z", "type": "commit"}, {"oid": "ad5c73bb1232b69e18e44bb764ddf13c5bbac556", "url": "https://github.com/grpc/grpc-java/commit/ad5c73bb1232b69e18e44bb764ddf13c5bbac556", "message": "Renamed enum Decision to Output", "committedDate": "2020-08-11T06:07:32Z", "type": "commit"}, {"oid": "47923382e65bc00ef095ef8d47e7f6ede2823b63", "url": "https://github.com/grpc/grpc-java/commit/47923382e65bc00ef095ef8d47e7f6ede2823b63", "message": "Separate AuthzEngine constructor", "committedDate": "2020-08-11T17:03:38Z", "type": "forcePushed"}, {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec", "url": "https://github.com/grpc/grpc-java/commit/ab103c81f41c1c512423aa8457aabceeedd87aec", "message": "Separate AuthzEngine constructor", "committedDate": "2020-08-11T17:10:13Z", "type": "commit"}, {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec", "url": "https://github.com/grpc/grpc-java/commit/ab103c81f41c1c512423aa8457aabceeedd87aec", "message": "Separate AuthzEngine constructor", "committedDate": "2020-08-11T17:10:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNjkyNQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470036925", "bodyText": "Consider using com.google.common.base.Preconditions.checkArgument like it is used everywhere else in grpc-java", "author": "sanjaypujare", "createdAt": "2020-08-13T15:27:12Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = Preconditions.checkNotNull(action);\n+      this.conditions = Preconditions.checkNotNull(conditions);\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from one Envoy RBAC.\n+   * @param rbacPolicy input Envoy RBAC policy.\n+   */\n+  public AuthorizationEngine(RBAC rbacPolicy) {\n+    Map<String, Expr> conditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: rbacPolicy.getPolicies().entrySet()) {\n+      conditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    allowEngine = (rbacPolicy.getAction() == Action.ALLOW) \n+        ? new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions)) : null; \n+    denyEngine = (rbacPolicy.getAction() == Action.DENY) \n+        ? new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions)) : null; \n+  }\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param denyPolicy input Envoy RBAC policy with DENY action.\n+   * @param allowPolicy input Envoy RBAC policy with ALLOW action.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(RBAC denyPolicy, RBAC allowPolicy) throws IllegalArgumentException {\n+    if (denyPolicy.getAction() != Action.DENY || allowPolicy.getAction() != Action.ALLOW) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" ", "originalCommit": "ab103c81f41c1c512423aa8457aabceeedd87aec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NDgzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470064831", "bodyText": "Sure, thanks for the advice!", "author": "cindyxue", "createdAt": "2020-08-13T16:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNjkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDk3MA==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470044970", "bodyText": "unknownPolicyNames belongs to this method and you are passing it to evaluateEngine twice and having that method return UNKNOWN based on the length of the array. What will be simpler/more elegant is to make the check in this method and have evaluateEngine return only ALLOW/DENY or null. Just a suggestion", "author": "sanjaypujare", "createdAt": "2020-08-13T15:39:26Z", "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = Preconditions.checkNotNull(action);\n+      this.conditions = Preconditions.checkNotNull(conditions);\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from one Envoy RBAC.\n+   * @param rbacPolicy input Envoy RBAC policy.\n+   */\n+  public AuthorizationEngine(RBAC rbacPolicy) {\n+    Map<String, Expr> conditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: rbacPolicy.getPolicies().entrySet()) {\n+      conditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    allowEngine = (rbacPolicy.getAction() == Action.ALLOW) \n+        ? new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions)) : null; \n+    denyEngine = (rbacPolicy.getAction() == Action.DENY) \n+        ? new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions)) : null; \n+  }\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param denyPolicy input Envoy RBAC policy with DENY action.\n+   * @param allowPolicy input Envoy RBAC policy with ALLOW action.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(RBAC denyPolicy, RBAC allowPolicy) throws IllegalArgumentException {\n+    if (denyPolicy.getAction() != Action.DENY || allowPolicy.getAction() != Action.ALLOW) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    Map<String, Expr> denyConditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: denyPolicy.getPolicies().entrySet()) {\n+      denyConditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(denyConditions));\n+    Map<String, Expr> allowConditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: allowPolicy.getPolicies().entrySet()) {\n+      allowConditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(allowConditions));   \n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();", "originalCommit": "ab103c81f41c1c512423aa8457aabceeedd87aec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE1OTE1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470159156", "bodyText": "unknownPolicyNames is updated in evaluateEngine when going over each condition, so I have to pass it to evaluateEngine. If that is the case, shall I still need to move the check for unknownPolicyNames to evaluate?", "author": "cindyxue", "createdAt": "2020-08-13T18:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MzYyMQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470163621", "bodyText": "Up to you. If it were me I would move the check for unknownPolicyNames being non-empty in this method to enforce the logic you have described in the comments below. But you can leave this unchanged if you prefer.", "author": "sanjaypujare", "createdAt": "2020-08-13T18:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjU1MQ==", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470166551", "bodyText": "I'll change it then since that seems to make the logic more clear :)", "author": "cindyxue", "createdAt": "2020-08-13T18:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDk3MA=="}], "type": "inlineReview"}, {"oid": "a1c8d9f7b83955903bcde0f4d09aa58e9243bfe4", "url": "https://github.com/grpc/grpc-java/commit/a1c8d9f7b83955903bcde0f4d09aa58e9243bfe4", "message": "Resolved Sanjay's review comments", "committedDate": "2020-08-13T18:56:44Z", "type": "forcePushed"}]}