{"pr_number": 7470, "pr_title": "xds: implement XdsClient APIs for watching LDS/RDS resources individually", "pr_createdAt": "2020-09-29T09:27:03Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7470", "timeline": [{"oid": "b228423ca41a2bbb2787466244d9b4af3a247897", "url": "https://github.com/grpc/grpc-java/commit/b228423ca41a2bbb2787466244d9b4af3a247897", "message": "Modify builder methods for easier usages.", "committedDate": "2020-09-29T09:23:14Z", "type": "commit"}, {"oid": "1323354981d3c35ceab7a31cb93d36ac9b38df85", "url": "https://github.com/grpc/grpc-java/commit/1323354981d3c35ceab7a31cb93d36ac9b38df85", "message": "Implement APIs for watching LDS/RDS resources.", "committedDate": "2020-09-29T09:23:55Z", "type": "commit"}, {"oid": "271d5a1d676e1a9b81a7f7b2486f060c717ba26f", "url": "https://github.com/grpc/grpc-java/commit/271d5a1d676e1a9b81a7f7b2486f060c717ba26f", "message": "Clean up XdsClient tests for covering watching each individual type of resources.", "committedDate": "2020-09-29T09:24:39Z", "type": "commit"}, {"oid": "a2712242f17fca9cd6f8b364c7a756addbd227ea", "url": "https://github.com/grpc/grpc-java/commit/a2712242f17fca9cd6f8b364c7a756addbd227ea", "message": "Enhance logging.", "committedDate": "2020-09-29T18:23:32Z", "type": "commit"}, {"oid": "016f871862f6219753afafbc9ee098310cc952ca", "url": "https://github.com/grpc/grpc-java/commit/016f871862f6219753afafbc9ee098310cc952ca", "message": "Add more tests.", "committedDate": "2020-09-29T18:29:07Z", "type": "commit"}, {"oid": "016f871862f6219753afafbc9ee098310cc952ca", "url": "https://github.com/grpc/grpc-java/commit/016f871862f6219753afafbc9ee098310cc952ca", "message": "Add more tests.", "committedDate": "2020-09-29T18:29:07Z", "type": "forcePushed"}, {"oid": "2c87b99b77a87f11659b7743cbf0f66aec088d84", "url": "https://github.com/grpc/grpc-java/commit/2c87b99b77a87f11659b7743cbf0f66aec088d84", "message": "Make type URLs private.", "committedDate": "2020-09-29T19:03:10Z", "type": "commit"}, {"oid": "3b54536bb0319e92c5de6b178d7fd95f5d10de9b", "url": "https://github.com/grpc/grpc-java/commit/3b54536bb0319e92c5de6b178d7fd95f5d10de9b", "message": "Fixed wrong constant reference.", "committedDate": "2020-09-29T19:13:46Z", "type": "commit"}, {"oid": "0a80cdcf2a0ded4d4c40935578ec0cdd0fded85c", "url": "https://github.com/grpc/grpc-java/commit/0a80cdcf2a0ded4d4c40935578ec0cdd0fded85c", "message": "Assert resource intial fetch timeout.", "committedDate": "2020-09-29T19:19:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY2MzAwNQ==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r497663005", "bodyText": "checkNotNull() without a message adds no value here as new ArrayList() throws NPE as well.", "author": "dapengzhang0", "createdAt": "2020-09-30T16:58:10Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -206,7 +211,8 @@ LdsUpdate build() {\n     private final List<VirtualHost> virtualHosts;\n \n     private RdsUpdate(List<VirtualHost> virtualHosts) {\n-      this.virtualHosts = virtualHosts;\n+      this.virtualHosts =\n+          Collections.unmodifiableList(new ArrayList<>(checkNotNull(virtualHosts)));", "originalCommit": "b228423ca41a2bbb2787466244d9b4af3a247897", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczMDE3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r497730179", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2020-09-30T18:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY2MzAwNQ=="}], "type": "inlineReview"}, {"oid": "1fd6c814acee60ac0a3cc521393ff9e022206b95", "url": "https://github.com/grpc/grpc-java/commit/1fd6c814acee60ac0a3cc521393ff9e022206b95", "message": "Add checkNotNull message.", "committedDate": "2020-09-30T18:53:14Z", "type": "commit"}, {"oid": "1a72fdff3a493e90963f4b5485c8f373b34b6c97", "url": "https://github.com/grpc/grpc-java/commit/1a72fdff3a493e90963f4b5485c8f373b34b6c97", "message": "Rename handler methods for handling client/server side LDS responses.", "committedDate": "2020-10-01T00:52:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTM4MA==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499039380", "bodyText": "Seems this request is never retried for the listenerWatcher case.", "author": "dapengzhang0", "createdAt": "2020-10-02T20:38:02Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl2.java", "diffHunk": "@@ -0,0 +1,1688 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.Durations;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+final class XdsClientImpl2 extends XdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final String targetName;  // TODO: delete me.\n+  private final XdsChannel xdsChannel;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Supplier<Stopwatch> stopwatchSupplier;\n+  private final Stopwatch adsStreamRetryStopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  private Node node;\n+\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledHandle rpcRetryTimer;\n+  @Nullable\n+  private LoadReportClient lrsClient;\n+  private int loadReportCount;  // number of clusters enabling load reporting\n+\n+  // For server side usage.\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  XdsClientImpl2(\n+      String targetName,\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    this.targetName = checkNotNull(targetName, \"targetName\");\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatchSupplier = checkNotNull(stopwatchSupplier, \"stopwatch\");\n+    adsStreamRetryStopwatch = stopwatchSupplier.get();\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+    xdsChannel.getManagedChannel().shutdown();\n+    if (adsStream != null) {\n+      adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+    }\n+    cleanUpResourceTimers();\n+    if (lrsClient != null) {\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+    if (rpcRetryTimer != null) {\n+      rpcRetryTimer.cancel();\n+    }\n+  }\n+\n+  private void cleanUpResourceTimers() {\n+    for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+  }\n+\n+  @Override\n+  void watchLdsResource(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.LDS, resourceName);\n+      ldsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelLdsResourceWatch(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe LDS resource {0}\", resourceName);\n+      ldsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchRdsResource(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe RDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.RDS, resourceName);\n+      rdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelRdsResourceWatch(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe RDS resource {0}\", resourceName);\n+      rdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchCdsResource(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.CDS, resourceName);\n+      cdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelCdsResourceWatch(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe CDS resource {0}\", resourceName);\n+      cdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchEdsResource(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe EDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.EDS, resourceName);\n+      edsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelEdsResourceWatch(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe EDS resource {0}\", resourceName);\n+      edsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    logger.log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    updateNodeMetadataForListenerRequest(port);\n+    adsStream.sendXdsRequest(ResourceType.LDS, ImmutableList.<String>of());", "originalCommit": "1a72fdff3a493e90963f4b5485c8f373b34b6c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1NzEyNw==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499057127", "bodyText": "Forgot that was for Sanjay's code. Added back.", "author": "voidzcy", "createdAt": "2020-10-02T21:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MDY5MA==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499040690", "bodyText": "Same comment as #7458 (comment)", "author": "dapengzhang0", "createdAt": "2020-10-02T20:41:14Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl2.java", "diffHunk": "@@ -0,0 +1,1688 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.Durations;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+final class XdsClientImpl2 extends XdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final String targetName;  // TODO: delete me.\n+  private final XdsChannel xdsChannel;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Supplier<Stopwatch> stopwatchSupplier;\n+  private final Stopwatch adsStreamRetryStopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  private Node node;\n+\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledHandle rpcRetryTimer;\n+  @Nullable\n+  private LoadReportClient lrsClient;\n+  private int loadReportCount;  // number of clusters enabling load reporting\n+\n+  // For server side usage.\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  XdsClientImpl2(\n+      String targetName,\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    this.targetName = checkNotNull(targetName, \"targetName\");\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatchSupplier = checkNotNull(stopwatchSupplier, \"stopwatch\");\n+    adsStreamRetryStopwatch = stopwatchSupplier.get();\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+    xdsChannel.getManagedChannel().shutdown();\n+    if (adsStream != null) {\n+      adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+    }\n+    cleanUpResourceTimers();\n+    if (lrsClient != null) {\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+    if (rpcRetryTimer != null) {\n+      rpcRetryTimer.cancel();\n+    }\n+  }\n+\n+  private void cleanUpResourceTimers() {\n+    for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+  }\n+\n+  @Override\n+  void watchLdsResource(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.LDS, resourceName);\n+      ldsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelLdsResourceWatch(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe LDS resource {0}\", resourceName);\n+      ldsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchRdsResource(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe RDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.RDS, resourceName);\n+      rdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelRdsResourceWatch(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe RDS resource {0}\", resourceName);\n+      rdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchCdsResource(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.CDS, resourceName);\n+      cdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelCdsResourceWatch(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe CDS resource {0}\", resourceName);\n+      cdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchEdsResource(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe EDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.EDS, resourceName);\n+      edsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelEdsResourceWatch(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe EDS resource {0}\", resourceName);\n+      edsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    logger.log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    updateNodeMetadataForListenerRequest(port);\n+    adsStream.sendXdsRequest(ResourceType.LDS, ImmutableList.<String>of());\n+    ldsRespTimer =\n+        syncContext\n+            .schedule(\n+                new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, timeService);\n+  }\n+\n+  /** In case of Listener watcher metadata to be updated to include port. */\n+  private void updateNodeMetadataForListenerRequest(int port) {\n+    Map<String, Object> newMetadata = new HashMap<>();\n+    if (node.getMetadata() != null) {\n+      newMetadata.putAll(node.getMetadata());\n+    }\n+    newMetadata.put(\"TRAFFICDIRECTOR_PROXYLESS\", \"1\");\n+    // TODO(sanjaypujare): eliminate usage of listening_addresses.\n+    EnvoyProtoData.Address listeningAddress =\n+        new EnvoyProtoData.Address(\"0.0.0.0\", port);\n+    node =\n+        node.toBuilder().setMetadata(newMetadata).addListeningAddresses(listeningAddress).build();\n+  }\n+\n+  @Override\n+  void reportClientStats() {\n+    if (lrsClient == null) {\n+      logger.log(XdsLogLevel.INFO, \"Turning on load reporting\");\n+      lrsClient =\n+          new LoadReportClient(\n+              targetName,\n+              loadStatsManager,\n+              xdsChannel,\n+              node,\n+              syncContext,\n+              timeService,\n+              backoffPolicyProvider,\n+              stopwatchSupplier);\n+    }\n+    if (loadReportCount == 0) {\n+      lrsClient.startLoadReporting();\n+    }\n+    loadReportCount++;\n+  }\n+\n+  @Override\n+  void cancelClientStatsReport() {\n+    checkState(loadReportCount > 0, \"load reporting was never started\");\n+    loadReportCount--;\n+    if (loadReportCount == 0) {\n+      logger.log(XdsLogLevel.INFO, \"Turning off load reporting\");\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+  }\n+\n+  @Override\n+  LoadStatsStore addClientStats(String clusterName, @Nullable String clusterServiceName) {\n+    return loadStatsManager.addLoadStats(clusterName, clusterServiceName);\n+  }\n+\n+  @Override\n+  void removeClientStats(String clusterName, @Nullable String clusterServiceName) {\n+    loadStatsManager.removeLoadStats(clusterName, clusterServiceName);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    adsStreamRetryStopwatch.reset().start();\n+  }\n+\n+  private void handleLdsResponse(DiscoveryResponseData ldsResponse) {\n+    if (listenerWatcher != null) {\n+      handleLdsResponseForServer(ldsResponse);\n+    } else {\n+      handleLdsResponseForClient(ldsResponse);\n+    }\n+  }\n+\n+  private void handleLdsResponseForClient(DiscoveryResponseData ldsResponse) {\n+    // Unpack Listener messages.\n+    List<Listener> listeners = new ArrayList<>(ldsResponse.getResourcesList().size());\n+    List<String> listenerNames = new ArrayList<>(ldsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : ldsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_LDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_LDS).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        listeners.add(listener);\n+        listenerNames.add(listener.getName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received LDS response for resources: {0}\", listenerNames);\n+\n+    // Unpack HttpConnectionManager messages.\n+    Map<String, HttpConnectionManager> httpConnectionManagers = new HashMap<>(listeners.size());\n+    try {\n+      for (Listener listener : listeners) {\n+        Any apiListener = listener.getApiListener().getApiListener();\n+        if (apiListener.getTypeUrl().equals(TYPE_URL_HTTP_CONNECTION_MANAGER_V2)) {\n+          apiListener =\n+              apiListener.toBuilder().setTypeUrl(TYPE_URL_HTTP_CONNECTION_MANAGER).build();\n+        }\n+        HttpConnectionManager hcm = apiListener.unpack(HttpConnectionManager.class);\n+        httpConnectionManagers.put(listener.getName(), hcm);\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Failed to unpack HttpConnectionManagers in Listeners of LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+\n+    Map<String, LdsUpdate> ldsUpdates = new HashMap<>();\n+    Set<String> rdsNames = new HashSet<>();\n+    String errorMessage = null;\n+    for (Map.Entry<String, HttpConnectionManager> entry : httpConnectionManagers.entrySet()) {\n+      String listenerName = entry.getKey();\n+      HttpConnectionManager hcm = entry.getValue();\n+      LdsUpdate.Builder updateBuilder = LdsUpdate.newBuilder();\n+      if (hcm.hasRouteConfig()) {\n+        for (VirtualHost virtualHostProto : hcm.getRouteConfig().getVirtualHostsList()) {\n+          StructOrError<EnvoyProtoData.VirtualHost> virtualHost =\n+              EnvoyProtoData.VirtualHost.fromEnvoyProtoVirtualHost(virtualHostProto);\n+          if (virtualHost.getErrorDetail() != null) {\n+            errorMessage = \"Listener \" + listenerName + \" contains invalid virtual host: \"\n+                + virtualHost.getErrorDetail();\n+            break;\n+          } else {\n+            updateBuilder.addVirtualHost(virtualHost.getStruct());\n+          }\n+        }\n+      } else if (hcm.hasRds()) {\n+        Rds rds = hcm.getRds();\n+        if (!rds.getConfigSource().hasAds()) {\n+          errorMessage = \"Listener \" + listenerName + \" with RDS config_source not set to ADS\";\n+        } else {\n+          updateBuilder.setRdsName(rds.getRouteConfigName());\n+          rdsNames.add(rds.getRouteConfigName());\n+        }\n+      } else {\n+        errorMessage = \"Listener \" + listenerName + \" without inline RouteConfiguration or RDS\";\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      if (hcm.hasCommonHttpProtocolOptions()) {\n+        HttpProtocolOptions options = hcm.getCommonHttpProtocolOptions();\n+        if (options.hasMaxStreamDuration()) {\n+          updateBuilder.setHttpMaxStreamDurationNano(\n+              Durations.toNanos(options.getMaxStreamDuration()));\n+        }\n+      }\n+      ldsUpdates.put(listenerName, updateBuilder.build());\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(\n+        ResourceType.LDS, ldsResourceSubscribers.keySet(), ldsResponse.getVersionInfo());\n+\n+    for (String resource : ldsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = ldsResourceSubscribers.get(resource);\n+      if (ldsUpdates.containsKey(resource)) {\n+        subscriber.onData(ldsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n+      }\n+    }\n+    for (String resource : rdsResourceSubscribers.keySet()) {\n+      if (!rdsNames.contains(resource)) {\n+        ResourceSubscriber subscriber = rdsResourceSubscribers.get(resource);\n+        subscriber.onAbsent();\n+      }\n+    }\n+  }\n+\n+  private void handleRdsResponse(DiscoveryResponseData rdsResponse) {\n+    // Unpack RouteConfiguration messages.\n+    Map<String, RouteConfiguration> routeConfigs =\n+        new HashMap<>(rdsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : rdsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_RDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_RDS).build();\n+        }\n+        RouteConfiguration rc = res.unpack(RouteConfiguration.class);\n+        routeConfigs.put(rc.getName(), rc);\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING, \"Failed to unpack RouteConfiguration in RDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+          rdsResponse.getVersionInfo(), \"Malformed RDS response: \" + e);\n+      return;\n+    }\n+    logger.log(\n+        XdsLogLevel.INFO, \"Received RDS response for resources: {0}\", routeConfigs.keySet());\n+\n+    Map<String, RdsUpdate> rdsUpdates = new HashMap<>();\n+    String errorMessage = null;\n+    for (Map.Entry<String, RouteConfiguration> entry : routeConfigs.entrySet()) {\n+      String routeConfigName = entry.getKey();\n+      RouteConfiguration routeConfig = entry.getValue();\n+      List<EnvoyProtoData.VirtualHost> virtualHosts =\n+          new ArrayList<>(routeConfig.getVirtualHostsCount());\n+      for (VirtualHost virtualHostProto : routeConfig.getVirtualHostsList()) {\n+        StructOrError<EnvoyProtoData.VirtualHost> virtualHost =\n+            EnvoyProtoData.VirtualHost.fromEnvoyProtoVirtualHost(virtualHostProto);\n+        if (virtualHost.getErrorDetail() != null) {\n+          errorMessage = \"RouteConfiguration \" + routeConfigName\n+              + \" contains invalid virtual host: \" + virtualHost.getErrorDetail();\n+          break;\n+        } else {\n+          virtualHosts.add(virtualHost.getStruct());\n+        }\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      rdsUpdates.put(routeConfigName, RdsUpdate.fromVirtualHosts(virtualHosts));\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+          rdsResponse.getVersionInfo(), errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+        rdsResponse.getVersionInfo());\n+\n+    for (String resource : rdsResourceSubscribers.keySet()) {\n+      if (rdsUpdates.containsKey(resource)) {\n+        ResourceSubscriber subscriber = rdsResourceSubscribers.get(resource);\n+        subscriber.onData(rdsUpdates.get(resource));\n+      }\n+    }\n+  }\n+\n+  private void handleLdsResponseForServer(DiscoveryResponseData ldsResponse) {\n+    // Unpack Listener messages.\n+    Listener requestedListener = null;\n+    logger.log(XdsLogLevel.DEBUG, \"Listener count: {0}\", ldsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : ldsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_LDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_LDS).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        logger.log(XdsLogLevel.DEBUG, \"Found listener {0}\", listener.toString());\n+        if (isRequestedListener(listener)) {\n+          requestedListener = listener;\n+          logger.log(XdsLogLevel.DEBUG, \"Requested listener found: {0}\", listener.getName());\n+        }\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ImmutableList.<String>of(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    ListenerUpdate listenerUpdate = null;\n+    if (requestedListener != null) {\n+      if (ldsRespTimer != null) {\n+        ldsRespTimer.cancel();\n+        ldsRespTimer = null;\n+      }\n+      try {\n+        listenerUpdate = ListenerUpdate.newBuilder()\n+            .setListener(EnvoyServerProtoData.Listener.fromEnvoyProtoListener(requestedListener))\n+            .build();\n+      } catch (InvalidProtocolBufferException e) {\n+        logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listener in LDS response {0}\", e);\n+        adsStream.sendNackRequest(\n+            ResourceType.LDS, ImmutableList.<String>of(),\n+            ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+        return;\n+      }\n+    } else {\n+      if (ldsRespTimer == null) {\n+        listenerWatcher.onResourceDoesNotExist(\":\" + listenerPort);\n+      }\n+    }\n+    adsStream.sendAckRequest(ResourceType.LDS, ImmutableList.<String>of(),\n+        ldsResponse.getVersionInfo());\n+    if (listenerUpdate != null) {\n+      listenerWatcher.onListenerChanged(listenerUpdate);\n+    }\n+  }\n+\n+  private boolean isRequestedListener(Listener listener) {\n+    // TODO(sanjaypujare): check listener.getName() once we know what xDS server returns\n+    return isAddressMatching(listener.getAddress())\n+        && hasMatchingFilter(listener.getFilterChainsList());\n+  }\n+\n+  private boolean isAddressMatching(Address address) {\n+    // TODO(sanjaypujare): check IP address once we know xDS server will include it\n+    return address.hasSocketAddress()\n+        && (address.getSocketAddress().getPortValue() == listenerPort);\n+  }\n+\n+  private boolean hasMatchingFilter(List<FilterChain> filterChainsList) {\n+    // TODO(sanjaypujare): if myIp to be checked against filterChainMatch.getPrefixRangesList()\n+    for (FilterChain filterChain : filterChainsList) {\n+      FilterChainMatch filterChainMatch = filterChain.getFilterChainMatch();\n+\n+      if (listenerPort == filterChainMatch.getDestinationPort().getValue()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Handles CDS response, which contains a list of Cluster messages with information for a logical\n+   * cluster. The response is NACKed if messages for requested resources contain invalid\n+   * information for gRPC's usage. Otherwise, an ACK request is sent to management server.\n+   * Response data for requested clusters is cached locally, in case of new cluster watchers\n+   * interested in the same clusters are added later.\n+   */\n+  private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n+    adsStream.cdsRespNonce = cdsResponse.getNonce();\n+\n+    // Unpack Cluster messages.\n+    List<Cluster> clusters = new ArrayList<>(cdsResponse.getResourcesList().size());\n+    List<String> clusterNames = new ArrayList<>(cdsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : cdsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_CDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_CDS).build();\n+        }\n+        Cluster cluster = res.unpack(Cluster.class);\n+        clusters.add(cluster);\n+        clusterNames.add(cluster.getName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Clusters in CDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.CDS, cdsResourceSubscribers.keySet(),\n+          cdsResponse.getVersionInfo(), \"Malformed CDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received CDS response for resources: {0}\", clusterNames);\n+\n+    String errorMessage = null;\n+    // Cluster information update for requested clusters received in this CDS response.\n+    Map<String, CdsUpdate> cdsUpdates = new HashMap<>();\n+    // CDS responses represents the state of the world, EDS services not referenced by\n+    // Clusters are those no longer exist.\n+    Set<String> edsServices = new HashSet<>();\n+    for (Cluster cluster : clusters) {\n+      String clusterName = cluster.getName();\n+      // Skip information for clusters not requested.\n+      // Management server is required to always send newly requested resources, even if they\n+      // may have been sent previously (proactively). Thus, client does not need to cache\n+      // unrequested resources.\n+      if (!cdsResourceSubscribers.containsKey(clusterName)) {\n+        continue;\n+      }\n+      CdsUpdate.Builder updateBuilder = CdsUpdate.newBuilder();\n+      updateBuilder.setClusterName(clusterName);\n+      // The type field must be set to EDS.\n+      if (!cluster.getType().equals(DiscoveryType.EDS)) {\n+        errorMessage = \"Cluster \" + clusterName + \" : only EDS discovery type is supported \"\n+            + \"in gRPC.\";\n+        break;\n+      }\n+      // In the eds_cluster_config field, the eds_config field must be set to indicate to\n+      // use EDS (must be set to use ADS).\n+      EdsClusterConfig edsClusterConfig = cluster.getEdsClusterConfig();\n+      if (!edsClusterConfig.getEdsConfig().hasAds()) {\n+        errorMessage = \"Cluster \" + clusterName + \" : field eds_cluster_config must be set to \"\n+            + \"indicate to use EDS over ADS.\";\n+        break;\n+      }\n+      // If the service_name field is set, that value will be used for the EDS request.\n+      if (!edsClusterConfig.getServiceName().isEmpty()) {\n+        updateBuilder.setEdsServiceName(edsClusterConfig.getServiceName());\n+        edsServices.add(edsClusterConfig.getServiceName());\n+      } else {\n+        edsServices.add(clusterName);\n+      }\n+      // The lb_policy field must be set to ROUND_ROBIN.\n+      if (!cluster.getLbPolicy().equals(LbPolicy.ROUND_ROBIN)) {\n+        errorMessage = \"Cluster \" + clusterName + \" : only round robin load balancing policy is \"\n+            + \"supported in gRPC.\";\n+        break;\n+      }\n+      updateBuilder.setLbPolicy(\"round_robin\");\n+      // If the lrs_server field is set, it must have its self field set, in which case the\n+      // client should use LRS for load reporting. Otherwise (the lrs_server field is not set),\n+      // LRS load reporting will be disabled.\n+      if (cluster.hasLrsServer()) {\n+        if (!cluster.getLrsServer().hasSelf()) {\n+          errorMessage = \"Cluster \" + clusterName + \" : only support enabling LRS for the same \"\n+              + \"management server.\";\n+          break;\n+        }\n+        updateBuilder.setLrsServerName(\"\");\n+      }\n+      try {\n+        UpstreamTlsContext upstreamTlsContext = getTlsContextFromCluster(cluster);\n+        if (upstreamTlsContext != null && upstreamTlsContext.getCommonTlsContext() != null) {\n+          updateBuilder.setUpstreamTlsContext(upstreamTlsContext);\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        errorMessage = \"Cluster \" + clusterName + \" : \" + e.getMessage();\n+        break;\n+      }\n+      cdsUpdates.put(clusterName, updateBuilder.build());\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.CDS,\n+          cdsResourceSubscribers.keySet(),\n+          cdsResponse.getVersionInfo(),\n+          errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n+        cdsResponse.getVersionInfo());\n+\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n+      }\n+    }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);\n+      if (!edsServices.contains(resource)) {\n+        subscriber.onAbsent();\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  private static UpstreamTlsContext getTlsContextFromCluster(Cluster cluster)\n+      throws InvalidProtocolBufferException {\n+    if (cluster.hasTransportSocket() && \"tls\".equals(cluster.getTransportSocket().getName())) {\n+      Any any = cluster.getTransportSocket().getTypedConfig();\n+      return UpstreamTlsContext.fromEnvoyProtoUpstreamTlsContext(\n+          io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext.parseFrom(\n+              any.getValue()));\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Handles EDS response, which contains a list of ClusterLoadAssignment messages with\n+   * endpoint load balancing information for each cluster. The response is NACKed if messages\n+   * for requested resources contain invalid information for gRPC's usage. Otherwise,\n+   * an ACK request is sent to management server. Response data for requested clusters is\n+   * cached locally, in case of new endpoint watchers interested in the same clusters\n+   * are added later.\n+   */\n+  private void handleEdsResponse(DiscoveryResponseData edsResponse) {\n+    // Unpack ClusterLoadAssignment messages.\n+    List<ClusterLoadAssignment> clusterLoadAssignments =\n+        new ArrayList<>(edsResponse.getResourcesList().size());\n+    List<String> claNames = new ArrayList<>(edsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : edsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_EDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_EDS).build();\n+        }\n+        ClusterLoadAssignment assignment = res.unpack(ClusterLoadAssignment.class);\n+        clusterLoadAssignments.add(assignment);\n+        claNames.add(assignment.getClusterName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING, \"Failed to unpack ClusterLoadAssignments in EDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.EDS, edsResourceSubscribers.keySet(),\n+          edsResponse.getVersionInfo(), \"Malformed EDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received EDS response for resources: {0}\", claNames);\n+\n+    String errorMessage = null;\n+    // Endpoint information updates for requested clusters received in this EDS response.\n+    Map<String, EdsUpdate> edsUpdates = new HashMap<>();\n+    // Walk through each ClusterLoadAssignment message. If any of them for requested clusters\n+    // contain invalid information for gRPC's load balancing usage, the whole response is rejected.\n+    for (ClusterLoadAssignment assignment : clusterLoadAssignments) {\n+      String clusterName = assignment.getClusterName();\n+      // Skip information for clusters not requested.\n+      // Management server is required to always send newly requested resources, even if they\n+      // may have been sent previously (proactively). Thus, client does not need to cache\n+      // unrequested resources.\n+      if (!edsResourceSubscribers.containsKey(clusterName)) {\n+        continue;\n+      }\n+      EdsUpdate.Builder updateBuilder = EdsUpdate.newBuilder();\n+      updateBuilder.setClusterName(clusterName);\n+      Set<Integer> priorities = new HashSet<>();\n+      int maxPriority = -1;\n+      for (io.envoyproxy.envoy.config.endpoint.v3.LocalityLbEndpoints localityLbEndpoints\n+          : assignment.getEndpointsList()) {\n+        // Filter out localities without or with 0 weight.\n+        if (!localityLbEndpoints.hasLoadBalancingWeight()\n+            || localityLbEndpoints.getLoadBalancingWeight().getValue() < 1) {\n+          continue;\n+        }\n+        int localityPriority = localityLbEndpoints.getPriority();\n+        if (localityPriority < 0) {\n+          errorMessage =\n+              \"ClusterLoadAssignment \" + clusterName + \" : locality with negative priority.\";\n+          break;\n+        }\n+        maxPriority = Math.max(maxPriority, localityPriority);\n+        priorities.add(localityPriority);\n+        // The endpoint field of each lb_endpoints must be set.\n+        // Inside of it: the address field must be set.\n+        for (LbEndpoint lbEndpoint : localityLbEndpoints.getLbEndpointsList()) {\n+          if (!lbEndpoint.getEndpoint().hasAddress()) {\n+            errorMessage = \"ClusterLoadAssignment \" + clusterName + \" : endpoint with no address.\";\n+            break;\n+          }\n+        }\n+        if (errorMessage != null) {\n+          break;\n+        }\n+        // Note endpoints with health status other than UNHEALTHY and UNKNOWN are still\n+        // handed over to watching parties. It is watching parties' responsibility to\n+        // filter out unhealthy endpoints. See EnvoyProtoData.LbEndpoint#isHealthy().\n+        updateBuilder.addLocalityLbEndpoints(\n+            Locality.fromEnvoyProtoLocality(localityLbEndpoints.getLocality()),\n+            LocalityLbEndpoints.fromEnvoyProtoLocalityLbEndpoints(localityLbEndpoints));\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      if (priorities.size() != maxPriority + 1) {\n+        errorMessage = \"ClusterLoadAssignment \" + clusterName + \" : sparse priorities.\";\n+        break;\n+      }\n+      for (ClusterLoadAssignment.Policy.DropOverload dropOverload\n+          : assignment.getPolicy().getDropOverloadsList()) {\n+        updateBuilder.addDropPolicy(DropOverload.fromEnvoyProtoDropOverload(dropOverload));\n+      }\n+      EdsUpdate update = updateBuilder.build();\n+      edsUpdates.put(clusterName, update);\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.EDS,\n+          edsResourceSubscribers.keySet(),\n+          edsResponse.getVersionInfo(),\n+          errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.EDS, edsResourceSubscribers.keySet(),\n+        edsResponse.getVersionInfo());\n+\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);\n+      if (edsUpdates.containsKey(resource)) {\n+        subscriber.onData(edsUpdates.get(resource));\n+      }\n+    }\n+  }\n+\n+  private void adjustResourceSubscription(ResourceType type, Collection<String> resources) {\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    adsStream.sendXdsRequest(type, resources);\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      startRpcStream();\n+      if (!ldsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!rdsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!cdsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!edsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.EDS, edsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    @VisibleForTesting\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          logger.log(XdsLogLevel.INFO, \"{0} resource {1} initial fetch timeout\", type, resource);\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {\n+        for (ResourceWatcher watcher : watchers) {\n+          notifyWatcher(watcher, data);\n+        }\n+      }\n+    }\n+\n+    void onAbsent() {\n+      if (respTimer != null && respTimer.isPending()) {  // too early to conclude absence\n+        return;\n+      }\n+      logger.log(XdsLogLevel.INFO, \"Conclude {0} resource {1} not exist\", type, resource);\n+      boolean oldAbsent = absent;", "originalCommit": "1a72fdff3a493e90963f4b5485c8f373b34b6c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1NjI0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499056241", "bodyText": "Oops, sorry sorry. I was working on this PR in parallel with the previous one, forgot to fix the same thing in this one.\nFixed now.", "author": "voidzcy", "createdAt": "2020-10-02T21:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MTI5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499041296", "bodyText": "Still the #7458 (comment) on RdsUpdate.equals()", "author": "dapengzhang0", "createdAt": "2020-10-02T20:42:46Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl2.java", "diffHunk": "@@ -0,0 +1,1688 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.Durations;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+final class XdsClientImpl2 extends XdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final String targetName;  // TODO: delete me.\n+  private final XdsChannel xdsChannel;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Supplier<Stopwatch> stopwatchSupplier;\n+  private final Stopwatch adsStreamRetryStopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  private Node node;\n+\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledHandle rpcRetryTimer;\n+  @Nullable\n+  private LoadReportClient lrsClient;\n+  private int loadReportCount;  // number of clusters enabling load reporting\n+\n+  // For server side usage.\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  XdsClientImpl2(\n+      String targetName,\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    this.targetName = checkNotNull(targetName, \"targetName\");\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatchSupplier = checkNotNull(stopwatchSupplier, \"stopwatch\");\n+    adsStreamRetryStopwatch = stopwatchSupplier.get();\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+    xdsChannel.getManagedChannel().shutdown();\n+    if (adsStream != null) {\n+      adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+    }\n+    cleanUpResourceTimers();\n+    if (lrsClient != null) {\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+    if (rpcRetryTimer != null) {\n+      rpcRetryTimer.cancel();\n+    }\n+  }\n+\n+  private void cleanUpResourceTimers() {\n+    for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+  }\n+\n+  @Override\n+  void watchLdsResource(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.LDS, resourceName);\n+      ldsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelLdsResourceWatch(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe LDS resource {0}\", resourceName);\n+      ldsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchRdsResource(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe RDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.RDS, resourceName);\n+      rdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelRdsResourceWatch(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe RDS resource {0}\", resourceName);\n+      rdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchCdsResource(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.CDS, resourceName);\n+      cdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelCdsResourceWatch(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe CDS resource {0}\", resourceName);\n+      cdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchEdsResource(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe EDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.EDS, resourceName);\n+      edsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelEdsResourceWatch(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe EDS resource {0}\", resourceName);\n+      edsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    logger.log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    updateNodeMetadataForListenerRequest(port);\n+    adsStream.sendXdsRequest(ResourceType.LDS, ImmutableList.<String>of());\n+    ldsRespTimer =\n+        syncContext\n+            .schedule(\n+                new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, timeService);\n+  }\n+\n+  /** In case of Listener watcher metadata to be updated to include port. */\n+  private void updateNodeMetadataForListenerRequest(int port) {\n+    Map<String, Object> newMetadata = new HashMap<>();\n+    if (node.getMetadata() != null) {\n+      newMetadata.putAll(node.getMetadata());\n+    }\n+    newMetadata.put(\"TRAFFICDIRECTOR_PROXYLESS\", \"1\");\n+    // TODO(sanjaypujare): eliminate usage of listening_addresses.\n+    EnvoyProtoData.Address listeningAddress =\n+        new EnvoyProtoData.Address(\"0.0.0.0\", port);\n+    node =\n+        node.toBuilder().setMetadata(newMetadata).addListeningAddresses(listeningAddress).build();\n+  }\n+\n+  @Override\n+  void reportClientStats() {\n+    if (lrsClient == null) {\n+      logger.log(XdsLogLevel.INFO, \"Turning on load reporting\");\n+      lrsClient =\n+          new LoadReportClient(\n+              targetName,\n+              loadStatsManager,\n+              xdsChannel,\n+              node,\n+              syncContext,\n+              timeService,\n+              backoffPolicyProvider,\n+              stopwatchSupplier);\n+    }\n+    if (loadReportCount == 0) {\n+      lrsClient.startLoadReporting();\n+    }\n+    loadReportCount++;\n+  }\n+\n+  @Override\n+  void cancelClientStatsReport() {\n+    checkState(loadReportCount > 0, \"load reporting was never started\");\n+    loadReportCount--;\n+    if (loadReportCount == 0) {\n+      logger.log(XdsLogLevel.INFO, \"Turning off load reporting\");\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+  }\n+\n+  @Override\n+  LoadStatsStore addClientStats(String clusterName, @Nullable String clusterServiceName) {\n+    return loadStatsManager.addLoadStats(clusterName, clusterServiceName);\n+  }\n+\n+  @Override\n+  void removeClientStats(String clusterName, @Nullable String clusterServiceName) {\n+    loadStatsManager.removeLoadStats(clusterName, clusterServiceName);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    adsStreamRetryStopwatch.reset().start();\n+  }\n+\n+  private void handleLdsResponse(DiscoveryResponseData ldsResponse) {\n+    if (listenerWatcher != null) {\n+      handleLdsResponseForServer(ldsResponse);\n+    } else {\n+      handleLdsResponseForClient(ldsResponse);\n+    }\n+  }\n+\n+  private void handleLdsResponseForClient(DiscoveryResponseData ldsResponse) {\n+    // Unpack Listener messages.\n+    List<Listener> listeners = new ArrayList<>(ldsResponse.getResourcesList().size());\n+    List<String> listenerNames = new ArrayList<>(ldsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : ldsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_LDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_LDS).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        listeners.add(listener);\n+        listenerNames.add(listener.getName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received LDS response for resources: {0}\", listenerNames);\n+\n+    // Unpack HttpConnectionManager messages.\n+    Map<String, HttpConnectionManager> httpConnectionManagers = new HashMap<>(listeners.size());\n+    try {\n+      for (Listener listener : listeners) {\n+        Any apiListener = listener.getApiListener().getApiListener();\n+        if (apiListener.getTypeUrl().equals(TYPE_URL_HTTP_CONNECTION_MANAGER_V2)) {\n+          apiListener =\n+              apiListener.toBuilder().setTypeUrl(TYPE_URL_HTTP_CONNECTION_MANAGER).build();\n+        }\n+        HttpConnectionManager hcm = apiListener.unpack(HttpConnectionManager.class);\n+        httpConnectionManagers.put(listener.getName(), hcm);\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Failed to unpack HttpConnectionManagers in Listeners of LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+\n+    Map<String, LdsUpdate> ldsUpdates = new HashMap<>();\n+    Set<String> rdsNames = new HashSet<>();\n+    String errorMessage = null;\n+    for (Map.Entry<String, HttpConnectionManager> entry : httpConnectionManagers.entrySet()) {\n+      String listenerName = entry.getKey();\n+      HttpConnectionManager hcm = entry.getValue();\n+      LdsUpdate.Builder updateBuilder = LdsUpdate.newBuilder();\n+      if (hcm.hasRouteConfig()) {\n+        for (VirtualHost virtualHostProto : hcm.getRouteConfig().getVirtualHostsList()) {\n+          StructOrError<EnvoyProtoData.VirtualHost> virtualHost =\n+              EnvoyProtoData.VirtualHost.fromEnvoyProtoVirtualHost(virtualHostProto);\n+          if (virtualHost.getErrorDetail() != null) {\n+            errorMessage = \"Listener \" + listenerName + \" contains invalid virtual host: \"\n+                + virtualHost.getErrorDetail();\n+            break;\n+          } else {\n+            updateBuilder.addVirtualHost(virtualHost.getStruct());\n+          }\n+        }\n+      } else if (hcm.hasRds()) {\n+        Rds rds = hcm.getRds();\n+        if (!rds.getConfigSource().hasAds()) {\n+          errorMessage = \"Listener \" + listenerName + \" with RDS config_source not set to ADS\";\n+        } else {\n+          updateBuilder.setRdsName(rds.getRouteConfigName());\n+          rdsNames.add(rds.getRouteConfigName());\n+        }\n+      } else {\n+        errorMessage = \"Listener \" + listenerName + \" without inline RouteConfiguration or RDS\";\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      if (hcm.hasCommonHttpProtocolOptions()) {\n+        HttpProtocolOptions options = hcm.getCommonHttpProtocolOptions();\n+        if (options.hasMaxStreamDuration()) {\n+          updateBuilder.setHttpMaxStreamDurationNano(\n+              Durations.toNanos(options.getMaxStreamDuration()));\n+        }\n+      }\n+      ldsUpdates.put(listenerName, updateBuilder.build());\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(\n+        ResourceType.LDS, ldsResourceSubscribers.keySet(), ldsResponse.getVersionInfo());\n+\n+    for (String resource : ldsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = ldsResourceSubscribers.get(resource);\n+      if (ldsUpdates.containsKey(resource)) {\n+        subscriber.onData(ldsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n+      }\n+    }\n+    for (String resource : rdsResourceSubscribers.keySet()) {\n+      if (!rdsNames.contains(resource)) {\n+        ResourceSubscriber subscriber = rdsResourceSubscribers.get(resource);\n+        subscriber.onAbsent();\n+      }\n+    }\n+  }\n+\n+  private void handleRdsResponse(DiscoveryResponseData rdsResponse) {\n+    // Unpack RouteConfiguration messages.\n+    Map<String, RouteConfiguration> routeConfigs =\n+        new HashMap<>(rdsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : rdsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_RDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_RDS).build();\n+        }\n+        RouteConfiguration rc = res.unpack(RouteConfiguration.class);\n+        routeConfigs.put(rc.getName(), rc);\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING, \"Failed to unpack RouteConfiguration in RDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+          rdsResponse.getVersionInfo(), \"Malformed RDS response: \" + e);\n+      return;\n+    }\n+    logger.log(\n+        XdsLogLevel.INFO, \"Received RDS response for resources: {0}\", routeConfigs.keySet());\n+\n+    Map<String, RdsUpdate> rdsUpdates = new HashMap<>();\n+    String errorMessage = null;\n+    for (Map.Entry<String, RouteConfiguration> entry : routeConfigs.entrySet()) {\n+      String routeConfigName = entry.getKey();\n+      RouteConfiguration routeConfig = entry.getValue();\n+      List<EnvoyProtoData.VirtualHost> virtualHosts =\n+          new ArrayList<>(routeConfig.getVirtualHostsCount());\n+      for (VirtualHost virtualHostProto : routeConfig.getVirtualHostsList()) {\n+        StructOrError<EnvoyProtoData.VirtualHost> virtualHost =\n+            EnvoyProtoData.VirtualHost.fromEnvoyProtoVirtualHost(virtualHostProto);\n+        if (virtualHost.getErrorDetail() != null) {\n+          errorMessage = \"RouteConfiguration \" + routeConfigName\n+              + \" contains invalid virtual host: \" + virtualHost.getErrorDetail();\n+          break;\n+        } else {\n+          virtualHosts.add(virtualHost.getStruct());\n+        }\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      rdsUpdates.put(routeConfigName, RdsUpdate.fromVirtualHosts(virtualHosts));\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+          rdsResponse.getVersionInfo(), errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+        rdsResponse.getVersionInfo());\n+\n+    for (String resource : rdsResourceSubscribers.keySet()) {\n+      if (rdsUpdates.containsKey(resource)) {\n+        ResourceSubscriber subscriber = rdsResourceSubscribers.get(resource);\n+        subscriber.onData(rdsUpdates.get(resource));\n+      }\n+    }\n+  }\n+\n+  private void handleLdsResponseForServer(DiscoveryResponseData ldsResponse) {\n+    // Unpack Listener messages.\n+    Listener requestedListener = null;\n+    logger.log(XdsLogLevel.DEBUG, \"Listener count: {0}\", ldsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : ldsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_LDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_LDS).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        logger.log(XdsLogLevel.DEBUG, \"Found listener {0}\", listener.toString());\n+        if (isRequestedListener(listener)) {\n+          requestedListener = listener;\n+          logger.log(XdsLogLevel.DEBUG, \"Requested listener found: {0}\", listener.getName());\n+        }\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ImmutableList.<String>of(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    ListenerUpdate listenerUpdate = null;\n+    if (requestedListener != null) {\n+      if (ldsRespTimer != null) {\n+        ldsRespTimer.cancel();\n+        ldsRespTimer = null;\n+      }\n+      try {\n+        listenerUpdate = ListenerUpdate.newBuilder()\n+            .setListener(EnvoyServerProtoData.Listener.fromEnvoyProtoListener(requestedListener))\n+            .build();\n+      } catch (InvalidProtocolBufferException e) {\n+        logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listener in LDS response {0}\", e);\n+        adsStream.sendNackRequest(\n+            ResourceType.LDS, ImmutableList.<String>of(),\n+            ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+        return;\n+      }\n+    } else {\n+      if (ldsRespTimer == null) {\n+        listenerWatcher.onResourceDoesNotExist(\":\" + listenerPort);\n+      }\n+    }\n+    adsStream.sendAckRequest(ResourceType.LDS, ImmutableList.<String>of(),\n+        ldsResponse.getVersionInfo());\n+    if (listenerUpdate != null) {\n+      listenerWatcher.onListenerChanged(listenerUpdate);\n+    }\n+  }\n+\n+  private boolean isRequestedListener(Listener listener) {\n+    // TODO(sanjaypujare): check listener.getName() once we know what xDS server returns\n+    return isAddressMatching(listener.getAddress())\n+        && hasMatchingFilter(listener.getFilterChainsList());\n+  }\n+\n+  private boolean isAddressMatching(Address address) {\n+    // TODO(sanjaypujare): check IP address once we know xDS server will include it\n+    return address.hasSocketAddress()\n+        && (address.getSocketAddress().getPortValue() == listenerPort);\n+  }\n+\n+  private boolean hasMatchingFilter(List<FilterChain> filterChainsList) {\n+    // TODO(sanjaypujare): if myIp to be checked against filterChainMatch.getPrefixRangesList()\n+    for (FilterChain filterChain : filterChainsList) {\n+      FilterChainMatch filterChainMatch = filterChain.getFilterChainMatch();\n+\n+      if (listenerPort == filterChainMatch.getDestinationPort().getValue()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Handles CDS response, which contains a list of Cluster messages with information for a logical\n+   * cluster. The response is NACKed if messages for requested resources contain invalid\n+   * information for gRPC's usage. Otherwise, an ACK request is sent to management server.\n+   * Response data for requested clusters is cached locally, in case of new cluster watchers\n+   * interested in the same clusters are added later.\n+   */\n+  private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n+    adsStream.cdsRespNonce = cdsResponse.getNonce();\n+\n+    // Unpack Cluster messages.\n+    List<Cluster> clusters = new ArrayList<>(cdsResponse.getResourcesList().size());\n+    List<String> clusterNames = new ArrayList<>(cdsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : cdsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_CDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_CDS).build();\n+        }\n+        Cluster cluster = res.unpack(Cluster.class);\n+        clusters.add(cluster);\n+        clusterNames.add(cluster.getName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Clusters in CDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.CDS, cdsResourceSubscribers.keySet(),\n+          cdsResponse.getVersionInfo(), \"Malformed CDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received CDS response for resources: {0}\", clusterNames);\n+\n+    String errorMessage = null;\n+    // Cluster information update for requested clusters received in this CDS response.\n+    Map<String, CdsUpdate> cdsUpdates = new HashMap<>();\n+    // CDS responses represents the state of the world, EDS services not referenced by\n+    // Clusters are those no longer exist.\n+    Set<String> edsServices = new HashSet<>();\n+    for (Cluster cluster : clusters) {\n+      String clusterName = cluster.getName();\n+      // Skip information for clusters not requested.\n+      // Management server is required to always send newly requested resources, even if they\n+      // may have been sent previously (proactively). Thus, client does not need to cache\n+      // unrequested resources.\n+      if (!cdsResourceSubscribers.containsKey(clusterName)) {\n+        continue;\n+      }\n+      CdsUpdate.Builder updateBuilder = CdsUpdate.newBuilder();\n+      updateBuilder.setClusterName(clusterName);\n+      // The type field must be set to EDS.\n+      if (!cluster.getType().equals(DiscoveryType.EDS)) {\n+        errorMessage = \"Cluster \" + clusterName + \" : only EDS discovery type is supported \"\n+            + \"in gRPC.\";\n+        break;\n+      }\n+      // In the eds_cluster_config field, the eds_config field must be set to indicate to\n+      // use EDS (must be set to use ADS).\n+      EdsClusterConfig edsClusterConfig = cluster.getEdsClusterConfig();\n+      if (!edsClusterConfig.getEdsConfig().hasAds()) {\n+        errorMessage = \"Cluster \" + clusterName + \" : field eds_cluster_config must be set to \"\n+            + \"indicate to use EDS over ADS.\";\n+        break;\n+      }\n+      // If the service_name field is set, that value will be used for the EDS request.\n+      if (!edsClusterConfig.getServiceName().isEmpty()) {\n+        updateBuilder.setEdsServiceName(edsClusterConfig.getServiceName());\n+        edsServices.add(edsClusterConfig.getServiceName());\n+      } else {\n+        edsServices.add(clusterName);\n+      }\n+      // The lb_policy field must be set to ROUND_ROBIN.\n+      if (!cluster.getLbPolicy().equals(LbPolicy.ROUND_ROBIN)) {\n+        errorMessage = \"Cluster \" + clusterName + \" : only round robin load balancing policy is \"\n+            + \"supported in gRPC.\";\n+        break;\n+      }\n+      updateBuilder.setLbPolicy(\"round_robin\");\n+      // If the lrs_server field is set, it must have its self field set, in which case the\n+      // client should use LRS for load reporting. Otherwise (the lrs_server field is not set),\n+      // LRS load reporting will be disabled.\n+      if (cluster.hasLrsServer()) {\n+        if (!cluster.getLrsServer().hasSelf()) {\n+          errorMessage = \"Cluster \" + clusterName + \" : only support enabling LRS for the same \"\n+              + \"management server.\";\n+          break;\n+        }\n+        updateBuilder.setLrsServerName(\"\");\n+      }\n+      try {\n+        UpstreamTlsContext upstreamTlsContext = getTlsContextFromCluster(cluster);\n+        if (upstreamTlsContext != null && upstreamTlsContext.getCommonTlsContext() != null) {\n+          updateBuilder.setUpstreamTlsContext(upstreamTlsContext);\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        errorMessage = \"Cluster \" + clusterName + \" : \" + e.getMessage();\n+        break;\n+      }\n+      cdsUpdates.put(clusterName, updateBuilder.build());\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.CDS,\n+          cdsResourceSubscribers.keySet(),\n+          cdsResponse.getVersionInfo(),\n+          errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n+        cdsResponse.getVersionInfo());\n+\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n+      }\n+    }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);\n+      if (!edsServices.contains(resource)) {\n+        subscriber.onAbsent();\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  private static UpstreamTlsContext getTlsContextFromCluster(Cluster cluster)\n+      throws InvalidProtocolBufferException {\n+    if (cluster.hasTransportSocket() && \"tls\".equals(cluster.getTransportSocket().getName())) {\n+      Any any = cluster.getTransportSocket().getTypedConfig();\n+      return UpstreamTlsContext.fromEnvoyProtoUpstreamTlsContext(\n+          io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext.parseFrom(\n+              any.getValue()));\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Handles EDS response, which contains a list of ClusterLoadAssignment messages with\n+   * endpoint load balancing information for each cluster. The response is NACKed if messages\n+   * for requested resources contain invalid information for gRPC's usage. Otherwise,\n+   * an ACK request is sent to management server. Response data for requested clusters is\n+   * cached locally, in case of new endpoint watchers interested in the same clusters\n+   * are added later.\n+   */\n+  private void handleEdsResponse(DiscoveryResponseData edsResponse) {\n+    // Unpack ClusterLoadAssignment messages.\n+    List<ClusterLoadAssignment> clusterLoadAssignments =\n+        new ArrayList<>(edsResponse.getResourcesList().size());\n+    List<String> claNames = new ArrayList<>(edsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : edsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_EDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_EDS).build();\n+        }\n+        ClusterLoadAssignment assignment = res.unpack(ClusterLoadAssignment.class);\n+        clusterLoadAssignments.add(assignment);\n+        claNames.add(assignment.getClusterName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING, \"Failed to unpack ClusterLoadAssignments in EDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.EDS, edsResourceSubscribers.keySet(),\n+          edsResponse.getVersionInfo(), \"Malformed EDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received EDS response for resources: {0}\", claNames);\n+\n+    String errorMessage = null;\n+    // Endpoint information updates for requested clusters received in this EDS response.\n+    Map<String, EdsUpdate> edsUpdates = new HashMap<>();\n+    // Walk through each ClusterLoadAssignment message. If any of them for requested clusters\n+    // contain invalid information for gRPC's load balancing usage, the whole response is rejected.\n+    for (ClusterLoadAssignment assignment : clusterLoadAssignments) {\n+      String clusterName = assignment.getClusterName();\n+      // Skip information for clusters not requested.\n+      // Management server is required to always send newly requested resources, even if they\n+      // may have been sent previously (proactively). Thus, client does not need to cache\n+      // unrequested resources.\n+      if (!edsResourceSubscribers.containsKey(clusterName)) {\n+        continue;\n+      }\n+      EdsUpdate.Builder updateBuilder = EdsUpdate.newBuilder();\n+      updateBuilder.setClusterName(clusterName);\n+      Set<Integer> priorities = new HashSet<>();\n+      int maxPriority = -1;\n+      for (io.envoyproxy.envoy.config.endpoint.v3.LocalityLbEndpoints localityLbEndpoints\n+          : assignment.getEndpointsList()) {\n+        // Filter out localities without or with 0 weight.\n+        if (!localityLbEndpoints.hasLoadBalancingWeight()\n+            || localityLbEndpoints.getLoadBalancingWeight().getValue() < 1) {\n+          continue;\n+        }\n+        int localityPriority = localityLbEndpoints.getPriority();\n+        if (localityPriority < 0) {\n+          errorMessage =\n+              \"ClusterLoadAssignment \" + clusterName + \" : locality with negative priority.\";\n+          break;\n+        }\n+        maxPriority = Math.max(maxPriority, localityPriority);\n+        priorities.add(localityPriority);\n+        // The endpoint field of each lb_endpoints must be set.\n+        // Inside of it: the address field must be set.\n+        for (LbEndpoint lbEndpoint : localityLbEndpoints.getLbEndpointsList()) {\n+          if (!lbEndpoint.getEndpoint().hasAddress()) {\n+            errorMessage = \"ClusterLoadAssignment \" + clusterName + \" : endpoint with no address.\";\n+            break;\n+          }\n+        }\n+        if (errorMessage != null) {\n+          break;\n+        }\n+        // Note endpoints with health status other than UNHEALTHY and UNKNOWN are still\n+        // handed over to watching parties. It is watching parties' responsibility to\n+        // filter out unhealthy endpoints. See EnvoyProtoData.LbEndpoint#isHealthy().\n+        updateBuilder.addLocalityLbEndpoints(\n+            Locality.fromEnvoyProtoLocality(localityLbEndpoints.getLocality()),\n+            LocalityLbEndpoints.fromEnvoyProtoLocalityLbEndpoints(localityLbEndpoints));\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      if (priorities.size() != maxPriority + 1) {\n+        errorMessage = \"ClusterLoadAssignment \" + clusterName + \" : sparse priorities.\";\n+        break;\n+      }\n+      for (ClusterLoadAssignment.Policy.DropOverload dropOverload\n+          : assignment.getPolicy().getDropOverloadsList()) {\n+        updateBuilder.addDropPolicy(DropOverload.fromEnvoyProtoDropOverload(dropOverload));\n+      }\n+      EdsUpdate update = updateBuilder.build();\n+      edsUpdates.put(clusterName, update);\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.EDS,\n+          edsResourceSubscribers.keySet(),\n+          edsResponse.getVersionInfo(),\n+          errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.EDS, edsResourceSubscribers.keySet(),\n+        edsResponse.getVersionInfo());\n+\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);\n+      if (edsUpdates.containsKey(resource)) {\n+        subscriber.onData(edsUpdates.get(resource));\n+      }\n+    }\n+  }\n+\n+  private void adjustResourceSubscription(ResourceType type, Collection<String> resources) {\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    adsStream.sendXdsRequest(type, resources);\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      startRpcStream();\n+      if (!ldsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!rdsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!cdsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!edsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.EDS, edsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    @VisibleForTesting\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          logger.log(XdsLogLevel.INFO, \"{0} resource {1} initial fetch timeout\", type, resource);\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {", "originalCommit": "1a72fdff3a493e90963f4b5485c8f373b34b6c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1NjMyMg==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499056322", "bodyText": "Added.", "author": "voidzcy", "createdAt": "2020-10-02T21:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NTg2Ng==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499045866", "bodyText": "Why deleted\nif (listenerWatcher != null) {\n  listenerWatcher.onError(error);\n}", "author": "dapengzhang0", "createdAt": "2020-10-02T20:54:17Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl2.java", "diffHunk": "@@ -0,0 +1,1688 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.Durations;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+final class XdsClientImpl2 extends XdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final String targetName;  // TODO: delete me.\n+  private final XdsChannel xdsChannel;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Supplier<Stopwatch> stopwatchSupplier;\n+  private final Stopwatch adsStreamRetryStopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  private Node node;\n+\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledHandle rpcRetryTimer;\n+  @Nullable\n+  private LoadReportClient lrsClient;\n+  private int loadReportCount;  // number of clusters enabling load reporting\n+\n+  // For server side usage.\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  XdsClientImpl2(\n+      String targetName,\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    this.targetName = checkNotNull(targetName, \"targetName\");\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatchSupplier = checkNotNull(stopwatchSupplier, \"stopwatch\");\n+    adsStreamRetryStopwatch = stopwatchSupplier.get();\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+    xdsChannel.getManagedChannel().shutdown();\n+    if (adsStream != null) {\n+      adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+    }\n+    cleanUpResourceTimers();\n+    if (lrsClient != null) {\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+    if (rpcRetryTimer != null) {\n+      rpcRetryTimer.cancel();\n+    }\n+  }\n+\n+  private void cleanUpResourceTimers() {\n+    for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+    for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+      subscriber.stopTimer();\n+    }\n+  }\n+\n+  @Override\n+  void watchLdsResource(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.LDS, resourceName);\n+      ldsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelLdsResourceWatch(String resourceName, LdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = ldsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe LDS resource {0}\", resourceName);\n+      ldsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchRdsResource(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe RDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.RDS, resourceName);\n+      rdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelRdsResourceWatch(String resourceName, RdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = rdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe RDS resource {0}\", resourceName);\n+      rdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchCdsResource(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe CDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.CDS, resourceName);\n+      cdsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelCdsResourceWatch(String resourceName, CdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = cdsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe CDS resource {0}\", resourceName);\n+      cdsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchEdsResource(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    if (subscriber == null) {\n+      logger.log(XdsLogLevel.INFO, \"Subscribe EDS resource {0}\", resourceName);\n+      subscriber = new ResourceSubscriber(ResourceType.EDS, resourceName);\n+      edsResourceSubscribers.put(resourceName, subscriber);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+    subscriber.addWatcher(watcher);\n+  }\n+\n+  @Override\n+  void cancelEdsResourceWatch(String resourceName, EdsResourceWatcher watcher) {\n+    ResourceSubscriber subscriber = edsResourceSubscribers.get(resourceName);\n+    subscriber.removeWatcher(watcher);\n+    if (!subscriber.isWatched()) {\n+      subscriber.stopTimer();\n+      logger.log(XdsLogLevel.INFO, \"Unsubscribe EDS resource {0}\", resourceName);\n+      edsResourceSubscribers.remove(resourceName);\n+      adjustResourceSubscription(ResourceType.EDS, edsResourceSubscribers.keySet());\n+    }\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    logger.log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    updateNodeMetadataForListenerRequest(port);\n+    adsStream.sendXdsRequest(ResourceType.LDS, ImmutableList.<String>of());\n+    ldsRespTimer =\n+        syncContext\n+            .schedule(\n+                new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, timeService);\n+  }\n+\n+  /** In case of Listener watcher metadata to be updated to include port. */\n+  private void updateNodeMetadataForListenerRequest(int port) {\n+    Map<String, Object> newMetadata = new HashMap<>();\n+    if (node.getMetadata() != null) {\n+      newMetadata.putAll(node.getMetadata());\n+    }\n+    newMetadata.put(\"TRAFFICDIRECTOR_PROXYLESS\", \"1\");\n+    // TODO(sanjaypujare): eliminate usage of listening_addresses.\n+    EnvoyProtoData.Address listeningAddress =\n+        new EnvoyProtoData.Address(\"0.0.0.0\", port);\n+    node =\n+        node.toBuilder().setMetadata(newMetadata).addListeningAddresses(listeningAddress).build();\n+  }\n+\n+  @Override\n+  void reportClientStats() {\n+    if (lrsClient == null) {\n+      logger.log(XdsLogLevel.INFO, \"Turning on load reporting\");\n+      lrsClient =\n+          new LoadReportClient(\n+              targetName,\n+              loadStatsManager,\n+              xdsChannel,\n+              node,\n+              syncContext,\n+              timeService,\n+              backoffPolicyProvider,\n+              stopwatchSupplier);\n+    }\n+    if (loadReportCount == 0) {\n+      lrsClient.startLoadReporting();\n+    }\n+    loadReportCount++;\n+  }\n+\n+  @Override\n+  void cancelClientStatsReport() {\n+    checkState(loadReportCount > 0, \"load reporting was never started\");\n+    loadReportCount--;\n+    if (loadReportCount == 0) {\n+      logger.log(XdsLogLevel.INFO, \"Turning off load reporting\");\n+      lrsClient.stopLoadReporting();\n+      lrsClient = null;\n+    }\n+  }\n+\n+  @Override\n+  LoadStatsStore addClientStats(String clusterName, @Nullable String clusterServiceName) {\n+    return loadStatsManager.addLoadStats(clusterName, clusterServiceName);\n+  }\n+\n+  @Override\n+  void removeClientStats(String clusterName, @Nullable String clusterServiceName) {\n+    loadStatsManager.removeLoadStats(clusterName, clusterServiceName);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    adsStreamRetryStopwatch.reset().start();\n+  }\n+\n+  private void handleLdsResponse(DiscoveryResponseData ldsResponse) {\n+    if (listenerWatcher != null) {\n+      handleLdsResponseForServer(ldsResponse);\n+    } else {\n+      handleLdsResponseForClient(ldsResponse);\n+    }\n+  }\n+\n+  private void handleLdsResponseForClient(DiscoveryResponseData ldsResponse) {\n+    // Unpack Listener messages.\n+    List<Listener> listeners = new ArrayList<>(ldsResponse.getResourcesList().size());\n+    List<String> listenerNames = new ArrayList<>(ldsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : ldsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_LDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_LDS).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        listeners.add(listener);\n+        listenerNames.add(listener.getName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received LDS response for resources: {0}\", listenerNames);\n+\n+    // Unpack HttpConnectionManager messages.\n+    Map<String, HttpConnectionManager> httpConnectionManagers = new HashMap<>(listeners.size());\n+    try {\n+      for (Listener listener : listeners) {\n+        Any apiListener = listener.getApiListener().getApiListener();\n+        if (apiListener.getTypeUrl().equals(TYPE_URL_HTTP_CONNECTION_MANAGER_V2)) {\n+          apiListener =\n+              apiListener.toBuilder().setTypeUrl(TYPE_URL_HTTP_CONNECTION_MANAGER).build();\n+        }\n+        HttpConnectionManager hcm = apiListener.unpack(HttpConnectionManager.class);\n+        httpConnectionManagers.put(listener.getName(), hcm);\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Failed to unpack HttpConnectionManagers in Listeners of LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+\n+    Map<String, LdsUpdate> ldsUpdates = new HashMap<>();\n+    Set<String> rdsNames = new HashSet<>();\n+    String errorMessage = null;\n+    for (Map.Entry<String, HttpConnectionManager> entry : httpConnectionManagers.entrySet()) {\n+      String listenerName = entry.getKey();\n+      HttpConnectionManager hcm = entry.getValue();\n+      LdsUpdate.Builder updateBuilder = LdsUpdate.newBuilder();\n+      if (hcm.hasRouteConfig()) {\n+        for (VirtualHost virtualHostProto : hcm.getRouteConfig().getVirtualHostsList()) {\n+          StructOrError<EnvoyProtoData.VirtualHost> virtualHost =\n+              EnvoyProtoData.VirtualHost.fromEnvoyProtoVirtualHost(virtualHostProto);\n+          if (virtualHost.getErrorDetail() != null) {\n+            errorMessage = \"Listener \" + listenerName + \" contains invalid virtual host: \"\n+                + virtualHost.getErrorDetail();\n+            break;\n+          } else {\n+            updateBuilder.addVirtualHost(virtualHost.getStruct());\n+          }\n+        }\n+      } else if (hcm.hasRds()) {\n+        Rds rds = hcm.getRds();\n+        if (!rds.getConfigSource().hasAds()) {\n+          errorMessage = \"Listener \" + listenerName + \" with RDS config_source not set to ADS\";\n+        } else {\n+          updateBuilder.setRdsName(rds.getRouteConfigName());\n+          rdsNames.add(rds.getRouteConfigName());\n+        }\n+      } else {\n+        errorMessage = \"Listener \" + listenerName + \" without inline RouteConfiguration or RDS\";\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      if (hcm.hasCommonHttpProtocolOptions()) {\n+        HttpProtocolOptions options = hcm.getCommonHttpProtocolOptions();\n+        if (options.hasMaxStreamDuration()) {\n+          updateBuilder.setHttpMaxStreamDurationNano(\n+              Durations.toNanos(options.getMaxStreamDuration()));\n+        }\n+      }\n+      ldsUpdates.put(listenerName, updateBuilder.build());\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ldsResourceSubscribers.keySet(),\n+          ldsResponse.getVersionInfo(), errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(\n+        ResourceType.LDS, ldsResourceSubscribers.keySet(), ldsResponse.getVersionInfo());\n+\n+    for (String resource : ldsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = ldsResourceSubscribers.get(resource);\n+      if (ldsUpdates.containsKey(resource)) {\n+        subscriber.onData(ldsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n+      }\n+    }\n+    for (String resource : rdsResourceSubscribers.keySet()) {\n+      if (!rdsNames.contains(resource)) {\n+        ResourceSubscriber subscriber = rdsResourceSubscribers.get(resource);\n+        subscriber.onAbsent();\n+      }\n+    }\n+  }\n+\n+  private void handleRdsResponse(DiscoveryResponseData rdsResponse) {\n+    // Unpack RouteConfiguration messages.\n+    Map<String, RouteConfiguration> routeConfigs =\n+        new HashMap<>(rdsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : rdsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_RDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_RDS).build();\n+        }\n+        RouteConfiguration rc = res.unpack(RouteConfiguration.class);\n+        routeConfigs.put(rc.getName(), rc);\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING, \"Failed to unpack RouteConfiguration in RDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+          rdsResponse.getVersionInfo(), \"Malformed RDS response: \" + e);\n+      return;\n+    }\n+    logger.log(\n+        XdsLogLevel.INFO, \"Received RDS response for resources: {0}\", routeConfigs.keySet());\n+\n+    Map<String, RdsUpdate> rdsUpdates = new HashMap<>();\n+    String errorMessage = null;\n+    for (Map.Entry<String, RouteConfiguration> entry : routeConfigs.entrySet()) {\n+      String routeConfigName = entry.getKey();\n+      RouteConfiguration routeConfig = entry.getValue();\n+      List<EnvoyProtoData.VirtualHost> virtualHosts =\n+          new ArrayList<>(routeConfig.getVirtualHostsCount());\n+      for (VirtualHost virtualHostProto : routeConfig.getVirtualHostsList()) {\n+        StructOrError<EnvoyProtoData.VirtualHost> virtualHost =\n+            EnvoyProtoData.VirtualHost.fromEnvoyProtoVirtualHost(virtualHostProto);\n+        if (virtualHost.getErrorDetail() != null) {\n+          errorMessage = \"RouteConfiguration \" + routeConfigName\n+              + \" contains invalid virtual host: \" + virtualHost.getErrorDetail();\n+          break;\n+        } else {\n+          virtualHosts.add(virtualHost.getStruct());\n+        }\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      rdsUpdates.put(routeConfigName, RdsUpdate.fromVirtualHosts(virtualHosts));\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+          rdsResponse.getVersionInfo(), errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.RDS, rdsResourceSubscribers.keySet(),\n+        rdsResponse.getVersionInfo());\n+\n+    for (String resource : rdsResourceSubscribers.keySet()) {\n+      if (rdsUpdates.containsKey(resource)) {\n+        ResourceSubscriber subscriber = rdsResourceSubscribers.get(resource);\n+        subscriber.onData(rdsUpdates.get(resource));\n+      }\n+    }\n+  }\n+\n+  private void handleLdsResponseForServer(DiscoveryResponseData ldsResponse) {\n+    // Unpack Listener messages.\n+    Listener requestedListener = null;\n+    logger.log(XdsLogLevel.DEBUG, \"Listener count: {0}\", ldsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : ldsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_LDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_LDS).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        logger.log(XdsLogLevel.DEBUG, \"Found listener {0}\", listener.toString());\n+        if (isRequestedListener(listener)) {\n+          requestedListener = listener;\n+          logger.log(XdsLogLevel.DEBUG, \"Requested listener found: {0}\", listener.getName());\n+        }\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.LDS, ImmutableList.<String>of(),\n+          ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    ListenerUpdate listenerUpdate = null;\n+    if (requestedListener != null) {\n+      if (ldsRespTimer != null) {\n+        ldsRespTimer.cancel();\n+        ldsRespTimer = null;\n+      }\n+      try {\n+        listenerUpdate = ListenerUpdate.newBuilder()\n+            .setListener(EnvoyServerProtoData.Listener.fromEnvoyProtoListener(requestedListener))\n+            .build();\n+      } catch (InvalidProtocolBufferException e) {\n+        logger.log(XdsLogLevel.WARNING, \"Failed to unpack Listener in LDS response {0}\", e);\n+        adsStream.sendNackRequest(\n+            ResourceType.LDS, ImmutableList.<String>of(),\n+            ldsResponse.getVersionInfo(), \"Malformed LDS response: \" + e);\n+        return;\n+      }\n+    } else {\n+      if (ldsRespTimer == null) {\n+        listenerWatcher.onResourceDoesNotExist(\":\" + listenerPort);\n+      }\n+    }\n+    adsStream.sendAckRequest(ResourceType.LDS, ImmutableList.<String>of(),\n+        ldsResponse.getVersionInfo());\n+    if (listenerUpdate != null) {\n+      listenerWatcher.onListenerChanged(listenerUpdate);\n+    }\n+  }\n+\n+  private boolean isRequestedListener(Listener listener) {\n+    // TODO(sanjaypujare): check listener.getName() once we know what xDS server returns\n+    return isAddressMatching(listener.getAddress())\n+        && hasMatchingFilter(listener.getFilterChainsList());\n+  }\n+\n+  private boolean isAddressMatching(Address address) {\n+    // TODO(sanjaypujare): check IP address once we know xDS server will include it\n+    return address.hasSocketAddress()\n+        && (address.getSocketAddress().getPortValue() == listenerPort);\n+  }\n+\n+  private boolean hasMatchingFilter(List<FilterChain> filterChainsList) {\n+    // TODO(sanjaypujare): if myIp to be checked against filterChainMatch.getPrefixRangesList()\n+    for (FilterChain filterChain : filterChainsList) {\n+      FilterChainMatch filterChainMatch = filterChain.getFilterChainMatch();\n+\n+      if (listenerPort == filterChainMatch.getDestinationPort().getValue()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Handles CDS response, which contains a list of Cluster messages with information for a logical\n+   * cluster. The response is NACKed if messages for requested resources contain invalid\n+   * information for gRPC's usage. Otherwise, an ACK request is sent to management server.\n+   * Response data for requested clusters is cached locally, in case of new cluster watchers\n+   * interested in the same clusters are added later.\n+   */\n+  private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n+    adsStream.cdsRespNonce = cdsResponse.getNonce();\n+\n+    // Unpack Cluster messages.\n+    List<Cluster> clusters = new ArrayList<>(cdsResponse.getResourcesList().size());\n+    List<String> clusterNames = new ArrayList<>(cdsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : cdsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_CDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_CDS).build();\n+        }\n+        Cluster cluster = res.unpack(Cluster.class);\n+        clusters.add(cluster);\n+        clusterNames.add(cluster.getName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(XdsLogLevel.WARNING, \"Failed to unpack Clusters in CDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.CDS, cdsResourceSubscribers.keySet(),\n+          cdsResponse.getVersionInfo(), \"Malformed CDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received CDS response for resources: {0}\", clusterNames);\n+\n+    String errorMessage = null;\n+    // Cluster information update for requested clusters received in this CDS response.\n+    Map<String, CdsUpdate> cdsUpdates = new HashMap<>();\n+    // CDS responses represents the state of the world, EDS services not referenced by\n+    // Clusters are those no longer exist.\n+    Set<String> edsServices = new HashSet<>();\n+    for (Cluster cluster : clusters) {\n+      String clusterName = cluster.getName();\n+      // Skip information for clusters not requested.\n+      // Management server is required to always send newly requested resources, even if they\n+      // may have been sent previously (proactively). Thus, client does not need to cache\n+      // unrequested resources.\n+      if (!cdsResourceSubscribers.containsKey(clusterName)) {\n+        continue;\n+      }\n+      CdsUpdate.Builder updateBuilder = CdsUpdate.newBuilder();\n+      updateBuilder.setClusterName(clusterName);\n+      // The type field must be set to EDS.\n+      if (!cluster.getType().equals(DiscoveryType.EDS)) {\n+        errorMessage = \"Cluster \" + clusterName + \" : only EDS discovery type is supported \"\n+            + \"in gRPC.\";\n+        break;\n+      }\n+      // In the eds_cluster_config field, the eds_config field must be set to indicate to\n+      // use EDS (must be set to use ADS).\n+      EdsClusterConfig edsClusterConfig = cluster.getEdsClusterConfig();\n+      if (!edsClusterConfig.getEdsConfig().hasAds()) {\n+        errorMessage = \"Cluster \" + clusterName + \" : field eds_cluster_config must be set to \"\n+            + \"indicate to use EDS over ADS.\";\n+        break;\n+      }\n+      // If the service_name field is set, that value will be used for the EDS request.\n+      if (!edsClusterConfig.getServiceName().isEmpty()) {\n+        updateBuilder.setEdsServiceName(edsClusterConfig.getServiceName());\n+        edsServices.add(edsClusterConfig.getServiceName());\n+      } else {\n+        edsServices.add(clusterName);\n+      }\n+      // The lb_policy field must be set to ROUND_ROBIN.\n+      if (!cluster.getLbPolicy().equals(LbPolicy.ROUND_ROBIN)) {\n+        errorMessage = \"Cluster \" + clusterName + \" : only round robin load balancing policy is \"\n+            + \"supported in gRPC.\";\n+        break;\n+      }\n+      updateBuilder.setLbPolicy(\"round_robin\");\n+      // If the lrs_server field is set, it must have its self field set, in which case the\n+      // client should use LRS for load reporting. Otherwise (the lrs_server field is not set),\n+      // LRS load reporting will be disabled.\n+      if (cluster.hasLrsServer()) {\n+        if (!cluster.getLrsServer().hasSelf()) {\n+          errorMessage = \"Cluster \" + clusterName + \" : only support enabling LRS for the same \"\n+              + \"management server.\";\n+          break;\n+        }\n+        updateBuilder.setLrsServerName(\"\");\n+      }\n+      try {\n+        UpstreamTlsContext upstreamTlsContext = getTlsContextFromCluster(cluster);\n+        if (upstreamTlsContext != null && upstreamTlsContext.getCommonTlsContext() != null) {\n+          updateBuilder.setUpstreamTlsContext(upstreamTlsContext);\n+        }\n+      } catch (InvalidProtocolBufferException e) {\n+        errorMessage = \"Cluster \" + clusterName + \" : \" + e.getMessage();\n+        break;\n+      }\n+      cdsUpdates.put(clusterName, updateBuilder.build());\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.CDS,\n+          cdsResourceSubscribers.keySet(),\n+          cdsResponse.getVersionInfo(),\n+          errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n+        cdsResponse.getVersionInfo());\n+\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n+      }\n+    }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);\n+      if (!edsServices.contains(resource)) {\n+        subscriber.onAbsent();\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  private static UpstreamTlsContext getTlsContextFromCluster(Cluster cluster)\n+      throws InvalidProtocolBufferException {\n+    if (cluster.hasTransportSocket() && \"tls\".equals(cluster.getTransportSocket().getName())) {\n+      Any any = cluster.getTransportSocket().getTypedConfig();\n+      return UpstreamTlsContext.fromEnvoyProtoUpstreamTlsContext(\n+          io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext.parseFrom(\n+              any.getValue()));\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Handles EDS response, which contains a list of ClusterLoadAssignment messages with\n+   * endpoint load balancing information for each cluster. The response is NACKed if messages\n+   * for requested resources contain invalid information for gRPC's usage. Otherwise,\n+   * an ACK request is sent to management server. Response data for requested clusters is\n+   * cached locally, in case of new endpoint watchers interested in the same clusters\n+   * are added later.\n+   */\n+  private void handleEdsResponse(DiscoveryResponseData edsResponse) {\n+    // Unpack ClusterLoadAssignment messages.\n+    List<ClusterLoadAssignment> clusterLoadAssignments =\n+        new ArrayList<>(edsResponse.getResourcesList().size());\n+    List<String> claNames = new ArrayList<>(edsResponse.getResourcesList().size());\n+    try {\n+      for (com.google.protobuf.Any res : edsResponse.getResourcesList()) {\n+        if (res.getTypeUrl().equals(ADS_TYPE_URL_EDS_V2)) {\n+          res = res.toBuilder().setTypeUrl(ADS_TYPE_URL_EDS).build();\n+        }\n+        ClusterLoadAssignment assignment = res.unpack(ClusterLoadAssignment.class);\n+        clusterLoadAssignments.add(assignment);\n+        claNames.add(assignment.getClusterName());\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      logger.log(\n+          XdsLogLevel.WARNING, \"Failed to unpack ClusterLoadAssignments in EDS response {0}\", e);\n+      adsStream.sendNackRequest(\n+          ResourceType.EDS, edsResourceSubscribers.keySet(),\n+          edsResponse.getVersionInfo(), \"Malformed EDS response: \" + e);\n+      return;\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Received EDS response for resources: {0}\", claNames);\n+\n+    String errorMessage = null;\n+    // Endpoint information updates for requested clusters received in this EDS response.\n+    Map<String, EdsUpdate> edsUpdates = new HashMap<>();\n+    // Walk through each ClusterLoadAssignment message. If any of them for requested clusters\n+    // contain invalid information for gRPC's load balancing usage, the whole response is rejected.\n+    for (ClusterLoadAssignment assignment : clusterLoadAssignments) {\n+      String clusterName = assignment.getClusterName();\n+      // Skip information for clusters not requested.\n+      // Management server is required to always send newly requested resources, even if they\n+      // may have been sent previously (proactively). Thus, client does not need to cache\n+      // unrequested resources.\n+      if (!edsResourceSubscribers.containsKey(clusterName)) {\n+        continue;\n+      }\n+      EdsUpdate.Builder updateBuilder = EdsUpdate.newBuilder();\n+      updateBuilder.setClusterName(clusterName);\n+      Set<Integer> priorities = new HashSet<>();\n+      int maxPriority = -1;\n+      for (io.envoyproxy.envoy.config.endpoint.v3.LocalityLbEndpoints localityLbEndpoints\n+          : assignment.getEndpointsList()) {\n+        // Filter out localities without or with 0 weight.\n+        if (!localityLbEndpoints.hasLoadBalancingWeight()\n+            || localityLbEndpoints.getLoadBalancingWeight().getValue() < 1) {\n+          continue;\n+        }\n+        int localityPriority = localityLbEndpoints.getPriority();\n+        if (localityPriority < 0) {\n+          errorMessage =\n+              \"ClusterLoadAssignment \" + clusterName + \" : locality with negative priority.\";\n+          break;\n+        }\n+        maxPriority = Math.max(maxPriority, localityPriority);\n+        priorities.add(localityPriority);\n+        // The endpoint field of each lb_endpoints must be set.\n+        // Inside of it: the address field must be set.\n+        for (LbEndpoint lbEndpoint : localityLbEndpoints.getLbEndpointsList()) {\n+          if (!lbEndpoint.getEndpoint().hasAddress()) {\n+            errorMessage = \"ClusterLoadAssignment \" + clusterName + \" : endpoint with no address.\";\n+            break;\n+          }\n+        }\n+        if (errorMessage != null) {\n+          break;\n+        }\n+        // Note endpoints with health status other than UNHEALTHY and UNKNOWN are still\n+        // handed over to watching parties. It is watching parties' responsibility to\n+        // filter out unhealthy endpoints. See EnvoyProtoData.LbEndpoint#isHealthy().\n+        updateBuilder.addLocalityLbEndpoints(\n+            Locality.fromEnvoyProtoLocality(localityLbEndpoints.getLocality()),\n+            LocalityLbEndpoints.fromEnvoyProtoLocalityLbEndpoints(localityLbEndpoints));\n+      }\n+      if (errorMessage != null) {\n+        break;\n+      }\n+      if (priorities.size() != maxPriority + 1) {\n+        errorMessage = \"ClusterLoadAssignment \" + clusterName + \" : sparse priorities.\";\n+        break;\n+      }\n+      for (ClusterLoadAssignment.Policy.DropOverload dropOverload\n+          : assignment.getPolicy().getDropOverloadsList()) {\n+        updateBuilder.addDropPolicy(DropOverload.fromEnvoyProtoDropOverload(dropOverload));\n+      }\n+      EdsUpdate update = updateBuilder.build();\n+      edsUpdates.put(clusterName, update);\n+    }\n+    if (errorMessage != null) {\n+      adsStream.sendNackRequest(\n+          ResourceType.EDS,\n+          edsResourceSubscribers.keySet(),\n+          edsResponse.getVersionInfo(),\n+          errorMessage);\n+      return;\n+    }\n+    adsStream.sendAckRequest(ResourceType.EDS, edsResourceSubscribers.keySet(),\n+        edsResponse.getVersionInfo());\n+\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);\n+      if (edsUpdates.containsKey(resource)) {\n+        subscriber.onData(edsUpdates.get(resource));\n+      }\n+    }\n+  }\n+\n+  private void adjustResourceSubscription(ResourceType type, Collection<String> resources) {\n+    if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+      // Currently in retry backoff.\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    adsStream.sendXdsRequest(type, resources);\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      startRpcStream();\n+      if (!ldsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.LDS, ldsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : ldsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!rdsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.RDS, rdsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : rdsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!cdsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.CDS, cdsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : cdsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+      if (!edsResourceSubscribers.isEmpty()) {\n+        adsStream.sendXdsRequest(ResourceType.EDS, edsResourceSubscribers.keySet());\n+        for (ResourceSubscriber subscriber : edsResourceSubscribers.values()) {\n+          subscriber.restartTimer();\n+        }\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    @VisibleForTesting\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          logger.log(XdsLogLevel.INFO, \"{0} resource {1} initial fetch timeout\", type, resource);\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {\n+        for (ResourceWatcher watcher : watchers) {\n+          notifyWatcher(watcher, data);\n+        }\n+      }\n+    }\n+\n+    void onAbsent() {\n+      if (respTimer != null && respTimer.isPending()) {  // too early to conclude absence\n+        return;\n+      }\n+      logger.log(XdsLogLevel.INFO, \"Conclude {0} resource {1} not exist\", type, resource);\n+      boolean oldAbsent = absent;\n+      data = null;\n+      absent = true;\n+      if (!oldAbsent) {\n+        for (ResourceWatcher watcher : watchers) {\n+          watcher.onResourceDoesNotExist(resource);\n+        }\n+      }\n+    }\n+\n+    void onError(Status error) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      for (ResourceWatcher watcher : watchers) {\n+        watcher.onError(error);\n+      }\n+    }\n+\n+    private void notifyWatcher(ResourceWatcher watcher, ResourceUpdate update) {\n+      switch (type) {\n+        case LDS:\n+          ((LdsResourceWatcher) watcher).onChanged((LdsUpdate) update);\n+          break;\n+        case RDS:\n+          ((RdsResourceWatcher) watcher).onChanged((RdsUpdate) update);\n+          break;\n+        case CDS:\n+          ((CdsResourceWatcher) watcher).onChanged((CdsUpdate) update);\n+          break;\n+        case EDS:\n+          ((EdsResourceWatcher) watcher).onChanged((EdsUpdate) update);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"should never be here\");\n+      }\n+    }\n+  }\n+\n+  private static final class DiscoveryRequestData {\n+    private final ResourceType resourceType;\n+    private final Collection<String> resourceNames;\n+    private final String versionInfo;\n+    private final String responseNonce;\n+    private final Node node;\n+    @Nullable\n+    private final com.google.rpc.Status errorDetail;\n+\n+    DiscoveryRequestData(\n+        ResourceType resourceType, Collection<String> resourceNames, String versionInfo,\n+        String responseNonce, Node node, @Nullable com.google.rpc.Status errorDetail) {\n+      this.resourceType = resourceType;\n+      this.resourceNames = resourceNames;\n+      this.versionInfo = versionInfo;\n+      this.responseNonce = responseNonce;\n+      this.node = node;\n+      this.errorDetail = errorDetail;\n+    }\n+\n+    DiscoveryRequest toEnvoyProto() {\n+      DiscoveryRequest.Builder builder =\n+          DiscoveryRequest.newBuilder()\n+              .setVersionInfo(versionInfo)\n+              .setNode(node.toEnvoyProtoNode())\n+              .addAllResourceNames(resourceNames)\n+              .setTypeUrl(resourceType.typeUrl())\n+              .setResponseNonce(responseNonce);\n+      if (errorDetail != null) {\n+        builder.setErrorDetail(errorDetail);\n+      }\n+      return builder.build();\n+    }\n+\n+    io.envoyproxy.envoy.api.v2.DiscoveryRequest toEnvoyProtoV2() {\n+      io.envoyproxy.envoy.api.v2.DiscoveryRequest.Builder builder =\n+          io.envoyproxy.envoy.api.v2.DiscoveryRequest.newBuilder()\n+              .setVersionInfo(versionInfo)\n+              .setNode(node.toEnvoyProtoNodeV2())\n+              .addAllResourceNames(resourceNames)\n+              .setTypeUrl(resourceType.typeUrlV2())\n+              .setResponseNonce(responseNonce);\n+      if (errorDetail != null) {\n+        builder.setErrorDetail(errorDetail);\n+      }\n+      return builder.build();\n+    }\n+  }\n+\n+  private static final class DiscoveryResponseData {\n+    private final ResourceType resourceType;\n+    private final List<Any> resources;\n+    private final String versionInfo;\n+    private final String nonce;\n+\n+    DiscoveryResponseData(\n+        ResourceType resourceType, List<Any> resources, String versionInfo, String nonce) {\n+      this.resourceType = resourceType;\n+      this.resources = resources;\n+      this.versionInfo = versionInfo;\n+      this.nonce = nonce;\n+    }\n+\n+    ResourceType getResourceType() {\n+      return resourceType;\n+    }\n+\n+    List<Any> getResourcesList() {\n+      return resources;\n+    }\n+\n+    String getVersionInfo() {\n+      return versionInfo;\n+    }\n+\n+    String getNonce() {\n+      return nonce;\n+    }\n+\n+    static DiscoveryResponseData fromEnvoyProto(DiscoveryResponse proto) {\n+      return new DiscoveryResponseData(\n+          ResourceType.fromTypeUrl(proto.getTypeUrl()), proto.getResourcesList(),\n+          proto.getVersionInfo(), proto.getNonce());\n+    }\n+\n+    static DiscoveryResponseData fromEnvoyProtoV2(\n+        io.envoyproxy.envoy.api.v2.DiscoveryResponse proto) {\n+      return new DiscoveryResponseData(\n+          ResourceType.fromTypeUrl(proto.getTypeUrl()), proto.getResourcesList(),\n+          proto.getVersionInfo(), proto.getNonce());\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendDiscoveryRequest(DiscoveryRequestData request);\n+\n+    abstract void sendError(Exception error);\n+\n+    // Must run in syncContext.\n+    final void handleResponse(DiscoveryResponseData response) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      String respNonce = response.getNonce();\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      ResourceType resourceType = response.getResourceType();\n+      switch (resourceType) {\n+        case LDS:\n+          ldsRespNonce = respNonce;\n+          handleLdsResponse(response);\n+          break;\n+        case RDS:\n+          rdsRespNonce = respNonce;\n+          handleRdsResponse(response);\n+          break;\n+        case CDS:\n+          cdsRespNonce = respNonce;\n+          handleCdsResponse(response);\n+          break;\n+        case EDS:\n+          edsRespNonce = respNonce;\n+          handleEdsResponse(response);\n+          break;\n+        case UNKNOWN:\n+          logger.log(\n+              XdsLogLevel.WARNING,\n+              \"Received an unknown type of DiscoveryResponse\\n{0}\",\n+              respNonce);\n+          break;\n+        default:\n+          throw new AssertionError(\"Missing case in enum switch: \" + resourceType);\n+      }\n+    }\n+\n+    // Must run in syncContext.\n+    final void handleRpcError(Throwable t) {\n+      handleStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    // Must run in syncContext.\n+    final void handleRpcCompleted() {\n+      handleStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;", "originalCommit": "1a72fdff3a493e90963f4b5485c8f373b34b6c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1Njk0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499056941", "bodyText": "Oops, forgot Sanjay's code. Added back now.", "author": "voidzcy", "createdAt": "2020-10-02T21:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NTg2Ng=="}], "type": "inlineReview"}, {"oid": "ec00b60c50c3f6d3a7e4fc1d2fd9e3ba49cdf19b", "url": "https://github.com/grpc/grpc-java/commit/ec00b60c50c3f6d3a7e4fc1d2fd9e3ba49cdf19b", "message": "Implement equality for RdsUpdate.", "committedDate": "2020-10-02T21:14:24Z", "type": "commit"}, {"oid": "262344211e49a1b550e349a20b9264d736023e03", "url": "https://github.com/grpc/grpc-java/commit/262344211e49a1b550e349a20b9264d736023e03", "message": "Add back handlings for listener watcher in server side usage.", "committedDate": "2020-10-02T21:20:47Z", "type": "commit"}, {"oid": "83af19666f2fed613d47f755e5a871685bcd6037", "url": "https://github.com/grpc/grpc-java/commit/83af19666f2fed613d47f755e5a871685bcd6037", "message": "Fix style issue.", "committedDate": "2020-10-02T21:21:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTU0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499081541", "bodyText": "This adsEnded flag is weak because if retry happens there could be multiple streams created, as long as one of them is cancelled, this flag is true. (XdsClientImplTest1 has adsEnded.set(false))", "author": "dapengzhang0", "createdAt": "2020-10-02T22:56:27Z", "path": "xds/src/test/java/io/grpc/xds/XdsClientImplTest2.java", "diffHunk": "@@ -0,0 +1,1857 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientTestHelper.buildCluster;\n+import static io.grpc.xds.XdsClientTestHelper.buildClusterLoadAssignment;\n+import static io.grpc.xds.XdsClientTestHelper.buildDiscoveryRequest;\n+import static io.grpc.xds.XdsClientTestHelper.buildDiscoveryResponse;\n+import static io.grpc.xds.XdsClientTestHelper.buildDropOverload;\n+import static io.grpc.xds.XdsClientTestHelper.buildLbEndpoint;\n+import static io.grpc.xds.XdsClientTestHelper.buildListener;\n+import static io.grpc.xds.XdsClientTestHelper.buildLocalityLbEndpoints;\n+import static io.grpc.xds.XdsClientTestHelper.buildRouteConfiguration;\n+import static io.grpc.xds.XdsClientTestHelper.buildSecureCluster;\n+import static io.grpc.xds.XdsClientTestHelper.buildUpstreamTlsContext;\n+import static io.grpc.xds.XdsClientTestHelper.buildVirtualHost;\n+import static io.grpc.xds.XdsClientTestHelper.buildVirtualHosts;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.core.v3.AggregatedConfigSource;\n+import io.envoyproxy.envoy.config.core.v3.ConfigSource;\n+import io.envoyproxy.envoy.config.core.v3.HealthStatus;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Policy;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterStats;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc.AggregatedDiscoveryServiceImplBase;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.envoyproxy.envoy.service.load_stats.v3.LoadReportingServiceGrpc.LoadReportingServiceImplBase;\n+import io.envoyproxy.envoy.service.load_stats.v3.LoadStatsRequest;\n+import io.envoyproxy.envoy.service.load_stats.v3.LoadStatsResponse;\n+import io.grpc.Context;\n+import io.grpc.Context.CancellationListener;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Status;\n+import io.grpc.Status.Code;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.FakeClock;\n+import io.grpc.internal.FakeClock.ScheduledTask;\n+import io.grpc.internal.FakeClock.TaskFilter;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsClient.LdsResourceWatcher;\n+import io.grpc.xds.XdsClient.LdsUpdate;\n+import io.grpc.xds.XdsClient.RdsResourceWatcher;\n+import io.grpc.xds.XdsClient.RdsUpdate;\n+import io.grpc.xds.XdsClient.ResourceWatcher;\n+import io.grpc.xds.XdsClient.XdsChannel;\n+import io.grpc.xds.XdsClientImpl2.MessagePrinter;\n+import io.grpc.xds.XdsClientImpl2.ResourceType;\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Captor;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Tests for {@link XdsClientImpl2}.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsClientImplTest2 {\n+  private static final String TARGET_NAME = \"hello.googleapis.com\";\n+  private static final String LDS_RESOURCE = \"listener.googleapis.com\";\n+  private static final String RDS_RESOURCE = \"route-configuration.googleapis.com\";\n+  private static final String CDS_RESOURCE = \"cluster.googleapis.com\";\n+  private static final String EDS_RESOURCE = \"cluster-load-assignment.googleapis.com\";\n+  private static final Node NODE = Node.newBuilder().build();\n+  private static final FakeClock.TaskFilter RPC_RETRY_TASK_FILTER =\n+      new FakeClock.TaskFilter() {\n+        @Override\n+        public boolean shouldAccept(Runnable command) {\n+          return command.toString().contains(XdsClientImpl2.RpcRetryTask.class.getSimpleName());\n+        }\n+      };\n+\n+  private static final FakeClock.TaskFilter LDS_RESOURCE_FETCH_TIMEOUT_TASK_FILTER =\n+      new TaskFilter() {\n+        @Override\n+        public boolean shouldAccept(Runnable command) {\n+          return command.toString().contains(ResourceType.LDS.toString());\n+        }\n+      };\n+\n+  private static final FakeClock.TaskFilter RDS_RESOURCE_FETCH_TIMEOUT_TASK_FILTER =\n+      new TaskFilter() {\n+        @Override\n+        public boolean shouldAccept(Runnable command) {\n+          return command.toString().contains(ResourceType.RDS.toString());\n+        }\n+      };\n+\n+  private static final FakeClock.TaskFilter CDS_RESOURCE_FETCH_TIMEOUT_TASK_FILTER =\n+      new TaskFilter() {\n+        @Override\n+        public boolean shouldAccept(Runnable command) {\n+          return command.toString().contains(ResourceType.CDS.toString());\n+        }\n+      };\n+\n+  private static final FakeClock.TaskFilter EDS_RESOURCE_FETCH_TIMEOUT_TASK_FILTER =\n+      new FakeClock.TaskFilter() {\n+        @Override\n+        public boolean shouldAccept(Runnable command) {\n+          return command.toString().contains(ResourceType.EDS.toString());\n+        }\n+      };\n+\n+  @Rule\n+  public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n+        }\n+      });\n+  private final FakeClock fakeClock = new FakeClock();\n+  private final Queue<RpcCall<DiscoveryRequest, DiscoveryResponse>> resourceDiscoveryCalls =\n+      new ArrayDeque<>();\n+  private final Queue<RpcCall<LoadStatsRequest, LoadStatsResponse>> loadReportCalls =\n+      new ArrayDeque<>();\n+  private final AtomicBoolean adsEnded = new AtomicBoolean(true);\n+  private final AtomicBoolean lrsEnded = new AtomicBoolean(true);\n+\n+  @Captor\n+  private ArgumentCaptor<LdsUpdate> ldsUpdateCaptor;\n+  @Captor\n+  private ArgumentCaptor<RdsUpdate> rdsUpdateCaptor;\n+  @Captor\n+  private ArgumentCaptor<CdsUpdate> cdsUpdateCaptor;\n+  @Captor\n+  private ArgumentCaptor<EdsUpdate> edsUpdateCaptor;\n+  @Captor\n+  private ArgumentCaptor<Status> errorCaptor;\n+  @Mock\n+  private BackoffPolicy.Provider backoffPolicyProvider;\n+  @Mock\n+  private BackoffPolicy backoffPolicy1;\n+  @Mock\n+  private BackoffPolicy backoffPolicy2;\n+  @Mock\n+  private LdsResourceWatcher ldsResourceWatcher;\n+  @Mock\n+  private RdsResourceWatcher rdsResourceWatcher;\n+  @Mock\n+  private CdsResourceWatcher cdsResourceWatcher;\n+  @Mock\n+  private EdsResourceWatcher edsResourceWatcher;\n+\n+  private ManagedChannel channel;\n+  private XdsClientImpl2 xdsClient;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    when(backoffPolicyProvider.get()).thenReturn(backoffPolicy1, backoffPolicy2);\n+    when(backoffPolicy1.nextBackoffNanos()).thenReturn(10L, 100L);\n+    when(backoffPolicy2.nextBackoffNanos()).thenReturn(20L, 200L);\n+\n+    final String serverName = InProcessServerBuilder.generateName();\n+    AggregatedDiscoveryServiceImplBase adsServiceImpl = new AggregatedDiscoveryServiceImplBase() {\n+      @Override\n+      public StreamObserver<DiscoveryRequest> streamAggregatedResources(\n+          final StreamObserver<DiscoveryResponse> responseObserver) {\n+        @SuppressWarnings(\"unchecked\")\n+        StreamObserver<DiscoveryRequest> requestObserver = mock(StreamObserver.class);\n+        RpcCall<DiscoveryRequest, DiscoveryResponse> call =\n+            new RpcCall<>(requestObserver, responseObserver);\n+        resourceDiscoveryCalls.offer(call);\n+        Context.current().addListener(\n+            new CancellationListener() {\n+              @Override\n+              public void cancelled(Context context) {\n+                adsEnded.set(true);", "originalCommit": "83af19666f2fed613d47f755e5a871685bcd6037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4NjQxMQ==", "url": "https://github.com/grpc/grpc-java/pull/7470#discussion_r499086411", "bodyText": "You are right. Added.", "author": "voidzcy", "createdAt": "2020-10-02T23:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTU0MQ=="}], "type": "inlineReview"}, {"oid": "470f40df1b21847d7b5f0d55c1db5b5f0cae23fd", "url": "https://github.com/grpc/grpc-java/commit/470f40df1b21847d7b5f0d55c1db5b5f0cae23fd", "message": "Ensure the previous RPC ended before running the next.", "committedDate": "2020-10-02T23:20:28Z", "type": "commit"}]}