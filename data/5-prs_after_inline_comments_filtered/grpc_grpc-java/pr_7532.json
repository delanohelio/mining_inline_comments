{"pr_number": 7532, "pr_title": "netty: create adaptive cumulator", "pr_createdAt": "2020-10-19T15:17:23Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7532", "timeline": [{"oid": "0be7b25c5d5016a6071f66b9e6e8d596860e854a", "url": "https://github.com/grpc/grpc-java/commit/0be7b25c5d5016a6071f66b9e6e8d596860e854a", "message": "netty: create adaptive cumulator", "committedDate": "2020-10-19T16:15:48Z", "type": "forcePushed"}, {"oid": "218f7720484814c0962879b141076785664c953b", "url": "https://github.com/grpc/grpc-java/commit/218f7720484814c0962879b141076785664c953b", "message": "netty: create adaptive cumulator", "committedDate": "2020-10-19T16:30:19Z", "type": "commit"}, {"oid": "218f7720484814c0962879b141076785664c953b", "url": "https://github.com/grpc/grpc-java/commit/218f7720484814c0962879b141076785664c953b", "message": "netty: create adaptive cumulator", "committedDate": "2020-10-19T16:30:19Z", "type": "forcePushed"}, {"oid": "169c94d49d72e4f485ff28b671e33199b5a57e0a", "url": "https://github.com/grpc/grpc-java/commit/169c94d49d72e4f485ff28b671e33199b5a57e0a", "message": "minor spelling fixes", "committedDate": "2020-10-19T17:52:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNTU3MA==", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r516305570", "bodyText": "Why duplicate, and then unwrap?", "author": "ejona86", "createdAt": "2020-11-02T22:49:26Z", "path": "netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.netty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.CompositeByteBuf;\n+\n+class NettyAdaptiveCumulator implements io.netty.handler.codec.ByteToMessageDecoder.Cumulator {\n+  private final int composeMinSize;\n+\n+  NettyAdaptiveCumulator(int composeMinSize) {\n+    Preconditions.checkArgument(composeMinSize >= 0, \"composeMinSize must be non-negative\");\n+    this.composeMinSize = composeMinSize;\n+  }\n+\n+  /**\n+   * \"Adaptive\" cumulator: cumulate {@link ByteBuf}s by dynamically switching between merge and\n+   * compose strategies.\n+   *\n+   * <p>This cumulator applies a heuristic to make a decision whether to track a reference to the\n+   * buffer with bytes received from the network stack in an array (\"zero-copy\"), or to merge into\n+   * the last component (the tail) by performing a memory copy.\n+   *\n+   * <p>It is necessary as a protection from a potential attack on the {@link\n+   * io.netty.handler.codec.ByteToMessageDecoder#COMPOSITE_CUMULATOR}. Consider a pathological case\n+   * when an attacker sends TCP packages containing a single byte of data, and forcing the cumulator\n+   * to track each one in a separate buffer. The cost is memory overhead for each buffer, and extra\n+   * compute to read the cumulation.\n+   *\n+   * <p>Implemented heuristic establishes a minimal threshold for the total size of the tail and\n+   * incoming buffer, below which they are merged. The sum of the tail and the incoming buffer is\n+   * used to avoid a case where attacker alternates the size of data packets to trick the cumulator\n+   * into always selecting compose strategy.\n+   *\n+   * <p>Merging strategy attempts to minimize unnecessary memory writes. When possible, it expands\n+   * the tail capacity and only copies the incoming buffer into available memory. Otherwise, when\n+   * both tail and the buffer must be copied, the tail is reallocated (or fully replaced) with a new\n+   * buffer of exponentially increasing capacity (bounded to {@link #composeMinSize}) to ensure\n+   * runtime {@code O(n^2)} is amortized to {@code O(n)}.\n+   */\n+  @Override\n+  @SuppressWarnings(\"ReferenceEquality\")\n+  public final ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {\n+    if (!cumulation.isReadable()) {\n+      cumulation.release();\n+      return in;\n+    }\n+    CompositeByteBuf composite = null;\n+    try {\n+      if (cumulation instanceof CompositeByteBuf && cumulation.refCnt() == 1) {\n+        composite = (CompositeByteBuf) cumulation;\n+        // Writer index must equal capacity if we are going to \"write\"\n+        // new components to the end\n+        if (composite.writerIndex() != composite.capacity()) {\n+          composite.capacity(composite.writerIndex());\n+        }\n+      } else {\n+        composite = alloc.compositeBuffer(Integer.MAX_VALUE)\n+            .addFlattenedComponents(true, cumulation);\n+      }\n+      addInput(alloc, composite, in);\n+      in = null;\n+      return composite;\n+    } finally {\n+      if (in != null) {\n+        // We must release if the ownership was not transferred as otherwise it may produce a leak\n+        in.release();\n+        // Also release any new buffer allocated if we're not returning it\n+        if (composite != null && composite != cumulation) {\n+          composite.release();\n+        }\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n+    if (shouldCompose(composite, in, composeMinSize)) {\n+      composite.addFlattenedComponents(true, in);\n+    } else {\n+      // The total size of the new data and the last component are below the threshold. Merge them.\n+      mergeWithCompositeTail(alloc, composite, in);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static boolean shouldCompose(CompositeByteBuf composite, ByteBuf in, int composeMinSize) {\n+    int componentCount = composite.numComponents();\n+    if (composite.numComponents() == 0) {\n+      return true;\n+    }\n+    int tailSize = composite.capacity() - composite.toByteIndex(componentCount - 1);\n+    return tailSize + in.readableBytes() >= composeMinSize;\n+  }\n+\n+  /**\n+   * Append the given {@link ByteBuf} {@code in} to {@link CompositeByteBuf} {@code composite} by\n+   * expanding or replacing the tail component of the {@link CompositeByteBuf}.\n+   *\n+   * <p>The goal is to prevent {@code O(n^2)} runtime in a pathological case, that forces copying\n+   * the tail component into a new buffer, for each incoming single-byte buffer. We append the new\n+   * bytes to the tail, when a write (or a fast write) is possible.\n+   *\n+   * <p>Otherwise, the tail is replaced with a new buffer, with the capacity increased enough to\n+   * achieve runtime amortization.\n+   *\n+   * <p>We assume that implementations of {@link ByteBufAllocator#calculateNewCapacity(int, int)},\n+   * are similar to {@link io.netty.buffer.AbstractByteBufAllocator#calculateNewCapacity(int, int)},\n+   * which doubles buffer capacity by normalizing it to the closest power of two. This assumption\n+   * is verified in unit tests for this method.\n+   */\n+  @VisibleForTesting\n+  static void mergeWithCompositeTail(ByteBufAllocator alloc, CompositeByteBuf composite,\n+      ByteBuf in) {\n+\n+    int newBytes = in.readableBytes();\n+    int tailIndex = composite.numComponents() - 1;\n+    int tailStart = composite.toByteIndex(tailIndex);\n+    int tailBytes = composite.capacity() - tailStart;\n+    int totalBytes = newBytes + tailBytes;\n+\n+    ByteBuf tail = composite.component(tailIndex);\n+    ByteBuf merged = null;\n+\n+    try {\n+      if (tail.refCnt() == 1 && !tail.isReadOnly() && totalBytes <= tail.maxCapacity()) {\n+        // Ideal case: the tail isn't shared, and can be expanded to the required capacity.\n+        // Take ownership of the tail.\n+        merged = tail.retainedDuplicate();", "originalCommit": "169c94d49d72e4f485ff28b671e33199b5a57e0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fda5c7731052b8f22e8e5b8370a44184d6f22cc3", "url": "https://github.com/grpc/grpc-java/commit/fda5c7731052b8f22e8e5b8370a44184d6f22cc3", "message": "pooled buffers cleanup safe release", "committedDate": "2020-11-10T03:31:28Z", "type": "commit"}, {"oid": "265b0f6976857e5648477307a13ab26e02dbbecb", "url": "https://github.com/grpc/grpc-java/commit/265b0f6976857e5648477307a13ab26e02dbbecb", "message": "document unwrap, take care of leak-aware buffers", "committedDate": "2020-11-10T16:32:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2ODQ1Mw==", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r520768453", "bodyText": "No, please no. This is asking to be misused, and I don't think it is appropriate even in the test. I do think we should clean up the buffers, but if the reference counting is wrong the test should fail.", "author": "ejona86", "createdAt": "2020-11-10T18:11:05Z", "path": "netty/src/test/java/io/grpc/netty/NettyTestUtil.java", "diffHunk": "@@ -56,6 +57,13 @@ static ByteBuf compressionFrame(byte[] data) {\n     return buf;\n   }\n \n+  // Buffer safe release: release until it's free.", "originalCommit": "265b0f6976857e5648477307a13ab26e02dbbecb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0bfa0c317e388ca8d4e60c82270064e32dd58548", "url": "https://github.com/grpc/grpc-java/commit/0bfa0c317e388ca8d4e60c82270064e32dd58548", "message": "Remove unwrap, handle buffer release in tests", "committedDate": "2020-11-17T05:41:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjAyMg==", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r525572022", "bodyText": "nit: normally this sort of thing we'd just do inline at the declaration and not in the @Before. This is fine though.", "author": "ejona86", "createdAt": "2020-11-17T22:38:17Z", "path": "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java", "diffHunk": "@@ -84,6 +86,14 @@ void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n           composite.addFlattenedComponents(true, in);\n         }\n       };\n+\n+      // Throws an error on adding incoming buffer.\n+      throwingCumulator = new NettyAdaptiveCumulator(0) {", "originalCommit": "0bfa0c317e388ca8d4e60c82270064e32dd58548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4NDE3Mg==", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r525584172", "bodyText": "I'll get it fixed separately to not delay this.", "author": "sergiitk", "createdAt": "2020-11-17T23:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjAyMg=="}], "type": "inlineReview"}]}