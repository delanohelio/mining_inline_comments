{"pr_number": 7264, "pr_title": "core: Add DelayedClientCall", "pr_createdAt": "2020-07-29T18:49:34Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7264", "timeline": [{"oid": "165273402db26dc9794bf1a26f16809d5d132e00", "url": "https://github.com/grpc/grpc-java/commit/165273402db26dc9794bf1a26f16809d5d132e00", "message": "core: Add DelayedClientCall", "committedDate": "2020-07-29T21:01:21Z", "type": "commit"}, {"oid": "165273402db26dc9794bf1a26f16809d5d132e00", "url": "https://github.com/grpc/grpc-java/commit/165273402db26dc9794bf1a26f16809d5d132e00", "message": "core: Add DelayedClientCall", "committedDate": "2020-07-29T21:01:21Z", "type": "forcePushed"}, {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3", "url": "https://github.com/grpc/grpc-java/commit/15696ca67c5070a1d138e46bcc7553d50faf69e3", "message": "correct javadoc for initialDeadlineMonitor", "committedDate": "2020-07-30T18:49:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTExNA==", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465289114", "bodyText": "This is quite a bit directly in the constructor. Could this all be moved into a function so that it'd become:\nthis.initialDeadlineMonitor = scheduleDeadlineIfNeeded(scheduler, deadline, context);", "author": "ejona86", "createdAt": "2020-08-04T19:44:51Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();", "originalCommit": "15696ca67c5070a1d138e46bcc7553d50faf69e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTE0Ng==", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465365146", "bodyText": "Done. Not passing context as an argument because scheduleDeadlineIfNeeded can not be static method anyway.", "author": "dapengzhang0", "createdAt": "2020-08-04T22:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg==", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465305192", "bodyText": "It's unclear to me how much this does. What would happen if we didn't have this check?\nI feel like we either don't need this check, or we need to pass a boolean to cancel(Status) saying not to cancel if realCall is set, in a non-racy way.", "author": "ejona86", "createdAt": "2020-08-04T20:16:42Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();\n+    if (deadline == null && contextDeadline == null) {\n+      this.initialDeadlineMonitor = null;\n+      return;\n+    }\n+    long remainingNanos = Long.MAX_VALUE;\n+    if (deadline != null) {\n+      remainingNanos = Math.min(remainingNanos, deadline.timeRemaining(NANOSECONDS));\n+    }\n+    if (contextDeadline != null && contextDeadline.timeRemaining(NANOSECONDS) < remainingNanos) {\n+      remainingNanos = contextDeadline.timeRemaining(NANOSECONDS);\n+      if (logger.isLoggable(Level.FINE)) {\n+        StringBuilder builder =\n+            new StringBuilder(\n+                String.format(\n+                    \"Call timeout set to '%d' ns, due to context deadline.\", remainingNanos));\n+        if (deadline == null) {\n+          builder.append(\" Explicit call timeout was not set.\");\n+        } else {\n+          long callTimeout = deadline.timeRemaining(TimeUnit.NANOSECONDS);\n+          builder.append(String.format(\" Explicit call timeout was '%d' ns.\", callTimeout));\n+        }\n+        logger.fine(builder.toString());\n+      }\n+    }\n+    long seconds = Math.abs(remainingNanos) / TimeUnit.SECONDS.toNanos(1);\n+    long nanos = Math.abs(remainingNanos) % TimeUnit.SECONDS.toNanos(1);\n+    final StringBuilder buf = new StringBuilder();\n+    if (remainingNanos < 0) {\n+      buf.append(\"ClientCall started after deadline exceeded. Deadline exceeded after -\");\n+    } else {\n+      buf.append(\"Deadline exceeded after \");\n+    }\n+    buf.append(seconds);\n+    buf.append(String.format(\".%09d\", nanos));\n+    buf.append(\"s. \");\n+    /** Cancels the call if deadline exceeded prior to the real call being set. */\n+    class DeadlineExceededRunnable implements Runnable {\n+      @Override\n+      public void run() {\n+        synchronized (DelayedClientCall.this) {\n+          if (realCall != null) {", "originalCommit": "15696ca67c5070a1d138e46bcc7553d50faf69e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMTcxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465311719", "bodyText": "The interop test (AbstractInteropTest.deadlineInPast()) was very flaky without it. So I guessed it was due to racy cancellation. Adding it just fixed the flakiness. Let me check if this is the right fix...", "author": "dapengzhang0", "createdAt": "2020-08-04T20:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MTI1NQ==", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465351255", "bodyText": "Discussed \"offline.\" This is legitimate because ClientCall.cancel() is non-thread-safe and will cause exceptions if you try to send after it. That is different from in the stream where cancel() is thread-safe and wouldn't trigger any checkState()s. But as-is it isn't atomic; we need to move the realCall != null check into the private cancel() function to make it atomic.", "author": "ejona86", "createdAt": "2020-08-04T21:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTI2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465365265", "bodyText": "Done.", "author": "dapengzhang0", "createdAt": "2020-08-04T22:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg=="}], "type": "inlineReview"}, {"oid": "c14998f2eb38910d329bb7afa38588b6d8b09fbc", "url": "https://github.com/grpc/grpc-java/commit/c14998f2eb38910d329bb7afa38588b6d8b09fbc", "message": "fix racy cancel", "committedDate": "2020-08-04T22:18:29Z", "type": "commit"}, {"oid": "cd496605e046504096e177a0a496b3907db003a9", "url": "https://github.com/grpc/grpc-java/commit/cd496605e046504096e177a0a496b3907db003a9", "message": "refactor constructor", "committedDate": "2020-08-04T22:21:52Z", "type": "commit"}, {"oid": "22070f8c0e8f6f1bf48996f8adec69aabe961594", "url": "https://github.com/grpc/grpc-java/commit/22070f8c0e8f6f1bf48996f8adec69aabe961594", "message": "fix typo", "committedDate": "2020-08-04T22:32:15Z", "type": "commit"}]}