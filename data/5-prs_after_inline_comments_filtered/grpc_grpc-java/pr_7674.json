{"pr_number": 7674, "pr_title": "Move multiple-port ServerImpl to NettyServer", "pr_createdAt": "2020-11-26T20:51:10Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7674", "timeline": [{"oid": "744ffdeb7b48bf34db56e974fdf6c69a6bb2f1a1", "url": "https://github.com/grpc/grpc-java/commit/744ffdeb7b48bf34db56e974fdf6c69a6bb2f1a1", "message": "Move multiple port transport servers to NettyServer", "committedDate": "2020-11-26T20:26:24Z", "type": "commit"}, {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "url": "https://github.com/grpc/grpc-java/commit/bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "message": "execute bind in bossExecutor", "committedDate": "2020-11-28T00:30:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4OTk4Ng==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532789986", "bodyText": "I would prefer either passing a single InternalServer instead of a List in the constructor or not adding checkArgument(transportServers.size() == 1) here.", "author": "dapengzhang0", "createdAt": "2020-11-30T17:56:31Z", "path": "core/src/main/java/io/grpc/internal/ServerImpl.java", "diffHunk": "@@ -143,8 +142,9 @@\n     this.fallbackRegistry =\n         Preconditions.checkNotNull(builder.fallbackRegistry, \"fallbackRegistry\");\n     Preconditions.checkNotNull(transportServers, \"transportServers\");\n-    Preconditions.checkArgument(!transportServers.isEmpty(), \"no servers provided\");\n-    this.transportServers = new ArrayList<>(transportServers);\n+    // Supporting multiple listening socket address function is moved to a single transport server.\n+    Preconditions.checkArgument(transportServers.size() == 1, \"One and only one server\");", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTI0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532795242", "bodyText": "Maybe if(serverShutdownCallbackInvoked)?", "author": "dapengzhang0", "createdAt": "2020-11-30T18:04:52Z", "path": "core/src/main/java/io/grpc/internal/ServerImpl.java", "diffHunk": "@@ -388,8 +378,7 @@ public void serverShutdown() {\n       ArrayList<ServerTransport> copiedTransports;\n       Status shutdownNowStatusCopy;\n       synchronized (lock) {\n-        activeTransportServers--;\n-        if (activeTransportServers != 0) {\n+        if (transportServersTerminated) {", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTg0OA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532801848", "bodyText": "Why is this not consistent with getListenSocketAddress() for the case \"server is not listening/bound yet\"", "author": "dapengzhang0", "createdAt": "2020-11-30T18:15:50Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +157,49 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n+    this.bossExecutor = bossGroup.next();\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    return listenSocketAddresses;", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMzEzMw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532803133", "bodyText": "What's the reason for this change?", "author": "dapengzhang0", "createdAt": "2020-11-30T18:18:03Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +157,49 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n+    this.bossExecutor = bossGroup.next();\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    return listenSocketStatsList.isEmpty() ? null : listenSocketStatsList.get(0);\n+  }\n+\n+  @Override\n+  public List<InternalInstrumented<SocketStats>> getListenSocketStatsList() {\n+    return listenSocketStatsList;\n   }\n \n   @Override\n   public void start(ServerListener serverListener) throws IOException {\n     listener = checkNotNull(serverListener, \"serverListener\");\n \n-    ServerBootstrap b = new ServerBootstrap();\n+    final ServerBootstrap b = new ServerBootstrap();\n     b.option(ALLOCATOR, Utils.getByteBufAllocator(forceHeapBuffer));\n     b.childOption(ALLOCATOR, Utils.getByteBufAllocator(forceHeapBuffer));\n-    b.group(bossGroup, workerGroup);\n+    b.group(bossExecutor, workerGroup);", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNzQwOQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532917409", "bodyText": "@ejona86  suggested before(#6641 (comment)), and I thought it is a brilliant idea in terms of thread safety:\n\nIf NettyServer is handling the multiple ports, then we can do all the binds as one \"atomic\" operation on the event loop. This depends on a behavior of Channel that it executes the operation immediately if already on the event loop.", "author": "YifeiZhuang", "createdAt": "2020-11-30T21:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODM5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532808396", "bodyText": "Why not just throw bindCallResult.cause()?", "author": "dapengzhang0", "createdAt": "2020-11-30T18:26:33Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +288,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw new IllegalStateException(bindCallResult.cause());", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODY5Mg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532808692", "bodyText": "Why not just ex rather than ex.getCause()?", "author": "dapengzhang0", "createdAt": "2020-11-30T18:27:04Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +288,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw new IllegalStateException(bindCallResult.cause());\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Exception ex) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), ex.getCause());", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDk0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532814942", "bodyText": "terminated is slightly different from shutdown. shutdown means no more new stream is allowed but the existing streams can still be active until they finish. terminated is once shutdown and all streams are closed.  Here the comment // Server already shutdown seems to have been not accurate, whereas the old comment here L283 // Already closed seems to be correct.", "author": "dapengzhang0", "createdAt": "2020-11-30T18:37:26Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -226,7 +256,7 @@ public void initChannel(Channel ch) {\n         ServerTransportListener transportListener;\n         // This is to order callbacks on the listener, not to guard access to channel.\n         synchronized (NettyServer.this) {\n-          if (channel != null && !channel.isOpen()) {\n+          if (terminated) {\n             // Server already shutdown.", "originalCommit": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e8042444c97ec89294d442273036858952b476c3", "url": "https://github.com/grpc/grpc-java/commit/e8042444c97ec89294d442273036858952b476c3", "message": "Revert \"netty: create adaptive cumulator\" (#7669)\n\nThis reverts commit 729175c783b3d565d6aee21b456bf494f3d6c530.", "committedDate": "2020-12-01T18:08:36Z", "type": "commit"}, {"oid": "ac92d19e6e895fa1a0dcd8054292d4f871cfd205", "url": "https://github.com/grpc/grpc-java/commit/ac92d19e6e895fa1a0dcd8054292d4f871cfd205", "message": "xds: fix the new server API for ServerXdsClient (#7666)", "committedDate": "2020-12-01T18:08:36Z", "type": "commit"}, {"oid": "67bef1457e9e7d629b42fdf1fecf34d443f1cc9b", "url": "https://github.com/grpc/grpc-java/commit/67bef1457e9e7d629b42fdf1fecf34d443f1cc9b", "message": "api,core: interceptor-based config selector (#7610)\n\n Interceptor-based config selector will be needed for fault injection.\r\n\r\nAdd `interceptor` field to `InternalConfigSelector.Result`. Keep `callOptions` and `committedCallback` fields for the moment, because it needs a refactoring to migrate the existing xds config selector implementation to the new API.", "committedDate": "2020-12-01T18:08:36Z", "type": "commit"}, {"oid": "e1afcc4889d2e26ae5bef3eec81f39a51349e55f", "url": "https://github.com/grpc/grpc-java/commit/e1afcc4889d2e26ae5bef3eec81f39a51349e55f", "message": "xds: fix text in the readme and the comment about the --secure flag (#7676)", "committedDate": "2020-12-01T18:08:36Z", "type": "commit"}, {"oid": "be578f49ef6fa5b78256a0ce127da9a2572519cd", "url": "https://github.com/grpc/grpc-java/commit/be578f49ef6fa5b78256a0ce127da9a2572519cd", "message": "interop-testing: update proto generated service files (#7682)", "committedDate": "2020-12-01T18:08:36Z", "type": "commit"}, {"oid": "e190675a9a656a5bf3dd83691aa7a45468168fec", "url": "https://github.com/grpc/grpc-java/commit/e190675a9a656a5bf3dd83691aa7a45468168fec", "message": "Fix nettyServer get listen addresses when not bound, bind exception cause, and serverImpl shutdown", "committedDate": "2020-12-01T18:08:36Z", "type": "commit"}, {"oid": "2a9db907c2550f966f6f57b6aa325dffb5bee638", "url": "https://github.com/grpc/grpc-java/commit/2a9db907c2550f966f6f57b6aa325dffb5bee638", "message": "Revert \"interop-testing: update proto generated service files (#7682)\"\n\nThis reverts commit be578f49ef6fa5b78256a0ce127da9a2572519cd.", "committedDate": "2020-12-01T18:29:51Z", "type": "commit"}, {"oid": "6887f49d730aa2315edee8b3b075d530f45817cb", "url": "https://github.com/grpc/grpc-java/commit/6887f49d730aa2315edee8b3b075d530f45817cb", "message": "Revert \"xds: fix text in the readme and the comment about the --secure flag (#7676)\"\n\nThis reverts commit e1afcc4889d2e26ae5bef3eec81f39a51349e55f.", "committedDate": "2020-12-01T18:29:56Z", "type": "commit"}, {"oid": "03a487c59e731d201c505fab4e99f906e882a08f", "url": "https://github.com/grpc/grpc-java/commit/03a487c59e731d201c505fab4e99f906e882a08f", "message": "Revert \"api,core: interceptor-based config selector (#7610)\"\n\nThis reverts commit 67bef1457e9e7d629b42fdf1fecf34d443f1cc9b.", "committedDate": "2020-12-01T18:30:34Z", "type": "commit"}, {"oid": "8dbceb46a8de0a76663dc67b0ff75aabf8bcf558", "url": "https://github.com/grpc/grpc-java/commit/8dbceb46a8de0a76663dc67b0ff75aabf8bcf558", "message": "Revert \"xds: fix the new server API for ServerXdsClient (#7666)\"\n\nThis reverts commit ac92d19e6e895fa1a0dcd8054292d4f871cfd205.", "committedDate": "2020-12-01T18:30:36Z", "type": "commit"}, {"oid": "f9b2985ffe9a55295bc02e97f77f6d6c7378ffec", "url": "https://github.com/grpc/grpc-java/commit/f9b2985ffe9a55295bc02e97f77f6d6c7378ffec", "message": "Revert \"Revert \"netty: create adaptive cumulator\" (#7669)\"\n\nThis reverts commit e8042444c97ec89294d442273036858952b476c3.", "committedDate": "2020-12-01T18:30:38Z", "type": "commit"}, {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "url": "https://github.com/grpc/grpc-java/commit/364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java", "committedDate": "2020-12-01T18:37:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MTM5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540481397", "bodyText": "I think we shouldn't change the return type here, compared to the base class. Use List<? extends SocketAddress>. Ditto above.\nUsing the different type here doesn't help anybody, and I don't think we should get into a habit of doing so. We've just suffered some with our Forwarding builders because of the return type being too specific.", "author": "ejona86", "createdAt": "2020-12-10T20:40:09Z", "path": "core/src/main/java/io/grpc/inprocess/InProcessServer.java", "diffHunk": "@@ -78,15 +77,25 @@ public void start(ServerListener serverListener) throws IOException {\n   }\n \n   @Override\n-  public SocketAddress getListenSocketAddress() {\n+  public InProcessSocketAddress getListenSocketAddress() {\n     return new InProcessSocketAddress(name);\n   }\n \n+  @Override\n+  public List<InProcessSocketAddress> getListenSocketAddresses() {", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDE0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540484141", "bodyText": "These additions will also require some changes to internal code. You should check to see how many updates will need to be made and should at least coordinate with the person on sync duty.", "author": "ejona86", "createdAt": "2020-12-10T20:44:52Z", "path": "core/src/main/java/io/grpc/internal/InternalServer.java", "diffHunk": "@@ -49,13 +50,25 @@\n   void shutdown();\n \n   /**\n-   * Returns the listening socket address.  May change after {@link start(ServerListener)} is\n+   * Returns the first listening socket address.  May change after {@link start(ServerListener)} is\n    * called.\n    */\n   SocketAddress getListenSocketAddress();\n \n   /**\n-   * Returns the listen socket stats of this server. May return {@code null}.\n+   * Returns the first listen socket stats of this server. May return {@code null}.\n    */\n   @Nullable InternalInstrumented<SocketStats> getListenSocketStats();\n+\n+  /**\n+   * Returns a list of listening socket addresses.  May change after {@link start(ServerListener)}\n+   * is called.\n+   */\n+  List<? extends SocketAddress> getListenSocketAddresses();", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDYzOQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540484639", "bodyText": "Why not change the constructor to only pass in one server?", "author": "ejona86", "createdAt": "2020-12-10T20:45:46Z", "path": "core/src/main/java/io/grpc/internal/ServerImpl.java", "diffHunk": "@@ -144,7 +143,7 @@\n         Preconditions.checkNotNull(builder.fallbackRegistry, \"fallbackRegistry\");\n     Preconditions.checkNotNull(transportServers, \"transportServers\");\n     Preconditions.checkArgument(!transportServers.isEmpty(), \"no servers provided\");\n-    this.transportServers = new ArrayList<>(transportServers);\n+    this.transportServer = transportServers.get(0);", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ4Njg1Mw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r542486853", "bodyText": "Because this is a two way door: it allows starting multiple servers, each supports multiple ports. And at that time, it won't break users' code again. Do you suggest to pass in only one server?", "author": "YifeiZhuang", "createdAt": "2020-12-14T15:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MTE4MQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r542741181", "bodyText": "I don't understand. Only the first server is accessed. How would code not be broken if they passed two servers?\nFWIW, this is not directly called by users, but instead is called by the builder.", "author": "ejona86", "createdAt": "2020-12-14T20:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU2NzIyNA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r544567224", "bodyText": "Because it is called from builder and Netty is the only place right now we provide this list, and we guarantee it is a singleton list. So there won't be two servers passing in right now.\nWhat I meant was that, IIRC, we might consider supporting multiple transportServers in the ServerImpl, each of those transport servers can support multiple ports, and at that time, we would need a list of transportServers here in the constructor, instead of one object, and if we keep it as a list, we do not need refactor again at that time.\nI agree the \"singleton list guarantee\" is less intuitive and can be confusing, as a trade off of maybe forward compatibility. I do not have strong preference over one or another, and It looks like both of you prefer passing in a single object. I can refactor it then.", "author": "YifeiZhuang", "createdAt": "2020-12-16T19:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMDcyMw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540500723", "bodyText": "We should not be using GlobalEventExecutor. It looks like you should use the bossExecutor", "author": "ejona86", "createdAt": "2020-12-10T21:13:20Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -78,7 +87,7 @@\n   private EventLoopGroup bossGroup;\n   private EventLoopGroup workerGroup;\n   private ServerListener listener;\n-  private Channel channel;\n+  private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ5NTMzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r542495331", "bodyText": "This executor's job seems merely notifying the the channelGroupFuture when the operations are done. We use it to kick off the listener at close(), which won't affect the scheduling or job execution at start(). And in general yes I guess bossExecutor might be more appropriate. I got new one from .next() from the bossGroup just to decouple, and also to make test easier.", "author": "YifeiZhuang", "createdAt": "2020-12-14T15:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMDcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5MTAwMA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540591000", "bodyText": "Why is this a field? It looks like it should be a local variable in start()", "author": "ejona86", "createdAt": "2020-12-11T00:02:51Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -97,10 +106,14 @@\n   private final TransportTracer.Factory transportTracerFactory;\n   private final InternalChannelz channelz;\n   // Only modified in event loop but safe to read any time.\n-  private volatile InternalInstrumented<SocketStats> listenSocketStats;\n+  private volatile List<InternalInstrumented<SocketStats>> listenSocketStatsList =\n+      new ArrayList<>();\n+  private volatile boolean terminated;\n+  private final EventLoop bossExecutor;", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5Njc1Mg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540596752", "bodyText": "Catching Throwable is generally wrong, unless it is being re-thrown unchanged. Certainly here where we wrap it in an IOException is probably a bad idea. Errors should generally propagate.\nI think the bindCallResult.cause() should just be wrapped in an IOException immediately. The get() should be replaced with getNow() to avoid potential exceptions. At that point, there's no need for the catch.", "author": "ejona86", "createdAt": "2020-12-11T00:17:26Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +292,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw bindCallResult.cause();\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Throwable ex) {", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwMDcwNg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r542500706", "bodyText": "Thanks. It made it simpler and more readable now. Still we throw IOException for whatever failures that prevent us from getting the bindfuture, although it may not be from the bind itself. I guess it is somewhat unnecessary to throw different exceptions types at a higher granularity, at least for now.", "author": "YifeiZhuang", "createdAt": "2020-12-14T16:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5Njc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5NzU5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540597596", "bodyText": "This leaks all the other ports. When any one bind fails, we should close all the channels. Note that the channelz registration may also be impacted.\nChannelz is probably easiest handled by two listeners added immediately after bind. A listener on the bindFuture would register the new socket. A listener on bindFuture.channel().closeFuture() would deregister the socket. I'll note that while closeFuture() may look really useful, you have to be careful with it, and it runs at an awkward time. I suggest only using it when the execution time doesn't matter. closeFuture() is different than \"the future returned from close()\".", "author": "ejona86", "createdAt": "2020-12-11T00:19:45Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +292,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw bindCallResult.cause();\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Throwable ex) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), ex);\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+\n+    for (Map.Entry<ChannelFuture, SocketAddress> channelFutureEntry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future  = channelFutureEntry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        throw new IOException(String.format(\"Failed to bind to address %s\",", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwNjc3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r542506779", "bodyText": "It looks that channel will be closed by b.bind() if that fails and channel only be set once b.bind() future isSuccess(). So I think we can trust the result of the future instead of adding listener to clean up by ourselves. Now I collect all the successful channels and then close them all if one fails to avoid leakage. Maybe we should consider allowing partial failures in the future.", "author": "YifeiZhuang", "createdAt": "2020-12-14T16:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5NzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYwMTI5NA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540601294", "bodyText": "What does this comment mean by \"making it worse\"?", "author": "ejona86", "createdAt": "2020-12-11T00:29:52Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +292,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw bindCallResult.cause();\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Throwable ex) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), ex);\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+\n+    for (Map.Entry<ChannelFuture, SocketAddress> channelFutureEntry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future  = channelFutureEntry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        throw new IOException(String.format(\"Failed to bind to address %s\",\n+            channelFutureEntry.getValue()), future.cause());\n       }\n-    });\n+      final Channel channel = future.channel();\n+      channel.eventLoop().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          InternalInstrumented<SocketStats> listenSocketStats = new ListenSocket(channel);\n+          channelz.addListenSocket(listenSocketStats);\n+          listenSocketStatsList.add(listenSocketStats);\n+        }\n+      });\n+      channelGroup.add(channel);\n+    }\n   }\n \n   @Override\n   public void shutdown() {\n-    if (channel == null || !channel.isOpen()) {\n-      // Already closed.\n+    if (terminated) {\n+      // Already closed. Not thread safe but we are not making it worse for now.", "originalCommit": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "315bd5df062c42aea361b252b95a69ffe2efbd49", "url": "https://github.com/grpc/grpc-java/commit/315bd5df062c42aea361b252b95a69ffe2efbd49", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java", "committedDate": "2020-12-11T19:59:46Z", "type": "commit"}, {"oid": "e5d98a69c8d2c5c64614d5684b41c64d139ef4c7", "url": "https://github.com/grpc/grpc-java/commit/e5d98a69c8d2c5c64614d5684b41c64d139ef4c7", "message": "bind multiple partial failure", "committedDate": "2020-12-14T05:09:34Z", "type": "commit"}, {"oid": "15c61a9a1be04d33146a4f757706168f791545d4", "url": "https://github.com/grpc/grpc-java/commit/15c61a9a1be04d33146a4f757706168f791545d4", "message": "use single transportServer in ServerImpl instead of a list", "committedDate": "2020-12-16T22:26:37Z", "type": "commit"}, {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "url": "https://github.com/grpc/grpc-java/commit/e8e243a35b19bd760f94c344ab94f924fa61d18b", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java", "committedDate": "2020-12-16T22:26:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzkyMg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548233922", "bodyText": "s/;;/;/", "author": "ejona86", "createdAt": "2020-12-23T21:00:58Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +158,57 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    // server is not listening/bound yet, just return the original ports.\n+    if (listenSocketAddresses.isEmpty())  {\n+      listenSocketAddresses.addAll(addresses);\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    if (listenSocketStatsList == null || listenSocketStatsList.isEmpty()) {\n+      return null;\n+    } else {\n+      return listenSocketStatsList.get(0);\n+    }\n+  }\n+\n+  @Override\n+  public List<InternalInstrumented<SocketStats>> getListenSocketStatsList() {\n+    return listenSocketStatsList;\n   }\n \n   @Override\n   public void start(ServerListener serverListener) throws IOException {\n     listener = checkNotNull(serverListener, \"serverListener\");\n \n-    ServerBootstrap b = new ServerBootstrap();\n+    final ServerBootstrap b = new ServerBootstrap();\n+    final EventLoop bossExecutor = bossGroup.next();;", "originalCommit": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzNTYzOA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548235638", "bodyText": "We should use the same event loop for the channels and the channelGroup. It's super-easy to and it means there are less threads involved for debugging/understanding the system.", "author": "ejona86", "createdAt": "2020-12-23T21:03:47Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +158,57 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    // server is not listening/bound yet, just return the original ports.\n+    if (listenSocketAddresses.isEmpty())  {\n+      listenSocketAddresses.addAll(addresses);\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    if (listenSocketStatsList == null || listenSocketStatsList.isEmpty()) {\n+      return null;\n+    } else {\n+      return listenSocketStatsList.get(0);\n+    }\n+  }\n+\n+  @Override\n+  public List<InternalInstrumented<SocketStats>> getListenSocketStatsList() {\n+    return listenSocketStatsList;\n   }\n \n   @Override\n   public void start(ServerListener serverListener) throws IOException {\n     listener = checkNotNull(serverListener, \"serverListener\");\n \n-    ServerBootstrap b = new ServerBootstrap();\n+    final ServerBootstrap b = new ServerBootstrap();\n+    final EventLoop bossExecutor = bossGroup.next();;", "originalCommit": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0MTIyNA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548241224", "bodyText": "Just inline the list and Throwable here, and get rid of the class? It seems the class only hides one if statement checking for null that could be inlined here (or simply be removed; there's nothing special about the first or last throwable).\nI don't mind helpers like this. It just seems this helper isn't really helping and the indirection makes the code harder to read.\nI think this loop would be simpler if you pre-added add the channels to the channelGroup; the channels exist as soon as the future is created. Then, if any future fails you close the channelGroup and throw immediately. That would remove the need for BindResult completely.", "author": "ejona86", "createdAt": "2020-12-23T21:11:16Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+    if (channelFutures == null) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    BindResult bindResult = new BindResult();", "originalCommit": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0NjQ3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548246479", "bodyText": "This management of the listenSocketStatsList seems quite a bit more involved and error-prone than my suggestion of doing the equivalent of channel.closeFuture().addListener(() -> channelz.removeListenSocket(listenSocketStats)) right here. (The code is just a sketch, we can't use lambdas.)", "author": "ejona86", "createdAt": "2020-12-23T21:18:10Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+    if (channelFutures == null) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    BindResult bindResult = new BindResult();\n+    for (Map.Entry<ChannelFuture, SocketAddress> entry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future = entry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        bindResult.failAddress(entry.getValue()).causedBy(future.cause());\n+      } else {\n+        final Channel channel = future.channel();\n+        channel.eventLoop().execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            InternalInstrumented<SocketStats> listenSocketStats = new ListenSocket(channel);\n+            channelz.addListenSocket(listenSocketStats);\n+            listenSocketStatsList.add(listenSocketStats);", "originalCommit": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1NDUyNw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548254527", "bodyText": "I see that closeChannelGroup() was split out to be reused here, but it doesn't seem safe to call. It does inappropriate things in this context like sharedResourceReferenceCounter.release() and protocolNegotiator.close(). (There's pre-existing issues already surrounding sharedResourceReferenceCounter, but this change doesn't fix them so it seems better to leave it alone.)\nIf listenSocketStatsList is removed by my other suggestion, I think this just becomes channelGroup.close().awaitUninterruptibly().", "author": "ejona86", "createdAt": "2020-12-23T21:28:57Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+    if (channelFutures == null) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    BindResult bindResult = new BindResult();\n+    for (Map.Entry<ChannelFuture, SocketAddress> entry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future = entry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        bindResult.failAddress(entry.getValue()).causedBy(future.cause());\n+      } else {\n+        final Channel channel = future.channel();\n+        channel.eventLoop().execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            InternalInstrumented<SocketStats> listenSocketStats = new ListenSocket(channel);\n+            channelz.addListenSocket(listenSocketStats);\n+            listenSocketStatsList.add(listenSocketStats);\n+          }\n+        });\n+        channelGroup.add(channel);\n       }\n-    });\n+    }\n+\n+    if (!bindResult.isSuccess()) {\n+      if (!channelGroup.isEmpty()) {\n+        closeChannelGroup().awaitUninterruptibly();", "originalCommit": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1NzI1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548257256", "bodyText": "This produces the wrong results if the future hasn't failed and just hasn't completed yet.", "author": "ejona86", "createdAt": "2020-12-23T21:32:59Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();", "originalCommit": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMDI1MA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549430250", "bodyText": "Could you help elaborate on why awaitUninterruptibly() is not enough to have the result ready when getNow() is called? Thanks.", "author": "YifeiZhuang", "createdAt": "2020-12-28T17:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1NzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMTM1MA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549431350", "bodyText": "I think I was probably blind to the awaitUninterruptibly(). This looks fine.", "author": "ejona86", "createdAt": "2020-12-28T17:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1NzI1Ng=="}], "type": "inlineReview"}, {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763", "url": "https://github.com/grpc/grpc-java/commit/ecac9055e0ff95796c8e15827a527885cf0b1763", "message": "fix close channel group on paritial failures", "committedDate": "2020-12-28T17:40:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549453995", "bodyText": "Why is this volatile? It actually looks like it could be final", "author": "ejona86", "createdAt": "2020-12-28T19:00:14Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -78,7 +87,7 @@\n   private EventLoopGroup bossGroup;\n   private EventLoopGroup workerGroup;\n   private ServerListener listener;\n-  private Channel channel;\n+  private volatile ChannelGroup channelGroup;", "originalCommit": "ecac9055e0ff95796c8e15827a527885cf0b1763", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2MDI5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549460293", "bodyText": "channel is added to channelGroup in the eventloop task when bind.", "author": "YifeiZhuang", "createdAt": "2020-12-28T19:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2MDg5MA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549460890", "bodyText": "Volatile has no effect on that. Volatile only controls the behavior of the variable's direct value. Since the value here never changes, it doesn't need to be volatile.\nThe issue you mention is impacted by whether ChannelGroup itself is thread-safe or not.", "author": "ejona86", "createdAt": "2020-12-28T19:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2NDg3Mw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549464873", "bodyText": "It is supposed to be thread-safe and it is explicitly documented, likely we can make it final. (weird that i didn't get consistent result in my debug.)", "author": "YifeiZhuang", "createdAt": "2020-12-28T19:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2NTI4NA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549465284", "bodyText": "I'm a bit concerned that discussion of \"final\" seemed to be as a result of thread-safety of ChannelGroup. The two are completely separate; one has no impact on the other.", "author": "ejona86", "createdAt": "2020-12-28T19:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3NjQ5NQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549476495", "bodyText": "Understood. Just as a result of that fact that there is no final + volatile.", "author": "YifeiZhuang", "createdAt": "2020-12-28T20:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NTczMw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549455733", "bodyText": "Drop this. This listener isn't responsible for closing, just interested to know when it happens. The code that actually closes should be handling this error.", "author": "ejona86", "createdAt": "2020-12-28T19:06:45Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,101 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, Map<ChannelFuture,ChannelFutureListener>>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>>>() {\n+          @Override\n+          public Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> call() {\n+            Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> bindFutures =\n+                new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                      log.log(Level.WARNING, \"Error closing server channel\", future.cause());", "originalCommit": "ecac9055e0ff95796c8e15827a527885cf0b1763", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549457106", "bodyText": "Why do this? If you just leave the listener in-place, then you don't have to communicate it back to this thread (in the awkward map) and you don't need to call removeListenSocket within shutdown().", "author": "ejona86", "createdAt": "2020-12-28T19:12:09Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,101 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, Map<ChannelFuture,ChannelFutureListener>>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>>>() {\n+          @Override\n+          public Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> call() {\n+            Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> bindFutures =\n+                new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                      log.log(Level.WARNING, \"Error closing server channel\", future.cause());\n+                    }\n+                    channelz.removeListenSocket(listenSocketStats);\n+                    listenSocketStatsList.remove(listenSocketStats);\n+                  }\n+                };\n+                future.channel().closeFuture().addListener(closeListener);\n+                bindFutures.put(address, ImmutableMap.of(future, closeListener));\n+            }\n+            return bindFutures;\n+          }\n+        }\n+    );\n+    Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+\n+    if (!bindCallFuture.isSuccess()) {\n+      channelGroup.close().awaitUninterruptibly();\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    for (Map.Entry<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> entry:\n+        channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      for (ChannelFuture future: entry.getValue().keySet()) {\n+        if (!future.awaitUninterruptibly().isSuccess()) {\n+          channelGroup.close().awaitUninterruptibly();\n+          throw new IOException(String.format(\"Failed to bind to address %s\",\n+              entry.getKey()), future.cause());\n+        }\n       }\n-    });\n+    }\n+    for (Map<ChannelFuture, ChannelFutureListener> channelListener: channelFutures.values()) {\n+      for (Map.Entry<ChannelFuture, ChannelFutureListener> entry: channelListener.entrySet()) {\n+        entry.getKey().channel().closeFuture().removeListener(entry.getValue());", "originalCommit": "ecac9055e0ff95796c8e15827a527885cf0b1763", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2MTY5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549461697", "bodyText": "The close listener installed on the channel will stay with it in the entire lifetime, so if we do not remove it, then it conflicts with removeListenSocket at shutdown(), isn't it?", "author": "YifeiZhuang", "createdAt": "2020-12-28T19:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2MTk4NA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549461984", "bodyText": "I agree, but it seems simpler to remove the removal in shutdown().", "author": "ejona86", "createdAt": "2020-12-28T19:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3NzI3MQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549477271", "bodyText": "I know where the conflict was from. Left the individual channel close listener removal there and the group close listener removal is ok to run again because of the emptiness check.", "author": "YifeiZhuang", "createdAt": "2020-12-28T20:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMjYzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549512631", "bodyText": "But you don't need the group close listener removal! And setting listenSocketStatsList = null doesn't add much value and makes the code more complex. Why should this code even exist if the other code will handle the cleanup?", "author": "ejona86", "createdAt": "2020-12-28T23:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg=="}], "type": "inlineReview"}, {"oid": "d0ced0f2696b87252858cb871134cc38fcaae9fd", "url": "https://github.com/grpc/grpc-java/commit/d0ced0f2696b87252858cb871134cc38fcaae9fd", "message": "fix remove channel group channel close listener", "committedDate": "2020-12-28T20:22:24Z", "type": "commit"}, {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2", "url": "https://github.com/grpc/grpc-java/commit/20bbb9bb6a2455577019cf58567e650f221172c2", "message": "fix indentation, add listenSocketStatsList null check", "committedDate": "2020-12-28T21:04:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTAwOQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549511009", "bodyText": "ArrayList is not thread-safe, but this is used from multiple threads.", "author": "ejona86", "createdAt": "2020-12-28T22:54:07Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -97,10 +105,14 @@\n   private final TransportTracer.Factory transportTracerFactory;\n   private final InternalChannelz channelz;\n   // Only modified in event loop but safe to read any time.\n-  private volatile InternalInstrumented<SocketStats> listenSocketStats;\n+  private volatile List<InternalInstrumented<SocketStats>> listenSocketStatsList =", "originalCommit": "20bbb9bb6a2455577019cf58567e650f221172c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzOTM1MQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549539351", "bodyText": "It can be modified in different channels' eventloop, and there is only a single one, so it looks fine at write. And the socketStats can be transient, so we return a snapshot on the direct read. I see the getListenSocketStatsList returned the reference directly which might cause problems as it is mutable, we can return an immutable list, or create a new copy then return.", "author": "YifeiZhuang", "createdAt": "2020-12-29T01:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NDgwMg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549544802", "bodyText": "Actually each server channel's eventloop can be different.", "author": "YifeiZhuang", "createdAt": "2020-12-29T02:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTMxMw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549511313", "bodyText": "This is not a thread-safe usage of a volatile reference as the value can change between each access. You need to copy it to a local variable to have a stable value.\nList<InternalInstrumented<SocketStats>> savedListenSocketStatsList = listenSocketStatsList;\nif (savedListenSocketSatsList == null || ...)", "author": "ejona86", "createdAt": "2020-12-28T22:55:41Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +158,56 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    // server is not listening/bound yet, just return the original ports.\n+    if (listenSocketAddresses.isEmpty())  {\n+      listenSocketAddresses.addAll(addresses);\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    if (listenSocketStatsList == null || listenSocketStatsList.isEmpty()) {", "originalCommit": "20bbb9bb6a2455577019cf58567e650f221172c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMjA4MQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549512081", "bodyText": "listenSocketStatsList could be null here, as it can race with the code in shutdown().\nThis is not actually a thread-safety risk as both listeners will run from the event loop, but just a normal \"that other operation may happen first.\" We shouldn't unnecessarily depend on the closeListener() completing and running the listeners before the future returned from close() completes.", "author": "ejona86", "createdAt": "2020-12-28T22:59:32Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +296,92 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, ChannelFuture>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, ChannelFuture>>() {\n+          @Override\n+          public Map<SocketAddress, ChannelFuture> call() {\n+            Map<SocketAddress, ChannelFuture> bindFutures = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (listenSocketStatsList != null) {\n+                      channelz.removeListenSocket(listenSocketStats);\n+                      listenSocketStatsList.remove(listenSocketStats);", "originalCommit": "20bbb9bb6a2455577019cf58567e650f221172c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0038bb5e876034f35c34e4ab1cee5514b30a4b0f", "url": "https://github.com/grpc/grpc-java/commit/0038bb5e876034f35c34e4ab1cee5514b30a4b0f", "message": "fix listenSocketStatsList read thread-unsafe, remove removing from channelz in shutdown", "committedDate": "2020-12-28T23:38:59Z", "type": "commit"}, {"oid": "6ac7aa56121de73b8a55c5cb717c6aa636d12fee", "url": "https://github.com/grpc/grpc-java/commit/6ac7aa56121de73b8a55c5cb717c6aa636d12fee", "message": "fix thread unsafe listenSocketStatsList", "committedDate": "2020-12-29T01:48:51Z", "type": "commit"}, {"oid": "d091381f74c1aa4a10814f8225b2420faba5ac7c", "url": "https://github.com/grpc/grpc-java/commit/d091381f74c1aa4a10814f8225b2420faba5ac7c", "message": "fix thread unsafe listenSocketsList", "committedDate": "2020-12-29T02:21:22Z", "type": "commit"}, {"oid": "589cbe90a402b57cc61915e859aecf935d92e2e5", "url": "https://github.com/grpc/grpc-java/commit/589cbe90a402b57cc61915e859aecf935d92e2e5", "message": "fix thread unsafe listenSocketStatsList", "committedDate": "2020-12-30T17:12:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3OTE4OQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550279189", "bodyText": "Assign to Collections.emptyList() to avoid null pointer concerns?", "author": "ejona86", "createdAt": "2020-12-30T18:00:51Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -364,6 +368,7 @@ public void operationComplete(ChannelGroupFuture future) throws Exception {\n               }\n               sharedResourceReferenceCounter.release();\n               protocolNegotiator.close();\n+              listenSocketStatsList = null;", "originalCommit": "589cbe90a402b57cc61915e859aecf935d92e2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3OTM0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550279342", "bodyText": "This synchronization does nothing.", "author": "ejona86", "createdAt": "2020-12-30T18:01:28Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -348,6 +349,9 @@ public void operationComplete(ChannelFuture future) throws Exception {\n             entry.getKey()), future.cause());\n       }\n     }\n+    synchronized (NettyServer.this) {", "originalCommit": "589cbe90a402b57cc61915e859aecf935d92e2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550284808", "bodyText": "This is not thread-safe, as it can happen after future.awaitUninterruptibly().isSuccess() returns.\nWe had discussed needing to have another future that is completed right after this synchronized block, and pass that future instead in bindFutures. But I actually think it'd be easier to move this code (and listenSocketStats creation) to the channelFutures.entrySet() for loop directly. At that location, the entire contents of this ChannelFutureListener could be called directly and the synchronized block would be unnecessary. It'd be best to move future.channel().closeFuture().addListener() for channelz.removeListenSocket() to the for loop as well so they stay paired (but it would stay as a listener).", "author": "ejona86", "createdAt": "2020-12-30T18:21:56Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -309,20 +314,16 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                   public void operationComplete(ChannelFuture future) throws Exception {\n                     channelz.addListenSocket(listenSocketStats);\n                     synchronized (NettyServer.this) {\n-                      listenSocketStatsList.add(listenSocketStats);\n+                      socketStats.add(listenSocketStats);", "originalCommit": "589cbe90a402b57cc61915e859aecf935d92e2e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NzQxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550287419", "bodyText": "Why synchronization block (L352) is not enough to ensure all write to the arraylist is sequentially done and the read is also up to date?", "author": "YifeiZhuang", "createdAt": "2020-12-30T18:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI5MTQwNg==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550291406", "bodyText": "Because this listener may be executed after that block.", "author": "ejona86", "createdAt": "2020-12-30T18:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNzQ4Nw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550307487", "bodyText": "k, could you remind me why we originally have this in eventloop?", "author": "YifeiZhuang", "createdAt": "2020-12-30T19:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMDUxMA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550310510", "bodyText": "I don't think it is necessary. What is necessary is that it is executed after the bind completes. It appears it could have been simplified when 49c8bdb was done, but wasn't noticed at the time (nor in b8474d6)", "author": "ejona86", "createdAt": "2020-12-30T19:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyNTYyMA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550325620", "bodyText": "Thanks. I put it inline, but I am actually not hundred percent sure if L341 is publish-safe. Reference assignment is fine, and because the list is modified in a single thread, it looks other thread would get() what this thread can see by the time unmodifiable view is created, which might be safe.", "author": "YifeiZhuang", "createdAt": "2020-12-30T20:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTkxOA==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550329918", "bodyText": "It looks fine. Yes, the volatile write publishes any writes that occurred before it on the same thread.", "author": "ejona86", "createdAt": "2020-12-30T21:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA=="}], "type": "inlineReview"}, {"oid": "5de6d7030a29d2995c2d9044454f162ccf4add03", "url": "https://github.com/grpc/grpc-java/commit/5de6d7030a29d2995c2d9044454f162ccf4add03", "message": "fix thread unsafe listenSocketStatsList", "committedDate": "2020-12-30T20:50:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyODA4Mw==", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550328083", "bodyText": "nit: no need for final.", "author": "ejona86", "createdAt": "2020-12-30T21:10:31Z", "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +293,77 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> bindFutures = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                bindFutures.put(future, address);\n+            }\n+            return bindFutures;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+\n+    if (!bindCallFuture.isSuccess()) {\n+      channelGroup.close().awaitUninterruptibly();\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    final List<InternalInstrumented<SocketStats>> socketStats = new ArrayList<>();", "originalCommit": "5de6d7030a29d2995c2d9044454f162ccf4add03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}