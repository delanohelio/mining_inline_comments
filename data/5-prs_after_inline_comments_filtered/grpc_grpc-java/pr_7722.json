{"pr_number": 7722, "pr_title": "xds: implement new CDS LB policy for supporting aggregate clusters", "pr_createdAt": "2020-12-11T02:37:04Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7722", "timeline": [{"oid": "3fbca448b4df0045e3078b87f17e6a968c081925", "url": "https://github.com/grpc/grpc-java/commit/3fbca448b4df0045e3078b87f17e6a968c081925", "message": "Implement the new CDS LB policy, which is capable of discovering an aggregate cluster with tree hierarchy.", "committedDate": "2020-12-11T02:35:42Z", "type": "commit"}, {"oid": "d99112542cd10a8517e42b95dccfc014b8f333ff", "url": "https://github.com/grpc/grpc-java/commit/d99112542cd10a8517e42b95dccfc014b8f333ff", "message": "Implement tests.", "committedDate": "2020-12-11T02:40:27Z", "type": "commit"}, {"oid": "d99112542cd10a8517e42b95dccfc014b8f333ff", "url": "https://github.com/grpc/grpc-java/commit/d99112542cd10a8517e42b95dccfc014b8f333ff", "message": "Implement tests.", "committedDate": "2020-12-11T02:40:27Z", "type": "forcePushed"}, {"oid": "f5b593de03f078658950c9305e8ed2379d925398", "url": "https://github.com/grpc/grpc-java/commit/f5b593de03f078658950c9305e8ed2379d925398", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/implement_new_cds_lb_policy", "committedDate": "2020-12-31T00:39:50Z", "type": "commit"}, {"oid": "3c0834d6c42f03383bf700a3f21af936c2c6b998", "url": "https://github.com/grpc/grpc-java/commit/3c0834d6c42f03383bf700a3f21af936c2c6b998", "message": "Fix wrong import.", "committedDate": "2020-12-31T00:40:47Z", "type": "commit"}, {"oid": "6e49a2d88d547323107faa4ce6b835a75ba24546", "url": "https://github.com/grpc/grpc-java/commit/6e49a2d88d547323107faa4ce6b835a75ba24546", "message": "Prefer ArrayDeque to LinkedList for Queue.", "committedDate": "2020-12-31T00:43:20Z", "type": "commit"}, {"oid": "e3259603025fd0fe3d438dfdb22f0f2ed910f825", "url": "https://github.com/grpc/grpc-java/commit/e3259603025fd0fe3d438dfdb22f0f2ed910f825", "message": "Fix style line too long.", "committedDate": "2020-12-31T00:49:32Z", "type": "commit"}, {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18", "url": "https://github.com/grpc/grpc-java/commit/3f1c2b381256dae82341f8862f72a3d8f6e52e18", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/implement_new_cds_lb_policy", "committedDate": "2021-01-08T09:09:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQwMDY5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r555400696", "bodyText": "also revoke child clusters if if (childClusterStates != null), and then set childClusterStates = null?", "author": "dapengzhang0", "createdAt": "2021-01-11T23:17:17Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.CLUSTER_RESOLVER_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.CdsUpdate.AggregateClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterType;\n+import io.grpc.xds.XdsClient.CdsUpdate.EdsClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.LogicalDnsClusterConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cds_experimental LB policy. One instance per top-level cluster.\n+ * The top-level cluster may be a plain EDS/logical-DNS cluster or an aggregate cluster that\n+ * formed by a group of sub-clusters in a tree hierarchy.\n+ */\n+final class CdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final LoadBalancerRegistry lbRegistry;\n+  // Following fields are effectively final.\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private CdsLbState cdsLbState;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  CdsLoadBalancer2(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry());\n+  }\n+\n+  @VisibleForTesting\n+  CdsLoadBalancer2(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    if (this.resolvedAddresses != null) {\n+      return;\n+    }\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+    xdsClient = xdsClientPool.getObject();\n+    CdsConfig config = (CdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    logger.log(XdsLogLevel.INFO, \"Config: {0}\", config);\n+    cdsLbState = new CdsLbState(config.name);\n+    cdsLbState.start();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (cdsLbState != null && cdsLbState.childLb != null) {\n+      cdsLbState.childLb.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    if (cdsLbState != null) {\n+      cdsLbState.shutdown();\n+    }\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  /**\n+   * The state of a CDS working session of {@link CdsLoadBalancer2}. Created and started when\n+   * receiving the CDS LB policy config with the top-level cluster name.\n+   */\n+  private final class CdsLbState {\n+    private ClusterState root;\n+    private LoadBalancer childLb;\n+\n+    private CdsLbState(String rootCluster) {\n+      root = new ClusterState(rootCluster);\n+    }\n+\n+    private void start() {\n+      root.start();\n+    }\n+\n+    private void shutdown() {\n+      root.shutdown();\n+    }\n+\n+    private void handleClusterDiscovered() {\n+      List<DiscoveryMechanism> instances = new ArrayList<>();\n+      // Level-order traversal.\n+      // Collect configurations for all non-aggregate (leaf) clusters.\n+      Queue<ClusterState> queue = new ArrayDeque<>();\n+      queue.add(root);\n+      while (!queue.isEmpty()) {\n+        int size = queue.size();\n+        for (int i = 0; i < size; i++) {\n+          ClusterState clusterState = queue.remove();\n+          if (!clusterState.discovered) {\n+            return;  // do not proceed until all clusters discovered\n+          }\n+          if (clusterState.result == null) {  // resource revoked or not exists\n+            continue;\n+          }\n+          if (clusterState.isLeaf) {\n+            DiscoveryMechanism instance;\n+            if (clusterState.result instanceof EdsClusterConfig) {\n+              EdsClusterConfig clusterConfig = (EdsClusterConfig) clusterState.result;\n+              instance = DiscoveryMechanism.forEds(clusterState.name, clusterConfig.edsServiceName,\n+                  clusterConfig.lrsServerName, clusterConfig.maxConcurrentRequests,\n+                  clusterConfig.upstreamTlsContext);\n+            } else {  // logical DNS\n+              LogicalDnsClusterConfig clusterConfig =\n+                  (LogicalDnsClusterConfig) clusterState.result;\n+              instance = DiscoveryMechanism.forLogicalDns(clusterState.name,\n+                  clusterConfig.lrsServerName, clusterConfig.maxConcurrentRequests,\n+                  clusterConfig.upstreamTlsContext);\n+            }\n+            instances.add(instance);\n+          } else {\n+            if (clusterState.childClusterStates != null) {\n+              queue.addAll(clusterState.childClusterStates.values());\n+            }\n+          }\n+        }\n+      }\n+      if (instances.isEmpty()) {  // none of non-aggregate clusters exists\n+        if (childLb != null) {\n+          childLb.shutdown();\n+          childLb = null;\n+        }\n+        Status unavailable =\n+            Status.UNAVAILABLE.withDescription(\"Cluster \" + root.name + \" unusable\");\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(unavailable));\n+        return;\n+      }\n+      String endpointPickingPolicy = root.result.lbPolicy;\n+      LoadBalancerProvider localityPickingLbProvider =\n+          lbRegistry.getProvider(XdsLbPolicies.WEIGHTED_TARGET_POLICY_NAME);  // hardcoded\n+      LoadBalancerProvider endpointPickingLbProvider =\n+          lbRegistry.getProvider(endpointPickingPolicy);\n+      ClusterResolverConfig config = new ClusterResolverConfig(\n+          Collections.unmodifiableList(instances),\n+          new PolicySelection(localityPickingLbProvider, null /* by cluster_resolver LB policy */),\n+          new PolicySelection(endpointPickingLbProvider, null));\n+      if (childLb == null) {\n+        childLb = lbRegistry.getProvider(CLUSTER_RESOLVER_POLICY_NAME).newLoadBalancer(helper);\n+      }\n+      childLb.handleResolvedAddresses(\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(config).build());\n+    }\n+\n+    private void handleClusterDiscoveryError(Status error) {\n+      if (childLb != null) {\n+        childLb.handleNameResolutionError(error);\n+      } else {\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+      }\n+    }\n+\n+    private final class ClusterState implements CdsResourceWatcher {\n+      private final String name;\n+      @Nullable\n+      private Map<String, ClusterState> childClusterStates;\n+      @Nullable\n+      private ClusterConfig result;\n+      // Following fields are effectively final.\n+      private boolean isLeaf;\n+      private boolean discovered;\n+      private boolean shutdown;\n+\n+      private ClusterState(String name) {\n+        this.name = name;\n+      }\n+\n+      private void start() {\n+        xdsClient.watchCdsResource(name, this);\n+      }\n+\n+      void shutdown() {\n+        shutdown = true;\n+        xdsClient.cancelCdsResourceWatch(name, this);\n+        if (childClusterStates != null) {  // recursively shut down all descendants\n+          for (ClusterState state : childClusterStates.values()) {\n+            state.shutdown();\n+          }\n+        }\n+      }\n+\n+      @Override\n+      public void onError(final Status error) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            // All watchers should receive the same error, so we only propagate it once.\n+            if (ClusterState.this == root) {\n+              handleClusterDiscoveryError(error);\n+            }\n+          }\n+        });\n+      }\n+\n+      @Override\n+      public void onResourceDoesNotExist(String resourceName) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            discovered = true;\n+            result = null;\n+            if (childClusterStates != null) {\n+              for (ClusterState state : childClusterStates.values()) {\n+                state.shutdown();\n+              }\n+              childClusterStates = null;\n+            }\n+            handleClusterDiscovered();\n+          }\n+        });\n+      }\n+\n+      @Override\n+      public void onChanged(final CdsUpdate update) {\n+        class ClusterDiscovered implements Runnable {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            discovered = true;\n+            result = update.clusterConfig;\n+            if (update.clusterType == ClusterType.AGGREGATE) {\n+              isLeaf = false;\n+              AggregateClusterConfig clusterConfig = (AggregateClusterConfig) update.clusterConfig;\n+              logger.log(XdsLogLevel.INFO, \"Aggregate cluster {0}\", update.clusterName);\n+              logger.log(XdsLogLevel.DEBUG, \"Cluster config: {0}\", clusterConfig);\n+              Map<String, ClusterState> newChildStates = new LinkedHashMap<>();\n+              for (String cluster : clusterConfig.prioritizedClusterNames) {\n+                if (childClusterStates == null || !childClusterStates.containsKey(cluster)) {\n+                  ClusterState childState = new ClusterState(cluster);\n+                  childState.start();\n+                  newChildStates.put(cluster, childState);\n+                } else {\n+                  newChildStates.put(cluster, childClusterStates.remove(cluster));\n+                }\n+              }\n+              if (childClusterStates != null) {  // stop subscribing to revoked child clusters\n+                for (ClusterState watcher : childClusterStates.values()) {\n+                  watcher.shutdown();\n+                }\n+              }\n+              childClusterStates = newChildStates;\n+            } else if (update.clusterType == ClusterType.EDS) {\n+              isLeaf = true;\n+              EdsClusterConfig clusterConfig = (EdsClusterConfig) update.clusterConfig;\n+              logger.log(XdsLogLevel.INFO, \"EDS cluster {0}, edsServiceName: {1}\",\n+                  update.clusterName, clusterConfig.edsServiceName);\n+              logger.log(XdsLogLevel.DEBUG, \"Cluster config: {0}\", clusterConfig);", "originalCommit": "3f1c2b381256dae82341f8862f72a3d8f6e52e18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODcyMw==", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r555418723", "bodyText": "I don't think we need to consider such a weird use case: a EDS/Logical DNS cluster becomes an aggregate cluster (or vice versa).", "author": "voidzcy", "createdAt": "2021-01-12T00:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQwMDY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MzM2OA==", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r556043368", "bodyText": "'that is formed' or 'that formed'", "author": "dapengzhang0", "createdAt": "2021-01-12T19:54:57Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.CLUSTER_RESOLVER_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.CdsUpdate.AggregateClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterType;\n+import io.grpc.xds.XdsClient.CdsUpdate.EdsClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.LogicalDnsClusterConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cds_experimental LB policy. One instance per top-level cluster.\n+ * The top-level cluster may be a plain EDS/logical-DNS cluster or an aggregate cluster that\n+ * formed by a group of sub-clusters in a tree hierarchy.", "originalCommit": "3f1c2b381256dae82341f8862f72a3d8f6e52e18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY0MTExOA==", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r557641118", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2021-01-14T19:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MzUzMg==", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r556043532", "bodyText": "nit: final", "author": "dapengzhang0", "createdAt": "2021-01-12T19:55:11Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.CLUSTER_RESOLVER_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.CdsUpdate.AggregateClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterType;\n+import io.grpc.xds.XdsClient.CdsUpdate.EdsClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.LogicalDnsClusterConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cds_experimental LB policy. One instance per top-level cluster.\n+ * The top-level cluster may be a plain EDS/logical-DNS cluster or an aggregate cluster that\n+ * formed by a group of sub-clusters in a tree hierarchy.\n+ */\n+final class CdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final LoadBalancerRegistry lbRegistry;\n+  // Following fields are effectively final.\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private CdsLbState cdsLbState;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  CdsLoadBalancer2(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry());\n+  }\n+\n+  @VisibleForTesting\n+  CdsLoadBalancer2(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    if (this.resolvedAddresses != null) {\n+      return;\n+    }\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+    xdsClient = xdsClientPool.getObject();\n+    CdsConfig config = (CdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    logger.log(XdsLogLevel.INFO, \"Config: {0}\", config);\n+    cdsLbState = new CdsLbState(config.name);\n+    cdsLbState.start();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (cdsLbState != null && cdsLbState.childLb != null) {\n+      cdsLbState.childLb.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    if (cdsLbState != null) {\n+      cdsLbState.shutdown();\n+    }\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  /**\n+   * The state of a CDS working session of {@link CdsLoadBalancer2}. Created and started when\n+   * receiving the CDS LB policy config with the top-level cluster name.\n+   */\n+  private final class CdsLbState {\n+    private ClusterState root;", "originalCommit": "3f1c2b381256dae82341f8862f72a3d8f6e52e18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY0MTI0NQ==", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r557641245", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2021-01-14T19:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MzUzMg=="}], "type": "inlineReview"}, {"oid": "87f9a7eff9eea059a86392d5cfdc56427b46378a", "url": "https://github.com/grpc/grpc-java/commit/87f9a7eff9eea059a86392d5cfdc56427b46378a", "message": "Minor stylish fixes.", "committedDate": "2021-01-14T19:21:39Z", "type": "commit"}]}