{"pr_number": 7203, "pr_title": "xds: implement the top-level LB policy", "pr_createdAt": "2020-07-13T09:01:06Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7203", "timeline": [{"oid": "e3521b5d660f0757ff66a187aa781561ddf64a77", "url": "https://github.com/grpc/grpc-java/commit/e3521b5d660f0757ff66a187aa781561ddf64a77", "message": "Implement provider for the top-level LB policy, define config format and implement the config parser.", "committedDate": "2020-07-13T08:52:34Z", "type": "commit"}, {"oid": "b12839b895c671603117e932a95fbf6a7e252992", "url": "https://github.com/grpc/grpc-java/commit/b12839b895c671603117e932a95fbf6a7e252992", "message": "Add the top-level LB policy provider to the service provider resource", "committedDate": "2020-07-13T08:53:15Z", "type": "commit"}, {"oid": "c54dfc73a8b80cef92143afb95bcc280676d446b", "url": "https://github.com/grpc/grpc-java/commit/c54dfc73a8b80cef92143afb95bcc280676d446b", "message": "Add tests for parsing top-level LB policy config", "committedDate": "2020-07-13T08:54:01Z", "type": "commit"}, {"oid": "f328b4ba5733dccae85281b931ba1951cf3ed12d", "url": "https://github.com/grpc/grpc-java/commit/f328b4ba5733dccae85281b931ba1951cf3ed12d", "message": "Implement the top-level LB policy.", "committedDate": "2020-07-13T08:54:30Z", "type": "commit"}, {"oid": "91af118465460bc0c8ef10d03297dd175ad58b58", "url": "https://github.com/grpc/grpc-java/commit/91af118465460bc0c8ef10d03297dd175ad58b58", "message": "Add tests for the top-level LB policy", "committedDate": "2020-07-13T08:54:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NjM4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r454586382", "bodyText": "From our last discussion, we seemed to agree on updating the picker immediately if the list of clusters is changed, otherwise new RPCs may be routed to a new cluster but the picker does not include that cluster and will end up with failure.", "author": "dapengzhang0", "createdAt": "2020-07-14T19:17:41Z", "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    ClusterManagerConfig config = (ClusterManagerConfig)\n+        resolvedAddresses.getLoadBalancingPolicyConfig();\n+    Map<String, PolicySelection> newChildPolicies = config.childPolicies;\n+    logger.log(\n+        XdsLogLevel.INFO,\n+        \"Received cluster_manager lb config: child names={0}\", newChildPolicies.keySet());\n+    for (Map.Entry<String, PolicySelection> entry : newChildPolicies.entrySet()) {\n+      final String name = entry.getKey();\n+      LoadBalancerProvider childPolicyProvider = entry.getValue().getProvider();\n+      Object childConfig = entry.getValue().getConfig();\n+      if (!childLbStates.containsKey(name)) {\n+        childLbStates.put(name, new ChildLbState(name, childPolicyProvider));\n+      } else {\n+        childLbStates.get(name).reactivate(childPolicyProvider);\n+      }\n+      final ResolvedAddresses childAddresses =\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(childConfig).build();\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          childLbStates.get(name).lb.handleResolvedAddresses(childAddresses);\n+        }\n+      });\n+    }\n+    for (String name : childLbStates.keySet()) {\n+      if (!newChildPolicies.containsKey(name)) {\n+        childLbStates.get(name).deactivate();\n+      }\n+    }", "originalCommit": "91af118465460bc0c8ef10d03297dd175ad58b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNDc0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r454604747", "bodyText": "Oh, you are right, but that would be something slightly different. I think we still want the delayed deletion mechanism for the balancer subtree. However, when receiving an updated config, we need to immediately propagate an updated picker that will not choose removed child balancers. Currently, the new picker will only be propagated up when one of subchannels state changes. Note, the new picker will not choose removed/deactivated child balancers (see line 138), but the problem is we still need an immediate picker update. I will fix this.", "author": "voidzcy", "createdAt": "2020-07-14T19:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMTMwNA==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r455431304", "bodyText": "I updated the implementation, as well as refactored the tests. PTAL.", "author": "voidzcy", "createdAt": "2020-07-15T23:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NjM4Mg=="}], "type": "inlineReview"}, {"oid": "e72a07f6e230014f361fbc3b043210a909d08fb5", "url": "https://github.com/grpc/grpc-java/commit/e72a07f6e230014f361fbc3b043210a909d08fb5", "message": "typo: used the wrong contant from a different class in unit test.", "committedDate": "2020-07-15T21:08:04Z", "type": "commit"}, {"oid": "b7b3fd26849d4825efb3144d3c7adc081e699901", "url": "https://github.com/grpc/grpc-java/commit/b7b3fd26849d4825efb3144d3c7adc081e699901", "message": "Immediately propagate a picker that makes picking from the updated group of child balancers to the Channel when handleResolvedAddresses is invoked.", "committedDate": "2020-07-15T23:52:05Z", "type": "commit"}, {"oid": "af54f24ea510bb41439ccb12afa3fa34022f3402", "url": "https://github.com/grpc/grpc-java/commit/af54f24ea510bb41439ccb12afa3fa34022f3402", "message": "Improve unit tests", "committedDate": "2020-07-15T23:52:19Z", "type": "commit"}, {"oid": "3b9c5c67d9146f21c9a9b528c1a4184a1ae64c55", "url": "https://github.com/grpc/grpc-java/commit/3b9c5c67d9146f21c9a9b528c1a4184a1ae64c55", "message": "Picking a Subchannel for a removed cluster should result in UNAVAILABLE instead of INTERNAL error.", "committedDate": "2020-07-15T23:56:14Z", "type": "commit"}, {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059", "url": "https://github.com/grpc/grpc-java/commit/bcabf09e0eba9842493358bbeb15eba7be768059", "message": "formatting.", "committedDate": "2020-07-16T17:36:58Z", "type": "commit"}, {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059", "url": "https://github.com/grpc/grpc-java/commit/bcabf09e0eba9842493358bbeb15eba7be768059", "message": "formatting.", "committedDate": "2020-07-16T17:36:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NzExMw==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456047113", "bodyText": "_ACTION_?", "author": "dapengzhang0", "createdAt": "2020-07-16T20:07:13Z", "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;", "originalCommit": "bcabf09e0eba9842493358bbeb15eba7be768059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNDk4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456134982", "bodyText": "Oops. Fixed.", "author": "voidzcy", "createdAt": "2020-07-16T23:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODAxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456058019", "bodyText": "Even if deactivated, should still update currentState and currentPicker, just not updateOverallBalancingState() (already guaranteed). The XdsRoutingLoadBalancer has the same issue.", "author": "dapengzhang0", "createdAt": "2020-07-16T20:28:18Z", "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    ClusterManagerConfig config = (ClusterManagerConfig)\n+        resolvedAddresses.getLoadBalancingPolicyConfig();\n+    Map<String, PolicySelection> newChildPolicies = config.childPolicies;\n+    logger.log(\n+        XdsLogLevel.INFO,\n+        \"Received cluster_manager lb config: child names={0}\", newChildPolicies.keySet());\n+    for (Map.Entry<String, PolicySelection> entry : newChildPolicies.entrySet()) {\n+      final String name = entry.getKey();\n+      LoadBalancerProvider childPolicyProvider = entry.getValue().getProvider();\n+      Object childConfig = entry.getValue().getConfig();\n+      if (!childLbStates.containsKey(name)) {\n+        childLbStates.put(name, new ChildLbState(name, childPolicyProvider));\n+      } else {\n+        childLbStates.get(name).reactivate(childPolicyProvider);\n+      }\n+      final ResolvedAddresses childAddresses =\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(childConfig).build();\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          childLbStates.get(name).lb.handleResolvedAddresses(childAddresses);\n+        }\n+      });\n+    }\n+    for (String name : childLbStates.keySet()) {\n+      if (!newChildPolicies.containsKey(name)) {\n+        childLbStates.get(name).deactivate();\n+      }\n+    }\n+    updateOverallBalancingState();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    boolean gotoTransientFailure = true;\n+    for (ChildLbState state : childLbStates.values()) {\n+      if (!state.deactivated) {\n+        gotoTransientFailure = false;\n+        state.lb.handleNameResolutionError(error);\n+      }\n+    }\n+    if (gotoTransientFailure) {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState state : childLbStates.values()) {\n+      state.shutdown();\n+    }\n+  }\n+\n+  private void updateOverallBalancingState() {\n+    ConnectivityState overallState = null;\n+    final Map<String, SubchannelPicker> childPickers = new HashMap<>();\n+    for (ChildLbState childLbState : childLbStates.values()) {\n+      if (childLbState.deactivated) {\n+        continue;\n+      }\n+      childPickers.put(childLbState.name, childLbState.currentPicker);\n+      overallState = aggregateState(overallState, childLbState.currentState);\n+    }\n+    if (overallState != null) {\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          String clusterName = args.getCallOptions().getOption(ROUTING_CLUSTER_NAME_KEY);\n+          SubchannelPicker delegate = childPickers.get(clusterName);\n+          if (delegate == null) {\n+            return\n+                PickResult.withError(\n+                    Status.UNAVAILABLE.withDescription(\"Unable to find cluster \" + clusterName));\n+          }\n+          return delegate.pickSubchannel(args);\n+        }\n+      };\n+      helper.updateBalancingState(overallState, picker);\n+    }\n+  }\n+\n+  @Nullable\n+  private static ConnectivityState aggregateState(\n+      @Nullable ConnectivityState overallState, ConnectivityState childState) {\n+    if (overallState == null) {\n+      return childState;\n+    }\n+    if (overallState == READY || childState == READY) {\n+      return READY;\n+    }\n+    if (overallState == CONNECTING || childState == CONNECTING) {\n+      return CONNECTING;\n+    }\n+    if (overallState == IDLE || childState == IDLE) {\n+      return IDLE;\n+    }\n+    return overallState;\n+  }\n+\n+  private final class ChildLbState {\n+    private final String name;\n+    private final GracefulSwitchLoadBalancer lb;\n+    private LoadBalancerProvider policyProvider;\n+    private ConnectivityState currentState = CONNECTING;\n+    private SubchannelPicker currentPicker = BUFFER_PICKER;\n+    private boolean deactivated;\n+    @Nullable\n+    ScheduledHandle deletionTimer;\n+\n+    ChildLbState(String name, LoadBalancerProvider policyProvider) {\n+      this.name = name;\n+      this.policyProvider = policyProvider;\n+      lb = new GracefulSwitchLoadBalancer(new ChildLbStateHelper());\n+      lb.switchTo(policyProvider);\n+    }\n+\n+    void deactivate() {\n+      if (deactivated) {\n+        return;\n+      }\n+\n+      class DeletionTask implements Runnable {\n+        @Override\n+        public void run() {\n+          shutdown();\n+          childLbStates.remove(name);\n+        }\n+      }\n+\n+      deletionTimer =\n+          syncContext.schedule(\n+              new DeletionTask(),\n+              DELAYED_ACTION_DELETION_TIME_MINUTES,\n+              TimeUnit.MINUTES,\n+              timeService);\n+      deactivated = true;\n+      logger.log(XdsLogLevel.DEBUG, \"Child balancer {0} deactivated\", name);\n+    }\n+\n+    void reactivate(LoadBalancerProvider policyProvider) {\n+      if (deletionTimer != null && deletionTimer.isPending()) {\n+        deletionTimer.cancel();\n+        deactivated = false;\n+        logger.log(XdsLogLevel.DEBUG, \"Child balancer {0} reactivated\", name);\n+      }\n+      if (!this.policyProvider.getPolicyName().equals(policyProvider.getPolicyName())) {\n+        logger.log(\n+            XdsLogLevel.DEBUG,\n+            \"Child balancer {0} switching policy from {1} to {2}\",\n+            name, this.policyProvider.getPolicyName(), policyProvider.getPolicyName());\n+        lb.switchTo(policyProvider);\n+        this.policyProvider = policyProvider;\n+      }\n+    }\n+\n+    void shutdown() {\n+      deactivated = true;\n+      if (deletionTimer != null && deletionTimer.isPending()) {\n+        deletionTimer.cancel();\n+      }\n+      lb.shutdown();\n+      logger.log(XdsLogLevel.DEBUG, \"Child balancer {0} deleted\", name);\n+    }\n+\n+    private final class ChildLbStateHelper extends ForwardingLoadBalancerHelper {\n+\n+      @Override\n+      public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+        if (deactivated) {", "originalCommit": "bcabf09e0eba9842493358bbeb15eba7be768059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTE4Mw==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456135183", "bodyText": "Good point. Fixed here.", "author": "voidzcy", "createdAt": "2020-07-16T23:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODkzNA==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456058934", "bodyText": "cds-lb?", "author": "dapengzhang0", "createdAt": "2020-07-16T20:30:00Z", "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));", "originalCommit": "bcabf09e0eba9842493358bbeb15eba7be768059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTE1NQ==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456135155", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2020-07-16T23:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA2MzgzNg==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456063836", "bodyText": "Declare variable for childLbStates.get(name) ahead of syncContext.execute(), otherwise childLbStates might have been mutated when `syncContext.execute() in extreme case.\nOr just run childLbStates.get(name).lb.handleResolvedAddresses(childAddresses) inline at the end of this method.", "author": "dapengzhang0", "createdAt": "2020-07-16T20:39:03Z", "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    ClusterManagerConfig config = (ClusterManagerConfig)\n+        resolvedAddresses.getLoadBalancingPolicyConfig();\n+    Map<String, PolicySelection> newChildPolicies = config.childPolicies;\n+    logger.log(\n+        XdsLogLevel.INFO,\n+        \"Received cluster_manager lb config: child names={0}\", newChildPolicies.keySet());\n+    for (Map.Entry<String, PolicySelection> entry : newChildPolicies.entrySet()) {\n+      final String name = entry.getKey();\n+      LoadBalancerProvider childPolicyProvider = entry.getValue().getProvider();\n+      Object childConfig = entry.getValue().getConfig();\n+      if (!childLbStates.containsKey(name)) {\n+        childLbStates.put(name, new ChildLbState(name, childPolicyProvider));\n+      } else {\n+        childLbStates.get(name).reactivate(childPolicyProvider);\n+      }\n+      final ResolvedAddresses childAddresses =\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(childConfig).build();\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          childLbStates.get(name).lb.handleResolvedAddresses(childAddresses);", "originalCommit": "bcabf09e0eba9842493358bbeb15eba7be768059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTI0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456135241", "bodyText": "Good point, this turns out to be a programming practice. Thanks. Fixed. Will change it in XdsRoutingLoadBalancer as well (although it will go away after XdsConfigSelector, we want it to be correct in the release).", "author": "voidzcy", "createdAt": "2020-07-16T23:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA2MzgzNg=="}], "type": "inlineReview"}, {"oid": "dea91462e48209d1abe46f45a9c9a783e3bfe304", "url": "https://github.com/grpc/grpc-java/commit/dea91462e48209d1abe46f45a9c9a783e3bfe304", "message": "Fix typos", "committedDate": "2020-07-16T23:09:24Z", "type": "commit"}, {"oid": "77717f12c887b8f4b1ae80f32fd498978c70f5a1", "url": "https://github.com/grpc/grpc-java/commit/77717f12c887b8f4b1ae80f32fd498978c70f5a1", "message": "Preserve updated picker/subchannel for deactivated child balancers.", "committedDate": "2020-07-16T23:30:07Z", "type": "commit"}, {"oid": "57cefab223cd7d5575749e187601d21912050062", "url": "https://github.com/grpc/grpc-java/commit/57cefab223cd7d5575749e187601d21912050062", "message": "Should call Update on the specific child balancer based on the time its config is updated in the parent balancer.", "committedDate": "2020-07-16T23:32:07Z", "type": "commit"}]}