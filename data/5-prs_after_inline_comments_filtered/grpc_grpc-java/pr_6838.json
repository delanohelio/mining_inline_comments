{"pr_number": 6838, "pr_title": "xds: integration of XdsClientImpl with XdsServerBuilder to deliver Listener updates", "pr_createdAt": "2020-03-18T17:25:41Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6838", "timeline": [{"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "url": "https://github.com/grpc/grpc-java/commit/27a7822898e9c1cfcabadef3c652e5a7c5707fde", "message": "xds: integration of XdsClientImpl with XdsServerBuilder to deliver Listener updates", "committedDate": "2020-03-18T17:23:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4NjkyMA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395486920", "bodyText": "Why you use an object pool? You are just creating an XdsClient instance in-place without sharing with other classes.", "author": "voidzcy", "createdAt": "2020-03-20T08:15:50Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+\n+    XdsClient.XdsClientFactory xdsClientFactory =\n+        new XdsClient.XdsClientFactory() {\n+          @Override\n+          XdsClient createXdsClient() {\n+            return new XdsClientImpl(\n+                \"\",\n+                serverList,\n+                XdsClient.XdsChannelFactory.getInstance(),\n+                node,\n+                syncContext,\n+                timeService,\n+                new ExponentialBackoffPolicy.Provider(),\n+                GrpcUtil.STOPWATCH_SUPPLIER);\n+          }\n+        };\n+    xdsClientPool = new XdsClient.RefCountedXdsClientObjectPool(xdsClientFactory);", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczMzMwOQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395733309", "bodyText": "You are right and my original prototype implementation didn't have the pool. When I adapted to the new XdsClientImpl I ended up using the existing pattern. I don't think there will be other classes needing to use a \"shared\" XdsClient on the server side so I will change this to the non-pool implementation.", "author": "sanjaypujare", "createdAt": "2020-03-20T15:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4NjkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4OTExMQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395489111", "bodyText": "I don't see any value of using a logId for this class.", "author": "voidzcy", "createdAt": "2020-03-20T08:21:02Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczNjEwNA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395736104", "bodyText": "Okay, this was really used in the syncContext definition and I used the pattern from elsewhere. I notice you have some comments on SynchronizationContext as well so once that is addressed this one hopefully will be addressed to.", "author": "sanjaypujare", "createdAt": "2020-03-20T16:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4OTExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MDA3NA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395490074", "bodyText": "The exception goes into nowhere except a log message. And this is a constructor. This pattern is bad.\nSame for other places, error handling/propagation in this class is in appropriate.", "author": "voidzcy", "createdAt": "2020-03-20T08:23:22Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1MTE1MQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395751151", "bodyText": "I would have agreed with you but look at the use-case: user uses XdsServerBuilder to build their gRPC server and it will try to use xDS to get the server credentials. If there is no bootstrap file I don't want the server build to fail but just to log a message and fall back to plain text (or fall back to fallback credential if we had one).\nSo in terms of logic I don't expect to do anything different but can look into refactoring because of your constructor concerns. Pls see my other comment as well.", "author": "sanjaypujare", "createdAt": "2020-03-20T16:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MDA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODIyOQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395788229", "bodyText": "can you handle the exception on the caller side? it may behave same, but there won't be any surprise.", "author": "creamsoup", "createdAt": "2020-03-20T17:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MDA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MjczNQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395492735", "bodyText": "If nothing to do, just don't implement it.", "author": "voidzcy", "createdAt": "2020-03-20T08:29:11Z", "path": "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+import com.google.common.base.Strings;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.netty.channel.Channel;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Tests for {@link XdsClientWrapperForServerSds}. */\n+@RunWith(JUnit4.class)\n+public class XdsClientWrapperForServerSdsTest {\n+\n+  private static final int PORT = 7000;\n+\n+  @Mock private XdsClient xdsClient;\n+  @Mock private Channel channel;\n+\n+  private XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n+  private DownstreamTlsContext tlsContext1;\n+  private DownstreamTlsContext tlsContext2;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    xdsClientWrapperForServerSds = new XdsClientWrapperForServerSds(PORT, xdsClient);\n+    tlsContext1 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT1\", \"VA1\");\n+    tlsContext2 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT2\", \"VA2\");\n+  }\n+\n+  @Test\n+  public void verifyListenerWatcherRegistered() {\n+    verify(xdsClient, times(1)).watchListenerData(eq(PORT), any(XdsClient.ListenerWatcher.class));\n+  }\n+\n+  @Test\n+  public void listener_nullFilterChainMatch1() throws UnknownHostException {\n+    // filterChainMatch missing for filter1, so it matches and returns tlsContext1\n+    commonFilterChainMatchTest(-1, null, null, \"192.168.10.1\", \"192.168.10.2\", tlsContext1);\n+  }\n+\n+  @Test\n+  public void listener_destPortMatchNoAddressPrefix() throws UnknownHostException {\n+    // destPort matches for filter2 even if no cidrRange, so it returns tlsContext2\n+    commonFilterChainMatchTest(PORT + 1, \"192.168.10.1\", \"192.168.10.2\", null, null, tlsContext2);\n+  }\n+\n+  @Test\n+  public void listener_destPortAndAddressPrefixMatch() throws UnknownHostException {\n+    // destPort and cidrRange exact match for filter1, so it returns tlsContext1\n+    commonFilterChainMatchTest(\n+        PORT, \"168.20.20.2\", \"10.1.2.3\", \"192.168.10.1\", \"192.168.10.2\", tlsContext1);\n+  }\n+\n+  @Test\n+  public void listener_emptyAddressRangeOverEmptyFilterChainMatch() throws UnknownHostException {\n+    // existing filterChain with empty address preferred over empty filterChain\n+    commonFilterChainMatchTest(-1, null, null, null, null, tlsContext2);\n+  }\n+\n+  @Test\n+  public void listener_cidrRangeIpAnyOverEmptyAddressRange() throws UnknownHostException {\n+    // IPANY (0.0.0.0) preferred over empty address range\n+    commonFilterChainMatchTest(\n+        PORT,\n+        null,\n+        null,\n+        \"192.168.1.4\",\n+        \"0.0.0.0\",\n+        tlsContext2); // IPANY to make second filterChain selected\n+  }\n+\n+  @Test\n+  public void listener_CidrRangeIpExactOverCidrRangeIpAny() throws UnknownHostException {\n+    // exact address match preferred over IPANY (0.0.0.0)\n+    commonFilterChainMatchTest(\n+        PORT,\n+        \"192.168.1.4\",\n+        \"0.0.0.0\",\n+        \"168.154.4.7\",\n+        \"10.1.2.3\",\n+        tlsContext2); // Matching IP to make second filterChain selected\n+  }\n+\n+  @Test\n+  public void listener_destPortAndAddressPrefixNoMatch() throws UnknownHostException {\n+    // when none matches it should return null\n+    commonFilterChainMatchTest(\n+        PORT, \"168.20.20.2\", \"10.1.2.4\", \"192.168.10.1\", \"192.168.10.2\", null);\n+  }\n+\n+  /**\n+   * Common method called by most tests. Creates 2 filterChains each with 2 addresses. First\n+   * filterChain's destPort is always PORT.\n+   *\n+   * @param destPort1 dest port of 1st filterChain\n+   * @param addressPrefix11 1st address of 1st filter\n+   * @param addressPrefix12 2nd address of 1st filter\n+   * @param addressPrefix21 1st address of 2nd filter\n+   * @param addressPrefix22 2nd address of 2nd filter\n+   * @param expectedTlsContext expected DownstreamTlsContext for the test\n+   */\n+  private void commonFilterChainMatchTest(\n+      int destPort1,\n+      String addressPrefix11,\n+      String addressPrefix12,\n+      String addressPrefix21,\n+      String addressPrefix22,\n+      DownstreamTlsContext expectedTlsContext)\n+      throws UnknownHostException {\n+    ArgumentCaptor<XdsClient.ListenerWatcher> listenerWatcherCaptor = ArgumentCaptor.forClass(null);\n+    verify(xdsClient).watchListenerData(eq(PORT), listenerWatcherCaptor.capture());\n+    XdsClient.ListenerWatcher registeredWatcher = listenerWatcherCaptor.getValue();\n+    InetAddress ipLocalAddress = Inet4Address.getByName(\"10.1.2.3\");\n+    InetSocketAddress localAddress = new InetSocketAddress(ipLocalAddress, PORT);\n+    when(channel.localAddress()).thenReturn(localAddress);\n+    EnvoyServerProtoData.Listener listener =\n+        buildTestListener(\n+            \"listener1\",\n+            \"10.1.2.3\",\n+            destPort1,\n+            PORT,\n+            addressPrefix11,\n+            addressPrefix12,\n+            addressPrefix21,\n+            addressPrefix22);\n+    XdsClient.ListenerUpdate listenerUpdate =\n+        XdsClient.ListenerUpdate.newBuilder().setListener(listener).build();\n+    registeredWatcher.onListenerChanged(listenerUpdate);\n+    DownstreamTlsContext downstreamTlsContext =\n+        xdsClientWrapperForServerSds.getDownstreamTlsContext(channel);\n+    assertThat(downstreamTlsContext).isSameInstanceAs(expectedTlsContext);\n+  }\n+\n+  @After\n+  public void tearDown() {}", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODQ4Mg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395498482", "bodyText": "Not sure if creating a sync context here is appropriate. The whole control plane workflow should use a single sync context, it should not be something to be created just because you need it. You need to consider the whole server side flow.", "author": "voidzcy", "createdAt": "2020-03-20T08:42:57Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMzg2MQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395833861", "bodyText": "I looked at the client side and over there a sync context is created by a ManagedChannelImpl  and used everywhere starting from the name-resolver, load-balancers, and the XdsClient as well. So you have one sync context per managed channel. In this case (server side), there is currently no sync context being created because one wasn't needed on the server side so far. So I ended up creating it in this class which associates one sync context with one server (listener) and that cardinality seems correct. But may be the correct place to create this sync context is in the server builder and plumb the value all the way down here instead of creating it here. Let me know if you agree.", "author": "sanjaypujare", "createdAt": "2020-03-20T18:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0MDEzMg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395840132", "bodyText": "Would need suggestion from @creamsoup", "author": "voidzcy", "createdAt": "2020-03-20T19:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyNzc3NA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395927774", "bodyText": "@creamsoup lmk if you have comments here", "author": "sanjaypujare", "createdAt": "2020-03-20T23:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395498743", "bodyText": "It's usually a bad practice to do so much in constructor.", "author": "voidzcy", "createdAt": "2020-03-20T08:43:37Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0MTk5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395741996", "bodyText": "I'll see if this can be refactored into a separate init method but it will have to be in this class because this is the bridge between XdsClientImpl and SdsProtocolNegotiators. This is a wrapper for XdsClientImpl and needs to do most of the \"setting up\" kind of stuff that classes like XdsNameResolver are doing. If the constructor call is going to be immediately followed by init I am not sure it makes that much of difference. Let me know your thoughts.", "author": "sanjaypujare", "createdAt": "2020-03-20T16:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4NDk2NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395784965", "bodyText": "imo init is worse. can you move some of the prep work to the caller side or factory?", "author": "creamsoup", "createdAt": "2020-03-20T17:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODk5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395888996", "bodyText": "Prefer factory than putting it in the caller.", "author": "sanjaypujare", "createdAt": "2020-03-20T21:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTQxMg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395889412", "bodyText": "can you move some of the prep work to the caller side or factory?\n\nYes, this is what I was thinking about.", "author": "voidzcy", "createdAt": "2020-03-20T21:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjE3NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395812175", "bodyText": "passing channel around doesn't seem like a good idea. can you change to local address?", "author": "creamsoup", "createdAt": "2020-03-20T18:14:09Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+\n+    XdsClient.XdsClientFactory xdsClientFactory =\n+        new XdsClient.XdsClientFactory() {\n+          @Override\n+          XdsClient createXdsClient() {\n+            return new XdsClientImpl(\n+                \"\",\n+                serverList,\n+                XdsClient.XdsChannelFactory.getInstance(),\n+                node,\n+                syncContext,\n+                timeService,\n+                new ExponentialBackoffPolicy.Provider(),\n+                GrpcUtil.STOPWATCH_SUPPLIER);\n+          }\n+        };\n+    xdsClientPool = new XdsClient.RefCountedXdsClientObjectPool(xdsClientFactory);\n+    xdsClient = xdsClientPool.getObject();\n+    setClientAndWatcher(port);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    this.xdsClient = xdsClient;\n+    setClientAndWatcher(port);\n+  }\n+\n+  private void setClientAndWatcher(int port) {\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), channel);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(FilterChainMatch filterChainMatch, Channel channel) {", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MTk2NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395891965", "bodyText": "In the original filterChainMatch (from proto) there are other fields like the remote address,  which will ideally need to be matched with the remote address, remote port in the Channel. Trying to implement all the logic now seems like an overkill now since most filterChainMatch don't use it but it makes sense to pass Channel instead of separate fields from the Channel. Agree?", "author": "sanjaypujare", "createdAt": "2020-03-20T21:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NjU4NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395896585", "bodyText": "it is a private method so we can always change if we need more fields. also, if you use comparator it may look very different.", "author": "creamsoup", "createdAt": "2020-03-20T21:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMDU3Mg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395930572", "bodyText": "Yes, with comparator it will use localAddress now and Channel later.", "author": "sanjaypujare", "createdAt": "2020-03-20T23:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395820489", "bodyText": "score based sort error prone. can you use Collections.max with comparator?", "author": "creamsoup", "createdAt": "2020-03-20T18:30:30Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+\n+    XdsClient.XdsClientFactory xdsClientFactory =\n+        new XdsClient.XdsClientFactory() {\n+          @Override\n+          XdsClient createXdsClient() {\n+            return new XdsClientImpl(\n+                \"\",\n+                serverList,\n+                XdsClient.XdsChannelFactory.getInstance(),\n+                node,\n+                syncContext,\n+                timeService,\n+                new ExponentialBackoffPolicy.Provider(),\n+                GrpcUtil.STOPWATCH_SUPPLIER);\n+          }\n+        };\n+    xdsClientPool = new XdsClient.RefCountedXdsClientObjectPool(xdsClientFactory);\n+    xdsClient = xdsClientPool.getObject();\n+    setClientAndWatcher(port);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    this.xdsClient = xdsClient;\n+    setClientAndWatcher(port);\n+  }\n+\n+  private void setClientAndWatcher(int port) {\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), channel);", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NDQxMg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395894412", "bodyText": "Can you give me some idea why this approach is more error prone? Errors are possible with computation of the score (or heuristics involved in assigning a score) but I don't see why Collections.max is better (except in cases where you have multiple max candidates and there is some logic about which one to pick). Also we don't need elaborate sort/select algorithm as I don't see the control plane sending more than one or two with complex selection criterion.", "author": "sanjaypujare", "createdAt": "2020-03-20T21:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5OTg1MA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395899850", "bodyText": "it is maybe not as error prone as it is (although it is harder to read the code). when you try to modify, it can be very hard to keep everything aligned (how many methods here need to be modified to add new logic?). thus, those score has no meaning and it only makes reader/maintainer confused. if you implement it as comparator, it is easy to add new logic. this it doesn't have any performance penalty in terms of big O.\ni tried to do the same thing before. and, i got same comment which I now agree.", "author": "creamsoup", "createdAt": "2020-03-20T21:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMDM2Mg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395930362", "bodyText": "Okay, just to clarify: you are saying to ditch the whole idea of scores and just compare 2 filterChains for a given channel? So initialize the Comparator with the channel and then given 2 filterChains pick one? That's interesting and let me think about it. In any case I think is probably overkill for the number of filterChains we will be expected to compare (in most cases just 1?) But I'll definitely consider it", "author": "sanjaypujare", "createdAt": "2020-03-20T23:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNTQxMA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396115410", "bodyText": "Collections.max with comparator doesn't work here. There may not be a matching filter at all in which case we need to return null and that's not handled by max (which returns one as max even if they are all same). One can add a post-check but seems unnecessary especially when we don't expect multiple filters from the control plane. Not making any changes", "author": "sanjaypujare", "createdAt": "2020-03-22T16:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MzExMA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396673110", "bodyText": "post check is what i was expecting. this is relatively minor issue compare to the score based approach.", "author": "creamsoup", "createdAt": "2020-03-23T18:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3OTM4OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396679389", "bodyText": "@creamsoup Honestly I think the Comparator here is an overkill assuming the control plane will mostly give us a single filterChain matching our requirements. The multiple filterChains happens with Envoy (since it's a proxy) but most likely won't happen with proxyless gRPC. I still need to confirm with the control plane team and if that is confirmed I can even remove the current logic and error in case of multiple filters and verify the single filter returned matches what I need.", "author": "sanjaypujare", "createdAt": "2020-03-23T18:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NDIxOA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396684218", "bodyText": "i know it can be tedious to covert but it is not hard nor overkill (compare to score based) while it makes the code more maintainable/readable.", "author": "creamsoup", "createdAt": "2020-03-23T18:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcwMjc5MQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396702791", "bodyText": "I spent a whole afternoon on it and I realized I still have to compute scores for doing a match :-) We can discuss offline to discuss the details. If the control plane sends only one filterChain then there is no need to implement a matcher and we can just error out when multiple are received. Do you agree?", "author": "sanjaypujare", "createdAt": "2020-03-23T19:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcxNzUzNw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396717537", "bodyText": "okay if we don't need to compare, problem solved.\nI am not sure about it is desired behavior or not. how confident are we that the control plain will only send 1 filterChain (including in near future)?", "author": "creamsoup", "createdAt": "2020-03-23T19:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc2NjUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396766521", "bodyText": "So I am talking to the control plane team to find out how many filterChains I can expect to get. If it is just 1 (or max 2) I don't see why spend so much time on the Comparator. But I have opened this again (marked it not resolved) and will get back to this after addressing all the other comments. By that time I would have some answers and hopefully a clearer idea about which way to go and we can discuss offline if nedeed.", "author": "sanjaypujare", "createdAt": "2020-03-23T21:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzNTU3MQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397335571", "bodyText": "So it looks like the planned interface will take some time to be implemented on the control plane side so we still need to be prepared to handle multiple filterChains on our side. But the bottom line is that there will be exactly one filterChain that will be a match for the localAddress where destPort, localIPaddress will match and there is no need to implement either a score or sorting based selection of filterChain. So that is my plan for now: select the filterChain that perfectly matches my localAddress or else report error.", "author": "sanjaypujare", "createdAt": "2020-03-24T17:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY0MTIzNg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397641236", "bodyText": "So I ended up implementing the Comparator as per the suggestion here. PTAL", "author": "sanjaypujare", "createdAt": "2020-03-25T06:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMzIxMg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395823212", "bodyText": "eventLoopGroupResource can be null, it should be handled.", "author": "creamsoup", "createdAt": "2020-03-20T18:35:58Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDU4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395824587", "bodyText": "the argument name is not changed?", "author": "creamsoup", "createdAt": "2020-03-20T18:38:42Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -63,12 +65,12 @@ public static ProtocolNegotiatorFactory clientProtocolNegotiatorFactory(\n \n   /**\n    * Creates an SDS based {@link ProtocolNegotiator} for a {@link io.grpc.netty.NettyServerBuilder}.\n-   * Passing {@code null} for downstreamTlsContext will fall back to plaintext.\n+   * Passing {@code null} for downstreamTlsContextFromBuilder will fall back to plaintext.", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDc3Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395824773", "bodyText": "what is the port for? need some documentation.", "author": "creamsoup", "createdAt": "2020-03-20T18:39:06Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -63,12 +65,12 @@ public static ProtocolNegotiatorFactory clientProtocolNegotiatorFactory(\n \n   /**\n    * Creates an SDS based {@link ProtocolNegotiator} for a {@link io.grpc.netty.NettyServerBuilder}.\n-   * Passing {@code null} for downstreamTlsContext will fall back to plaintext.\n+   * Passing {@code null} for downstreamTlsContextFromBuilder will fall back to plaintext.\n    */\n   // TODO (sanjaypujare) integrate with xDS client to get LDS\n   public static ProtocolNegotiator serverProtocolNegotiator(\n-      @Nullable DownstreamTlsContext downstreamTlsContext) {\n-    return new ServerSdsProtocolNegotiator(downstreamTlsContext);\n+      @Nullable DownstreamTlsContext downstreamTlsContext, int port) {", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MzE5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395863196", "bodyText": "can you add doc for the new behavior (fall back to plaintext)?", "author": "creamsoup", "createdAt": "2020-03-20T20:01:08Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -63,12 +65,12 @@ public static ProtocolNegotiatorFactory clientProtocolNegotiatorFactory(\n \n   /**\n    * Creates an SDS based {@link ProtocolNegotiator} for a {@link io.grpc.netty.NettyServerBuilder}.", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MzM4Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395863383", "bodyText": "can you add logging if it falls back to plaintext", "author": "creamsoup", "createdAt": "2020-03-20T20:01:36Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -294,11 +293,29 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n           });\n       checkNotNull(grpcHandler, \"grpcHandler\");\n       this.grpcHandler = grpcHandler;\n-      this.downstreamTlsContext = downstreamTlsContext;\n+      this.downstreamTlsContextFromBuilder = downstreamTlsContext;\n+      this.xdsClientWrapperForServerSds = xdsClientWrapperForServerSds;\n+    }\n+\n+    private static boolean isTlsContextEmpty(DownstreamTlsContext downstreamTlsContext) {\n+      return downstreamTlsContext == null || !downstreamTlsContext.hasCommonTlsContext();\n     }\n \n     @Override\n     protected void handlerAdded0(final ChannelHandlerContext ctx) {\n+      DownstreamTlsContext downstreamTlsContext =\n+          xdsClientWrapperForServerSds == null\n+              ? null\n+              : xdsClientWrapperForServerSds.getDownstreamTlsContext(ctx.channel());\n+      if (isTlsContextEmpty(downstreamTlsContext)) {\n+        downstreamTlsContext = downstreamTlsContextFromBuilder;\n+      }\n+      if (isTlsContextEmpty(downstreamTlsContext)) {", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2NTM2Nw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395865367", "bodyText": "we would love to make ProtocolNegotiationHandler as small as possible. can you make a new handler that decides which negotiator to use (plaintext/sds)?", "author": "creamsoup", "createdAt": "2020-03-20T20:06:12Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -294,11 +293,29 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n           });\n       checkNotNull(grpcHandler, \"grpcHandler\");\n       this.grpcHandler = grpcHandler;\n-      this.downstreamTlsContext = downstreamTlsContext;\n+      this.downstreamTlsContextFromBuilder = downstreamTlsContext;\n+      this.xdsClientWrapperForServerSds = xdsClientWrapperForServerSds;\n+    }\n+\n+    private static boolean isTlsContextEmpty(DownstreamTlsContext downstreamTlsContext) {\n+      return downstreamTlsContext == null || !downstreamTlsContext.hasCommonTlsContext();\n     }\n \n     @Override\n     protected void handlerAdded0(final ChannelHandlerContext ctx) {", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyNzE4OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395927189", "bodyText": "Sounds like a good idea. How about if I create a TODO task for a separate PR? So this PR doesn't have too many changes.", "author": "sanjaypujare", "createdAt": "2020-03-20T23:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2NTM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyOTYwMw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395929603", "bodyText": "this should be relatively simple change (okay maybe some boiler plates, but this way will be helpful when you need to debug), i don't see why we want to delay.", "author": "creamsoup", "createdAt": "2020-03-20T23:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2NTM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMzk4Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395933983", "bodyText": "Yes, it is actually not that difficult. And with your other suggestion about handling exception(s) in the caller for xdsClientWrapperForServerSds, this change goes well with that. So I'll do it in this one", "author": "sanjaypujare", "createdAt": "2020-03-20T23:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2NTM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2ODg0Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395868843", "bodyText": "this is harder to read. consider parameterized test.", "author": "creamsoup", "createdAt": "2020-03-20T20:14:38Z", "path": "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+import com.google.common.base.Strings;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.netty.channel.Channel;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Tests for {@link XdsClientWrapperForServerSds}. */\n+@RunWith(JUnit4.class)\n+public class XdsClientWrapperForServerSdsTest {\n+\n+  private static final int PORT = 7000;\n+\n+  @Mock private XdsClient xdsClient;\n+  @Mock private Channel channel;\n+\n+  private XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n+  private DownstreamTlsContext tlsContext1;\n+  private DownstreamTlsContext tlsContext2;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    xdsClientWrapperForServerSds = new XdsClientWrapperForServerSds(PORT, xdsClient);\n+    tlsContext1 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT1\", \"VA1\");\n+    tlsContext2 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT2\", \"VA2\");\n+  }\n+\n+  @Test\n+  public void verifyListenerWatcherRegistered() {\n+    verify(xdsClient, times(1)).watchListenerData(eq(PORT), any(XdsClient.ListenerWatcher.class));\n+  }\n+\n+  @Test\n+  public void listener_nullFilterChainMatch1() throws UnknownHostException {\n+    // filterChainMatch missing for filter1, so it matches and returns tlsContext1\n+    commonFilterChainMatchTest(-1, null, null, \"192.168.10.1\", \"192.168.10.2\", tlsContext1);", "originalCommit": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyMzU5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395923593", "bodyText": "You mean org.junit.runners.Parameterized ? I prefer adding more comments to the existing code to make it more readable.", "author": "sanjaypujare", "createdAt": "2020-03-20T22:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2ODg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyNjQwMQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395926401", "bodyText": "requires comment means it is not readable. the code structure is already ready to be converted to parameterized. anyways, i'll leave it up to you as long as it is readable.", "author": "creamsoup", "createdAt": "2020-03-20T23:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2ODg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyODk3Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395928973", "bodyText": "With parameterized, it is helpful if parameter values tell you what the test is. In this case one needs to know more. e.g. passing null for certain params doesn't convey anything. But I'll give it some more thought.", "author": "sanjaypujare", "createdAt": "2020-03-20T23:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2ODg0Mw=="}], "type": "inlineReview"}, {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181", "url": "https://github.com/grpc/grpc-java/commit/3929209c69c9982d73bc0728ac8844cbc66e9181", "message": "address review comments", "committedDate": "2020-03-23T00:48:23Z", "type": "commit"}, {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181", "url": "https://github.com/grpc/grpc-java/commit/3929209c69c9982d73bc0728ac8844cbc66e9181", "message": "address review comments", "committedDate": "2020-03-23T00:48:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396646680", "bodyText": "I doubt the usage of NoSuchElementException here and IllegalStateException below. Error handling still looks a bit abrupt, basically it would panic immediately when encountering those cases. @creamsoup Does server side have any error propagation APIs?", "author": "voidzcy", "createdAt": "2020-03-23T17:57:29Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");", "originalCommit": "3929209c69c9982d73bc0728ac8844cbc66e9181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NzM5Mg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396657392", "bodyText": "No these are caught by the caller where it will switch over to plaintext. As mentioned elsewhere there is no error propagation/error listener similar to what you have on the client side.", "author": "sanjaypujare", "createdAt": "2020-03-23T18:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODk1OA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396658958", "bodyText": "netty installs WriteBufferingAndExceptionHandler which handles exception. but, this specific exception happens on XdsServerBuilder#build.", "author": "creamsoup", "createdAt": "2020-03-23T18:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyNTExNQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396725115", "bodyText": "No these are caught by the caller where it will switch over to plaintext. As mentioned elsewhere there is no error propagation/error listener similar to what you have on the client side.\n\nI still do not follow where these runtime exceptions are handled other than abruptly panic the workflow.", "author": "voidzcy", "createdAt": "2020-03-23T20:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNzg4MA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396737880", "bodyText": "https://github.com/grpc/grpc-java/pull/6838/files#diff-fe0356a9c9642d0f91961b377c24e5d3R265 line 265 in SdsProtocolNegotiators.java (in this commit). Just follow calls to XdsClientWrapperForServerSds.newInstance.", "author": "sanjaypujare", "createdAt": "2020-03-23T20:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1MDEyNw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396750127", "bodyText": "That's catching the IOException. I am talking about NoSuchElementException here and IllegalStateException exception below. They are not gracefully handled. It panic the server indefinitely once getting into those situations.", "author": "voidzcy", "createdAt": "2020-03-23T20:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1Nzc2Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396757766", "bodyText": "Good point, thanks for catching that. The IllegalStateException will go away since I will use ScheduledThreadPoolExecutor as we discussed in the other thread. And I will handle NoSuchElementException (or whatever is suitable type of exception for that case).", "author": "sanjaypujare", "createdAt": "2020-03-23T21:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396625737", "bodyText": "this basically means, it will only work on linux. this is expected?\nalso, XdsClientImpl expects ScheduledExecutorService, eventloop is good but with those limitation i am not sure why we want to use eventloop here?", "author": "creamsoup", "createdAt": "2020-03-23T17:26:25Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());", "originalCommit": "3929209c69c9982d73bc0728ac8844cbc66e9181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2NjE3Nw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396666177", "bodyText": "Good point! If Epoll is not available would it be a good idea to use DefaultEventLoopGroup ? Or ScheduledThreadPoolExecutor ? @voidzcy for the XdsClientImpl what will be better?", "author": "sanjaypujare", "createdAt": "2020-03-23T18:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NDA0Mg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396674042", "bodyText": "if we can reuse one from XdsClientImpl that would be the best. i think ScheduledThreadPoolExecutor is better than DefaultEventLoopGroup.", "author": "creamsoup", "createdAt": "2020-03-23T18:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNTkyNg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396735926", "bodyText": "reuse which one from XdsClientImpl? XdsClientImpl  doesn't have one of its own and I am passing one to it while creating a XdsClientImpl and there is no other XdsClientImpl instance to reuse it from unless I am missing something. I will use ScheduledThreadPoolExecutor.", "author": "sanjaypujare", "createdAt": "2020-03-23T20:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNzU0OA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396737548", "bodyText": "it was more generic comment. yes please use the ScheduledThreadPoolExecutor.", "author": "creamsoup", "createdAt": "2020-03-23T20:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczOTcyNA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396739724", "bodyText": "I mean XdsClientImpl just takes in a ScheduledExecutorService, with whatever its concrete implementation is. It doesn't matter from XdsClientImpl's perspective.", "author": "voidzcy", "createdAt": "2020-03-23T20:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzA1NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396747055", "bodyText": "@voidzcy I think there is some miscommunication here. I know XdsClientImpl takes a ScheduledExecutorService and I (as the creator of that object) pass a concrete implementation. When @creamsoup mentioned \"we can reuse one from XdsClientImpl that would be the best\" there isn't anything to reuse so that part threw me off. The plan now is to  use ScheduledThreadPoolExecutor. I hope we are all on the same page.", "author": "sanjaypujare", "createdAt": "2020-03-23T20:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0OTEyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396749121", "bodyText": "Oh  BTW, if @creamsoup meant, do the same thing the current client side user of XdsClientImpl does then that is what I did (after tracing laboriously where it came from via XdsNameResolver etc). I don't have the reference handy and I cannot see what it does when epoll is not available.", "author": "sanjaypujare", "createdAt": "2020-03-23T20:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1NDI5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396754296", "bodyText": "I am following. I thought you were gonna change XdsClientImpl and @creamsoup suggested we are able to \"reuse\" the existing code as is.  So nvm.", "author": "voidzcy", "createdAt": "2020-03-23T21:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1ODc0OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396758749", "bodyText": "since it accepts a ScheduledExecutorService I never intended to change XdsClientImpl. Anyway looks like this is all settled now", "author": "sanjaypujare", "createdAt": "2020-03-23T21:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzMjUxOA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396632518", "bodyText": "mark it @Nullable", "author": "creamsoup", "createdAt": "2020-03-23T17:36:11Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {", "originalCommit": "3929209c69c9982d73bc0728ac8844cbc66e9181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNTcwNg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396635706", "bodyText": "can simplify with checkState(predicate, msg);", "author": "creamsoup", "createdAt": "2020-03-23T17:41:13Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      if (!(localAddress instanceof InetSocketAddress)) {\n+        return null;\n+      }\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      if (port != localInetAddr.getPort()) {", "originalCommit": "3929209c69c9982d73bc0728ac8844cbc66e9181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNzEyNQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396637125", "bodyText": "this is still score based. i thought you will use Comparable?", "author": "creamsoup", "createdAt": "2020-03-23T17:43:13Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      if (!(localAddress instanceof InetSocketAddress)) {\n+        return null;\n+      }\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      if (port != localInetAddr.getPort()) {\n+        throw new IllegalStateException(\n+            \"Channel localAddress port does not match requested listener port\");\n+      }\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);", "originalCommit": "3929209c69c9982d73bc0728ac8844cbc66e9181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2ODM2MA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396668360", "bodyText": "Did you see my other comment #6838 (comment) ?", "author": "sanjaypujare", "createdAt": "2020-03-23T18:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNzEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NDE3Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396674176", "bodyText": "commented on the other one.", "author": "creamsoup", "createdAt": "2020-03-23T18:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNzEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NDMzOA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396644338", "bodyText": "protocol negotiation is event based. the ServerSdsHandler doesn't follow the pattern because of its unique requirement. the HandlerPickerHanlder should follow the general structure using ProtocolNegotiationEvent see alts/tls protocol negotiator for more detail.", "author": "creamsoup", "createdAt": "2020-03-23T17:54:04Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -260,28 +276,79 @@ public AsciiString scheme() {\n \n     @Override\n     public ChannelHandler newHandler(GrpcHttp2ConnectionHandler grpcHandler) {\n-      if (isTlsContextEmpty(downstreamTlsContext)) {\n-        return InternalProtocolNegotiators.serverPlaintext().newHandler(grpcHandler);\n-      }\n-      return new ServerSdsHandler(grpcHandler, downstreamTlsContext);\n+      return new HandlerPickerHandler(grpcHandler, downstreamTlsContext,", "originalCommit": "3929209c69c9982d73bc0728ac8844cbc66e9181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "url": "https://github.com/grpc/grpc-java/commit/8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "message": "address review comment: second set", "committedDate": "2020-03-24T01:50:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyMjA0OA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397322048", "bodyText": "nit: rephrase the error message. This is above-DEBUG-level logging, so it should be semantically meaningful to readers. It should be something like \"Failed to ...\". Also, \"SEVER\" means something is very broken and the system is probably panic. But it turns out we are still able to proceed by falling back to plaintext. I think if something required is missing and we have nothing to do, we just let it panic and halt. But if we do have alternative to recover, it may just be a warning.\nSame thing may apply for other log messages.", "author": "voidzcy", "createdAt": "2020-03-24T17:10:45Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -245,12 +253,21 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n \n   private static final class ServerSdsProtocolNegotiator implements ProtocolNegotiator {\n \n-    // TODO (sanjaypujare) integrate with xDS client to get LDS. LDS watcher will\n-    // inject/update the downstreamTlsContext from LDS\n     private DownstreamTlsContext downstreamTlsContext;\n+    private final XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n \n-    ServerSdsProtocolNegotiator(DownstreamTlsContext downstreamTlsContext) {\n+    ServerSdsProtocolNegotiator(\n+        DownstreamTlsContext downstreamTlsContext, int port, SynchronizationContext syncContext) {\n       this.downstreamTlsContext = downstreamTlsContext;\n+      XdsClientWrapperForServerSds localXdsClientWrapperForServerSds;\n+      try {\n+        localXdsClientWrapperForServerSds =\n+            XdsClientWrapperForServerSds.newInstance(port, Bootstrapper.getInstance(), syncContext);\n+      } catch (Exception e) {\n+        logger.log(Level.SEVERE, \"XdsClientWrapperForServerSds constructor\", e);", "originalCommit": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyOTcyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397329721", "bodyText": "nit: this will be printed as just \"Shutdown\", without anything else. It doesn't give any useful information.\nAlso, I doubt there should be any log messages above INFO level as anything above (or equal) INFO level will be printed out by default.", "author": "voidzcy", "createdAt": "2020-03-24T17:21:41Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      checkState(\n+          localAddress instanceof InetSocketAddress,\n+          \"Channel localAddress is expected to be InetSocketAddress\");\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      checkState(\n+          port == localInetAddr.getPort(),\n+          \"Channel localAddress port does not match requested listener port\");\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(\n+      FilterChainMatch filterChainMatch, InetSocketAddress localInetAddr) {\n+    if (filterChainMatch == null) {\n+      return 1;\n+    }\n+    if (filterChainMatch.getDestinationPort() != localInetAddr.getPort()) {\n+      return -1;\n+    }\n+    return getIpAddressAndRangesMatchScore(\n+        localInetAddr.getAddress(), filterChainMatch.getPrefixRanges());\n+  }\n+\n+  /**\n+   * Computes a score for IP address match against a list of CidrRange called only after ports have\n+   * matched, so a minimum score of 2 is returned to indicate a match or else -1 for a mismatch.\n+   *\n+   * <p>-1 => mismatch.\n+   *\n+   * <p>2 => prefixRanges is null/empty, so no IP address to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getIpAddressAndRangesMatchScore(\n+      InetAddress localAddress, List<CidrRange> prefixRanges) {\n+    if (prefixRanges == null || prefixRanges.isEmpty()) {\n+      return 2;\n+    }\n+    int highestScore = -1;\n+    for (CidrRange cidrRange : prefixRanges) {\n+      int curScore = getIpAddressMatchScore(localAddress, cidrRange);\n+      if (curScore > highestScore) {\n+        highestScore = curScore;\n+      }\n+    }\n+    return highestScore;\n+  }\n+\n+  /**\n+   * Computes a score for IP address to CidrRange match.\n+   *\n+   * <p>-1 => mismatch\n+   *\n+   * <p>0 => unimplemented (prefixLen < 32 logic)\n+   *\n+   * <p>4 => match because cidrRange is IPANY_ADDRESS (0.0.0.0)\n+   *\n+   * <p>8 => exact match\n+   */\n+  private static int getIpAddressMatchScore(InetAddress localAddress, CidrRange cidrRange) {\n+    if (cidrRange.getPrefixLen() == 32) {\n+      try {\n+        InetAddress cidrAddr = InetAddress.getByName(cidrRange.getAddressPrefix());\n+        if (cidrAddr.isAnyLocalAddress()) {\n+          return 4;\n+        }\n+        if (cidrAddr.equals(localAddress)) {\n+          return 8;\n+        }\n+        return -1;\n+      } catch (UnknownHostException e) {\n+        logger.log(Level.SEVERE, \"cidrRange address parsing\", e);\n+      }\n+    }\n+    // TODO(sanjaypujare): implement CIDR logic to match prefixes if needed\n+    return 0;\n+  }\n+\n+  /** Shutdown this instance and release resources. */\n+  public void shutdown() {\n+    logger.log(Level.INFO, \"Shutdown\");", "originalCommit": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjU4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397606587", "bodyText": "So all the *dsLoadBalancer.shutdown() (e.g. CdsLoadBalancer.shutdown) have this:\n  public void shutdown() {\n    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n...\n}\n\nAgreed XdsLogLevel.INFO is not the same as Level.INFO  but they all say \"Shutdown\" so being consistent. I am changing from INFO to FINER .", "author": "sanjaypujare", "createdAt": "2020-03-25T04:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyOTcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1NDg4OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397654889", "bodyText": "xDS policies (e.g., CdsLoadBalancer) uses XdsLogger, which prepends a unique LogId to the log message. So logging \"Shutdown\" really would print out \"[cds-lb] Shutdown\". But here, when seeing a \"Shutdown\" log message, we have no clue (unless the class name is shown) what is being shut down. Not a big issue.", "author": "voidzcy", "createdAt": "2020-03-25T07:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyOTcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MDIzMg==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397970232", "bodyText": "each log line output has the classname and method as the prefix so users know where this message is coming from.", "author": "sanjaypujare", "createdAt": "2020-03-25T15:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyOTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMDg1Mw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397330853", "bodyText": "nit: delete your personal note.", "author": "voidzcy", "createdAt": "2020-03-24T17:23:19Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      checkState(\n+          localAddress instanceof InetSocketAddress,\n+          \"Channel localAddress is expected to be InetSocketAddress\");\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      checkState(\n+          port == localInetAddr.getPort(),\n+          \"Channel localAddress port does not match requested listener port\");\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(\n+      FilterChainMatch filterChainMatch, InetSocketAddress localInetAddr) {\n+    if (filterChainMatch == null) {\n+      return 1;\n+    }\n+    if (filterChainMatch.getDestinationPort() != localInetAddr.getPort()) {\n+      return -1;\n+    }\n+    return getIpAddressAndRangesMatchScore(\n+        localInetAddr.getAddress(), filterChainMatch.getPrefixRanges());\n+  }\n+\n+  /**\n+   * Computes a score for IP address match against a list of CidrRange called only after ports have\n+   * matched, so a minimum score of 2 is returned to indicate a match or else -1 for a mismatch.\n+   *\n+   * <p>-1 => mismatch.\n+   *\n+   * <p>2 => prefixRanges is null/empty, so no IP address to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getIpAddressAndRangesMatchScore(\n+      InetAddress localAddress, List<CidrRange> prefixRanges) {\n+    if (prefixRanges == null || prefixRanges.isEmpty()) {\n+      return 2;\n+    }\n+    int highestScore = -1;\n+    for (CidrRange cidrRange : prefixRanges) {\n+      int curScore = getIpAddressMatchScore(localAddress, cidrRange);\n+      if (curScore > highestScore) {\n+        highestScore = curScore;\n+      }\n+    }\n+    return highestScore;\n+  }\n+\n+  /**\n+   * Computes a score for IP address to CidrRange match.\n+   *\n+   * <p>-1 => mismatch\n+   *\n+   * <p>0 => unimplemented (prefixLen < 32 logic)\n+   *\n+   * <p>4 => match because cidrRange is IPANY_ADDRESS (0.0.0.0)\n+   *\n+   * <p>8 => exact match\n+   */\n+  private static int getIpAddressMatchScore(InetAddress localAddress, CidrRange cidrRange) {\n+    if (cidrRange.getPrefixLen() == 32) {\n+      try {\n+        InetAddress cidrAddr = InetAddress.getByName(cidrRange.getAddressPrefix());\n+        if (cidrAddr.isAnyLocalAddress()) {\n+          return 4;\n+        }\n+        if (cidrAddr.equals(localAddress)) {\n+          return 8;\n+        }\n+        return -1;\n+      } catch (UnknownHostException e) {\n+        logger.log(Level.SEVERE, \"cidrRange address parsing\", e);\n+      }\n+    }\n+    // TODO(sanjaypujare): implement CIDR logic to match prefixes if needed\n+    return 0;\n+  }\n+\n+  /** Shutdown this instance and release resources. */\n+  public void shutdown() {\n+    logger.log(Level.INFO, \"Shutdown\");\n+    if (xdsClient != null) {\n+      xdsClient.shutdown();\n+    }\n+    if (timeService != null) {\n+      timeServiceResource.close(timeService);\n+    }\n+  }\n+\n+  private static final class TimeServiceResource\n+          implements SharedResourceHolder.Resource<ScheduledExecutorService> {\n+\n+    private final String name;\n+\n+    TimeServiceResource(String name) {\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public ScheduledExecutorService create() {\n+      // Use Netty's DefaultThreadFactory in order to get the benefit of FastThreadLocal.\n+      ThreadFactory threadFactory = new DefaultThreadFactory(name, /* daemon= */ true);\n+      if (Epoll.isAvailable()) {\n+        return new EpollEventLoopGroup(1, threadFactory);\n+      } else {\n+        return Executors.newSingleThreadScheduledExecutor(threadFactory);\n+      }\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    @Override\n+    public void close(ScheduledExecutorService instance) {\n+      try {\n+        if (instance instanceof EpollEventLoopGroup) {\n+          ((EpollEventLoopGroup)instance).shutdownGracefully(0, 0, TimeUnit.SECONDS).sync();\n+        } else {\n+          instance.shutdown();\n+        }\n+      } catch (InterruptedException e) {\n+        logger.log(Level.SEVERE, \"from EventLoopGroup.shutdownGracefully\", e);\n+        Thread.currentThread().interrupt(); // to not \"swallow\" the exception...", "originalCommit": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMTQyOQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397331429", "bodyText": "nit: redundant comment, should delete.", "author": "voidzcy", "createdAt": "2020-03-24T17:24:09Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */", "originalCommit": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzNzMyOA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397337328", "bodyText": "Forced by checkstyle - for a public method this is needed,", "author": "sanjaypujare", "createdAt": "2020-03-24T17:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MzQ0MA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397343440", "bodyText": "Then write something semantically meaningful.", "author": "voidzcy", "createdAt": "2020-03-24T17:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMTQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMjk5NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397332995", "bodyText": "IMO, if syncContext comes from the caller side, this should also come from the caller side.", "author": "voidzcy", "createdAt": "2020-03-24T17:26:27Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      checkState(\n+          localAddress instanceof InetSocketAddress,\n+          \"Channel localAddress is expected to be InetSocketAddress\");\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      checkState(\n+          port == localInetAddr.getPort(),\n+          \"Channel localAddress port does not match requested listener port\");\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(\n+      FilterChainMatch filterChainMatch, InetSocketAddress localInetAddr) {\n+    if (filterChainMatch == null) {\n+      return 1;\n+    }\n+    if (filterChainMatch.getDestinationPort() != localInetAddr.getPort()) {\n+      return -1;\n+    }\n+    return getIpAddressAndRangesMatchScore(\n+        localInetAddr.getAddress(), filterChainMatch.getPrefixRanges());\n+  }\n+\n+  /**\n+   * Computes a score for IP address match against a list of CidrRange called only after ports have\n+   * matched, so a minimum score of 2 is returned to indicate a match or else -1 for a mismatch.\n+   *\n+   * <p>-1 => mismatch.\n+   *\n+   * <p>2 => prefixRanges is null/empty, so no IP address to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getIpAddressAndRangesMatchScore(\n+      InetAddress localAddress, List<CidrRange> prefixRanges) {\n+    if (prefixRanges == null || prefixRanges.isEmpty()) {\n+      return 2;\n+    }\n+    int highestScore = -1;\n+    for (CidrRange cidrRange : prefixRanges) {\n+      int curScore = getIpAddressMatchScore(localAddress, cidrRange);\n+      if (curScore > highestScore) {\n+        highestScore = curScore;\n+      }\n+    }\n+    return highestScore;\n+  }\n+\n+  /**\n+   * Computes a score for IP address to CidrRange match.\n+   *\n+   * <p>-1 => mismatch\n+   *\n+   * <p>0 => unimplemented (prefixLen < 32 logic)\n+   *\n+   * <p>4 => match because cidrRange is IPANY_ADDRESS (0.0.0.0)\n+   *\n+   * <p>8 => exact match\n+   */\n+  private static int getIpAddressMatchScore(InetAddress localAddress, CidrRange cidrRange) {\n+    if (cidrRange.getPrefixLen() == 32) {\n+      try {\n+        InetAddress cidrAddr = InetAddress.getByName(cidrRange.getAddressPrefix());\n+        if (cidrAddr.isAnyLocalAddress()) {\n+          return 4;\n+        }\n+        if (cidrAddr.equals(localAddress)) {\n+          return 8;\n+        }\n+        return -1;\n+      } catch (UnknownHostException e) {\n+        logger.log(Level.SEVERE, \"cidrRange address parsing\", e);\n+      }\n+    }\n+    // TODO(sanjaypujare): implement CIDR logic to match prefixes if needed\n+    return 0;\n+  }\n+\n+  /** Shutdown this instance and release resources. */\n+  public void shutdown() {\n+    logger.log(Level.INFO, \"Shutdown\");\n+    if (xdsClient != null) {\n+      xdsClient.shutdown();\n+    }\n+    if (timeService != null) {\n+      timeServiceResource.close(timeService);\n+    }\n+  }\n+\n+  private static final class TimeServiceResource", "originalCommit": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzOTY5OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397339699", "bodyText": "But the \"caller\" is this class as far as XdsClientImpl is concerned. If you go up the call chain (all the way up to XdsServerBuilder) no other component either needs or creates a ScheduledExecutorService so this seems to be the right place.", "author": "sanjaypujare", "createdAt": "2020-03-24T17:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0NDg1Ng==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397344856", "bodyText": "The AbstractServerImplBuilder defines/uses DEFAULT_EXECUTOR_POOL which cannot be used here because it's not a ScheduledExecutorService (and probably not accessible). There is no other \"caller-provided\" ScheduledExecutorService we can use unless this wrapper class creates it for XdsClientImpl.", "author": "sanjaypujare", "createdAt": "2020-03-24T17:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0Njg2MA==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397346860", "bodyText": "Alright.", "author": "voidzcy", "createdAt": "2020-03-24T17:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMjk5NQ=="}], "type": "inlineReview"}, {"oid": "f628d36689675fc7c40fa082373f9e0fa33b6548", "url": "https://github.com/grpc/grpc-java/commit/f628d36689675fc7c40fa082373f9e0fa33b6548", "message": "address review comment: 3rd set", "committedDate": "2020-03-25T06:55:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2ODc5NQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397668795", "bodyText": "A better API would be to take in an InetSocketAddress as the argument instead of a Channel, which makes the method specification stronger (i.e., weaker precondition, the method requires less information).", "author": "voidzcy", "createdAt": "2020-03-25T08:09:14Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /**\n+   * Factory method for creating a {@link XdsClientWrapperForServerSds}.\n+   *\n+   * @param port server's port for which listener config is needed.\n+   * @param bootstrapper {@link Bootstrapper} instance to load bootstrap config.\n+   * @param syncContext {@link SynchronizationContext} needed by {@link XdsClient}.\n+   */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {", "originalCommit": "f628d36689675fc7c40fa082373f9e0fa33b6548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2NjI3OQ==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397966279", "bodyText": "You probably missed the comment exchange where @creamsoup talked about this for internal functions.\nI do agree that a type like InetSocketAddress is better than Channel in an API but the filters to be matched have various things like remoteAddress, protocol-type (not just TCP sockets) even if we haven't implemented all of the matching for those fields. And this an internal class (API) and is used by SdsProtocolNegotiators which is Netty specific so using Channel seems to be the better option.", "author": "sanjaypujare", "createdAt": "2020-03-25T15:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2ODc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAxNTUzNw==", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r398015537", "bodyText": "Alright, that't fine. It was just based on what I saw in this method.", "author": "voidzcy", "createdAt": "2020-03-25T16:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2ODc5NQ=="}], "type": "inlineReview"}]}