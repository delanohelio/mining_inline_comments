{"pr_number": 7364, "pr_title": "xds: implement SslContextProviderSupplier to prevent creds leakage", "pr_createdAt": "2020-08-26T19:14:22Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7364", "timeline": [{"oid": "02e7aed63a8a5e680fecc621ffb4ef95d003a6cf", "url": "https://github.com/grpc/grpc-java/commit/02e7aed63a8a5e680fecc621ffb4ef95d003a6cf", "message": "xds: implement SslContextProviderSupplier to prevent creds leakage", "committedDate": "2020-08-26T19:11:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NjQ0OA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r480466448", "bodyText": "I don't think verifying this test only flag is necessary. Just verifying any resource that need be released is released at the right time  as you already did is sufficient.", "author": "dapengzhang0", "createdAt": "2020-08-31T23:16:27Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SslContextProviderSupplier.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.sds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.netty.handler.ssl.SslContext;\n+\n+/**\n+ * Enables the CDS policy to initialize this object with the received {@link UpstreamTlsContext} &\n+ * communicate it to the consumer i.e. {@link SdsProtocolNegotiators.ClientSdsProtocolNegotiator}\n+ * to lazily evaluate the {@link SslContextProvider}. The supplier prevents credentials leakage in\n+ * cases where the user is not using xDS credentials but the CDS policy contains a non-default\n+ * {@link UpstreamTlsContext}.\n+ */\n+public final class SslContextProviderSupplier implements Closeable {\n+\n+  private final UpstreamTlsContext upstreamTlsContext;\n+  private final TlsContextManager tlsContextManager;\n+  private SslContextProvider sslContextProvider;\n+  private boolean shutdown;\n+\n+  public SslContextProviderSupplier(\n+      UpstreamTlsContext upstreamTlsContext, TlsContextManager tlsContextManager) {\n+    this.upstreamTlsContext = upstreamTlsContext;\n+    this.tlsContextManager = tlsContextManager;\n+  }\n+\n+  public UpstreamTlsContext getUpstreamTlsContext() {\n+    return upstreamTlsContext;\n+  }\n+\n+  @VisibleForTesting public boolean isShutdown() {", "originalCommit": "02e7aed63a8a5e680fecc621ffb4ef95d003a6cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODgyMA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r481458820", "bodyText": "Ordinarily yes but on line 56 I have\n    if (sslContextProvider == null && !shutdown) {\n\nwhere the value of shutdown is tested so it is important to make sure that shutdown is set correctly as per the design. Do you agree?", "author": "sanjaypujare", "createdAt": "2020-09-01T22:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NjQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU0NzAzNg==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482547036", "bodyText": "Well, things like\nsupplier.close();   \nassertThat(supplier.isShutdown()).isTrue();\nis just testing implementation details, but does not test any behavior.\nTo test\nif (sslContextProvider == null && !shutdown) {\n   sslContextProvider =\n          tlsContextManager.findOrCreateClientSslContextProvider(upstreamTlsContext);\nYou should verify the behavior difference between\ncalling updateSslContext() only\nand\ncalling supplier.close() then updateSslContext().", "author": "dapengzhang0", "createdAt": "2020-09-02T22:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NjQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxNDE4NA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482614184", "bodyText": "Okay, I'll try to change the test to not use shutdown.", "author": "sanjaypujare", "createdAt": "2020-09-03T00:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NjQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzNTMwMA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482635300", "bodyText": "done.", "author": "sanjaypujare", "createdAt": "2020-09-03T01:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NjQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzc0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r481327743", "bodyText": "If the ref-count is  incremented more than once, how it will be released by close()?", "author": "dapengzhang0", "createdAt": "2020-09-01T17:54:25Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SslContextProviderSupplier.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.sds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.netty.handler.ssl.SslContext;\n+\n+/**\n+ * Enables the CDS policy to initialize this object with the received {@link UpstreamTlsContext} &\n+ * communicate it to the consumer i.e. {@link SdsProtocolNegotiators.ClientSdsProtocolNegotiator}\n+ * to lazily evaluate the {@link SslContextProvider}. The supplier prevents credentials leakage in\n+ * cases where the user is not using xDS credentials but the CDS policy contains a non-default\n+ * {@link UpstreamTlsContext}.\n+ */\n+public final class SslContextProviderSupplier implements Closeable {\n+\n+  private final UpstreamTlsContext upstreamTlsContext;\n+  private final TlsContextManager tlsContextManager;\n+  private SslContextProvider sslContextProvider;\n+  private boolean shutdown;\n+\n+  public SslContextProviderSupplier(\n+      UpstreamTlsContext upstreamTlsContext, TlsContextManager tlsContextManager) {\n+    this.upstreamTlsContext = upstreamTlsContext;\n+    this.tlsContextManager = tlsContextManager;\n+  }\n+\n+  public UpstreamTlsContext getUpstreamTlsContext() {\n+    return upstreamTlsContext;\n+  }\n+\n+  @VisibleForTesting public boolean isShutdown() {\n+    return shutdown;\n+  }\n+\n+  /** Updates SslContext via the passed callback. */\n+  public synchronized void updateSslContext(final SslContextProvider.Callback callback) {\n+    checkNotNull(callback, \"callback\");\n+    if (sslContextProvider == null && !shutdown) {\n+      sslContextProvider =\n+          tlsContextManager.findOrCreateClientSslContextProvider(upstreamTlsContext);\n+    }\n+    // we want to increment the ref-count so call findOrCreate again...", "originalCommit": "02e7aed63a8a5e680fecc621ffb4ef95d003a6cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NDI4MA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r481464280", "bodyText": "If you see the anonymous Callback created on line 64, in each method I call releaseClientSslContextProvider (lines 69 and 75) which decrements the ref-count (after the SslContextProvider calls one of the callback methods) so that leaves the ref-count to 1 from the findOrCreate on line 58 which is the expected value when close is called to decrement to 0 and release the object.\nThe Supplier class achieves lazy initialization of SslContextProvider on the client side to solve this problem: when a CDS balancer receives a CDS response containing UpstreamTlsContext the code was earlier creating/allocating an SslContextProvider even if the channel didn't use XdsCredentials (i.e. authorizing use of xDS supplied certs). In that case the SslContextProvider was going ahead and sending CallCreds on the wire even if the user had not authorized use of XdsCreds. The problem is solved by using the Supplier which does lazy initialization of the SslContextProvider i.e. on the first actual use of the SslContextProvider it will allocate the object. The ref-count of 2 reflects the original creation (that would have happened in the CDS LB) and the current use.", "author": "sanjaypujare", "createdAt": "2020-09-01T22:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4MDM1MA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482580350", "bodyText": "findOrCreate twice doesn't look elegant, why not just always do findOrCreate() once and no-op for close()? Then you don't even need sslContextProvider and maybe shutdown fields.", "author": "dapengzhang0", "createdAt": "2020-09-02T23:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMzgyMw==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482613823", "bodyText": "if you consider the pre-Supplier behavior it is something like this:\n\ncontrol plane sends a CDS response with a certain UpstreamTlsContext value\nwhen the CDS LoadBalancer receives that, it creates an SslContextProvider with that UpstreamTlsContext value and as part of that creation the SslContextProvider does the initial heavy lifting of contacting the CA server, getting the certificates and making the SslContext ready to be consumed by the actual handshaker of a subchannel. The ref-count gets initialized to 1.\nWhen a subchannel is created and engages the ProtocolNegotiator it asks for the same SslContextProvider (based on how the Attribute is passed down) and because this SslContextProvider is already initialized the SslContext is just returned by the SslContextProvider. This happens for all the subchannels of a connection and all the connections to any backend in the cluster of that CDS policy. In this interaction the SslContextProvider is accessed (ref-count +1) and immediately released (ref-count -1) after the updateSecret call.\nAt some point the cluster is removed or the UpstreamTlsContext for that cluster changes. The CDS LoadBalancer at that time releases the SslContextProvider and because the ref-count reaches 0 the SslContextProvider is deallocated.\n\nIn the above flow because of the initial ref-count of 1 the flow in step 3 does not result into any overhead. With the Supplier modification the initialization becomes lazy so the very first access to the SslContextProvider is delayed but all the subsequent ones in the same CDS are quick.\nWith what you are suggesting we won't be maintaining the SslContextProvider thru the life of the cluster. But we will be creating and deallocating for every subchannel handshake and that's the overhead we are trying to avoid. For that matter we don't need the Supplier at all if we make close a no-op the way you are suggesting.\nSo no change is needed assuming you are okay with this explanation", "author": "sanjaypujare", "createdAt": "2020-09-03T00:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMzU1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r483323556", "bodyText": "Now I understood. I can't think of an obvious better alternative so I'm okay with as-is.", "author": "dapengzhang0", "createdAt": "2020-09-04T00:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTk1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r485005957", "bodyText": "marking as resolved then", "author": "sanjaypujare", "createdAt": "2020-09-08T15:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4MTY1MA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482581650", "bodyText": "So if shutdown is true, you still findOrCreate() and addCallback()?", "author": "dapengzhang0", "createdAt": "2020-09-02T23:03:39Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SslContextProviderSupplier.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.sds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.netty.handler.ssl.SslContext;\n+\n+/**\n+ * Enables the CDS policy to initialize this object with the received {@link UpstreamTlsContext} &\n+ * communicate it to the consumer i.e. {@link SdsProtocolNegotiators.ClientSdsProtocolNegotiator}\n+ * to lazily evaluate the {@link SslContextProvider}. The supplier prevents credentials leakage in\n+ * cases where the user is not using xDS credentials but the CDS policy contains a non-default\n+ * {@link UpstreamTlsContext}.\n+ */\n+public final class SslContextProviderSupplier implements Closeable {\n+\n+  private final UpstreamTlsContext upstreamTlsContext;\n+  private final TlsContextManager tlsContextManager;\n+  private SslContextProvider sslContextProvider;\n+  private boolean shutdown;\n+\n+  public SslContextProviderSupplier(\n+      UpstreamTlsContext upstreamTlsContext, TlsContextManager tlsContextManager) {\n+    this.upstreamTlsContext = upstreamTlsContext;\n+    this.tlsContextManager = tlsContextManager;\n+  }\n+\n+  public UpstreamTlsContext getUpstreamTlsContext() {\n+    return upstreamTlsContext;\n+  }\n+\n+  @VisibleForTesting public boolean isShutdown() {\n+    return shutdown;\n+  }\n+\n+  /** Updates SslContext via the passed callback. */\n+  public synchronized void updateSslContext(final SslContextProvider.Callback callback) {\n+    checkNotNull(callback, \"callback\");\n+    if (sslContextProvider == null && !shutdown) {\n+      sslContextProvider =\n+          tlsContextManager.findOrCreateClientSslContextProvider(upstreamTlsContext);\n+    }\n+    // we want to increment the ref-count so call findOrCreate again...", "originalCommit": "02e7aed63a8a5e680fecc621ffb4ef95d003a6cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzNzUxMg==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r482637512", "bodyText": "Yes. Ideally this should not happen because after shutdown is true no CDS load balancer should have any reference to the Supplier and so there should be no call to updateSslContext. I guess I can throw an IllegalStateException but it's doesn't seem that important to do anything like that. WDYT?", "author": "sanjaypujare", "createdAt": "2020-09-03T01:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4MTY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMzEyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r483323129", "bodyText": "I would either return or throw if shutdown is true. I think we should not accept new update after shutdown if we follow the pattern of ManagedChannel, Transport and especially LoadBalancer shutdown.", "author": "dapengzhang0", "createdAt": "2020-09-04T00:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4MTY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMjIyNQ==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r485022225", "bodyText": "done", "author": "sanjaypujare", "createdAt": "2020-09-08T15:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4MTY1MA=="}], "type": "inlineReview"}, {"oid": "12bb7653af266016a0f690395b3134556929233a", "url": "https://github.com/grpc/grpc-java/commit/12bb7653af266016a0f690395b3134556929233a", "message": "remove test-only code of isShutdown", "committedDate": "2020-09-03T01:13:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM0MjM1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r483342359", "bodyText": "Is the argument of updateSecret  nullable? Otherwise it should be a mock.", "author": "dapengzhang0", "createdAt": "2020-09-04T01:54:06Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SslContextProviderSupplierTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.sds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.grpc.xds.EnvoyServerProtoData;\n+import java.util.concurrent.Executor;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Unit tests for {@link SslContextProviderSupplier}.\n+ */\n+@RunWith(JUnit4.class)\n+public class SslContextProviderSupplierTest {\n+\n+  @Mock private TlsContextManager mockTlsContextManager;\n+  private SslContextProviderSupplier supplier;\n+  private SslContextProvider mockSslContextProvider;\n+  private EnvoyServerProtoData.UpstreamTlsContext upstreamTlsContext;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+  }\n+\n+  private void prepareSupplier() {\n+    upstreamTlsContext =\n+            CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+                    CLIENT_KEY_FILE, CLIENT_PEM_FILE, CA_PEM_FILE);\n+    mockSslContextProvider = mock(SslContextProvider.class);\n+    doReturn(mockSslContextProvider)\n+            .when(mockTlsContextManager)\n+            .findOrCreateClientSslContextProvider(eq(upstreamTlsContext));\n+    SslContextProvider.Callback mockCallback = mock(SslContextProvider.Callback.class);\n+    Executor mockExecutor = mock(Executor.class);\n+    doReturn(mockExecutor).when(mockCallback).getExecutor();\n+    supplier = new SslContextProviderSupplier(upstreamTlsContext, mockTlsContextManager);\n+    supplier.updateSslContext(mockCallback);\n+  }\n+\n+  @Test\n+  public void get_updateSecret() {\n+    prepareSupplier();\n+    verify(mockTlsContextManager, times(2))\n+        .findOrCreateClientSslContextProvider(eq(upstreamTlsContext));\n+    verify(mockTlsContextManager, times(0))\n+        .releaseClientSslContextProvider(any(SslContextProvider.class));\n+    ArgumentCaptor<SslContextProvider.Callback> callbackCaptor = ArgumentCaptor.forClass(null);\n+    verify(mockSslContextProvider, times(1)).addCallback(callbackCaptor.capture());\n+    SslContextProvider.Callback capturedCallback = callbackCaptor.getValue();\n+    assertThat(capturedCallback).isNotNull();\n+    capturedCallback.updateSecret(null);", "originalCommit": "12bb7653af266016a0f690395b3134556929233a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMjA4OA==", "url": "https://github.com/grpc/grpc-java/pull/7364#discussion_r485022088", "bodyText": "done", "author": "sanjaypujare", "createdAt": "2020-09-08T15:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM0MjM1OQ=="}], "type": "inlineReview"}, {"oid": "58d875ea07c76ab9da63b5519738acbd93a7ba34", "url": "https://github.com/grpc/grpc-java/commit/58d875ea07c76ab9da63b5519738acbd93a7ba34", "message": "address review comments", "committedDate": "2020-09-08T15:45:45Z", "type": "commit"}]}