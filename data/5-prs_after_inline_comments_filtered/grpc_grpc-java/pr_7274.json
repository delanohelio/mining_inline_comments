{"pr_number": 7274, "pr_title": "xds: implement MeshCACertificateProvider", "pr_createdAt": "2020-07-31T05:44:40Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7274", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r463889521", "bodyText": "Although not a change in this PR, should not be protected as the class is final.", "author": "dapengzhang0", "createdAt": "2020-07-31T23:48:38Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(", "originalCommit": "50081e9e9fe230fcfc7afa705be80a88aab6e28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEzMzQ5OQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466133499", "bodyText": "typo: downsstreamWatchers", "author": "dapengzhang0", "createdAt": "2020-08-06T04:07:05Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -104,6 +104,24 @@ public synchronized void onError(Status errorStatus) {\n         watcher.onError(errorStatus);\n       }\n     }\n+\n+    X509Certificate getLastIdentityCert() {\n+      if (lastCertChain != null && !lastCertChain.isEmpty()) {\n+        return lastCertChain.get(0);\n+      }\n+      return null;\n+    }\n+\n+    void close() {\n+      downsstreamWatchers.clear();", "originalCommit": "87bf16499833f063d3af39926bf350738a51002b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NzIzMA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466157230", "bodyText": "Just clearKeys() might be a better name.\nAlso I wonder if lastKey, lasterCertChain and lastTrustedRoots  can be just renamed to key, certChain and trustedRoots.", "author": "dapengzhang0", "createdAt": "2020-08-06T05:37:17Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -104,6 +104,24 @@ public synchronized void onError(Status errorStatus) {\n         watcher.onError(errorStatus);\n       }\n     }\n+\n+    X509Certificate getLastIdentityCert() {\n+      if (lastCertChain != null && !lastCertChain.isEmpty()) {\n+        return lastCertChain.get(0);\n+      }\n+      return null;\n+    }\n+\n+    void close() {\n+      downsstreamWatchers.clear();\n+      cleanupLastValues();\n+    }\n+\n+    void cleanupLastValues() {", "originalCommit": "87bf16499833f063d3af39926bf350738a51002b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0Mjc4Nw==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466542787", "bodyText": "Just clearKeys() might be a better name.\n\nThe values are certs and a key. I'll rename to clearValues.\n\nAlso I wonder if lastKey, lasterCertChain and lastTrustedRoots  can be just renamed to key, certChain and trustedRoots.\n\nOkay.", "author": "sanjaypujare", "createdAt": "2020-08-06T16:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NzIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1Mzg0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466553842", "bodyText": "My understanding is certs are public keys, and key is private key, so they are both keys.", "author": "dapengzhang0", "createdAt": "2020-08-06T16:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NzIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1Nzg3MA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466557870", "bodyText": "A cert contains the public key but it is much more than a public key - it is a certificate from the CA (certification authority) that is signed by the CA's own private key which is why it is verifiable. The certificate contains other identifying fields such as name, domain, issuer etc which are part of the certified info.", "author": "sanjaypujare", "createdAt": "2020-08-06T17:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NzIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2NDA0NQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466164045", "bodyText": "\"XdsClientWrapperForServerSds\"?", "author": "dapengzhang0", "createdAt": "2020-08-06T05:59:35Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);", "originalCommit": "87bf16499833f063d3af39926bf350738a51002b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0NDkzNQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466544935", "bodyText": "Oops :-) Fixed", "author": "sanjaypujare", "createdAt": "2020-08-06T16:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2NDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3Mzc1NQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466173755", "bodyText": "It might be better to move it to the scheduleNextRefreshCertificate() method.:\n@VisibleForTesting RefreshCertificateTask scheduledTask;\n@VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle; // top level field\n\nprivate void scheduleNextRefreshCertificate(long delayInSeconds) {\n  if (scheduledHandle != null && scheduledHandle.isPending()) {\n    logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n    scheduledHandle.cancel();\n  }\n  RefreshCertificateTask runnable = new RefreshCertificateTask();  // Pure Runnable class\n  scheduledHandle = syncContext.schedule(\n      runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n}\n\nclass RefreshCertificateTask implements Runnable {\n  @Override\n  public void run() {\n    try {\n      refreshCertificate();\n    } catch (NoSuchAlgorithmException | OperatorCreationException | IOException ex) {\n      logger.log(Level.SEVERE, \"refreshing certificate\", ex);\n    }\n  }\n}", "author": "dapengzhang0", "createdAt": "2020-08-06T06:29:00Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t).getStatus());\n+    } else if (t.getCause() instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t.getCause()).getStatus());\n+    }\n+    return false;\n+  }\n+\n+  private static boolean retriable(Status status) {\n+    return RETRIABLE_CODES.contains(status.getCode());\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > INITIAL_DELAY_SECONDS) {\n+        return;\n+      }\n+      getWatcher().cleanupLastValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  private KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n+    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(alg);\n+    keyPairGenerator.initialize(keySize);\n+    return keyPairGenerator.generateKeyPair();\n+  }\n+\n+  private String generateCsr(KeyPair pair) throws IOException, OperatorCreationException {\n+    PKCS10CertificationRequestBuilder p10Builder =\n+        new JcaPKCS10CertificationRequestBuilder(\n+            new X500Principal(\"CN=EXAMPLE.COM\"), pair.getPublic());\n+    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(signatureAlg);\n+    ContentSigner signer = csBuilder.build(pair.getPrivate());\n+    PKCS10CertificationRequest csr = p10Builder.build(signer);\n+    PemObject pemObject = new PemObject(\"NEW CERTIFICATE REQUEST\", csr.getEncoded());\n+    StringWriter str = new StringWriter();\n+    JcaPEMWriter pemWriter = new JcaPEMWriter(str);\n+    pemWriter.writeObject(pemObject);\n+    pemWriter.close();\n+    str.close();\n+    return str.toString();\n+  }\n+\n+  /** Compute refresh interval as half of interval to current cert expiry. */\n+  private long computeRefreshSecondsFromCurrentCertExpiry() {\n+    X509Certificate lastCert = getWatcher().getLastIdentityCert();\n+    if (lastCert == null) {\n+      return INITIAL_DELAY_SECONDS;\n+    }\n+    long delayToCertExpirySeconds = computeDelaySecondsToCertExpiry(lastCert) / 2;\n+    return Math.max(delayToCertExpirySeconds, INITIAL_DELAY_SECONDS);\n+  }\n+\n+  private long computeDelaySecondsToCertExpiry(X509Certificate lastCert) {\n+    checkNotNull(lastCert, \"lastCert\");\n+    return TimeUnit.NANOSECONDS.toSeconds(\n+        TimeUnit.MILLISECONDS.toNanos(lastCert.getNotAfter().getTime()) - timeProvider\n+            .currentTimeNanos());\n+  }\n+\n+  private static void shutdownChannel(ManagedChannel channel) {\n+    channel.shutdown();\n+    try {\n+      channel.awaitTermination(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException ex) {\n+      logger.log(Level.SEVERE, \"awaiting channel Termination\", ex);\n+      channel.shutdownNow();\n+    }\n+  }\n+\n+  private List<X509Certificate> getX509CertificatesFromResponse(\n+      Meshca.MeshCertificateResponse response) throws CertificateException, IOException {\n+    List<String> certChain = response.getCertChainList();\n+    List<X509Certificate> x509Chain = new ArrayList<>(certChain.size());\n+    for (String certString : certChain) {\n+      x509Chain.add(\n+          CertificateUtils\n+              .toX509Certificate(new ByteArrayInputStream(certString.getBytes(UTF_8))));\n+    }\n+    return x509Chain;\n+  }\n+\n+  @VisibleForTesting\n+  class RefreshCertificateTask implements Runnable {\n+    @VisibleForTesting final SynchronizationContext.ScheduledHandle scheduledHandle;\n+\n+    private RefreshCertificateTask(long delayInSeconds) {\n+      scheduledHandle =\n+          syncContext.schedule(this, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1NDE4Ng==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466554186", "bodyText": "That's what I had earlier and I understand that's the pattern followed elsewhere. There was a reason I made this change but if that reason doesn't exist I'll implement what you suggested.", "author": "sanjaypujare", "createdAt": "2020-08-06T16:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3Mzc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODQ0Ng==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466708446", "bodyText": "Done", "author": "sanjaypujare", "createdAt": "2020-08-06T21:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3Mzc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4MjE2OA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466182168", "bodyText": "Always call Thread.currentThread().interrupt() to re-mark the thread as interrupted. Ditto elsewhere.", "author": "dapengzhang0", "createdAt": "2020-08-06T06:50:07Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t).getStatus());\n+    } else if (t.getCause() instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t.getCause()).getStatus());\n+    }\n+    return false;\n+  }\n+\n+  private static boolean retriable(Status status) {\n+    return RETRIABLE_CODES.contains(status.getCode());\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > INITIAL_DELAY_SECONDS) {\n+        return;\n+      }\n+      getWatcher().cleanupLastValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  private KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n+    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(alg);\n+    keyPairGenerator.initialize(keySize);\n+    return keyPairGenerator.generateKeyPair();\n+  }\n+\n+  private String generateCsr(KeyPair pair) throws IOException, OperatorCreationException {\n+    PKCS10CertificationRequestBuilder p10Builder =\n+        new JcaPKCS10CertificationRequestBuilder(\n+            new X500Principal(\"CN=EXAMPLE.COM\"), pair.getPublic());\n+    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(signatureAlg);\n+    ContentSigner signer = csBuilder.build(pair.getPrivate());\n+    PKCS10CertificationRequest csr = p10Builder.build(signer);\n+    PemObject pemObject = new PemObject(\"NEW CERTIFICATE REQUEST\", csr.getEncoded());\n+    StringWriter str = new StringWriter();\n+    JcaPEMWriter pemWriter = new JcaPEMWriter(str);\n+    pemWriter.writeObject(pemObject);\n+    pemWriter.close();\n+    str.close();\n+    return str.toString();\n+  }\n+\n+  /** Compute refresh interval as half of interval to current cert expiry. */\n+  private long computeRefreshSecondsFromCurrentCertExpiry() {\n+    X509Certificate lastCert = getWatcher().getLastIdentityCert();\n+    if (lastCert == null) {\n+      return INITIAL_DELAY_SECONDS;\n+    }\n+    long delayToCertExpirySeconds = computeDelaySecondsToCertExpiry(lastCert) / 2;\n+    return Math.max(delayToCertExpirySeconds, INITIAL_DELAY_SECONDS);\n+  }\n+\n+  private long computeDelaySecondsToCertExpiry(X509Certificate lastCert) {\n+    checkNotNull(lastCert, \"lastCert\");\n+    return TimeUnit.NANOSECONDS.toSeconds(\n+        TimeUnit.MILLISECONDS.toNanos(lastCert.getNotAfter().getTime()) - timeProvider\n+            .currentTimeNanos());\n+  }\n+\n+  private static void shutdownChannel(ManagedChannel channel) {\n+    channel.shutdown();\n+    try {\n+      channel.awaitTermination(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException ex) {\n+      logger.log(Level.SEVERE, \"awaiting channel Termination\", ex);", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODM3Ng==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466708376", "bodyText": "Good point. Done", "author": "sanjaypujare", "createdAt": "2020-08-06T21:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4MjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4MzUzNg==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466183536", "bodyText": "If you don't override any method of the listener, no need to wrap.", "author": "dapengzhang0", "createdAt": "2020-08-06T06:53:03Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -129,6 +449,67 @@ abstract MeshCaCertificateProvider create(\n         BackoffPolicy.Provider backoffPolicyProvider,\n         long renewalGracePeriodSeconds,\n         int maxRetryAttempts,\n-        GoogleCredentials oauth2Creds);\n+        GoogleCredentials oauth2Creds,\n+        ScheduledExecutorService scheduledExecutorService,\n+        TimeProvider timeProvider,\n+        long rpcTimeoutMillis);\n   }\n+\n+  private class ZoneInfoClientInterceptor implements ClientInterceptor {\n+    private final String zone;\n+\n+    ZoneInfoClientInterceptor(String zone) {\n+      this.zone = zone;\n+    }\n+\n+    @Override\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n+        MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n+      return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(\n+          next.newCall(method, callOptions)) {\n+\n+        @Override\n+        public void start(Listener<RespT> responseListener, Metadata headers) {\n+          headers.put(KEY_FOR_ZONE_INFO, zone);\n+          super.start(\n+              new ForwardingClientCallListener.SimpleForwardingClientCallListener<RespT>(", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODI5MA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466708290", "bodyText": "Done", "author": "sanjaypujare", "createdAt": "2020-08-06T21:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4MzUzNg=="}], "type": "inlineReview"}, {"oid": "b98bfdeefd52572c16f5f9e9b111a87ec2459d5f", "url": "https://github.com/grpc/grpc-java/commit/b98bfdeefd52572c16f5f9e9b111a87ec2459d5f", "message": "xds: implement MeshCACertificateProvider", "committedDate": "2020-08-06T17:52:07Z", "type": "commit"}, {"oid": "02ac14272e7ce874545765eae09f00b0c18e82de", "url": "https://github.com/grpc/grpc-java/commit/02ac14272e7ce874545765eae09f00b0c18e82de", "message": "fix a windows specific error due to CRLF differences", "committedDate": "2020-08-06T17:52:13Z", "type": "commit"}, {"oid": "bda0e3f78177ec44f16ea2f11f3439a7f837004e", "url": "https://github.com/grpc/grpc-java/commit/bda0e3f78177ec44f16ea2f11f3439a7f837004e", "message": "refactor to move some fuctions to a utils class", "committedDate": "2020-08-06T17:52:13Z", "type": "commit"}, {"oid": "623a79871bfccc4c49b2181ff505cd3f1eb6751e", "url": "https://github.com/grpc/grpc-java/commit/623a79871bfccc4c49b2181ff505cd3f1eb6751e", "message": "Use a factory for ScheduledExecutorService", "committedDate": "2020-08-06T17:52:13Z", "type": "commit"}, {"oid": "42853d5a6324474ca729dcf3392ff39151993b25", "url": "https://github.com/grpc/grpc-java/commit/42853d5a6324474ca729dcf3392ff39151993b25", "message": "address review comments", "committedDate": "2020-08-06T17:52:13Z", "type": "commit"}, {"oid": "42853d5a6324474ca729dcf3392ff39151993b25", "url": "https://github.com/grpc/grpc-java/commit/42853d5a6324474ca729dcf3392ff39151993b25", "message": "address review comments", "committedDate": "2020-08-06T17:52:13Z", "type": "forcePushed"}, {"oid": "0e750e12e6513d286b63525ea295d6402b29461b", "url": "https://github.com/grpc/grpc-java/commit/0e750e12e6513d286b63525ea295d6402b29461b", "message": "Add suppresswarnings for JdkObsolete", "committedDate": "2020-08-06T21:23:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MjM1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466562359", "bodyText": "Could recreating a channel every time cost too much? How about creating just one channel and one stub as well per Provider, and shutdown() at Provider.close()? How often is the refresh typically?", "author": "dapengzhang0", "createdAt": "2020-08-06T17:14:46Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMDk0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466800949", "bodyText": "The refresh is (typically) once every 24 hours - doesn't make sense to keep the channel open for that long and the channel startup time etc are negligible compared to the interval. The MeshCA team also suggested not to keep the channel open for so long", "author": "sanjaypujare", "createdAt": "2020-08-07T03:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MjM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjQ4Nw==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466572487", "bodyText": "trustedRoots is always a single-element list?", "author": "dapengzhang0", "createdAt": "2020-08-06T17:28:34Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMTQ1MA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466801450", "bodyText": "For the MeshCA it is. So in general the trustedRoots is a list (that's why it is defined for CertificateProvider) but for the MeshCA it is the last one in the certChain received for the issued cert. Unfortunately there is no independent API to get this from the MeshCA.", "author": "sanjaypujare", "createdAt": "2020-08-07T03:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODM2MQ==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466578361", "bodyText": "return RETRIABLE_CODES.contains(Status.fromThrowable(t));", "author": "dapengzhang0", "createdAt": "2020-08-06T17:38:41Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTQ1NA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466585454", "bodyText": "need a white space", "author": "dapengzhang0", "createdAt": "2020-08-06T17:51:29Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/trust/CertificateUtils.java", "diffHunk": "@@ -61,5 +61,17 @@ private static synchronized void initInstance() throws CertificateException {\n     }\n   }\n \n+  /** See {@link CertificateFactory#generateCertificate(InputStream)} enerateCertificate}. */\n+  public static synchronized X509Certificate toX509Certificate(InputStream inputStream)\n+          throws CertificateException, IOException {\n+    initInstance();\n+    try {\n+      Certificate cert = factory.generateCertificate(inputStream);\n+      return (X509Certificate)cert;", "originalCommit": "29db1bf035e50c4729511c68e44916c518db6fa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzODU5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466838593", "bodyText": "done", "author": "sanjaypujare", "createdAt": "2020-08-07T06:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNDY4MA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466724680", "bodyText": "Seems we can use java7's try-with-resource now.", "author": "dapengzhang0", "createdAt": "2020-08-06T22:44:08Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/trust/CertificateUtils.java", "diffHunk": "@@ -61,5 +61,17 @@ private static synchronized void initInstance() throws CertificateException {\n     }\n   }\n \n+  /** See {@link CertificateFactory#generateCertificate(InputStream)} enerateCertificate}. */\n+  public static synchronized X509Certificate toX509Certificate(InputStream inputStream)\n+          throws CertificateException, IOException {\n+    initInstance();\n+    try {\n+      Certificate cert = factory.generateCertificate(inputStream);\n+      return (X509Certificate)cert;\n+    } finally {\n+      inputStream.close();", "originalCommit": "0e750e12e6513d286b63525ea295d6402b29461b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0NjU5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466846593", "bodyText": "added the try-with-resource in the callers", "author": "sanjaypujare", "createdAt": "2020-08-07T06:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNzM0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466727343", "bodyText": "Seems we can use java7's try-with-resource now.", "author": "dapengzhang0", "createdAt": "2020-08-06T22:52:13Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,346 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"MeshCaCertificateProvider\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledHandle != null) {\n+      scheduledHandle.cancel();\n+      scheduledHandle = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledHandle != null && scheduledHandle.isPending()) {\n+      logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+      scheduledHandle.cancel();\n+    }\n+    RefreshCertificateTask runnable = new RefreshCertificateTask();\n+    scheduledHandle = syncContext.schedule(\n+            runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException ie) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ie);\n+      Thread.currentThread().interrupt();\n+    } catch (ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t).getStatus());\n+    } else if (t.getCause() instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t.getCause()).getStatus());\n+    }\n+    return false;\n+  }\n+\n+  private static boolean retriable(Status status) {\n+    return RETRIABLE_CODES.contains(status.getCode());\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > INITIAL_DELAY_SECONDS) {\n+        return;\n+      }\n+      getWatcher().clearValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  private KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n+    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(alg);\n+    keyPairGenerator.initialize(keySize);\n+    return keyPairGenerator.generateKeyPair();\n+  }\n+\n+  private String generateCsr(KeyPair pair) throws IOException, OperatorCreationException {\n+    PKCS10CertificationRequestBuilder p10Builder =\n+        new JcaPKCS10CertificationRequestBuilder(\n+            new X500Principal(\"CN=EXAMPLE.COM\"), pair.getPublic());\n+    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(signatureAlg);\n+    ContentSigner signer = csBuilder.build(pair.getPrivate());\n+    PKCS10CertificationRequest csr = p10Builder.build(signer);\n+    PemObject pemObject = new PemObject(\"NEW CERTIFICATE REQUEST\", csr.getEncoded());\n+    StringWriter str = new StringWriter();\n+    JcaPEMWriter pemWriter = new JcaPEMWriter(str);\n+    pemWriter.writeObject(pemObject);\n+    pemWriter.close();\n+    str.close();", "originalCommit": "0e750e12e6513d286b63525ea295d6402b29461b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzNjEzOA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466836138", "bodyText": "Okay, BTW a single try-with-resources like this doesn't work:\n    try (StringWriter str = new StringWriter(); JcaPEMWriter pemWriter = new JcaPEMWriter(str)) {\n      pemWriter.writeObject(pemObject);\n      return str.toString();\n    }\n\nbut this one works:\n    try (StringWriter str = new StringWriter()) {\n      try (JcaPEMWriter pemWriter = new JcaPEMWriter(str)) {\n        pemWriter.writeObject(pemObject);\n      }\n      return str.toString();\n    }", "author": "sanjaypujare", "createdAt": "2020-08-07T05:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNzM0Mw=="}], "type": "inlineReview"}, {"oid": "648338305428b51a8055a1589cfb7200866d78c5", "url": "https://github.com/grpc/grpc-java/commit/648338305428b51a8055a1589cfb7200866d78c5", "message": "address review comments", "committedDate": "2020-08-07T05:59:28Z", "type": "commit"}, {"oid": "e3550d5af09ae2dc8d9e3749e946f0b6988b766b", "url": "https://github.com/grpc/grpc-java/commit/e3550d5af09ae2dc8d9e3749e946f0b6988b766b", "message": "white space fix", "committedDate": "2020-08-07T06:03:39Z", "type": "commit"}, {"oid": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471", "url": "https://github.com/grpc/grpc-java/commit/021a0edfe33bd3abd467a4c45c6d5cd2e8814471", "message": "misc fixes/format issues", "committedDate": "2020-08-07T06:27:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTcyMg==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467311722", "bodyText": "Why not just implement an extension of GoogleCredentials(it has a public and a protected constructor) and override refreshAccessToken()", "author": "dapengzhang0", "createdAt": "2020-08-07T22:25:31Z", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.auth.http.AuthHttpConstants;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.Context;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayDeque;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+/** Unit tests for {@link MeshCaCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class MeshCaCertificateProviderTest {\n+\n+  private static final String TEST_STS_TOKEN = \"test-stsToken\";\n+  private static final long RENEWAL_GRACE_PERIOD_SECONDS = TimeUnit.HOURS.toSeconds(1L);\n+  private static final Metadata.Key<String> KEY_FOR_AUTHORIZATION =\n+      Metadata.Key.of(AuthHttpConstants.AUTHORIZATION, Metadata.ASCII_STRING_MARSHALLER);\n+  private static final String ZONE = \"us-west2-a\";\n+  private static final long START_DELAY = 200_000_000L;  // 0.2 seconds\n+  private static final long[] DELAY_VALUES = {START_DELAY, START_DELAY * 2, START_DELAY * 4};\n+  private static final long RPC_TIMEOUT_MILLIS = 100L;\n+  /**\n+   * Expire time of cert SERVER_0_PEM_FILE.\n+   */\n+  private static final long CERT0_EXPIRY_TIME_MILLIS = 1899853658000L;\n+  /**\n+   * Cert validity of 12 hours for the above cert.\n+   */\n+  private static final long CERT0_VALIDITY_MILLIS = TimeUnit.MILLISECONDS\n+      .convert(12, TimeUnit.HOURS);\n+  /**\n+   * Compute current time based on cert expiry and cert validity.\n+   */\n+  private static final long CURRENT_TIME_NANOS =\n+      TimeUnit.MILLISECONDS.toNanos(CERT0_EXPIRY_TIME_MILLIS - CERT0_VALIDITY_MILLIS);\n+  @Rule\n+  public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+\n+  private static class ResponseToSend {\n+    Throwable getThrowable() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+\n+    List<String> getList() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+  }\n+\n+  private static class ResponseThrowable extends ResponseToSend {\n+    final Throwable throwableToSend;\n+\n+    ResponseThrowable(Throwable throwable) {\n+      throwableToSend = throwable;\n+    }\n+\n+    @Override\n+    Throwable getThrowable() {\n+      return throwableToSend;\n+    }\n+  }\n+\n+  private static class ResponseList extends ResponseToSend {\n+    final List<String> listToSend;\n+\n+    ResponseList(List<String> list) {\n+      listToSend = list;\n+    }\n+\n+    @Override\n+    List<String> getList() {\n+      return listToSend;\n+    }\n+  }\n+\n+  private final Queue<Meshca.MeshCertificateRequest> receivedRequests = new ArrayDeque<>();\n+  private final Queue<String> receivedStsCreds = new ArrayDeque<>();\n+  private final Queue<String> receivedZoneValues = new ArrayDeque<>();\n+  private final Queue<ResponseToSend> responsesToSend = new ArrayDeque<>();\n+  private final Queue<String> oauth2Tokens = new ArrayDeque<>();\n+  private final AtomicBoolean callEnded = new AtomicBoolean(true);\n+\n+  @Mock private MeshCertificateServiceGrpc.MeshCertificateServiceImplBase mockedMeshCaService;\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private BackoffPolicy.Provider backoffPolicyProvider;\n+  @Mock private BackoffPolicy backoffPolicy;\n+  @Spy private GoogleCredentials oauth2Creds;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  private ManagedChannel channel;\n+  private MeshCaCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    when(backoffPolicyProvider.get()).thenReturn(backoffPolicy);\n+    when(backoffPolicy.nextBackoffNanos())\n+        .thenReturn(DELAY_VALUES[0], DELAY_VALUES[1], DELAY_VALUES[2]);\n+    doAnswer(\n+        new Answer<AccessToken>() {\n+          @Override\n+          public AccessToken answer(InvocationOnMock invocation) throws Throwable {\n+            return new AccessToken(\n+                oauth2Tokens.poll(), new Date(System.currentTimeMillis() + 1000L));\n+          }\n+        })\n+        .when(oauth2Creds)", "originalCommit": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMzgxMA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467323810", "bodyText": "Ack. With a Mock/Spy I can get rid of a lot of boilerplate code (create a subclass of GoogleCredentials etc) and use a concise notation to inject test data which is why I prefer it.", "author": "sanjaypujare", "createdAt": "2020-08-07T23:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTQ4NA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467331484", "bodyText": "There is not much boilerplate for GoogleCredentials and you can use anonymous class. It will be a lot cleaner than doAnswer which has a lot of boilerplate.", "author": "dapengzhang0", "createdAt": "2020-08-07T23:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUxMjQyMw==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467512423", "bodyText": "Okay I'll consider refactoring and using a test class for this in my next PR", "author": "sanjaypujare", "createdAt": "2020-08-08T22:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjAyMg==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467312022", "bodyText": "nit/optional: you can implement real ones instead of mocks. Might be more readable. But I'm also okay with as-is.", "author": "dapengzhang0", "createdAt": "2020-08-07T22:26:46Z", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.auth.http.AuthHttpConstants;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.Context;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayDeque;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+/** Unit tests for {@link MeshCaCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class MeshCaCertificateProviderTest {\n+\n+  private static final String TEST_STS_TOKEN = \"test-stsToken\";\n+  private static final long RENEWAL_GRACE_PERIOD_SECONDS = TimeUnit.HOURS.toSeconds(1L);\n+  private static final Metadata.Key<String> KEY_FOR_AUTHORIZATION =\n+      Metadata.Key.of(AuthHttpConstants.AUTHORIZATION, Metadata.ASCII_STRING_MARSHALLER);\n+  private static final String ZONE = \"us-west2-a\";\n+  private static final long START_DELAY = 200_000_000L;  // 0.2 seconds\n+  private static final long[] DELAY_VALUES = {START_DELAY, START_DELAY * 2, START_DELAY * 4};\n+  private static final long RPC_TIMEOUT_MILLIS = 100L;\n+  /**\n+   * Expire time of cert SERVER_0_PEM_FILE.\n+   */\n+  private static final long CERT0_EXPIRY_TIME_MILLIS = 1899853658000L;\n+  /**\n+   * Cert validity of 12 hours for the above cert.\n+   */\n+  private static final long CERT0_VALIDITY_MILLIS = TimeUnit.MILLISECONDS\n+      .convert(12, TimeUnit.HOURS);\n+  /**\n+   * Compute current time based on cert expiry and cert validity.\n+   */\n+  private static final long CURRENT_TIME_NANOS =\n+      TimeUnit.MILLISECONDS.toNanos(CERT0_EXPIRY_TIME_MILLIS - CERT0_VALIDITY_MILLIS);\n+  @Rule\n+  public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+\n+  private static class ResponseToSend {\n+    Throwable getThrowable() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+\n+    List<String> getList() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+  }\n+\n+  private static class ResponseThrowable extends ResponseToSend {\n+    final Throwable throwableToSend;\n+\n+    ResponseThrowable(Throwable throwable) {\n+      throwableToSend = throwable;\n+    }\n+\n+    @Override\n+    Throwable getThrowable() {\n+      return throwableToSend;\n+    }\n+  }\n+\n+  private static class ResponseList extends ResponseToSend {\n+    final List<String> listToSend;\n+\n+    ResponseList(List<String> list) {\n+      listToSend = list;\n+    }\n+\n+    @Override\n+    List<String> getList() {\n+      return listToSend;\n+    }\n+  }\n+\n+  private final Queue<Meshca.MeshCertificateRequest> receivedRequests = new ArrayDeque<>();\n+  private final Queue<String> receivedStsCreds = new ArrayDeque<>();\n+  private final Queue<String> receivedZoneValues = new ArrayDeque<>();\n+  private final Queue<ResponseToSend> responsesToSend = new ArrayDeque<>();\n+  private final Queue<String> oauth2Tokens = new ArrayDeque<>();\n+  private final AtomicBoolean callEnded = new AtomicBoolean(true);\n+\n+  @Mock private MeshCertificateServiceGrpc.MeshCertificateServiceImplBase mockedMeshCaService;\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private BackoffPolicy.Provider backoffPolicyProvider;\n+  @Mock private BackoffPolicy backoffPolicy;\n+  @Spy private GoogleCredentials oauth2Creds;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  private ManagedChannel channel;\n+  private MeshCaCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    when(backoffPolicyProvider.get()).thenReturn(backoffPolicy);", "originalCommit": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMTU1MA==", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467321550", "bodyText": "I personally like mocks because it's concise and defined \"inline\" (close to where it is called/used) esp for BackoffPolicy which is not the main thing being tested here.", "author": "sanjaypujare", "createdAt": "2020-08-07T23:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjAyMg=="}], "type": "inlineReview"}]}